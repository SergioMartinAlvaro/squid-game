"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktest"] = self["webpackChunktest"] || []).push([["vendors-node_modules_vaadin_vaadin-charts_vaadin-chart_js-node_modules_lit-element_developmen-af2a57"],{

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-module.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DomModule\": () => (/* binding */ DomModule)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\nlet modules = {};\nlet lcModules = {};\n/**\n * Sets a dom-module into the global registry by id.\n *\n * @param {string} id dom-module id\n * @param {DomModule} module dom-module instance\n * @return {void}\n */\nfunction setModule(id, module) {\n  // store id separate from lowercased id so that\n  // in all cases mixedCase id will stored distinctly\n  // and lowercase version is a fallback\n  modules[id] = lcModules[id.toLowerCase()] = module;\n}\n/**\n * Retrieves a dom-module from the global registry by id.\n *\n * @param {string} id dom-module id\n * @return {DomModule!} dom-module instance\n */\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\n\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n}\n\n/**\n * The `dom-module` element registers the dom it contains to the name given\n * by the module's id attribute. It provides a unified database of dom\n * accessible via its static `import` API.\n *\n * A key use case of `dom-module` is for providing custom element `<template>`s\n * via HTML imports that are parsed by the native HTML parser, that can be\n * relocated during a bundling pass and still looked up by `id`.\n *\n * Example:\n *\n *     <dom-module id=\"foo\">\n *       <img src=\"stuff.png\">\n *     </dom-module>\n *\n * Then in code in some other location that cannot access the dom-module above\n *\n *     let img = customElements.get('dom-module').import('foo', 'img');\n *\n * @customElement\n * @extends HTMLElement\n * @summary Custom element that provides a registry of relocatable DOM content\n *   by `id` that is agnostic to bundling.\n * @unrestricted\n */\nclass DomModule extends HTMLElement {\n\n  /** @override */\n  static get observedAttributes() { return ['id']; }\n\n  /**\n   * Retrieves the element specified by the css `selector` in the module\n   * registered by `id`. For example, this.import('foo', 'img');\n   * @param {string} id The id of the dom-module in which to search.\n   * @param {string=} selector The css selector by which to find the element.\n   * @return {Element} Returns the element which matches `selector` in the\n   * module registered at the specified `id`.\n   *\n   * @export\n   * @nocollapse Referred to indirectly in style-gather.js\n   */\n  static import(id, selector) {\n    if (id) {\n      let m = findModule(id);\n      if (m && selector) {\n        return m.querySelector(selector);\n      }\n      return m;\n    }\n    return null;\n  }\n\n  /* eslint-disable no-unused-vars */\n  /**\n   * @param {string} name Name of attribute.\n   * @param {?string} old Old value of attribute.\n   * @param {?string} value Current value of attribute.\n   * @param {?string} namespace Attribute namespace.\n   * @return {void}\n   * @override\n   */\n  attributeChangedCallback(name, old, value, namespace) {\n    if (old !== value) {\n      this.register();\n    }\n  }\n  /* eslint-enable no-unused-args */\n\n  /**\n   * The absolute URL of the original location of this `dom-module`.\n   *\n   * This value will differ from this element's `ownerDocument` in the\n   * following ways:\n   * - Takes into account any `assetpath` attribute added during bundling\n   *   to indicate the original location relative to the bundled location\n   * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n   *   the path is relative to the import document's location since\n   *   `ownerDocument` is not currently polyfilled\n   */\n  get assetpath() {\n    // Don't override existing assetpath.\n    if (!this.__assetpath) {\n      // note: assetpath set via an attribute must be relative to this\n      // element's location; accomodate polyfilled HTMLImports\n      const owner = window.HTMLImports && HTMLImports.importForElement ?\n        HTMLImports.importForElement(this) || document : this.ownerDocument;\n      const url = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveUrl)(\n        this.getAttribute('assetpath') || '', owner.baseURI);\n      this.__assetpath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(url);\n    }\n    return this.__assetpath;\n  }\n\n  /**\n   * Registers the dom-module at a given id. This method should only be called\n   * when a dom-module is imperatively created. For\n   * example, `document.createElement('dom-module').register('foo')`.\n   * @param {string=} id The id at which to register the dom-module.\n   * @return {void}\n   */\n  register(id) {\n    id = id || this.id;\n    if (id) {\n      // Under strictTemplatePolicy, reject and null out any re-registered\n      // dom-module since it is ambiguous whether first-in or last-in is trusted\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_2__.strictTemplatePolicy && findModule(id) !== undefined) {\n        setModule(id, null);\n        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);\n      }\n      this.id = id;\n      setModule(id, this);\n      styleOutsideTemplateCheck(this);\n    }\n  }\n}\n\nDomModule.prototype['modules'] = modules;\n\ncustomElements.define('dom-module', DomModule);\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/elements/dom-module.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/element-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/element-mixin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"builtCSS\": () => (/* binding */ builtCSS),\n/* harmony export */   \"ElementMixin\": () => (/* binding */ ElementMixin),\n/* harmony export */   \"updateStyles\": () => (/* binding */ updateStyles)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@polymer/polymer/lib/utils/settings.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/style-gather.js */ \"./node_modules/@polymer/polymer/lib/utils/style-gather.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _property_effects_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-effects.js */ \"./node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n/* harmony import */ var _properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./properties-mixin.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nconst version = '3.4.1';\n\nconst builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst ElementMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = (0,_properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__.PropertiesMixin)((0,_property_effects_js__WEBPACK_IMPORTED_MODULE_6__.PropertyEffects)(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers =\n          constructor.hasOwnProperty(\n              JSCompiler_renameProperty('observers', constructor)) ?\n          /** @type {PolymerElementConstructor} */ (constructor).observers :\n          null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromTemplate)(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromModuleImports)(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n    // Support for `adoptedStylesheets` relies on using native Shadow DOM\n    // and built CSS. Built CSS is required because runtime transformation of\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\n    // to update a `style` element in the element template and this is\n    // removed when using `adoptedStyleSheets`.\n    // Note, it would be more efficient to allow style includes to become\n    // separate stylesheets; however, because of `@apply` these are\n    // potentially not shareable and sharing the ones that could be shared\n    // would require some coordination. To keep it simple, all the includes\n    // and styles are collapsed into a single shareable stylesheet.\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.useAdoptedStyleSheetsWithBuiltCSS && builtCSS &&\n        _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.supportsAdoptingStyleSheets) {\n      // Remove styles in template and make a shareable stylesheet\n      const styles = template.content.querySelectorAll('style');\n      if (styles) {\n        let css = '';\n        Array.from(styles).forEach(s => {\n          css += s.textContent;\n          s.parentNode.removeChild(s);\n        });\n        klass._styleSheet = new CSSStyleSheet();\n        klass._styleSheet.replaceSync(css);\n      }\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy || _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */ (\n          _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"](is, 'template'));\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     * @nocollapse\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      polymerElementBase._finalizeClass.call(this);\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n\n    /** @nocollapse */\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */ (this).template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n\n      /** @override */\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(\n            /** @type {?} */ (this.prototype), p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i=0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation will\n     * return the first `<template>` in a `dom-module` whose `id` matches this\n     * element's `is` (note that a `_template` property on the class prototype\n     * takes precedence over the `dom-module` template, to maintain legacy\n     * element semantics; a subclass will subsequently fall back to its super\n     * class template if neither a `prototype._template` or a `dom-module` for\n     * the class's `is` was found).\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     * @nocollapse\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        const protoTemplate = this.prototype.hasOwnProperty(\n          JSCompiler_renameProperty('_template', this.prototype)) ?\n          this.prototype._template : undefined;\n        this._template =\n          // If user has put template on prototype (e.g. in legacy via registered\n          // callback or info object), prefer that first. Note that `null` is\n          // used as a sentinel to indicate \"no template\" and can be used to\n          // override a super template, whereas `undefined` is used as a\n          // sentinel to mean \"fall-back to default template lookup\" via\n          // dom-module and/or super.template.\n          protoTemplate !== undefined ? protoTemplate :\n          // Look in dom-module associated with this element's is\n          ((this.hasOwnProperty(JSCompiler_renameProperty('is', this)) &&\n          (getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ (this).is))) ||\n          // Next look for superclass template (call the super impl this\n          // way so that `this` points to the superclass)\n          Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.template);\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     * @nocollapse\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     * @nocollapse\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.pathFromUrl)(meta.url);\n        } else {\n          const module = _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"](/** @type {PolymerElementConstructor} */ (this).is);\n          this._importPath = (module && module.assetpath) ||\n            Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate(/** @type {!HTMLElement} */(this).localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        if (this._canApplyPropertyDefault(p)) {\n          let value = typeof info.value == 'function' ?\n            info.value.call(this) :\n            info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determines if a property dfeault can be applied. For example, this\n     * prevents a default from being applied when a property that has no\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\n     * @override\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property default can be applied.\n     */\n    _canApplyPropertyDefault(property) {\n      return !this.hasOwnProperty(property);\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     * @nocollapse\n     */\n    static _processStyleText(cssText, baseURI) {\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveCss)(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    * @nocollapse\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__.wrap)(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});\n            n.shadowRoot.appendChild(dom);\n            // When `adoptedStyleSheets` is supported a stylesheet is made\n            // available on the element constructor.\n            if (this.constructor._styleSheet) {\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\n            }\n          }\n          if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.syncInitialRender && window.ShadyDOM) {\n            window.ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n          // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' +\n        'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(this.importPath);\n      }\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._parseTemplateContent.call(\n        this, template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyWarnings && !(prop in this._properties) &&\n          // Methods used in templates with no dependencies (or only literal\n          // dependencies) become accessors with template effects; ignore these\n          !(effect.info.part.signature && effect.info.part.signature.static) &&\n          // Warnings for bindings added to nested templates are handled by\n          // templatizer so ignore both the host-to-template bindings\n          // (`hostProp`) and TemplateInstance-to-child bindings\n          // (`nestedTemplate`)\n          !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +\n          `attribute will not be observed.`);\n      }\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._addTemplatePropertyEffect.call(\n        this, templateInfo, prop, effect);\n    }\n\n  }\n\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nconst updateStyles = function(props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/element-mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-changed.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-changed.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesChanged\": () => (/* binding */ PropertiesChanged)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/** @const {!AsyncInterface} */\nconst microtask = _utils_async_js__WEBPACK_IMPORTED_MODULE_2__.microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesChanged = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) { } //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n     _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        (old !== value &&\n          // This ensures (old==NaN, value==NaN) always returns false\n          (old === old || value === value))\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type ||\n          this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = (arguments.length < 3) ? this[property] : value;\n      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,\n        attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */((0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node));\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute, str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return (value !== null);\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/properties-changed.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesMixin\": () => (/* binding */ PropertiesMixin)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/telemetry.js */ \"./node_modules/@polymer/polymer/lib/utils/telemetry.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\n * Creates a copy of `props` with each property normalized such that\n * upgraded it is an object with at least a type property { type: Type}.\n *\n * @param {!Object} props Properties to normalize\n * @return {!Object} Copy of input `props` with normalized properties that\n * are in the form {type: Type}\n * @private\n */\nfunction normalizeProperties(props) {\n  const output = {};\n  for (let p in props) {\n    const o = props[p];\n    output[p] = (typeof o === 'function') ? {type: o} : o;\n  }\n  return output;\n}\n\n/**\n * Mixin that provides a minimal starting point to using the PropertiesChanged\n * mixin by providing a mechanism to declare properties in a static\n * getter (e.g. static get properties() { return { foo: String } }). Changes\n * are reported via the `_propertiesChanged` method.\n *\n * This mixin provides no specific support for rendering. Users are expected\n * to create a ShadowRoot and put content into it and update it in whatever\n * way makes sense. This can be done in reaction to properties changing by\n * implementing `_propertiesChanged`.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Mixin that provides a minimal starting point for using\n * the PropertiesChanged mixin by providing a declarative `properties` object.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n\n /**\n  * @constructor\n  * @implements {Polymer_PropertiesChanged}\n  * @private\n  */\n const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n /**\n  * Returns the super class constructor for the given class, if it is an\n  * instance of the PropertiesMixin.\n  *\n  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n  * @return {?PropertiesMixinConstructor} Super class constructor\n  */\n function superPropertiesClass(constructor) {\n   const superCtor = Object.getPrototypeOf(constructor);\n\n   // Note, the `PropertiesMixin` class below only refers to the class\n   // generated by this call to the mixin; the instanceof test only works\n   // because the mixin is deduped and guaranteed only to apply once, hence\n   // all constructors in a proto chain will see the same `PropertiesMixin`\n   return (superCtor.prototype instanceof PropertiesMixin) ?\n     /** @type {!PropertiesMixinConstructor} */ (superCtor) : null;\n }\n\n /**\n  * Returns a memoized version of the `properties` object for the\n  * given class. Properties not in object format are converted to at\n  * least {type}.\n  *\n  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n  * @return {Object} Memoized properties object\n  */\n function ownProperties(constructor) {\n   if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n     let props = null;\n\n     if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {\n       const properties = constructor.properties;\n\n       if (properties) {\n        props = normalizeProperties(properties);\n       }\n     }\n\n     constructor.__ownProperties = props;\n   }\n   return constructor.__ownProperties;\n }\n\n /**\n  * @polymer\n  * @mixinClass\n  * @extends {base}\n  * @implements {Polymer_PropertiesMixin}\n  * @unrestricted\n  */\n class PropertiesMixin extends base {\n\n   /**\n    * Implements standard custom elements getter to observes the attributes\n    * listed in `properties`.\n    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n    * @nocollapse\n    */\n   static get observedAttributes() {\n     if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n       (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.register)(this.prototype);\n       const props = this._properties;\n       this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];\n     }\n     return this.__observedAttributes;\n   }\n\n   /**\n    * Finalizes an element definition, including ensuring any super classes\n    * are also finalized. This includes ensuring property\n    * accessors exist on the element prototype. This method calls\n    * `_finalizeClass` to finalize each constructor in the prototype chain.\n    * @return {void}\n    * @nocollapse\n    */\n   static finalize() {\n     if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));\n       if (superCtor) {\n         superCtor.finalize();\n       }\n       this.__finalized = true;\n       this._finalizeClass();\n     }\n   }\n\n   /**\n    * Finalize an element class. This includes ensuring property\n    * accessors exist on the element prototype. This method is called by\n    * `finalize` and finalizes the class constructor.\n    *\n    * @protected\n    * @nocollapse\n    */\n   static _finalizeClass() {\n     const props = ownProperties(/** @type {!PropertiesMixinConstructor} */(this));\n     if (props) {\n       /** @type {?} */ (this).createProperties(props);\n     }\n   }\n\n   /**\n    * Returns a memoized version of all properties, including those inherited\n    * from super classes. Properties not in object format are converted to\n    * at least {type}.\n    *\n    * @return {Object} Object containing properties for this class\n    * @protected\n    * @nocollapse\n    */\n   static get _properties() {\n     if (!this.hasOwnProperty(\n       JSCompiler_renameProperty('__properties', this))) {\n       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));\n       this.__properties = Object.assign({},\n         superCtor && superCtor._properties,\n         ownProperties(/** @type {PropertiesMixinConstructor} */(this)));\n     }\n     return this.__properties;\n   }\n\n   /**\n    * Overrides `PropertiesChanged` method to return type specified in the\n    * static `properties` object for the given property.\n    * @param {string} name Name of property\n    * @return {*} Type to which to deserialize attribute\n    *\n    * @protected\n    * @nocollapse\n    */\n   static typeForProperty(name) {\n     const info = this._properties[name];\n     return info && info.type;\n   }\n\n   /**\n    * Overrides `PropertiesChanged` method and adds a call to\n    * `finalize` which lazily configures the element's property accessors.\n    * @override\n    * @return {void}\n    */\n   _initializeProperties() {\n     (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.incrementInstanceCount)();\n     this.constructor.finalize();\n     super._initializeProperties();\n   }\n\n   /**\n    * Called when the element is added to a document.\n    * Calls `_enableProperties` to turn on property system from\n    * `PropertiesChanged`.\n    * @suppress {missingProperties} Super may or may not implement the callback\n    * @return {void}\n    * @override\n    */\n   connectedCallback() {\n     if (super.connectedCallback) {\n       super.connectedCallback();\n     }\n     this._enableProperties();\n   }\n\n   /**\n    * Called when the element is removed from a document\n    * @suppress {missingProperties} Super may or may not implement the callback\n    * @return {void}\n    * @override\n    */\n   disconnectedCallback() {\n     if (super.disconnectedCallback) {\n       super.disconnectedCallback();\n     }\n   }\n\n }\n\n return PropertiesMixin;\n\n});\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-accessors.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-accessors.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyAccessors\": () => (/* binding */ PropertyAccessors)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n  for (let i=0; i<props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertyAccessors = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n   const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  class PropertyAccessors extends base {\n\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ =  /** @type {?} */ (this).observedAttributes;\n      for (let i=0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor((0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.dashToCamelCase)(a$[i]));\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.camelToDashCase)(property);\n    }\n\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n        this.__dataProto = null;\n      }\n      super._initializeProperties();\n    }\n\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */(this);\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            try {\n              return JSON.stringify(value);\n            } catch(x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n          break;\n        case Array:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n          break;\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n      super._definePropertyAccessor(property, readOnly);\n    }\n\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && (prop in this.__dataPending));\n    }\n\n  }\n\n  return PropertyAccessors;\n\n});\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/property-accessors.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-effects.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-effects.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyEffects\": () => (/* binding */ PropertyEffects)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@polymer/polymer/lib/utils/path.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _property_accessors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property-accessors.js */ \"./node_modules/@polymer/polymer/lib/mixins/property-accessors.js\");\n/* harmony import */ var _template_stamp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./template-stamp.js */ \"./node_modules/@polymer/polymer/lib/mixins/template-stamp.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n/* for notify, reflect */\n\n\n/* for annotated effects */\n\n\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nlet dedupeId = 0;\n\nconst NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\n\nconst COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nconst capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p];\n        // Perf optimization over Array.slice\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i=0; i<protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n      let fxs = effects[rootProperty];\n      if (fxs) {\n        for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) &&\n              (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  let fxs = effects[rootProperty];\n  if (fxs) {\n    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = /** @type {string} */ (trigger.name);\n    return (triggerPath == path) ||\n        !!(trigger.structured && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isAncestor)(triggerPath, path)) ||\n        !!(trigger.wildcard && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  let host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  let rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(path);\n  if (rootProperty !== path) {\n    let eventName = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(/** @type {!HTMLElement} */(inst)).dispatchEvent(new CustomEvent(eventName, { detail }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property];  // specifically for .splices\n  }\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */(event.detail);\n  let fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\n      && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */(inst));\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      let info;\n      while ((info = queue.shift())) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n      Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n        Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n  while (start <= end) {\n    const mid = (start + end) >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (let i=0; i<fxs.length; i++) {\n      const fx = fxs[i];\n      if ((fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {counts, ready, total} = dependencyCounts(inst);\n    let curr;\n    while ((curr = ready.shift())) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      const el = /** @type {HTMLElement} */ (inst);\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0;\n  // Count dependencies for each computed property\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] =\n      info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n  return {counts, ready, total};\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  let computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n  if (links) {\n    let link;\n    for (let a in links) {\n      let b = links[a];\n      if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(a, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(b, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    let {event, negate} = binding.parts[0];\n    binding.listenerEvent = event || ((0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(target) + '-changed');\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  let index = templateInfo.nodeInfoList.length;\n  for (let i=0; i<binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target +\n        ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = { index, binding, part, evaluator: constructor };\n      for (let j=0; j<dependencies.length; j++) {\n        let trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info, trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && (path.length > part.source.length) &&\n      (binding.kind == 'property') && !binding.isCompound &&\n      node.__isPropertyEffectsClient &&\n      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n    if (node.__isPropertyEffectsClient &&\n        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' ||\n        (binding.target === 'value' &&\n          (node.localName === 'input' || node.localName === 'textarea'))) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) &&\n         binding.kind != 'attribute' &&\n         binding.kind != 'text' &&\n         !binding.isCompound &&\n         binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {nodeList, nodeInfoList} = templateInfo;\n  if (nodeInfoList.length) {\n    for (let i=0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n      if (bindings) {\n        for (let i=0; i<bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage ||\n      (node.__dataCompoundStorage = {});\n    let parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    let literals = new Array(parts.length);\n    for (let j=0; j<parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    let target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function(e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || (dynamicFn &&\n    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn, info: info, trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn, info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nconst emptyArray = [];\n\n// Regular expressions used for binding\nconst IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                              '(?:' + ARGUMENTS + '?' + ')' +\n                            '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  let s = '';\n  for (let i=0; i<parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    let methodName = m[1];\n    let sig = { methodName, static: true, args: emptyArray };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function(rawArg) {\n    let arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim()\n    // replace comma entity with comma\n    .replace(/&comma;/g, ',')\n    // repair extra escape sequences; note only commas strictly need\n    // escaping, but we allow any other char to be escaped since its\n    // likely users will do this\n    .replace(/\\\\(.)/g, '\\$1')\n    ;\n  // basic argument descriptor\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  let fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch(fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(arg);\n    // detect structured path (has dots)\n    a.structured = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(arg);\n    if (a.structured) {\n      a.wildcard = (arg.slice(-2) == '.*');\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\n\nfunction getArgValue(data, props, path) {\n  let value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = { indexSplices: splices };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nconst PropertyEffects = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = (0,_template_stamp_js__WEBPACK_IMPORTED_MODULE_6__.TemplateStamp)((0,_property_accessors_js__WEBPACK_IMPORTED_MODULE_5__.PropertyAccessors)(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  class PropertyEffects extends propertyEffectsBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      this.__dataClientsReady;\n      /** @type {Array} */\n      this.__dataPendingClients;\n      /** @type {Object} */\n      this.__dataToNotify;\n      /** @type {Object} */\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n      this.__dataHasPaths;\n      /** @type {Object} */\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      this.__dataHost;\n      /** @type {!Object} */\n      this.__dataTemp;\n      /** @type {boolean} */\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n      this.__data;\n      /** @type {!Object|null} */\n      this.__dataPending;\n      /** @type {!Object} */\n      this.__dataOld;\n      /** @type {Object} */\n      this.__computeEffects;\n      /** @type {Object} */\n      this.__computeInfo;\n      /** @type {Object} */\n      this.__reflectEffects;\n      /** @type {Object} */\n      this.__notifyEffects;\n      /** @type {Object} */\n      this.__propagateEffects;\n      /** @type {Object} */\n      this.__observeEffects;\n      /** @type {Object} */\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n      this.__templateInfo;\n      /** @type {boolean} */\n      this._overrideLegacyUndefined;\n    }\n\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      super._initializeProperties();\n      this._registerHost();\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false;\n      // May be set on instance prior to upgrade\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length-1];\n        host._enqueueClient(this);\n        // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n        this.__dataHost = host;\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    }\n\n    // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n      // effects are accumulated into arrays per property based on type\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n      effects.push(effect);\n    }\n\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    }\n\n    // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification ||\n          (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path);\n          path = /** @type {string} */ ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(this, path, value));\n          // Use property-accessor's simpler dirty check\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n        this.__dataHasPaths = true;\n        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {\n          computeLinkedPaths(this, /**@type{string}*/ (path), value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node = /** @type {!Node} */((0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node));\n        }\n        node[prop] = value;\n      }\n    }\n\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        }\n        // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        }\n        // All changes go into pending property bag, passed to _propertiesChanged\n        this.__dataPending[property] = value;\n        // Track properties that should notify separately\n        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n        this._readyClients();\n        // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    }\n\n    // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n      if (clients) {\n        this.__dataPendingClients = null;\n        for (let i=0; i < clients.length; i++) {\n          let client = clients[i];\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n      this._invalidateProperties();\n    }\n\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties();\n      // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      }\n      // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps;\n      // Compute properties\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\n      // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null;\n      // Propagate properties to clients\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n      // Flush clients\n      this._flushClients();\n      // Reflect properties\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n      // Observe properties\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n      // Notify properties to host\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      }\n      // Clear temporary cache at end of turn\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      }\n      // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n    }\n\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\n          hasPaths, templateInfo.nodeList);\n        for (let info=templateInfo.firstChild; info; info=info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n    linkPaths(to, from) {\n      to = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(to);\n      from = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n    unlinkPaths(path) {\n      path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n    notifySplices(path, splices) {\n      let info = {path: ''};\n      let array = /** @type {Array} */((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      notifySplices(this, array, info.path, splices);\n    }\n\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n    get(path, root) {\n      return (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(root || this, path);\n    }\n\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n    set(path, value, root) {\n      if (root) {\n        (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n    push(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array}*/((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      let len = array.length;\n      let ret = array.push(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    pop(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n    splice(path, start, deleteCount, ...items) {\n      let info = {path : ''};\n      let array = /** @type {Array} */((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      // Normalize fancy native splice handling of crazy start values\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      }\n      // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n      let ret;\n      // Omit any additional arguments if they were not passed in\n      if (arguments.length === 2) {\n        ret = array.splice(start);\n      // Either start was undefined and the others were defined, but in this\n      // case we can safely pass on all arguments\n      //\n      // Note: this includes the case where none of the arguments were passed in,\n      // e.g. this.splice('array'). However, if both start and deleteCount\n      // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      }\n      // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    shift(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n    unshift(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array} */((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info));\n      let ret = array.unshift(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {path: ''};\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      } else {\n        propPath = /** @type{string} */(path);\n      }\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = { property, method, dynamicFn: Boolean(dynamicFn) };\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect, info, trigger: {name: property}\n      });\n      if (dynamicFn) {\n        this._addPropertyEffect(/** @type {string} */(method), TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: {name: method}\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(property) + '-changed',\n          property: property\n        }\n      });\n    }\n\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n          attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n      for (let i=0, l=args.length; i<l; i++) {\n        let {name, structured, wildcard, value, literal} = args[i];\n        if (!literal) {\n          if (wildcard) {\n            const matches = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        }\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n        if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n        values[i] = value;\n      }\n      return values;\n    }\n\n    // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    }\n\n    // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n      // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));\n        templateInfo.wasPreBound = wasPreBound;\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n      return templateInfo;\n    }\n\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n    _stampTemplate(template, templateInfo) {\n      templateInfo =  templateInfo || /** @type {!TemplateInfo} */(this._bindTemplate(template, true));\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.push(this);\n      let dom = super._stampTemplate(template, templateInfo);\n      hostStack.pop();\n      // Add template-instance-specific data to instanced templateInfo\n      templateInfo.nodeList = dom.nodeList;\n      // Capture child nodes to allow unstamping of non-prototypical templates\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n        for (let n=dom.firstChild; n; n=n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n      dom.templateInfo = templateInfo;\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\n      setupBindings(this, templateInfo);\n      // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n        this._flushClients();\n      }\n      return dom;\n    }\n\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {previousSibling, nextSibling, parent} = templateInfo;\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\n      // Remove stamped nodes\n      let nodes = templateInfo.childNodes;\n      for (let i=0; i<nodes.length; i++) {\n        let node = nodes[i];\n        (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)((0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node).parentNode).removeChild(node);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(\n        this, node, templateInfo, nodeInfo);\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property';\n        // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length-1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        }\n        // Initialize attribute bindings with any literal parts\n        let literal = literalFromParts(parts);\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n          node.setAttribute(name, literal);\n        }\n        // support disable-upgrade\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        }\n        // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        }\n        // Remove annotation\n        node.removeAttribute(origName);\n        // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n        if (kind === 'property') {\n          name = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.dashToCamelCase)(name);\n        }\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(\n          this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(\n        this, node, templateInfo, nodeInfo);\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat';\n      // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node);\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo;\n        // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n        nodeInfo.noted = true;\n        noted = false;\n      }\n      // Merge host props into outer template and add bindings\n      let hostProps = nestedTemplateInfo.hostProps;\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps =\n            Object.assign(templateInfo.hostProps || {}, hostProps);\n          // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n          if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source], hostProp: true }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m;\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({literal: text.slice(lastIndex, m.index)});\n        }\n        // Add binding part\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false, notifyEvent = '', colon = -1;\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n        let signature = parseMethod(source);\n        let dependencies = [];\n        if (signature) {\n          // Inline computed function\n          let {args, methodName} = signature;\n          for (let i=0; i<args.length; i++) {\n            let arg = args[i];\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n          let dynamicFns = templateInfo.dynamicFns;\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n        parts.push({\n          source, mode, negate, customEvent, signature, dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      }\n      // Add a final literal part\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, part.source);\n      } else {\n        if (hasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(path)) {\n          value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      if (part.negate) {\n        value = !value;\n      }\n      return value;\n    }\n\n  }\n\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nconst hostStack = [];\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/property-effects.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/template-stamp.js":
/*!********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/template-stamp.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateStamp\": () => (/* binding */ TemplateStamp)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\n\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\n\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder\n        && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while(t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nconst TemplateStamp = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */ templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace =\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n          template.hasAttribute('strip-whitespace');\n         // TODO(rictic): fix typing\n         this._parseTemplateContent(\n             template, templateInfo, /** @type {?} */ ({parent: null}));\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */ n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo =\n            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content =\n          element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n      return (templateInfo && templateInfo.content) || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content &&\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n\n});\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/mixins/template-stamp.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/array-splice.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/array-splice.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateSplices\": () => (/* binding */ calculateSplices)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(current, currentStart, currentEnd,\n                            old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  let rowCount = oldEnd - oldStart + 1;\n  let columnCount = currentEnd - currentStart + 1;\n  let distances = new Array(rowCount);\n\n  // \"Addition\" rows. Initialize null column.\n  for (let i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  }\n\n  // Initialize null row\n  for (let j = 0; j < columnCount; j++)\n    distances[0][j] = j;\n\n  for (let i = 1; i < rowCount; i++) {\n    for (let j = 1; j < columnCount; j++) {\n      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n        distances[i][j] = distances[i - 1][j - 1];\n      else {\n        let north = distances[i - 1][j] + 1;\n        let west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n}\n\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  let edits = [];\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n    let northWest = distances[i - 1][j - 1];\n    let west = distances[i - 1][j];\n    let north = distances[i][j - 1];\n\n    let min;\n    if (west < north)\n      min = west < northWest ? west : northWest;\n    else\n      min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n *\n * @param {!Array} current The current \"changed\" array for which to\n * calculate splices.\n * @param {number} currentStart Starting index in the `current` array for\n * which splices are calculated.\n * @param {number} currentEnd Ending index in the `current` array for\n * which splices are calculated.\n * @param {!Array} old The original \"unchanged\" array to compare `current`\n * against to determine splices.\n * @param {number} oldStart Starting index in the `old` array for\n * which splices are calculated.\n * @param {number} oldEnd Ending index in the `old` array for\n * which splices are calculated.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\nfunction calcSplices(current, currentStart, currentEnd,\n                      old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  let splice;\n\n  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0)\n    prefixCount = sharedPrefix(current, old, minLength);\n\n  if (currentEnd == current.length && oldEnd == old.length)\n    suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n    return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n    while (oldStart < oldEnd)\n      splice.removed.push(old[oldStart++]);\n\n    return [ splice ];\n  } else if (oldStart == oldEnd)\n    return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n  let ops = spliceOperationsFromEditDistances(\n      calcEditDistances(current, currentStart, currentEnd,\n                             old, oldStart, oldEnd));\n\n  splice = undefined;\n  let splices = [];\n  let index = currentStart;\n  let oldIndex = oldStart;\n  for (let i = 0; i < ops.length; i++) {\n    switch(ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n      case EDIT_UPDATE:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.addedCount++;\n        index++;\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      case EDIT_ADD:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.addedCount++;\n        index++;\n        break;\n      case EDIT_DELETE:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; i++)\n    if (!equals(current[i], old[i]))\n      return i;\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n  while (count < searchLength && equals(current[--index1], old[--index2]))\n    count++;\n\n  return count;\n}\n\n/**\n * Returns an array of splice records indicating the minimum edits required\n * to transform the `previous` array into the `current` array.\n *\n * Splice records are ordered by index and contain the following fields:\n * - `index`: index where edit started\n * - `removed`: array of removed items from this index\n * - `addedCount`: number of items added at this index\n *\n * This function is based on the Levenshtein \"minimum edit distance\"\n * algorithm. Note that updates are treated as removal followed by addition.\n *\n * The worst-case time complexity of this algorithm is `O(l * p)`\n *   l: The length of the current array\n *   p: The length of the previous array\n *\n * However, the worst-case complexity is reduced by an `O(n)` optimization\n * to detect any shared prefix & suffix between the two arrays and only\n * perform the more expensive minimum edit distance calculation over the\n * non-shared portions of the arrays.\n *\n * @function\n * @param {!Array} current The \"changed\" array for which splices will be\n * calculated.\n * @param {!Array} previous The \"unchanged\" original array to compare\n * `current` against to determine the splices.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0,\n                          previous.length);\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/array-splice.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/async.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"timeOut\": () => (/* binding */ timeOut),\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"idlePeriod\": () => (/* binding */ idlePeriod),\n/* harmony export */   \"microTask\": () => (/* binding */ microTask)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\n\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => { throw e; });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) { return window.setTimeout(fn, delay); },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ?\n      window.requestIdleCallback(fn) :\n      window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ?\n      window.cancelIdleCallback(handle) :\n      window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\n\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/async.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/boot.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {?} prop Property name\n * @param {*} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function(prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/boot.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/case-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/case-map.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dashToCamelCase\": () => (/* binding */ dashToCamelCase),\n/* harmony export */   \"camelToDashCase\": () => (/* binding */ camelToDashCase)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nconst caseMap = {};\nconst DASH_TO_CAMEL = /-[a-z]/g;\nconst CAMEL_TO_DASH = /([A-Z])/g;\n\n/**\n * @fileoverview Module with utilities for converting between \"dash-case\" and\n * \"camelCase\" identifiers.\n */\n\n/**\n * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n * (e.g. `fooBarBaz`).\n *\n * @param {string} dash Dash-case identifier\n * @return {string} Camel-case representation of the identifier\n */\nfunction dashToCamelCase(dash) {\n  return caseMap[dash] || (\n    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,\n      (m) => m[1].toUpperCase()\n    )\n  );\n}\n\n/**\n * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n * (e.g. `foo-bar-baz`).\n *\n * @param {string} camel Camel-case identifier\n * @return {string} Dash-case representation of the identifier\n */\nfunction camelToDashCase(camel) {\n  return caseMap[camel] || (\n    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()\n  );\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/case-map.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/debounce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/debounce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Debouncer\": () => (/* binding */ Debouncer),\n/* harmony export */   \"enqueueDebouncer\": () => (/* binding */ enqueueDebouncer),\n/* harmony export */   \"flushDebouncers\": () => (/* binding */ flushDebouncers)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nclass Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(/** @type {number} */(this._timer));\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n}\n\nlet debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nconst enqueueDebouncer = function(debouncer) {\n  debouncerQueue.add(debouncer);\n};\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nconst flushDebouncers = function() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch(e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/debounce.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlattenedNodesObserver\": () => (/* binding */ FlattenedNodesObserver)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _array_splice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array-splice.js */ \"./node_modules/@polymer/polymer/lib/utils/array-splice.js\");\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap.js */ \"./node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\n * Returns true if `node` is a slot element\n * @param {!Node} node Node to test.\n * @return {boolean} Returns true if the given `node` is a slot\n * @private\n */\nfunction isSlot(node) {\n  return (node.localName === 'slot');\n}\n\n/**\n * Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n * of a node's children and, for any children that are `<slot>` elements,\n * the expanded flattened list of `assignedNodes`.\n * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n * and the `<slot>` has one `<div>` assigned to it, then the flattened\n * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n * `<slot>` elements assigned to it, these are flattened as well.\n *\n * The provided `callback` is called whenever any change to this list\n * of flattened nodes occurs, where an addition or removal of a node is\n * considered a change. The `callback` is called with one argument, an object\n * containing an array of any `addedNodes` and `removedNodes`.\n *\n * Note: the callback is called asynchronous to any changes\n * at a microtask checkpoint. This is because observation is performed using\n * `MutationObserver` and the `<slot>` element's `slotchange` event which\n * are asynchronous.\n *\n * An example:\n * ```js\n * class TestSelfObserve extends PolymerElement {\n *   static get is() { return 'test-self-observe';}\n *   connectedCallback() {\n *     super.connectedCallback();\n *     this._observer = new FlattenedNodesObserver(this, (info) => {\n *       this.info = info;\n *     });\n *   }\n *   disconnectedCallback() {\n *     super.disconnectedCallback();\n *     this._observer.disconnect();\n *   }\n * }\n * customElements.define(TestSelfObserve.is, TestSelfObserve);\n * ```\n *\n * @summary Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`.\n * @implements {PolymerDomApi.ObserveHandle}\n */\nlet FlattenedNodesObserver = class {\n\n  /**\n   * Returns the list of flattened nodes for the given `node`.\n   * This list consists of a node's children and, for any children\n   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n   * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n   * and the `<slot>` has one `<div>` assigned to it, then the flattened\n   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n   * `<slot>` elements assigned to it, these are flattened as well.\n   *\n   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to\n   *      return the list of flattened nodes.\n   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.\n   * @nocollapse See https://github.com/google/closure-compiler/issues/2763\n   */\n  // eslint-disable-next-line\n  static getFlattenedNodes(node) {\n    const wrapped = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node);\n    if (isSlot(node)) {\n      node = /** @type {!HTMLSlotElement} */(node); // eslint-disable-line no-self-assign\n      return wrapped.assignedNodes({flatten: true});\n    } else {\n      return Array.from(wrapped.childNodes).map((node) => {\n        if (isSlot(node)) {\n          node = /** @type {!HTMLSlotElement} */(node); // eslint-disable-line no-self-assign\n          return (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node).assignedNodes({flatten: true});\n        } else {\n          return [node];\n        }\n      }).reduce((a, b) => a.concat(b), []);\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} target Node on which to listen for changes.\n   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions\n   * or removals from the target's list of flattened nodes.\n   */\n  // eslint-disable-next-line\n  constructor(target, callback) {\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._shadyChildrenObserver = null;\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._nativeChildrenObserver = null;\n    this._connected = false;\n    /**\n     * @type {!HTMLElement}\n     * @private\n     */\n    this._target = target;\n    this.callback = callback;\n    this._effectiveNodes = [];\n    this._observer = null;\n    this._scheduled = false;\n    /**\n     * @type {function()}\n     * @private\n     */\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n    this.connect();\n    this._schedule();\n  }\n\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `FlattenedNodesObserver` is created. It should only be called to\n   * re-activate an observer that has been deactivated via the `disconnect` method.\n   *\n   * @return {void}\n   */\n  connect() {\n    if (isSlot(this._target)) {\n      this._listenSlots([this._target]);\n    } else if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children) {\n      this._listenSlots(\n          /** @type {!NodeList<!Node>} */ ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children));\n      if (window.ShadyDOM) {\n        this._shadyChildrenObserver =\n          window.ShadyDOM.observeChildren(this._target, (mutations) => {\n            this._processMutations(mutations);\n          });\n      } else {\n        this._nativeChildrenObserver =\n          new MutationObserver((mutations) => {\n            this._processMutations(mutations);\n          });\n        this._nativeChildrenObserver.observe(this._target, {childList: true});\n      }\n    }\n    this._connected = true;\n  }\n\n  /**\n   * Deactivates the flattened nodes observer. After calling this method\n   * the observer callback will not be called when changes to flattened nodes\n   * occur. The `connect` method may be subsequently called to reactivate\n   * the observer.\n   *\n   * @return {void}\n   * @override\n   */\n  disconnect() {\n    if (isSlot(this._target)) {\n      this._unlistenSlots([this._target]);\n    } else if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children) {\n      this._unlistenSlots(\n          /** @type {!NodeList<!Node>} */ ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children));\n      if (window.ShadyDOM && this._shadyChildrenObserver) {\n        window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n        this._shadyChildrenObserver = null;\n      } else if (this._nativeChildrenObserver) {\n        this._nativeChildrenObserver.disconnect();\n        this._nativeChildrenObserver = null;\n      }\n    }\n    this._connected = false;\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      _async_js__WEBPACK_IMPORTED_MODULE_2__.microTask.run(() => this.flush());\n    }\n  }\n\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n  _processMutations(mutations) {\n    this._processSlotMutations(mutations);\n    this.flush();\n  }\n\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n  _processSlotMutations(mutations) {\n    if (mutations) {\n      for (let i=0; i < mutations.length; i++) {\n        let mutation = mutations[i];\n        if (mutation.addedNodes) {\n          this._listenSlots(mutation.addedNodes);\n        }\n        if (mutation.removedNodes) {\n          this._unlistenSlots(mutation.removedNodes);\n        }\n      }\n    }\n  }\n\n  /**\n   * Flushes the observer causing any pending changes to be immediately\n   * delivered the observer callback. By default these changes are delivered\n   * asynchronously at the next microtask checkpoint.\n   *\n   * @return {boolean} Returns true if any pending changes caused the observer\n   * callback to run.\n   */\n  flush() {\n    if (!this._connected) {\n      return false;\n    }\n    if (window.ShadyDOM) {\n      ShadyDOM.flush();\n    }\n    if (this._nativeChildrenObserver) {\n      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n    } else if (this._shadyChildrenObserver) {\n      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n    }\n    this._scheduled = false;\n    let info = {\n      target: this._target,\n      addedNodes: [],\n      removedNodes: []\n    };\n    let newNodes = this.constructor.getFlattenedNodes(this._target);\n    let splices = (0,_array_splice_js__WEBPACK_IMPORTED_MODULE_1__.calculateSplices)(newNodes,\n      this._effectiveNodes);\n    // process removals\n    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {\n      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n        info.removedNodes.push(n);\n      }\n    }\n    // process adds\n    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {\n      for (let j=s.index; j < s.index + s.addedCount; j++) {\n        info.addedNodes.push(newNodes[j]);\n      }\n    }\n    // update cache\n    this._effectiveNodes = newNodes;\n    let didFlush = false;\n    if (info.addedNodes.length || info.removedNodes.length) {\n      didFlush = true;\n      this.callback.call(this._target, info);\n    }\n    return didFlush;\n  }\n\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n  _listenSlots(nodeList) {\n    for (let i=0; i < nodeList.length; i++) {\n      let n = nodeList[i];\n      if (isSlot(n)) {\n        n.addEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n  _unlistenSlots(nodeList) {\n    for (let i=0; i < nodeList.length; i++) {\n      let n = nodeList[i];\n      if (isSlot(n)) {\n        n.removeEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n\n};\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/html-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/html-tag.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"htmlLiteral\": () => (/* binding */ htmlLiteral)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Class representing a static string value which can be used to filter\n * strings by asseting that they have been created via this class. The\n * `value` property returns the string passed to the constructor.\n */\nclass LiteralString {\n  constructor(string) {\n    /** @type {string} */\n    this.value = string.toString();\n  }\n  /**\n   * @return {string} LiteralString string value\n   * @override\n   */\n  toString() {\n    return this.value;\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return /** @type {!LiteralString} */(value).value;\n  } else {\n    throw new Error(\n        `non-literal value passed to Polymer's htmlLiteral function: ${value}`\n    );\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    return /** @type {!HTMLTemplateElement } */(value).innerHTML;\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error(\n        `non-template value passed to Polymer's html function: ${value}`);\n  }\n}\n\n/**\n * A template literal tag that creates an HTML <template> element from the\n * contents of the string.\n *\n * This allows you to write a Polymer Template in JavaScript.\n *\n * Templates can be composed by interpolating `HTMLTemplateElement`s in\n * expressions in the JavaScript template literal. The nested template's\n * `innerHTML` is included in the containing template.  The only other\n * values allowed in expressions are those returned from `htmlLiteral`\n * which ensures only literal values from JS source ever reach the HTML, to\n * guard against XSS risks.\n *\n * All other values are disallowed in expressions to help prevent XSS\n * attacks; however, `htmlLiteral` can be used to compose static\n * string values into templates. This is useful to compose strings into\n * places that do not accept html, like the css text of a `style`\n * element.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>:host{ content:\"...\" }</style>\n *         <div class=\"shadowed\">${this.partialTemplate}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get partialTemplate() { return html`<span>Partial!</span>`; }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\n */\nconst html = function html(strings, ...values) {\n  const template = /** @type {!HTMLTemplateElement} */(document.createElement('template'));\n  template.innerHTML = values.reduce((acc, v, idx) =>\n      acc + htmlValue(v) + strings[idx + 1], strings[0]);\n  return template;\n};\n\n/**\n * An html literal tag that can be used with `html` to compose.\n * a literal string.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>\n *           :host { display: block; }\n *           ${this.styleTemplate()}\n *         </style>\n *         <div class=\"shadowed\">${staticValue}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get styleTemplate() {\n *        return htmlLiteral`.shadowed { background: gray; }`;\n *     }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!LiteralString} Constructed literal string\n */\nconst htmlLiteral = function(strings, ...values) {\n  return new LiteralString(values.reduce((acc, v, idx) =>\n      acc + literalValue(v) + strings[idx + 1], strings[0]));\n};\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/html-tag.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dedupingMixin\": () => (/* binding */ dedupingMixin)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\nfunction MixinFunction(){}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nconst dedupingMixin = function(mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */(mixin)(base);\n      map.set(base, extended);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;\n    }\n    return extended;\n  }\n\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc */\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/mixin.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/path.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/path.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isPath\": () => (/* binding */ isPath),\n/* harmony export */   \"root\": () => (/* binding */ root),\n/* harmony export */   \"isAncestor\": () => (/* binding */ isAncestor),\n/* harmony export */   \"isDescendant\": () => (/* binding */ isDescendant),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"matches\": () => (/* binding */ matches),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"split\": () => (/* binding */ split),\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"isDeep\": () => (/* binding */ isDeep)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Module with utilities for manipulating structured data path strings.\n *\n * @summary Module with utilities for manipulating structured data path strings.\n */\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * Example:\n *\n * ```\n * isPath('foo.bar.baz') // true\n * isPath('foo')         // false\n * ```\n *\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nfunction isPath(path) {\n  return path.indexOf('.') >= 0;\n}\n\n/**\n * Returns the root property name for the given path.\n *\n * Example:\n *\n * ```\n * root('foo.bar.baz') // 'foo'\n * root('foo')         // 'foo'\n * ```\n *\n * @param {string} path Path string\n * @return {string} Root property name\n */\nfunction root(path) {\n  let dotIndex = path.indexOf('.');\n  if (dotIndex === -1) {\n    return path;\n  }\n  return path.slice(0, dotIndex);\n}\n\n/**\n * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n * Returns true if the given path is an ancestor of the base path.\n *\n * Example:\n *\n * ```\n * isAncestor('foo.bar', 'foo')         // true\n * isAncestor('foo.bar', 'foo.bar')     // false\n * isAncestor('foo.bar', 'foo.bar.baz') // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is an ancestor of `base`.\n */\nfunction isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n}\n\n/**\n * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n *\n * Example:\n *\n * ```\n * isDescendant('foo.bar', 'foo.bar.baz') // true\n * isDescendant('foo.bar', 'foo.bar')     // false\n * isDescendant('foo.bar', 'foo')         // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is a descendant of `base`.\n */\nfunction isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n}\n\n/**\n * Replaces a previous base path with a new base path, preserving the\n * remainder of the path.\n *\n * User must ensure `path` has a prefix of `base`.\n *\n * Example:\n *\n * ```\n * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\n * ```\n *\n * @param {string} base Current base string to remove\n * @param {string} newBase New base string to replace with\n * @param {string} path Path to translate\n * @return {string} Translated string\n */\nfunction translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n}\n\n/**\n * @param {string} base Path string to test against\n * @param {string} path Path string to test\n * @return {boolean} True if `path` is equal to `base`\n */\nfunction matches(base, path) {\n  return (base === path) ||\n         isAncestor(base, path) ||\n         isDescendant(base, path);\n}\n\n/**\n * Converts array-based paths to flattened path.  String-based paths\n * are returned as-is.\n *\n * Example:\n *\n * ```\n * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {string} Flattened path\n */\nfunction normalize(path) {\n  if (Array.isArray(path)) {\n    let parts = [];\n    for (let i=0; i<path.length; i++) {\n      let args = path[i].toString().split('.');\n      for (let j=0; j<args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n    return parts.join('.');\n  } else {\n    return path;\n  }\n}\n\n/**\n * Splits a path into an array of property names. Accepts either arrays\n * of path parts or strings.\n *\n * Example:\n *\n * ```\n * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {!Array<string>} Array of path parts\n * @suppress {checkTypes}\n */\nfunction split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n  return path.toString().split('.');\n}\n\n/**\n * Reads a value from a path.  If any sub-property in the path is `undefined`,\n * this method returns `undefined` (will never throw.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to read\n * @param {Object=} info If an object is provided to `info`, the normalized\n *  (flattened) path will be set to `info.path`.\n * @return {*} Value at path, or `undefined` if the path could not be\n *  fully dereferenced.\n */\nfunction get(root, path, info) {\n  let prop = root;\n  let parts = split(path);\n  // Loop over path parts[0..n-1] and dereference\n  for (let i=0; i<parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n    let part = parts[i];\n    prop = prop[part];\n  }\n  if (info) {\n    info.path = parts.join('.');\n  }\n  return prop;\n}\n\n/**\n * Sets a value to a path.  If any sub-property in the path is `undefined`,\n * this method will no-op.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to set\n * @param {*} value Value to set to path\n * @return {string | undefined} The normalized version of the input path\n */\nfunction set(root, path, value) {\n  let prop = root;\n  let parts = split(path);\n  let last = parts[parts.length-1];\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (let i=0; i<parts.length-1; i++) {\n      let part = parts[i];\n      prop = prop[part];\n      if (!prop) {\n        return;\n      }\n    }\n    // Set value to object at end of path\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n  return parts.join('.');\n}\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * This function is deprecated.  Use `isPath` instead.\n *\n * Example:\n *\n * ```\n * isDeep('foo.bar.baz') // true\n * isDeep('foo')         // false\n * ```\n *\n * @deprecated\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nconst isDeep = isPath;\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/path.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/render-status.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/render-status.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flush\": () => (/* binding */ flush),\n/* harmony export */   \"beforeNextRender\": () => (/* binding */ beforeNextRender),\n/* harmony export */   \"afterNextRender\": () => (/* binding */ afterNextRender)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for scheduling flushable pre-render and post-render tasks.\n *\n * @summary Module for scheduling flushable pre-render and post-render tasks.\n */\n\n\n\nlet scheduled = false;\nlet beforeRenderQueue = [];\nlet afterRenderQueue = [];\n\nfunction schedule() {\n  scheduled = true;\n  // before next render\n  requestAnimationFrame(function() {\n    scheduled = false;\n    flushQueue(beforeRenderQueue);\n    // after the render\n    setTimeout(function() {\n      runQueue(afterRenderQueue);\n    });\n  });\n}\n\nfunction flushQueue(queue) {\n  while (queue.length) {\n    callMethod(queue.shift());\n  }\n}\n\nfunction runQueue(queue) {\n  for (let i=0, l=queue.length; i < l; i++) {\n    callMethod(queue.shift());\n  }\n}\n\nfunction callMethod(info) {\n  const context = info[0];\n  const callback = info[1];\n  const args = info[2];\n  try {\n    callback.apply(context, args);\n  } catch(e) {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\n/**\n * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`\n * tasks.\n *\n * @return {void}\n */\nfunction flush() {\n  while (beforeRenderQueue.length || afterRenderQueue.length) {\n    flushQueue(beforeRenderQueue);\n    flushQueue(afterRenderQueue);\n  }\n  scheduled = false;\n}\n\n\n/**\n * Enqueues a callback which will be run before the next render, at\n * `requestAnimationFrame` timing.\n *\n * This method is useful for enqueuing work that requires DOM measurement,\n * since measurement may not be reliable in custom element callbacks before\n * the first render, as well as for batching measurement tasks in general.\n *\n * Tasks in this queue may be flushed by calling `flush()`.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction beforeNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  beforeRenderQueue.push([context, callback, args]);\n}\n\n/**\n * Enqueues a callback which will be run after the next render, equivalent\n * to one task (`setTimeout`) after the next `requestAnimationFrame`.\n *\n * This method is useful for tuning the first-render performance of an\n * element or application by deferring non-critical work until after the\n * first paint.  Typical non-render-critical work may include adding UI\n * event listeners and aria attributes.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction afterNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  afterRenderQueue.push([context, callback, args]);\n}\n\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/render-status.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js":
/*!****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/resolve-url.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveUrl\": () => (/* binding */ resolveUrl),\n/* harmony export */   \"resolveCss\": () => (/* binding */ resolveCss),\n/* harmony export */   \"pathFromUrl\": () => (/* binding */ pathFromUrl)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nlet CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nlet ABS_URL = /(^\\/[^\\/])|(^#)|(^[\\w-\\d]*:)/;\nlet workingURL;\nlet resolveDoc;\n/**\n * Resolves the given URL against the provided `baseUri'.\n *\n * Note that this function performs no resolution for URLs that start\n * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n * URL resolution, use `window.URL`.\n *\n * @param {string} url Input URL to resolve\n * @param {?string=} baseURI Base URI to resolve the URL against\n * @return {string} resolved URL\n */\nfunction resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  }\n  if (url === '//') {\n    return url;\n  }\n  // Lazy feature detection.\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      const u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = (u.href === 'http://a/c%20d');\n    } catch (e) {\n      // silently fail\n    }\n  }\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n  if (workingURL) {\n    try {\n      return (new URL(url, baseURI)).href;\n    } catch (e) {\n      // Bad url or baseURI structure. Do not attempt to resolve.\n      return url;\n    }\n  }\n  // Fallback to creating an anchor into a disconnected document.\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n\n}\n\n/**\n * Resolves any relative URL's in the given CSS text against the provided\n * `ownerDocument`'s `baseURI`.\n *\n * @param {string} cssText CSS text to process\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Processed CSS text with resolved URL's\n */\nfunction resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {\n    return pre + '\\'' +\n      resolveUrl(url.replace(/[\"']/g, ''), baseURI) +\n      '\\'' + post;\n  });\n}\n\n/**\n * Returns a path from a given `url`. The path includes the trailing\n * `/` from the url.\n *\n * @param {string} url Input URL to transform\n * @return {string} resolved path\n */\nfunction pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/resolve-url.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/settings.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/settings.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useShadow\": () => (/* binding */ useShadow),\n/* harmony export */   \"useNativeCSSProperties\": () => (/* binding */ useNativeCSSProperties),\n/* harmony export */   \"useNativeCustomElements\": () => (/* binding */ useNativeCustomElements),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* binding */ supportsAdoptingStyleSheets),\n/* harmony export */   \"rootPath\": () => (/* binding */ rootPath),\n/* harmony export */   \"setRootPath\": () => (/* binding */ setRootPath),\n/* harmony export */   \"sanitizeDOMValue\": () => (/* binding */ sanitizeDOMValue),\n/* harmony export */   \"setSanitizeDOMValue\": () => (/* binding */ setSanitizeDOMValue),\n/* harmony export */   \"getSanitizeDOMValue\": () => (/* binding */ getSanitizeDOMValue),\n/* harmony export */   \"passiveTouchGestures\": () => (/* binding */ passiveTouchGestures),\n/* harmony export */   \"setPassiveTouchGestures\": () => (/* binding */ setPassiveTouchGestures),\n/* harmony export */   \"strictTemplatePolicy\": () => (/* binding */ strictTemplatePolicy),\n/* harmony export */   \"setStrictTemplatePolicy\": () => (/* binding */ setStrictTemplatePolicy),\n/* harmony export */   \"allowTemplateFromDomModule\": () => (/* binding */ allowTemplateFromDomModule),\n/* harmony export */   \"setAllowTemplateFromDomModule\": () => (/* binding */ setAllowTemplateFromDomModule),\n/* harmony export */   \"legacyOptimizations\": () => (/* binding */ legacyOptimizations),\n/* harmony export */   \"setLegacyOptimizations\": () => (/* binding */ setLegacyOptimizations),\n/* harmony export */   \"legacyWarnings\": () => (/* binding */ legacyWarnings),\n/* harmony export */   \"setLegacyWarnings\": () => (/* binding */ setLegacyWarnings),\n/* harmony export */   \"syncInitialRender\": () => (/* binding */ syncInitialRender),\n/* harmony export */   \"setSyncInitialRender\": () => (/* binding */ setSyncInitialRender),\n/* harmony export */   \"legacyUndefined\": () => (/* binding */ legacyUndefined),\n/* harmony export */   \"setLegacyUndefined\": () => (/* binding */ setLegacyUndefined),\n/* harmony export */   \"orderedComputed\": () => (/* binding */ orderedComputed),\n/* harmony export */   \"setOrderedComputed\": () => (/* binding */ setOrderedComputed),\n/* harmony export */   \"cancelSyntheticClickEvents\": () => (/* binding */ cancelSyntheticClickEvents),\n/* harmony export */   \"setCancelSyntheticClickEvents\": () => (/* binding */ setCancelSyntheticClickEvents),\n/* harmony export */   \"removeNestedTemplates\": () => (/* binding */ removeNestedTemplates),\n/* harmony export */   \"setRemoveNestedTemplates\": () => (/* binding */ setRemoveNestedTemplates),\n/* harmony export */   \"fastDomIf\": () => (/* binding */ fastDomIf),\n/* harmony export */   \"setFastDomIf\": () => (/* binding */ setFastDomIf),\n/* harmony export */   \"suppressTemplateNotifications\": () => (/* binding */ suppressTemplateNotifications),\n/* harmony export */   \"setSuppressTemplateNotifications\": () => (/* binding */ setSuppressTemplateNotifications),\n/* harmony export */   \"legacyNoObservedAttributes\": () => (/* binding */ legacyNoObservedAttributes),\n/* harmony export */   \"setLegacyNoObservedAttributes\": () => (/* binding */ setLegacyNoObservedAttributes),\n/* harmony export */   \"useAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ useAdoptedStyleSheetsWithBuiltCSS),\n/* harmony export */   \"setUseAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ setUseAdoptedStyleSheetsWithBuiltCSS)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nconst useShadow = !(window.ShadyDOM) || !(window.ShadyDOM.inUse);\nconst useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nconst useNativeCustomElements = !(window.customElements.polyfillWrapFlushCallback);\nconst supportsAdoptingStyleSheets = useShadow &&\n    ('adoptedStyleSheets' in Document.prototype) &&\n    ('replaceSync' in CSSStyleSheet.prototype) &&\n    // Since spec may change, feature detect exact API we need\n    (() => {\n      try {\n        const sheet = new CSSStyleSheet();\n        sheet.replaceSync('');\n        const host = document.createElement('div');\n        host.attachShadow({mode: 'open'});\n        host.shadowRoot.adoptedStyleSheets = [sheet];\n        return (host.shadowRoot.adoptedStyleSheets[0] === sheet);\n      } catch(e) {\n        return false;\n      }\n    })();\n\n/**\n * Globally settable property that is automatically assigned to\n * `ElementMixin` instances, useful for binding in templates to\n * make URL's relative to an application's root.  Defaults to the main\n * document URL, but can be overridden by users.  It may be useful to set\n * `rootPath` to provide a stable application mount path when\n * using client side routing.\n */\nlet rootPath = window.Polymer && window.Polymer.rootPath ||\n  (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(document.baseURI || window.location.href);\n\n/**\n * Sets the global rootPath property used by `ElementMixin` and\n * available via `rootPath`.\n *\n * @param {string} path The new root path\n * @return {void}\n */\nconst setRootPath = function(path) {\n  rootPath = path;\n};\n\n/**\n * A global callback used to sanitize any value before inserting it into the DOM.\n * The callback signature is:\n *\n *  function sanitizeDOMValue(value, name, type, node) { ... }\n *\n * Where:\n *\n * `value` is the value to sanitize.\n * `name` is the name of an attribute or property (for example, href).\n * `type` indicates where the value is being inserted: one of property, attribute, or text.\n * `node` is the node where the value is being inserted.\n *\n * @type {(function(*,string,string,?Node):*)|undefined}\n */\nlet sanitizeDOMValue =\n  window.Polymer && window.Polymer.sanitizeDOMValue || undefined;\n\n/**\n * Sets the global sanitizeDOMValue available via this module's exported\n * `sanitizeDOMValue` variable.\n *\n * @param {(function(*,string,string,?Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback\n * @return {void}\n */\nconst setSanitizeDOMValue = function(newSanitizeDOMValue) {\n  sanitizeDOMValue = newSanitizeDOMValue;\n};\n\n/**\n * Gets sanitizeDOMValue, for environments that don't well support `export let`.\n *\n * @return {(function(*,string,string,?Node):*)|undefined} sanitizeDOMValue\n */\nconst getSanitizeDOMValue = function() {\n  return sanitizeDOMValue;\n};\n\n/**\n * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n * scrolling performance.\n * Defaults to `false` for backwards compatibility.\n */\nlet passiveTouchGestures =\n  window.Polymer && window.Polymer.setPassiveTouchGestures || false;\n\n/**\n * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.\n *\n * @param {boolean} usePassive enable or disable passive touch gestures globally\n * @return {void}\n */\nconst setPassiveTouchGestures = function(usePassive) {\n  passiveTouchGestures = usePassive;\n};\n\n/**\n * Setting to ensure Polymer template evaluation only occurs based on tempates\n * defined in trusted script.  When true, `<dom-module>` re-registration is\n * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`\n * templates will only evaluate in the context of a trusted element template.\n */\nlet strictTemplatePolicy =\n  window.Polymer && window.Polymer.strictTemplatePolicy || false;\n\n/**\n * Sets `strictTemplatePolicy` globally for all elements\n *\n * @param {boolean} useStrictPolicy enable or disable strict template policy\n *   globally\n * @return {void}\n */\nconst setStrictTemplatePolicy = function(useStrictPolicy) {\n  strictTemplatePolicy = useStrictPolicy;\n};\n\n/**\n * Setting to enable dom-module lookup from Polymer.Element.  By default,\n * templates must be defined in script using the `static get template()`\n * getter and the `html` tag function.  To enable legacy loading of templates\n * via dom-module, set this flag to true.\n */\nlet allowTemplateFromDomModule =\n  window.Polymer && window.Polymer.allowTemplateFromDomModule || false;\n\n/**\n * Sets `lookupTemplateFromDomModule` globally for all elements\n *\n * @param {boolean} allowDomModule enable or disable template lookup\n *   globally\n * @return {void}\n */\nconst setAllowTemplateFromDomModule = function(allowDomModule) {\n  allowTemplateFromDomModule = allowDomModule;\n};\n\n/**\n * Setting to skip processing style includes and re-writing urls in css styles.\n * Normally \"included\" styles are pulled into the element and all urls in styles\n * are re-written to be relative to the containing script url.\n * If no includes or relative urls are used in styles, these steps can be\n * skipped as an optimization.\n */\nlet legacyOptimizations =\n  window.Polymer && window.Polymer.legacyOptimizations || false;\n\n/**\n * Sets `legacyOptimizations` globally for all elements to enable optimizations\n * when only legacy based elements are used.\n *\n * @param {boolean} useLegacyOptimizations enable or disable legacy optimizations\n * includes and url rewriting\n * @return {void}\n */\nconst setLegacyOptimizations = function(useLegacyOptimizations) {\n  legacyOptimizations = useLegacyOptimizations;\n};\n\n/**\n * Setting to add warnings useful when migrating from Polymer 1.x to 2.x.\n */\nlet legacyWarnings =\n  window.Polymer && window.Polymer.legacyWarnings || false;\n\n/**\n * Sets `legacyWarnings` globally for all elements to migration warnings.\n *\n * @param {boolean} useLegacyWarnings enable or disable warnings\n * @return {void}\n */\nconst setLegacyWarnings = function(useLegacyWarnings) {\n  legacyWarnings = useLegacyWarnings;\n};\n\n/**\n * Setting to perform initial rendering synchronously when running under ShadyDOM.\n * This matches the behavior of Polymer 1.\n */\nlet syncInitialRender =\n  window.Polymer && window.Polymer.syncInitialRender || false;\n\n/**\n * Sets `syncInitialRender` globally for all elements to enable synchronous\n * initial rendering.\n *\n * @param {boolean} useSyncInitialRender enable or disable synchronous initial\n * rendering globally.\n * @return {void}\n */\nconst setSyncInitialRender = function(useSyncInitialRender) {\n  syncInitialRender = useSyncInitialRender;\n};\n\n/**\n * Setting to retain the legacy Polymer 1 behavior for multi-property\n * observers around undefined values. Observers and computed property methods\n * are not called until no argument is undefined.\n */\nlet legacyUndefined =\n  window.Polymer && window.Polymer.legacyUndefined || false;\n\n/**\n * Sets `legacyUndefined` globally for all elements to enable legacy\n * multi-property behavior for undefined values.\n *\n * @param {boolean} useLegacyUndefined enable or disable legacy\n * multi-property behavior for undefined.\n * @return {void}\n */\nconst setLegacyUndefined = function(useLegacyUndefined) {\n  legacyUndefined = useLegacyUndefined;\n};\n\n/**\n * Setting to ensure computed properties are computed in order to ensure\n * re-computation never occurs in a given turn.\n */\nlet orderedComputed =\n  window.Polymer && window.Polymer.orderedComputed || false;\n\n/**\n * Sets `orderedComputed` globally for all elements to enable ordered computed\n * property computation.\n *\n * @param {boolean} useOrderedComputed enable or disable ordered computed effects\n * @return {void}\n */\nconst setOrderedComputed = function(useOrderedComputed) {\n  orderedComputed = useOrderedComputed;\n};\n\n/**\n * Setting to cancel synthetic click events fired by older mobile browsers. Modern browsers\n * no longer fire synthetic click events, and the cancellation behavior can interfere\n * when programmatically clicking on elements.\n */\nlet cancelSyntheticClickEvents = true;\n\n/**\n * Sets `setCancelSyntheticEvents` globally for all elements to cancel synthetic click events.\n *\n * @param {boolean} useCancelSyntheticClickEvents enable or disable cancelling synthetic\n * events\n * @return {void}\n */\nconst setCancelSyntheticClickEvents = function(useCancelSyntheticClickEvents) {\n  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;\n};\n\n/**\n * Setting to remove nested templates inside `dom-if` and `dom-repeat` as\n * part of element template parsing.  This is a performance optimization that\n * eliminates most of the tax of needing two elements due to the loss of\n * type-extended templates as a result of the V1 specification changes.\n */\nlet removeNestedTemplates =\n  window.Polymer && window.Polymer.removeNestedTemplates || false;\n\n/**\n * Sets `removeNestedTemplates` globally, to eliminate nested templates\n * inside `dom-if` and `dom-repeat` as part of template parsing.\n *\n * @param {boolean} useRemoveNestedTemplates enable or disable removing nested\n *   templates during parsing\n * @return {void}\n */\nconst setRemoveNestedTemplates = function(useRemoveNestedTemplates) {\n  removeNestedTemplates = useRemoveNestedTemplates;\n};\n\n/**\n * Setting to place `dom-if` elements in a performance-optimized mode that takes\n * advantage of lighter-weight host runtime template stamping to eliminate the\n * need for an intermediate Templatizer `TemplateInstance` to mange the nodes\n * stamped by `dom-if`.  Under this setting, any Templatizer-provided API's\n * such as `modelForElement` will not be available for nodes stamped by\n * `dom-if`.\n */\nlet fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;\n\n/**\n * Sets `fastDomIf` globally, to put `dom-if` in a performance-optimized mode.\n *\n * @param {boolean} useFastDomIf enable or disable `dom-if` fast-mode\n * @return {void}\n */\nconst setFastDomIf = function(useFastDomIf) {\n  fastDomIf = useFastDomIf;\n};\n\n/**\n * Setting to disable `dom-change` and `rendered-item-count` events from\n * `dom-if` and `dom-repeat`. Users can opt back into `dom-change` events by\n * setting the `notify-dom-change` attribute (`notifyDomChange: true` property)\n * to `dom-if`/`don-repeat` instances.\n */\nlet suppressTemplateNotifications =\n  window.Polymer && window.Polymer.suppressTemplateNotifications || false;\n\n/**\n * Sets `suppressTemplateNotifications` globally, to disable `dom-change` and\n * `rendered-item-count` events from `dom-if` and `dom-repeat`.\n *\n * @param {boolean} suppress enable or disable `suppressTemplateNotifications`\n * @return {void}\n */\nconst setSuppressTemplateNotifications = function(suppress) {\n  suppressTemplateNotifications = suppress;\n};\n\n/**\n * Setting to disable use of dynamic attributes. This is an optimization\n * to avoid setting `observedAttributes`. Instead attributes are read\n * once at create time and set/removeAttribute are patched.\n */\nlet legacyNoObservedAttributes =\n  window.Polymer && window.Polymer.legacyNoObservedAttributes || false;\n\n/**\n * Sets `legacyNoObservedAttributes` globally, to disable `observedAttributes`.\n *\n * @param {boolean} noObservedAttributes enable or disable `legacyNoObservedAttributes`\n * @return {void}\n */\nconst setLegacyNoObservedAttributes = function(noObservedAttributes) {\n  legacyNoObservedAttributes = noObservedAttributes;\n};\n\n/**\n * Setting to enable use of `adoptedStyleSheets` for sharing style sheets\n * between component instances' shadow roots, if the app uses built Shady CSS\n * styles.\n */\nlet useAdoptedStyleSheetsWithBuiltCSS =\n  window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;\n\n/**\n * Sets `useAdoptedStyleSheetsWithBuiltCSS` globally.\n *\n * @param {boolean} value enable or disable `useAdoptedStyleSheetsWithBuiltCSS`\n * @return {void}\n */\nconst setUseAdoptedStyleSheetsWithBuiltCSS = function(value) {\n  useAdoptedStyleSheetsWithBuiltCSS = value;\n};\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/settings.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/style-gather.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/style-gather.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stylesFromModules\": () => (/* binding */ stylesFromModules),\n/* harmony export */   \"stylesFromModule\": () => (/* binding */ stylesFromModule),\n/* harmony export */   \"stylesFromTemplate\": () => (/* binding */ stylesFromTemplate),\n/* harmony export */   \"stylesFromModuleImports\": () => (/* binding */ stylesFromModuleImports),\n/* harmony export */   \"cssFromModules\": () => (/* binding */ cssFromModules),\n/* harmony export */   \"cssFromModule\": () => (/* binding */ cssFromModule),\n/* harmony export */   \"cssFromTemplate\": () => (/* binding */ cssFromTemplate),\n/* harmony export */   \"cssFromModuleImports\": () => (/* binding */ cssFromModuleImports)\n/* harmony export */ });\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module with utilities for collection CSS text from `<templates>`, external\n * stylesheets, and `dom-module`s.\n *\n * @summary Module with utilities for collection CSS text from various sources.\n */\n\n\n\n\nconst MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nconst INCLUDE_ATTR = 'include';\nconst SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n\n/**\n * @param {string} moduleId .\n * @return {?DomModule} .\n */\nfunction importModule(moduleId) {\n  return /** @type {?DomModule} */(_elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__.DomModule[\"import\"](moduleId));\n}\n\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  let container = importDoc.body ? importDoc.body : importDoc;\n  const importCss = (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(container.textContent,\n    importDoc.baseURI);\n  const style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n}\n\n/** @typedef {{assetpath: string}} */\nlet templateWithAssetPath; // eslint-disable-line no-unused-vars\n\n\n/**\n * Returns a list of <style> elements in a space-separated list of `dom-module`s.\n *\n * @function\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements\n */\nfunction stylesFromModules(moduleIds) {\n const modules = moduleIds.trim().split(/\\s+/);\n const styles = [];\n for (let i=0; i < modules.length; i++) {\n   styles.push(...stylesFromModule(modules[i]));\n }\n return styles;\n}\n\n/**\n * Returns a list of <style> elements in a given `dom-module`.\n * Styles in a `dom-module` can come either from `<style>`s within the\n * first `<template>`, or else from one or more\n * `<link rel=\"import\" type=\"css\">` links outside the template.\n *\n * @param {string} moduleId dom-module id to gather styles from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModule(moduleId) {\n  const m = importModule(moduleId);\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n\n  if (m._styles === undefined) {\n    const styles = [];\n    // module imports: <link rel=\"import\" type=\"css\">\n    styles.push(..._stylesFromModuleImports(m));\n    // include css from the first template in the module\n    const template = /** @type {?HTMLTemplateElement} */(\n        m.querySelector('template'));\n    if (template) {\n      styles.push(...stylesFromTemplate(template,\n        /** @type {templateWithAssetPath} */(m).assetpath));\n    }\n\n    m._styles = styles;\n  }\n\n  return m._styles;\n}\n\n/**\n * Returns the `<style>` elements within a given template.\n *\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string=} baseURI baseURI for style content\n * @return {!Array<!HTMLStyleElement>} Array of styles\n */\nfunction stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    const styles = [];\n    // if element is a template, get content from its .content\n    const e$ = template.content.querySelectorAll('style');\n    for (let i=0; i < e$.length; i++) {\n      let e = e$[i];\n      // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n      let include = e.getAttribute(INCLUDE_ATTR);\n      if (include) {\n        styles.push(...stylesFromModules(include).filter(function(item, index, self) {\n          return self.indexOf(item) === index;\n        }));\n      }\n      if (baseURI) {\n        e.textContent =\n            (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(e.textContent, /** @type {string} */ (baseURI));\n      }\n      styles.push(e);\n    }\n    template._styles = styles;\n  }\n  return template._styles;\n}\n\n/**\n * Returns a list of <style> elements  from stylesheets loaded via `<link rel=\"import\" type=\"css\">` links within the specified `dom-module`.\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModuleImports(moduleId) {\n let m = importModule(moduleId);\n return m ? _stylesFromModuleImports(m) : [];\n}\n\n/**\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {!Array<!HTMLStyleElement>} Array of contained styles\n */\nfunction _stylesFromModuleImports(module) {\n  const styles = [];\n  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n  for (let i=0; i < p$.length; i++) {\n    let p = p$[i];\n    if (p.import) {\n      const importDoc = p.import;\n      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n      if (unscoped && !importDoc._unscopedStyle) {\n        const style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n  return styles;\n}\n\n/**\n *\n * Returns CSS text of styles in a space-separated list of `dom-module`s.\n * Note: This method is deprecated, use `stylesFromModules` instead.\n *\n * @deprecated\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {string} Concatenated CSS content from specified `dom-module`s\n */\nfunction cssFromModules(moduleIds) {\n let modules = moduleIds.trim().split(/\\s+/);\n let cssText = '';\n for (let i=0; i < modules.length; i++) {\n   cssText += cssFromModule(modules[i]);\n }\n return cssText;\n}\n\n/**\n * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n * can come either from `<style>`s within the first `<template>`, or else\n * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n * template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromModule` instead.\n *\n * @deprecated\n * @param {string} moduleId dom-module id to gather styles from\n * @return {string} Concatenated CSS content from specified `dom-module`\n */\nfunction cssFromModule(moduleId) {\n  let m = importModule(moduleId);\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    let cssText = _cssFromModuleImports(m);\n    // include css from the first template in the module\n    let t = /** @type {?HTMLTemplateElement} */(m.querySelector('template'));\n    if (t) {\n      cssText += cssFromTemplate(t,\n        /** @type {templateWithAssetPath} */(m).assetpath);\n    }\n    m._cssText = cssText || null;\n  }\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n  return m && m._cssText || '';\n}\n\n/**\n * Returns CSS text of `<styles>` within a given template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromTemplate` instead.\n *\n * @deprecated\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Concatenated CSS content from specified template\n */\nfunction cssFromTemplate(template, baseURI) {\n  let cssText = '';\n  const e$ = stylesFromTemplate(template, baseURI);\n  // if element is a template, get content from its .content\n  for (let i=0; i < e$.length; i++) {\n    let e = e$[i];\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n    cssText += e.textContent;\n  }\n  return cssText;\n}\n\n/**\n * Returns CSS text from stylesheets loaded via `<link rel=\"import\" type=\"css\">`\n * links within the specified `dom-module`.\n *\n * Note: This method is deprecated, use `stylesFromModuleImports` instead.\n *\n * @deprecated\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {string} Concatenated CSS content from links in specified `dom-module`\n */\nfunction cssFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n}\n\n/**\n * @deprecated\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {string} Concatenated CSS content from links in the dom-module\n */\nfunction _cssFromModuleImports(module) {\n  let cssText = '';\n  let styles = _stylesFromModuleImports(module);\n  for (let i=0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n  return cssText;\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/style-gather.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/telemetry.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/telemetry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"instanceCount\": () => (/* binding */ instanceCount),\n/* harmony export */   \"incrementInstanceCount\": () => (/* binding */ incrementInstanceCount),\n/* harmony export */   \"registrations\": () => (/* binding */ registrations),\n/* harmony export */   \"register\": () => (/* binding */ register),\n/* harmony export */   \"dumpRegistrations\": () => (/* binding */ dumpRegistrations)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Total number of Polymer element instances created.\n * @type {number}\n */\nlet instanceCount = 0;\n\nfunction incrementInstanceCount() {\n  instanceCount++;\n}\n\n/**\n * Array of Polymer element classes that have been finalized.\n * @type {!Array<!PolymerElementConstructor>}\n */\nconst registrations = [];\n\n/**\n * @param {!PolymerElementConstructor} prototype Element prototype to log\n * @private\n */\nfunction _regLog(prototype) {\n  console.log('[' + /** @type {?} */(prototype).is + ']: registered');\n}\n\n/**\n * Registers a class prototype for telemetry purposes.\n * @param {!PolymerElementConstructor} prototype Element prototype to register\n * @protected\n */\nfunction register(prototype) {\n  registrations.push(prototype);\n}\n\n/**\n * Logs all elements registered with an `is` to the console.\n * @public\n */\nfunction dumpRegistrations() {\n  registrations.forEach(_regLog);\n}\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/telemetry.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/wrap.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/wrap.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable valid-jsdoc */\n/**\n * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill\n * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,\n * a node wrapper must be used to access ShadowDOM API.\n * This is similar to using `Polymer.dom` but relies exclusively\n * on the presence of the ShadyDOM polyfill rather than requiring the loading\n * of legacy (Polymer.dom) API.\n * @type {function(Node):Node}\n */\nconst wrap = (window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap']) ?\n  window['ShadyDOM']['wrap'] :\n  (window['ShadyDOM'] ? (n) => ShadyDOM['patch'](n) : (n) => n);\n\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/lib/utils/wrap.js?");

/***/ }),

/***/ "./node_modules/@polymer/polymer/polymer-element.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/polymer-element.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"html\": () => (/* reexport safe */ _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__.html),\n/* harmony export */   \"version\": () => (/* reexport safe */ _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.version),\n/* harmony export */   \"PolymerElement\": () => (/* binding */ PolymerElement)\n/* harmony export */ });\n/* harmony import */ var _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mixins/element-mixin.js */ \"./node_modules/@polymer/polymer/lib/mixins/element-mixin.js\");\n/* harmony import */ var _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\n * Base class that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * @customElement\n * @polymer\n * @constructor\n * @implements {Polymer_ElementMixin}\n * @extends HTMLElement\n * @appliesMixin ElementMixin\n * @summary Custom element base class that provides the core API for Polymer's\n *   key meta-programming features including template stamping, data-binding,\n *   attribute deserialization, and property change observation\n */\nconst PolymerElement = (0,_lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.ElementMixin)(HTMLElement);\n\n\n//# sourceURL=webpack://test/./node_modules/@polymer/polymer/polymer-element.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChartSeriesElement\": () => (/* binding */ ChartSeriesElement)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-chart.js */ \"./node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js\");\n/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\n\n\n\n/**\n * `<vaadin-chart-series>` is a custom element for creating series for Vaadin Charts.\n *\n * ### Basic use\n *\n * To use `<vaadin-chart-series>`, simply add it inside a `<vaadin-chart>` element:\n *\n * ```html\n *  <vaadin-chart>\n *    <vaadin-chart-series></vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * `<vaadin-chart-series>` accepts `values` as an array attribute, so you can add it to your element definition:\n *\n * ```html\n *  <vaadin-chart-series values=\"[10,20,30,40,50]\"></vaadin-chart-series>\n * ```\n *\n * which will add a new line series, where each value will be a data point.\n * Look for the Properties session to see all available attributes.\n *\n * ### Dynamically adding and removing series\n *\n * You are also able to add and remove series by using DOM API.\n *\n * To create a new series, simply call `document.createElement('vaadin-chart-series')` and append it to your `<vaadin-chart>`:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const newSeries = document.createElement('vaadin-chart-series');\n *  newSeries.values = [10,20,30,40,50];\n *  chart.appendChild(newSeries);\n * ```\n *\n * In order to remove it, you should use the series to be removed as a reference for the `#removeChild()` call:\n *\n * ```js\n *  const chart = \\* a <vaadin-chart> reference *\\\n *  const seriesToBeRemoved = \\* a <vaadin-chart-series> reference to remove*\\\n *  chart.removeChild(seriesToBeRemoved);\n * ```\n *\n * (There's an issue with `#remove()` method on Firefox, so we advice to remove the element from its parent)\n *\n *\n * @polymer\n * @customElement\n * @extends {Polymer.Element}\n * @extends PolymerElement\n * @demo demo/index.html\n */\nclass ChartSeriesElement extends _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement {\n  static get is() {\n    return 'vaadin-chart-series';\n  }\n\n  get options() {\n    const options = _vaadin_chart_js__WEBPACK_IMPORTED_MODULE_1__.ChartDeepMerger.__deepMerge({}, this.additionalOptions);\n\n    if (this.type) {\n      options.type = this.type;\n    }\n\n    if (this.title) {\n      options.name = this.title;\n    }\n\n    if (this.values) {\n      options.data = this.values;\n    }\n\n    if (this.markers) {\n      if (!this.__isMarkersValid()) {\n        this.markers = 'auto';\n      }\n      options.marker = this.__markersConfiguration;\n    }\n\n    if (this.unit) {\n      options.yAxis = this.unit;\n    }\n\n    if (this.stack) {\n      options.stack = this.stack;\n    }\n\n    if (isFinite(this.valueMin)) {\n      options.yAxisValueMin = this.valueMin;\n    }\n\n    if (isFinite(this.valueMax)) {\n      options.yAxisValueMax = this.valueMax;\n    }\n\n    if (this.neckWidth) {\n      options.neckWidth = this.neckWidth;\n    }\n\n    if (this.neckPosition) {\n      options.neckHeight = this.neckPosition;\n    }\n\n    return options;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * An array of data used by the series.\n       * Format depends on the chart type and can be:\n       *   - An array of numerical values `[y0, y1, y2, y3,...]`\n       *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`\n       *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`\n       *\n       *  See more in [API Site](https://api.highcharts.com/highcharts/series)\n       *\n       * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)\n       * to mutate the values array in order to make the component aware of the\n       * change and be able to synchronize it.\n       */\n      values: {\n        type: Array,\n        value: () => []\n      },\n\n      /**\n       *  Value-axis minimum-value.\n       *  Sets the value to a series bound by 'unit' property.\n       *  Otherwise sets the value to the first series.\n       *  Undefined by default (determined from data).\n       */\n      valueMin: {\n        type: Number,\n        observer: '__valueMinObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       *  Value-axis maximum-value.\n       *  See the 'valueMin'\n       */\n      valueMax: {\n        type: Number,\n        observer: '__valueMaxObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       *  A string with the type of the series.\n       *  Defaults to `'line'` in case no type is set for the chart.\n       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.\n       */\n      type: {\n        type: String,\n        observer: '__typeObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * The name of the series as shown in the legend, tooltip etc.\n       */\n      title: {\n        type: String,\n        observer: '__titleObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Shows/hides data-point markers for line-like series.\n       * Acceptable input are:\n       *  - `shown`: markers are always visible\n       *  - `hidden`: markers are always hidden\n       *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*\n       */\n      markers: {\n        type: String,\n        observer: '__markersObserver',\n        reflectToAttribute: true\n      },\n\n      /** Used to connect the series to an axis; if multiple series have the same unit, they will share axis.\n       * Displayed as a title for the axis.\n       * If no unit is defined, then series will be connected to the first axis.\n       */\n      unit: {\n        type: String,\n        observer: '__unitObserver',\n        reflectToAttribute: true\n      },\n\n      /** Used to group series in a different stacks.\n       * \"stacking\" property should be specified either for each series or in plotOptions.\n       * It is recommended to place series in a single stack, when they belong to the same yAxis.\n       */\n      stack: {\n        type: String,\n        observer: '__stackObserver',\n        reflectToAttribute: true\n      },\n\n      /** The height of the neck, the lower part of the funnel.\n       * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.\n       * Note that this property only applies for \"funnel\" charts.\n       */\n      neckPosition: {\n        type: String,\n        observer: '__neckPositionOberserver',\n        reflectToAttribute: true\n      },\n\n      /** The width of the neck, the lower part of the funnel.\n       * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.\n       * Note that this property only applies for \"funnel\" charts.\n       */\n      neckWidth: {\n        type: String,\n        observer: '__neckWidthOberserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Object with the configured options defined and used to create a series.\n       *\n       * @readonly\n       */\n      options: {\n        type: Object\n      },\n\n      /**\n       * Represents additional JSON configuration.\n       */\n      additionalOptions: {\n        type: Object,\n        reflectToAttribute: true\n      }\n    };\n  }\n\n  static get observers() {\n    return [\n      '__valuesObserver(values.splices)',\n      '__additionalOptionsObserver(additionalOptions.*)'\n    ];\n  }\n\n  /**\n   * Method to attach a series object of type `Highcharts.Series`.\n   * @param series Object of type `Highcharts.Series`\n   */\n  setSeries(series) {\n    this._series = series;\n  }\n\n  __valuesObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.setData(this.values);\n    }\n  }\n\n  __additionalOptionsObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update(this.additionalOptions);\n    }\n  }\n\n  __valueMinObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    if (!isFinite(this.valueMin)) {\n      this.__showWarn('value-min', 'Numbers or null');\n      return;\n    }\n\n    if (this._series.yAxis) {\n      this._series.yAxis.update({\n        min: this.valueMin\n      });\n    }\n  }\n\n  __valueMaxObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    if (!isFinite(this.valueMax)) {\n      this.__showWarn('value-max', 'Numbers or null');\n      return;\n    }\n\n    if (this._series.yAxis) {\n      this._series.yAxis.update({\n        max: this.valueMax\n      });\n    }\n  }\n\n  __typeObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        type: this.type\n      });\n    }\n  }\n\n  __titleObserver() {\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        name: this.title\n      });\n    }\n  }\n\n  __stackObserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n\n    this._series.update({\n      stack: this.stack\n    });\n  }\n\n  __neckPositionOberserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n    this._series.update({\n      neckHeight: this.neckPosition\n    });\n  }\n\n  __neckWidthOberserver() {\n    if (!this.__hasSeriesConfig()) {\n      return;\n    }\n    this._series.update({\n      neckWidth: this.neckWidth\n    });\n  }\n\n  __unitObserver() {\n    if (this.__hasSeriesConfig()) {\n      const parent = this.parentNode instanceof _vaadin_chart_js__WEBPACK_IMPORTED_MODULE_1__.ChartElement && this.parentNode;\n      if (parent && parent instanceof _vaadin_chart_js__WEBPACK_IMPORTED_MODULE_1__.ChartElement) {\n\n        if (this.unit && !parent.__getAxis(this.unit)) {\n          const title = {title: {text: this.unit}};\n          parent.__addAxis(Object.assign({id: this.unit, axisGenerated: true}, title));\n        }\n        this._series.update({yAxis: this.unit || 0});\n        this.__valueMinObserver();\n        this.__valueMaxObserver();\n        parent.__removeAxisIfEmpty();\n      }\n    }\n  }\n\n  __hasSeriesConfig() {\n    return !!this._series;\n  }\n\n  __isMarkersValid() {\n    if (['shown', 'hidden', 'auto'].indexOf(this.markers) === -1) {\n      this.__showWarn('markers', '\"shown\", \"hidden\" or \"auto\"');\n      return false;\n    }\n    return true;\n  }\n\n  __markersObserver() {\n    if (!this.__isMarkersValid()) {\n      this.markers = 'auto';\n      return;\n    }\n    if (this.__hasSeriesConfig()) {\n      this._series.update({\n        marker: this.__markersConfiguration\n      });\n    }\n  }\n\n  get __markersConfiguration() {\n    const config = {};\n    switch (this.markers) {\n      case 'shown':\n        config.enabled = true;\n        break;\n      case 'hidden':\n        config.enabled = false;\n        break;\n      case 'auto':\n      default:\n        config.enabled = null;\n        break;\n    }\n\n    return config;\n  }\n\n  __showWarn(propertyName, acceptedValues) {\n    console.warn('<vaadin-chart-series> Acceptable values for \"' + propertyName + '\" are ' + acceptedValues);\n  }\n}\n\ncustomElements.define(ChartSeriesElement.is, ChartSeriesElement);\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChartDeepMerger\": () => (/* binding */ ChartDeepMerger),\n/* harmony export */   \"ChartElement\": () => (/* binding */ ChartElement)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/flattened-nodes-observer.js */ \"./node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@polymer/polymer/lib/utils/render-status.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_element_mixin_vaadin_element_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/vaadin-element-mixin/vaadin-element-mixin.js */ \"./node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_license_checker_vaadin_license_checker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @vaadin/vaadin-license-checker/vaadin-license-checker.js */ \"./node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js\");\n/* harmony import */ var _vaadin_chart_series_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vaadin-chart-series.js */ \"./node_modules/@vaadin/vaadin-charts/src/vaadin-chart-series.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _webcomponents_shadycss_src_style_settings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @webcomponents/shadycss/src/style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/* harmony import */ var _webcomponents_shadycss_src_scoping_shim_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @webcomponents/shadycss/src/scoping-shim.js */ \"./node_modules/@webcomponents/shadycss/src/scoping-shim.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! highcharts/js/es-modules/masters/highstock.src.js */ \"./node_modules/highcharts/js/es-modules/masters/highstock.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_accessibility_src_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/accessibility.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_highcharts_more_src_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! highcharts/js/es-modules/masters/highcharts-more.src.js */ \"./node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_highcharts_3d_src_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! highcharts/js/es-modules/masters/highcharts-3d.src.js */ \"./node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_data_src_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/data.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/data.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_drilldown_src_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/drilldown.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_exporting_src_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/exporting.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_funnel_src_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/funnel.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_heatmap_src_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/heatmap.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_solid_gauge_src_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/solid-gauge.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_treemap_src_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/treemap.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js\");\n/* harmony import */ var highcharts_js_es_modules_masters_modules_no_data_to_display_src_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! highcharts/js/es-modules/masters/modules/no-data-to-display.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js\");\n/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\n\n\n\n\n\n\n\n\n\n\n\n     \n\n     \n\n\n\n\n\n\n\n\n\n\n\n\n/** @private */\n// eslint-disable-next-line no-unused-vars\nconst ChartDeepMerger = (() => class {\n\n  static __isObject(item) {\n    return (item && typeof item === 'object' && !Array.isArray(item));\n  }\n\n  static __deepMerge(target, source) {\n    if (this.__isObject(source) && this.__isObject(target)) {\n      for (const key in source) {\n        if (this.__isObject(source[key])) {\n          if (!target[key]) {\n            Object.assign(target, {[key]: {}});\n          }\n\n          this.__deepMerge(target[key], source[key]);\n        } else {\n          Object.assign(target, {[key]: source[key]});\n        }\n      }\n    }\n\n    return target;\n  }\n})();\n\nif (highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]) {\n  ['exportChart', 'exportChartLocal', 'getSVG'].forEach(methodName => {\n    highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].wrap(\n      highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].Chart.prototype,\n      methodName,\n      function(proceed) {\n        highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].fireEvent(this, 'beforeExport');\n        const result = proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].fireEvent(this, 'afterExport');\n        return result;\n      }\n    );\n  });\n}\nif (highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]) {\n  highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].wrap(\n    highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].seriesTypes.column.prototype,\n    'plotGroup',\n    function(proceed, prop, name, visibility, zIndex, parent) {\n      if (this.chart.is3d() && this[prop]) {\n        delete this[prop];\n      }\n      return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n  );\n}\nif (!_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement) {\n  console.warn(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);\n}\n\n/**\n * `<vaadin-chart>` is a Web Component for creating high quality charts.\n *\n * ### Quick Start\n *\n * #### Polymer 2 App\n *\n * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/2.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-2-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * bower install --save vaadin-charts\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.html` and add the following snipped before the `<dom-module>` tag\n * ```html\n * <link rel=\"import\" href=\"../../bower_components/vaadin-charts/vaadin-chart.html\">\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.html` add the following snippet before the `</template>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * #### Polymer 3 App\n *\n * * 1. Create a Polymer application using [Polymer CLI](https://www.polymer-project.org/3.0/docs/tools/polymer-cli)\n * ```\n * mkdir my-app\n * cd my-app\n * polymer init\n * select `polymer-3-application`\n * ```\n * 1. Install Vaadin Charts\n * ```\n * npm i @vaadin/vaadin-charts --save\n * ```\n * 1. Import `<vaadin-chart>` to your app\n * Edit the file `src/my-app/my-app.js` and add the following snipped on the top, after the first `import` declaration\n * ```js\n * import '@vaadin/vaadin-charts';\n * ```\n * 1. Add your first `<vaadin-chart>`\n * Also in `my-app.js`, at the template getter, add the following snippet after the `</h2>` closing tag\n * ```html\n * <vaadin-chart></vaadin-chart>\n * ```\n * 1. Run your app with:\n * ```\n * polymer serve --npm --open\n * ```\n *\n * Congratulations! You have your first Vaadin Chart setup.\n *\n * ### Basic use\n *\n * Now that we covered the basic steps to create an empty chart, let us show how you can configure it.\n *\n * There are two ways of configuring your `<vaadin-chart>` element: **HTML API**, **JS API** and **JSON API**.\n * Note that you can make use of all APIs in your element.\n *\n * #### Configuring your chart using HTML API\n *\n * `vaadin-chart` has a set of attributes to make it easier for you to customize your chart.\n * Using as a base the project created with in Quick Start:\n *\n * ```html\n *  <vaadin-chart title=\"The chart title\" subtitle=\"The chart subtitle\">\n *    <vaadin-chart-series\n *          type=\"column\"\n *          title=\"The series title\"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * > Note that while you can set type for each series individually, for some types, such as `'bar'`, `'gauge'` and `'solidgauge'`, you\n * > have to set it as the default series type on `<vaadin-chart>` in order to work properly.\n *\n * #### Configuring your chart using JS API\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `configuration` property (JS Api) to set chart title, categories and data\n * ```js\n * initChartWithJSApi() {\n *     Polymer.RenderStatus.beforeNextRender(this, () => {\n *        const configuration = this.$.mychart.configuration;\n *        configuration.setTitle({ text: 'The chart title' });\n *        // By default there is one x axis, it is referenced by configuration.xAxis[0].\n *        configuration.xAxis[0].setCategories(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);\n *        configuration.addSeries({\n *            type: 'column',\n *            data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *        });\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n *\n * #### Configuring your chart using JS JSON API\n *\n * JS JSON API is a simple alternative to the JS API.\n *\n * Using as a base the project created with in Quick Start\n *\n * Do the following changes in `my-app.html`\n *\n * 1. Set and id for the `<vaadin-chart>` in the template\n * ```html\n *     <vaadin-chart id=\"mychart\"></vaadin-chart>\n * ```\n * 1. Add a function that uses `update` method (JS JSON Api) to set chart title, categories and data\n * ```js\n * initChartWithJSJSONApi() {\n *     this.$.mychart.update({\n *       title: {\n *         text: 'The chart title'\n *       },\n *       subtitle: {\n *         text: 'Subtitle'\n *       },\n *       xAxis: {\n *         categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n *       },\n *       series: [{\n *         type: 'column',\n *         data: [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]\n *       }]\n *     });\n * }\n * ```\n * 1. Call that function from connectedCallback (when the element is added to a document)\n * ```js\n * connectedCallback() {\n *     super.connectedCallback();\n *     this.initChartWithJSJSONApi();\n * }\n * ```\n * 1. And finally run your app with:\n * ```\n * polymer serve --open\n * ```\n *\n * It should be noted that chart style customization cannot be done via the JS or JSON API.\n * Styling properties in the JSON configuration will be ignored. The following section discusses chart styling.\n *\n *\n * ### CSS Styling\n * Chart appearance is primarily controlled by CSS style rules.\n * A comprehensive list of the supported style classes can be found at\n * https://www.highcharts.com/docs/chart-design-and-style/style-by-css\n *\n *\n * ### Steps for styling a chart\n *\n * 1. Create a theme file (for example `shared-styles.html`). The theme's dom-module must declare `theme-for=vaadin-chart`.\n * 2. Import `vaadin-chart-default-theme.html` and declare `include=\"vaadin-chart-default-theme\"`\n * on the theme module's style tag to customize Chart's default theme. If there are multiple theme\n * modules *only one* of them should declare this `include`.\n * 3. Specify the desired CSS rules in the theme file.\n * 4. If multiple charts are present, each one can be specifically targeted using the host selector e.g `:host(.my-chart-class)`.\n * 5. Import the theme file.\n *\n *\n * ### Example: Two Charts with a Red Title but only one with a Blue Subtitle\n *\n * ```html\n * <link rel=\"import\" href=\"shared-styles.html\">\n * ...\n * <vaadin-chart title=\"Red Title\" subtitle=\"Not Styled\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n *\n * <vaadin-chart class=\"blue-subtitle\" title=\"Red Title\" subtitle=\"Blue Subtitle\">\n *   <vaadin-chart-series values=\"[19,12,9,24,5]\"></vaadin-chart-series>\n * </vaadin-chart>\n * ```\n *\n * shared-styles.html\n *\n * ```html\n * <link rel=\"import\" href=\"../bower_components/vaadin-charts/theme/vaadin-chart-default-theme.html\">\n *\n * <dom-module id=\"css-style-example\" theme-for=\"vaadin-chart\">\n *    <template>\n *      <style include=\"vaadin-chart-default-theme\">\n *        .highcharts-title {\n *          fill: red;\n *          font-size: xx-large;\n *        }\n *\n *        :host(.blue-subtitle) .highcharts-subtitle {\n *          fill: blue;\n *        }\n *      </style>\n *    </template>\n * </dom-module>\n * ```\n *\n * ### RTL support\n *\n * `vaadin-charts` as well as [Highcharts](https://www.highcharts.com/) by itself are not adjusting the layout\n * based on the `dir` attribute. In order to make `vaadin-charts` display RTL content properly additional\n * JSON configuration should be used.\n * Each chart should be updated based on the specific needs, but general recommendations are:\n *\n *  1. Set `reversed` to true for xAxis (https://api.highcharts.com/highcharts/xAxis.reversed).\n *  2. Set `useHTML` to true for text elements, i.e. `tooltip` (https://api.highcharts.com/highcharts/tooltip.useHTML).\n *  3. Set `rtl` to true for `legend` (https://api.highcharts.com/highcharts/legend.rtl).\n *\n * Using as a base the project created with in Quick Start and an `additionalOptions` in order to make RTL adjustments:\n *\n * ```html\n *  <vaadin-chart title=\"-  \" subtitle=\"-   \"\n *    additional-options='{\"title\": {\"useHTML\": true}, \"tooltip\": {\"useHTML\": true}, \"subtitle\": {\"useHTML\": true},\n *    \"legend\": {\"rtl\": true}, \"yAxis\": [{\"id\": \"- \", \"title\": {\"text\": \"- \", \"useHTML\": true}}],\n *    \"xAxis\": {\"reversed\": true}}'>\n *    <vaadin-chart-series\n *          type= \"column\"\n *          title=\"-  \"\n *          unit=\"- \"\n *          values=\"[10,20,30]\">\n *    </vaadin-chart-series>\n *  </vaadin-chart>\n * ```\n *\n * ### Setting colors\n *\n * Although charts can be styled as described above, there is a simpler way for setting colors.\n * Colors can be set using CSS custom properties `--vaadin-charts-color-{n}` (where `n` goes from `0 - 9`).\n *\n * For example `--vaadin-charts-color-0` sets the color of the first series on a chart.\n *\n * ### Validating your License\n * After one day using Vaadin Charts in a development environment you will see a pop-up that asks you\n * to validate your license by signing in to vaadin.com.\n *\n * @extends PolymerElement\n * @demo demo/index.html\n */\nclass ChartElement extends (0,_vaadin_vaadin_element_mixin_vaadin_element_mixin_js__WEBPACK_IMPORTED_MODULE_4__.ElementMixin)((0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.ThemableMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement)) {\n  static get template() {\n    return _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_7__.html`\n    <style>\n      :host {\n        display: block;\n        width: 100%;\n        overflow: hidden;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n    </style>\n    <div id=\"chart\"></div>\n    <slot id=\"slot\"></slot>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-chart';\n  }\n\n  static get version() {\n    return '6.3.3';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Configuration object that exposes the JS Api to configure the chart.\n       *\n       * Most important methods are:\n       * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`\n       * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`\n       * - `setTitle (Object title, object subtitle, Boolean redraw)`\n       *\n       * Most important properties are:\n       * - `configuration.series`: An array of the chart's series. Detailed API for Series object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)\n       * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n       * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is\n       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)\n       * - `configuration.title`: The chart title.\n       *\n       * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)\n       * @readonly\n       * @public\n       * @type {Object}\n       */\n      configuration: Object,\n\n      /**\n       * If categories are present names are used instead of numbers for the category axis.\n       * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`\n       * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.\n       */\n      categories: {\n        type: Object,\n        reflectToAttribute: true,\n        observer: '__updateCategories'\n      },\n\n      /**\n       * Category-axis maximum value. Defaults to `undefined`.\n       */\n      categoryMax: {\n        type: Number,\n        observer: '__updateCategoryMax',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Category-axis minimum value. Defaults to `undefined`.\n       */\n      categoryMin: {\n        type: Number,\n        observer: '__updateCategoryMin',\n        reflectToAttribute: true\n      },\n\n      /**\n       * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`\n       * except for bar charts which only accept `left` and `right`.\n       * With the default value, charts appear as though they have `category-position=\"bottom\"`\n       * except for bar charts that appear as though they have `category-position=\"left\"`.\n       *\n       * Defaults to `undefined`\n       */\n      categoryPosition: {\n        type: String,\n        observer: '__updateCategoryPosition',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether to hide legend or show.\n       * Legend configuration can be set up via additionalOptions property\n       */\n      noLegend: {\n        type: Boolean,\n        observer: '__hideLegend',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies how series are stacked on top of each other.\n       * Possible values are null, \"normal\" or \"percent\".\n       * If \"stack\" property is not defined on the vaadin-chart-series elements, then series will be put into\n       * the default stack.\n       */\n      stacking: {\n        type: String,\n        observer: '__stackingObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether the chart is a normal chart or a timeline chart.\n       */\n      timeline: {\n        type: Boolean,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents the title of the chart.\n       */\n      title: {\n        type: String,\n        observer: '__updateTitle',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Whether or not to show tooltip when hovering data points.\n       */\n      tooltip: {\n        type: Boolean,\n        observer: '__tooltipObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Sets the default series type of the chart.\n       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.\n       */\n      type: {\n        type: String,\n        observer: '__updateType',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents the subtitle of the chart.\n       */\n      subtitle: {\n        type: String,\n        observer: '__updateSubtitle',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies whether to show chart in 3 or in 2 dimensions.\n       * Some display angles are added by default to the \"chart.options3d\" (`{alpha: 15, beta: 15, depth: 50}`).\n       * 3D display options can be modified via `additionalOptions`.\n       * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.\n       * 3D is supported by Bar, Column, Pie and Scatter3D charts.\n       * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).\n       */\n      chart3d: {\n        type: Boolean,\n        observer: '__chart3dObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Specifies the message displayed on a chart without displayable data.\n       */\n      emptyText: {\n        type: String,\n        value: ' ',\n        observer: '__emptyTextObserver',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Represents additional JSON configuration.\n       */\n      additionalOptions: {\n        type: Object,\n        reflectToAttribute: true\n      },\n\n      /**\n       * When present, cartesian charts like line, spline, area and column are transformed\n       * into the polar coordinate system.\n       */\n      polar: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '__polarObserver'\n      }\n    };\n  }\n\n  static get observers() {\n    return [\n      '__updateAdditionalOptions(additionalOptions.*)'\n    ];\n  }\n\n  /**\n   * @protected\n   */\n  static _finalizeClass() {\n    super._finalizeClass();\n\n    const devModeCallback = window.Vaadin.developmentModeCallback;\n    const licenseChecker = devModeCallback && devModeCallback['vaadin-license-checker'];\n    if (typeof licenseChecker === 'function') {\n      licenseChecker(ChartElement);\n    }\n  }\n\n  constructor() {\n    super();\n\n    /**\n     * List of properties that will always be copied from the chart element to the container div\n     **/\n    this._copyStyleProperties = ['flex', '-webkit-flex', '-ms-flex'];\n\n    this._baseConfig = {\n      credits: {\n        enabled: false\n      },\n      exporting: {\n        enabled: false\n      },\n      title: {\n        text: null\n      },\n      series: [],\n      xAxis: {\n\n      },\n      yAxis: {\n        axisGenerated: true\n      }\n    };\n\n    this._baseChart3d = {\n      enabled: true,\n      alpha: 15,\n      beta: 15,\n      depth: 50\n    };\n\n    this.__mutationCallback = this.__mutationCallback.bind(this);\n  }\n\n  /** @private */\n  connectedCallback() {\n    super.connectedCallback();\n    this.__updateStyles();\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_2__.beforeNextRender)(this, () => {\n      // Detect if the chart had already been initialized. This might happen in\n      // environments where the chart is lazily attached (e.g Grid).\n      if (this.configuration) {\n        this.__reflow();\n        return;\n      }\n\n      const options = Object.assign({}, this.options, this._jsonConfigurationBuffer);\n      this._jsonConfigurationBuffer = null;\n      this.__initChart(options);\n      this.__addChildObserver();\n      const config = {attributes: true, characterData: true};\n      this.__mutationObserver = new MutationObserver(this.__mutationCallback);\n      this.__mutationObserver.observe(this, config);\n    });\n  }\n\n  get options() {\n    const options = Object.assign({}, this._baseConfig);\n    ChartDeepMerger.__deepMerge(options, this.additionalOptions);\n\n    if (this.type) {\n      options.chart = options.chart || {};\n      options.chart.type = this.type;\n    }\n\n    if (this.polar) {\n      options.chart = options.chart || {};\n      options.chart.polar = true;\n    }\n\n    if (this.title) {\n      options.title = {\n        text: this.title\n      };\n    }\n\n    if (!options.tooltip) {\n      // Workaround for highcharts#7398 to make updating tooltip works\n      options.tooltip = {};\n      if (!this.tooltip) {\n        options.tooltip.enabled = false;\n      }\n    }\n\n    if (this.subtitle) {\n      options.subtitle = {\n        text: this.subtitle\n      };\n    }\n\n    if (this.categories) {\n      options.xAxis = options.xAxis || {};\n      if (Array.isArray(options.xAxis)) {\n        // Set categories on first x axis\n        options.xAxis[0].categories = this.categories;\n      } else {\n        options.xAxis.categories = this.categories;\n      }\n    }\n\n    if (isFinite(this.categoryMin)) {\n      options.xAxis = options.xAxis || {};\n      if (Array.isArray(options.xAxis)) {\n        // Set category-min on first x axis\n        options.xAxis[0].min = this.categoryMin;\n      } else {\n        options.xAxis.min = this.categoryMin;\n      }\n    }\n\n    if (isFinite(this.categoryMax)) {\n      options.xAxis = options.xAxis || {};\n      if (Array.isArray(options.xAxis)) {\n        // Set category-max on first x axis\n        options.xAxis[0].max = this.categoryMax;\n      } else {\n        options.xAxis.max = this.categoryMax;\n      }\n    }\n\n    if (this.noLegend) {\n      options.legend = {\n        enabled: false\n      };\n    }\n\n    if (this.emptyText) {\n      options.lang = options.lang || {};\n      options.lang.noData = this.emptyText;\n    }\n\n    if (this.categoryPosition) {\n      options.chart = options.chart || {};\n\n      options.chart.inverted = this.__shouldInvert();\n\n      if (Array.isArray(options.xAxis)) {\n        options.xAxis.forEach(e => e.opposite = this.__shouldFlipOpposite());\n      } else if (options.xAxis) {\n        options.xAxis.opposite = this.__shouldFlipOpposite();\n      }\n    }\n\n    if (this.stacking) {\n      options.plotOptions = options.plotOptions || {};\n      options.plotOptions.series = options.plotOptions.series || {};\n      options.plotOptions.series.stacking = this.stacking;\n    }\n\n    if (this.chart3d) {\n      options.chart = options.chart || {};\n\n      options.chart.options3d = Object.assign({}, this._baseChart3d, options.chart.options3d);\n    }\n\n    return options;\n  }\n\n  /**\n   *  Name of the chart events to add to the configuration and its corresponding event for the chart element\n   **/\n  get __chartEventNames() {\n    return {\n\n      /**\n       *\n       * @event chart-add-series  Fired when a new series is added\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      addSeries: 'chart-add-series',\n      /**\n       *\n       * @event chart-after-export  Fired after a chart is exported\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      afterExport: 'chart-after-export',\n      /**\n       *\n       * @event chart-after-print  Fired after a chart is printed\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      afterPrint: 'chart-after-print',\n      /**\n       *\n       * @event chart-before-export  Fired before a chart is exported\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      beforeExport: 'chart-before-export',\n      /**\n       *\n       * @event chart-before-print  Fired before a chart is printed\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      beforePrint: 'chart-before-print',\n      /**\n       *\n       * @event chart-click  Fired when clicking on the plot background\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      click: 'chart-click',\n      /**\n       *\n       * @event chart-drilldown  Fired when drilldown point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drilldown: 'chart-drilldown',\n      /**\n       *\n       * @event chart-drillup  Fired when drilling up from a drilldown series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drillup: 'chart-drillup',\n      /**\n       *\n       * @event chart-drillupall  Fired after all the series  has been drilled up\n       *                          if chart has multiple drilldown series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      drillupall: 'chart-drillupall',\n      /**\n       *\n       * @event chart-load  Fired when the chart is finished loading\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      load: 'chart-load',\n      /**\n       *\n       * @event chart-redraw  Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`\n       *                      or after an axis, series or point is modified with the `redraw` option set to `true`\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      redraw: 'chart-redraw',\n      /**\n       *\n       * @event chart-selection  Fired when an area of the chart has been selected\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} chart Chart object where the event was sent from\n       */\n      selection: 'chart-selection'\n    };\n  }\n\n  /**\n   *  Name of the series events to add to the configuration and its corresponding event for the chart element\n   **/\n  get __seriesEventNames() {\n    return {\n      /**\n       *\n       * @event series-after-animate  Fired when the series has finished its initial animation\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      afterAnimate: 'series-after-animate',\n      /**\n       *\n       * @event series-checkbox-click  Fired when the checkbox next to the series' name in the legend is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      checkboxClick: 'series-checkbox-click',\n      /**\n       *\n       * @event series-click  Fired when the series is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      click: 'series-click',\n      /**\n       *\n       * @event series-hide  Fired when the series is hidden after chart generation time\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      hide: 'series-hide',\n      /**\n       *\n       * @event series-legend-item-click  Fired when the legend item belonging to the series is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      legendItemClick: 'series-legend-item-click',\n      /**\n       *\n       * @event series-mouse-out  Fired when the mouses leave the graph\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      mouseOut: 'series-mouse-out',\n      /**\n       *\n       * @event series-mouse-over  Fired when the mouse enters the graph\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      mouseOver: 'series-mouse-over',\n      /**\n       *\n       * @event series-show  Fired when the series is show after chart generation time\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} series Series object where the event was sent from\n       */\n      show: 'series-show'\n    };\n  }\n\n  /**\n   *  Name of the point events to add to the configuration and its corresponding event for the chart element\n   **/\n  get __pointEventNames() {\n    return {\n      /**\n       *\n       * @event point-click  Fired when the point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      click: 'point-click',\n      /**\n       *\n       * @event point-legend-item-click  Fired when the legend item belonging to the point is clicked\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      legendItemClick: 'point-legend-item-click',\n      /**\n       *\n       * @event point-mouse-out  Fired when the mouse leaves the area close to the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      mouseOut: 'point-mouse-out',\n      /**\n       *\n       * @event point-mouse-over  Fired when the mouse enters the area close to the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      mouseOver: 'point-mouse-over',\n      /**\n       *\n       * @event point-remove  Fired when the point is removed from the series\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      remove: 'point-remove',\n      /**\n       *\n       * @event point-select  Fired when the point is selected etheir programmatically or by clicking on the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      select: 'point-select',\n      /**\n       *\n       * @event point-unselect  Fired when the point is unselected etheir programmatically or by clicking on the point\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      unselect: 'point-unselect',\n      /**\n       *\n       * @event point-update  Fired when the point is updated programmatically through `.update()` method\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} point Point object where the event was sent from\n       */\n      update: 'point-update'\n    };\n  }\n\n  get __xAxesEventNames() {\n    return {\n      /**\n       *\n       * @event xaxes-extremes-set  Fired when when the minimum and maximum is set for the x axis\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} axis Point object where the event was sent from\n       */\n      afterSetExtremes: 'xaxes-extremes-set',\n    };\n  }\n\n  get __yAxesEventNames() {\n    return {\n      /**\n       *\n       * @event yaxes-extremes-set  Fired when when the minimum and maximum is set for the y axis\n       * @param {Object} detail.originalEvent object with details about the event sent\n       * @param {Object} axis Point object where the event was sent from\n       */\n      afterSetExtremes: 'yaxes-extremes-set',\n    };\n  }\n\n  __reflow() {\n    if (!this.configuration) {\n      return;\n    }\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_2__.beforeNextRender)(this, () => {\n      this.configuration.reflow();\n    });\n  }\n\n  __mutationCallback() {\n    const {height: componentHeight} = this.getBoundingClientRect();\n    const {chartHeight} = this.configuration;\n\n    if (componentHeight !== chartHeight) {\n      this.__reflow();\n    }\n  }\n\n  __addChildObserver() {\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_2__.beforeNextRender)(this, () => {\n      this._childObserver = new _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_1__.FlattenedNodesObserver(this.$.slot, (info) => {\n        this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));\n        this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));\n        this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));\n      });\n    });\n  }\n\n  __filterSeriesNodes(node) {\n    return node.nodeType === Node.ELEMENT_NODE && node instanceof _vaadin_chart_series_js__WEBPACK_IMPORTED_MODULE_6__.ChartSeriesElement;\n  }\n\n  __addSeries(series) {\n    if (this.__isSeriesEmpty(series)) {\n      return;\n    }\n    const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);\n\n    const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {\n      acc[axis.options.id || index] = axis;\n      return acc;\n    }, {});\n\n    for (let i = 0, len = series.length; i < len; i++) {\n      const seriesElement = series[i];\n      const {yAxis: unit, yAxisValueMin: valueMin, yAxisValueMax: valueMax} = seriesElement.options;\n\n      const idxOnChildList = seriesNodes.indexOf(seriesElement);\n      if (!unit && !this.configuration.yAxis.some(e => e.userOptions.id === undefined)) {\n        yAxes[unit] = this.__addAxis({axisGenerated: true});\n      } else if (unit && !yAxes[unit]) {\n        yAxes[unit] = this.__addAxis({id: unit, title: {text: unit}, axisGenerated: true});\n      }\n      if (isFinite(valueMin)) {\n        this.__setYAxisProps(yAxes, unit, {min: valueMin});\n      }\n      if (isFinite(valueMax)) {\n        this.__setYAxisProps(yAxes, unit, {max: valueMax});\n      }\n\n      const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList, false);\n\n      seriesElement.setSeries(seriesConfiguration);\n    }\n    this.__removeAxisIfEmpty();\n\n    this.configuration.redraw();\n  }\n\n  __removeSeries(seriesNodes) {\n    if (this.__isSeriesEmpty(seriesNodes)) {\n      return;\n    }\n\n    seriesNodes.forEach(series => {\n      if (series instanceof _vaadin_chart_series_js__WEBPACK_IMPORTED_MODULE_6__.ChartSeriesElement) {\n        series._series.remove();\n      }\n    });\n  }\n\n  __setYAxisProps(yAxes, yAxisId, props) {\n    if (yAxisId) {\n      yAxes[yAxisId].update(props);\n    } else {\n      this.configuration.yAxis[0].update(props);\n    }\n  }\n\n  __isSeriesEmpty(series) {\n    return series === null || series.length === 0;\n  }\n\n  __cleanupAfterSeriesRemoved(series) {\n    if (this.__isSeriesEmpty(series)) {\n      return;\n    }\n\n    this.__removeAxisIfEmpty();\n\n    // Best effort to make chart display custom empty-text messages when series are removed.\n    // This is needed because Highcharts currently doesn't react. A condition not catered for is\n    // when all points are removed from all series without removing any series.\n    const isEmpty = this.configuration.series.length === 0 ||\n        this.configuration.series.map(e => e.data.length === 0).reduce((e1, e2) => e1 && e2, true);\n    if (isEmpty) {\n      this.configuration.hideNoData();\n      this.configuration.showNoData(this.emptyText);\n    }\n  }\n\n  __initChart(options) {\n    this.__initEventsListeners(options);\n    // Workaround for https://github.com/highcharts/highcharts/issues/7523\n    this.__ensureObjectPath(options, 'drilldown.activeDataLabelStyle');\n    if (this.timeline) {\n      this.configuration = highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].stockChart(this.$.chart, options);\n    } else {\n      this.configuration = highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].chart(this.$.chart, options);\n    }\n\n    // Workaround for https://github.com/highcharts/highcharts/issues/9978\n    const elementsToChange = [\n      ...Array.from(this.$.chart.getElementsByTagName('h4'))\n        .filter(el => el.style.left === '-9999px'),\n      this.configuration.screenReaderRegion,\n      this.configuration.tabExitAnchor\n    ];\n\n    elementsToChange.forEach(el => {\n      if (el && el.style) {\n        el.style.left = '';\n        el.style.top = '-999em';\n      }\n    });\n  }\n\n  /** @private */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__mutationObserver && this.__mutationObserver.disconnect();\n    this._childObserver && this._childObserver.disconnect();\n  }\n\n  /**\n   * Search for axis with given `id`.\n   *\n   * @param {String} id contains the id that will be searched\n   * @param {Boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n   */\n  __getAxis(id, isXAxis) {\n    id = Number.parseInt(id) || id;\n    if (this.configuration) {\n      return (isXAxis\n        ? this.configuration.xAxis\n        : this.configuration.yAxis).find((axis) => axis.options.id === id);\n    }\n  }\n\n  /**\n   * Add an axis with given options\n   *\n   * @param {Object} options axis options\n   * @param {Boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.\n   */\n  __addAxis(options, isXAxis) {\n    if (this.configuration) {\n      this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, 'events', 'axis');\n      return this.configuration.addAxis(options, isXAxis);\n    }\n  }\n\n  /**\n   * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit\n   *\n   * @param {Boolean}  isXAxis indicates if it will remove x or y axes. Defaults to `false`.\n   */\n  __removeAxisIfEmpty(isXAxis) {\n    if (this.configuration) {\n      (isXAxis\n        ? this.configuration.xAxis\n        : this.configuration.yAxis).forEach(axis => {\n        if (axis.userOptions.axisGenerated && axis.series.length === 0) {\n          axis.remove();\n        }\n      });\n    }\n  }\n\n  /**\n   * Update the chart configuration.\n   * This JSON API provides a simple single-argument alternative to the configuration property.\n   *\n   * Styling properties specified in this configuration will be ignored. To learn about chart styling\n   * please see the CSS Styling section above.\n   *\n   * @param {Object} jsonConfiguration Object chart configuration. Most important properties are:\n   *\n   * - chart `Object` with options regarding the chart area and plot area as well as general chart options.\n   *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)\n   * - credits `Object` with options regarding the chart area and plot area as well as general chart options.\n   *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)\n   * - labels `Object[]` with HTML labels that can be positioned anywhere in the chart area\n   *    Detailed API for labels object is available in [API Site](http://api.highcharts.com/highcharts/labels)\n   * - plotOptions `Object` wrapper for config objects for each series type.\n   *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)\n   * - series `Object[]` the actual series to append to the chart.\n   *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)\n   * - subtitle `Object` the chart's subtitle.\n   *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)\n   * - title `Object` the chart's main title.\n   *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)\n   * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.\n   *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)\n   * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.\n   *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)\n   * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.\n   *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)\n   * - zAxis `Object[]` The Z axis or depth axis for 3D plots.\n   *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)\n   *\n   * @param {Boolean} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or\n   *    if existing configuration should be discarded.\n   */\n  update(jsonConfiguration, resetConfiguration) {\n    if (resetConfiguration || !this._jsonConfigurationBuffer) {\n      this._jsonConfigurationBuffer = {};\n    }\n\n    const configCopy = ChartDeepMerger.__deepMerge({}, jsonConfiguration);\n    this.__inflateFunctions(configCopy);\n    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);\n\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_2__.beforeNextRender)(this, () => {\n      if (!this.configuration || !this._jsonConfigurationBuffer) {\n        return;\n      }\n\n      if (resetConfiguration) {\n        const initialOptions = Object.assign({}, this.options, this._jsonConfigurationBuffer);\n\n        this.__initChart(initialOptions);\n\n        this._jsonConfigurationBuffer = null;\n        return;\n      }\n\n      this.configuration.update(this._jsonConfigurationBuffer, false);\n      if (this._jsonConfigurationBuffer.credits) {\n        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);\n      }\n      if (this._jsonConfigurationBuffer.xAxis) {\n        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true, false);\n      }\n      if (this._jsonConfigurationBuffer.yAxis) {\n        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false, false);\n      }\n      if (this._jsonConfigurationBuffer.series) {\n        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series, false);\n      }\n      this._jsonConfigurationBuffer = null;\n\n      this.configuration.redraw();\n    });\n  }\n\n  __makeConfigurationBuffer(target, source) {\n    const _source = highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].merge(source);\n    const _target = highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].merge(target);\n\n    this.__mergeConfigurationArray(_target, _source, 'series');\n    this.__mergeConfigurationArray(_target, _source, 'xAxis');\n    this.__mergeConfigurationArray(_target, _source, 'yAxis');\n\n    return highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].merge(_target, _source);\n  }\n\n  __mergeConfigurationArray(target, configuration, entry) {\n    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {\n      return;\n    }\n\n    if (!target[entry]) {\n      target[entry] = Array.from(configuration[entry]);\n      return;\n    }\n\n    const maxLength = Math.max(target[entry].length, configuration[entry].length);\n    for (let i = 0; i < maxLength; i++) {\n      target[entry][i] = highcharts_js_es_modules_masters_highstock_src_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].merge(target[entry][i], configuration[entry][i]);\n    }\n    delete configuration[entry];\n  }\n\n  __inflateFunctions(jsonConfiguration) {\n    for (const attr in jsonConfiguration) {\n      if (jsonConfiguration.hasOwnProperty(attr)) {\n        const targetProperty = jsonConfiguration[attr];\n        if (attr.indexOf('_fn_') === 0 && (typeof targetProperty === 'string' || targetProperty instanceof String)) {\n          try {\n            jsonConfiguration[attr.substr(4)] = eval('(' + targetProperty + ')');\n          } catch (e) {\n            jsonConfiguration[attr.substr(4)] = eval('(function(){' + targetProperty + '})');\n          }\n          delete jsonConfiguration[attr];\n        } else if (targetProperty instanceof Object) {\n          this.__inflateFunctions(targetProperty);\n        }\n      }\n    }\n  }\n\n  __initEventsListeners(configuration) {\n    this.__initChartEventsListeners(configuration);\n    this.__initSeriesEventsListeners(configuration);\n    this.__initPointsEventsListeners(configuration);\n    this.__initAxisEventsListeners(configuration, true);\n    this.__initAxisEventsListeners(configuration, false);\n  }\n\n  __initChartEventsListeners(configuration) {\n    this.__createEventListeners(this.__chartEventNames, configuration, 'chart.events', 'chart');\n  }\n\n  __initSeriesEventsListeners(configuration) {\n    this.__createEventListeners(this.__seriesEventNames, configuration, 'plotOptions.series.events', 'series');\n  }\n\n  __initPointsEventsListeners(configuration) {\n    this.__createEventListeners(this.__pointEventNames, configuration, 'plotOptions.series.point.events', 'point');\n  }\n\n  __initAxisEventsListeners(configuration, isXAxis) {\n    let eventNames, axes;\n\n    if (isXAxis) {\n      eventNames = this.__xAxesEventNames;\n      axes = configuration.xAxis;\n    } else {\n      eventNames = this.__yAxesEventNames;\n      axes = configuration.yAxis;\n    }\n\n    if (Array.isArray(axes)) {\n      axes.forEach(axis => this.__createEventListeners(eventNames, axis, 'events', 'axis'));\n    } else {\n      this.__createEventListeners(eventNames, axes, 'events', 'axis');\n    }\n  }\n\n  __createEventListeners(eventList, configuration, pathToAdd, eventType) {\n    const self = this;\n    const eventObject = this.__ensureObjectPath(configuration, pathToAdd);\n\n    for (let keys = Object.keys(eventList), i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (!eventObject[key]) {\n        const chart = this;\n        eventObject[key] = function(event) {\n          const customEvent = {\n            bubbles: false,\n            composed: true,\n            detail: {\n              originalEvent: event,\n              [eventType]: this\n            }\n          };\n\n          if (event.type === 'afterSetExtremes') {\n            if (event.min == null || event.max == null) {\n              return;\n            }\n          }\n\n          // Workaround for vaadin-charts-flow because of https://github.com/vaadin/flow/issues/3102\n          if (event.type === 'selection') {\n            if (event.xAxis && event.xAxis[0]) {\n              customEvent.detail.xAxisMin = event.xAxis[0].min;\n              customEvent.detail.xAxisMax = event.xAxis[0].max;\n            }\n            if (event.yAxis && event.yAxis[0]) {\n              customEvent.detail.yAxisMin = event.yAxis[0].min;\n              customEvent.detail.yAxisMax = event.yAxis[0].max;\n            }\n          }\n          if (event.type === 'click') {\n            if (event.xAxis && event.xAxis[0]) {\n              customEvent.detail.xValue = event.xAxis[0].value;\n            }\n            if (event.yAxis && event.yAxis[0]) {\n              customEvent.detail.yValue = event.yAxis[0].value;\n            }\n          }\n\n          // Workaround for https://github.com/vaadin/vaadin-charts/issues/389\n          // Hook into beforePrint and beforeExport to ensure correct styling\n          if (['beforePrint', 'beforeExport'].indexOf(event.type) >= 0) {\n\n            // Guard against another print 'before print' event coming before\n            // the 'after print' event.\n            if (!this.tempBodyStyle) {\n              let effectiveCss = '';\n              if (_webcomponents_shadycss_src_style_settings_js__WEBPACK_IMPORTED_MODULE_8__.nativeShadow) {\n                const shadowStyles = self.shadowRoot.querySelectorAll('style');\n                for (let i = 0; i < shadowStyles.length; i++) {\n                  effectiveCss = effectiveCss + shadowStyles[i].textContent;\n                }\n\n                // Strip off host selectors that target individual instances\n                effectiveCss = effectiveCss.replace(/:host\\(.+?\\)/g, match => {\n                  const selector = match.substr(6, match.length - 7);\n                  const matchesFn = self.matches || self.msMatchesSelector;\n                  return matchesFn.call(self, selector) ? '' : match;\n                });\n              } else {\n                effectiveCss = _webcomponents_shadycss_src_scoping_shim_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].prototype.styleAstToString(\n                  _webcomponents_shadycss_src_scoping_shim_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].prototype._styleInfoForNode(self)._getStyleRules());\n\n                // Remove the style scopes added by ShadyCSS\n                // e.g. '.vaadin-chart-1 .highcharts-container.vaadin-chart'\n                //   -> '.highcharts-container'\n\n                // 1. Web Component instance scope\n                const match = self.className.match(/\\bvaadin-chart-\\d+\\b/);\n                if (match) {\n                  effectiveCss = effectiveCss.replace(new RegExp('\\\\.' + match[0], 'g'), '');\n                }\n\n                // 2. Web Component tag scope\n                effectiveCss = effectiveCss.replace(/\\.vaadin-chart/g, '');\n              }\n\n              // Zoom out a bit to avoid clipping the chart's edge on paper\n              effectiveCss = effectiveCss +\n                  + 'body {' +\n                  '    -moz-transform: scale(0.9, 0.9);' + // Mozilla\n                  '    zoom: 0.9;' + // Others\n                  '    zoom: 90%;' + // Webkit\n                  '}';\n\n              this.tempBodyStyle = document.createElement('style');\n              this.tempBodyStyle.textContent = effectiveCss;\n              document.body.appendChild(this.tempBodyStyle);\n            }\n          }\n\n          // Hook into afterPrint and afterExport to revert changes made before\n          if (['afterPrint', 'afterExport'].indexOf(event.type) >= 0) {\n            if (this.tempBodyStyle) {\n              document.body.removeChild(this.tempBodyStyle);\n              delete this.tempBodyStyle;\n            }\n          }\n\n          self.dispatchEvent(new CustomEvent(eventList[key], customEvent));\n\n          if (event.type === 'legendItemClick' && chart['_visibilityTogglingDisabled']) {\n            return false;\n          }\n        };\n      }\n    }\n  }\n\n  __ensureObjectPath(object, path) {\n    if (typeof path !== 'string') {\n      return;\n    }\n\n    path = path.split('.');\n    return path.reduce((obj, key) => {\n      obj[key] = obj[key] || {};\n      return obj[key];\n    }, object);\n  }\n\n  __updateOrAddCredits(credits) {\n    if (this.configuration.credits) {\n      this.configuration.credits.update(credits);\n    } else {\n      this.configuration.addCredits(credits);\n    }\n  }\n\n  __updateOrAddAxes(axes, isX, redraw) {\n    if (!Array.isArray(axes)) {\n      axes = [axes];\n    }\n    const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;\n    for (let i = 0; i < axes.length; i++) {\n      const axis = axes[i];\n      if (confAxes[i]) {\n        confAxes[i].update(axis, redraw);\n      } else {\n        this.configuration.addAxis(axis, isX, redraw);\n      }\n    }\n  }\n\n  __updateOrAddSeries(series, redraw) {\n    if (!Array.isArray(series)) {\n      throw new Error('The type of jsonConfiguration.series should be Object[]');\n    }\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      this.__updateOrAddSeriesInstance(currentSeries, i, redraw);\n    }\n  }\n\n  __updateOrAddSeriesInstance(seriesOptions, position, redraw) {\n    if (this.configuration.series[position]) {\n      this.configuration.series[position].update(seriesOptions, redraw);\n    } else {\n      this.configuration.addSeries(seriesOptions, redraw);\n    }\n    return this.configuration.series[position];\n  }\n\n  __updateCategories() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      categories: this.categories\n    }], true);\n  }\n\n  __updateCategoryMax() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!isFinite(this.categoryMax)) {\n      console.warn('<vaadin-chart> Acceptable value for \"category-max\" are Numbers or null');\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      max: this.categoryMax\n    }], true);\n  }\n\n  __updateCategoryMin() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!isFinite(this.categoryMin)) {\n      console.warn('<vaadin-chart> Acceptable value for \"category-min\" are Numbers or null');\n      return;\n    }\n\n    this.__updateOrAddAxes([{\n      min: this.categoryMin\n    }], true);\n  }\n\n  __shouldInvert() {\n    // A bar chart will never be inverted, consider using a column chart.\n    // See https://stackoverflow.com/questions/11235251#answer-21739793\n    if (this.type === 'bar' && ['top', 'bottom'].indexOf(this.categoryPosition) >= 0) {\n      console.warn(`<vaadin-chart> Acceptable \"category-position\" values for bar charts are\n          \"left\" and \"right\". For \"top\" and \"bottom\" positions please consider using a column chart.`);\n      return;\n    }\n\n    const inverted = ['left', 'right'];\n    return inverted.indexOf(this.categoryPosition) >= 0;\n  }\n\n  __shouldFlipOpposite() {\n    const opposite = ['top', 'right'];\n    const oppositeBar = ['right'];\n    return (this.type === 'bar' ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;\n  }\n\n  __updateCategoryPosition() {\n    if (!this.configuration) {\n      return;\n    }\n\n    const validPositions = ['left', 'right', 'top', 'bottom'];\n\n    if (validPositions.indexOf(this.categoryPosition) < 0) {\n      console.warn(`<vaadin-chart> Acceptable \"category-position\" values are ${validPositions}`);\n      return;\n    }\n\n    this.configuration.update({\n      chart: {\n        inverted: this.__shouldInvert()\n      }\n    });\n\n    this.configuration.xAxis.forEach(e => e.update({\n      opposite: this.__shouldFlipOpposite()\n    }));\n  }\n\n  __hideLegend(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (this.configuration.legend) {\n      this.configuration.legend.update({enabled: !newValue});\n    } else {\n      this.configuration.legend = {enabled: !newValue};\n    }\n  }\n\n  __updateTitle(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      this.configuration.title.update({text: newValue});\n    }\n  }\n\n  __tooltipObserver(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.tooltip.update({enabled: this.tooltip});\n  }\n\n  __updateType(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      this.configuration.update({\n        chart: {\n          type: newValue\n        }\n      });\n    }\n  }\n\n  __updateSubtitle(newValue) {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (newValue && newValue.length > 0) {\n      if (!this.configuration.subtitle) {\n        this.configuration.setSubtitle({text: newValue});\n      } else {\n        this.configuration.subtitle.update({text: newValue});\n      }\n    }\n  }\n\n  __updateAdditionalOptions() {\n    if (this.configuration) {\n      this.update(this.additionalOptions);\n    }\n  }\n\n  __isStackingValid() {\n    if (['normal', 'percent', null].indexOf(this.stacking) === -1) {\n      this.__showWarn('stacking', '\"normal\", \"percent\" or null');\n      return false;\n    }\n    return true;\n  }\n\n  __stackingObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (!this.__isStackingValid()) {\n      this.stacking = null;\n      return;\n    }\n\n    this.configuration.update({\n      plotOptions: {\n        series: {\n          stacking: this.stacking\n        }\n      }\n    });\n  }\n\n  __chart3dObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    if (this.chart3d) {\n      this.configuration.update({\n        chart: {\n          options3d: Object.assign(\n            {},\n            this._baseChart3d,\n            (\n              this.additionalOptions\n              && this.additionalOptions.chart\n              && this.additionalOptions.chart.options3d\n            ),\n            {enabled: true}\n          )\n        }\n      });\n    } else {\n      this.configuration.update({\n        chart: {\n          options3d: {\n            enabled: false\n          }\n        }\n      });\n    }\n  }\n\n  __polarObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.update({\n      chart: {\n        polar: this.polar\n      }\n    });\n  }\n\n  __emptyTextObserver() {\n    if (!this.configuration) {\n      return;\n    }\n\n    this.configuration.update({\n      lang: {\n        noData: this.emptyText\n      }\n    });\n    this.configuration.hideNoData();\n    this.configuration.showNoData(this.emptyText);\n  }\n\n  __callChartFunction(functionName) {\n    if (this.configuration) {\n      const functionToCall = this.configuration[functionName];\n      const argumentsForCall = Array.prototype.splice.call(arguments, 1);\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(this.configuration, argumentsForCall);\n      }\n    }\n  }\n\n  __callSeriesFunction(functionName, seriesIndex) {\n    if (this.configuration && this.configuration.series[seriesIndex]) {\n      const series = this.configuration.series[seriesIndex];\n      const functionToCall = series[functionName];\n      const argumentsForCall = Array.prototype.splice.call(arguments, 2);\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(series, argumentsForCall);\n      }\n    }\n  }\n\n  __callAxisFunction(functionName, axisCategory, axisIndex) {\n    /*\n     * axisCategory:\n     * 0 - xAxis\n     * 1 - yAxis\n     * 2 - zAxis\n     * 3 - colorAxis\n     */\n    if (this.configuration) {\n      let axes;\n      switch (axisCategory) {\n        case 0:\n          axes = this.configuration.xAxis;\n          break;\n        case 1:\n          axes = this.configuration.yAxis;\n          break;\n        case 2:\n          axes = this.configuration.zAxis;\n          break;\n        case 3:\n          axes = this.configuration.colorAxis;\n          break;\n      }\n      if (axes && axes[axisIndex]) {\n        const axis = axes[axisIndex];\n        const functionToCall = axis[functionName];\n        const argumentsForCall = Array.prototype.splice.call(arguments, 3);\n        if (functionToCall && typeof functionToCall === 'function') {\n          functionToCall.apply(axis, argumentsForCall);\n        }\n      }\n    }\n  }\n\n  __callPointFunction(functionName, seriesIndex, pointIndex) {\n    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {\n      const point = this.configuration.series[seriesIndex].data[pointIndex];\n      const functionToCall = point[functionName];\n      const argumentsForCall = Array.prototype.splice.call(arguments, 3);\n      if (functionToCall && typeof functionToCall === 'function') {\n        functionToCall.apply(point, argumentsForCall);\n      }\n    }\n  }\n\n  /**\n   * Updates chart container and current chart style property depending on flex status\n   */\n  __updateStyles() {\n    // Chrome returns default value if property is not set\n    // check if flex is defined for chart, and different than default value\n    const isFlex = this._copyStyleProperties.some(property =>\n      getComputedStyle(this)[property] && getComputedStyle(this)[property] != '0 1 auto', this);\n\n    // If chart element is a flexible item the chartContainer should be flex too\n    if (isFlex) {\n      this.$.chart.setAttribute('style', 'flex: 1; -webkit-flex: 1; -ms-flex: 1; ');\n      let style = '';\n      if (this.hasAttribute('style')) {\n        style = this.getAttribute('style');\n        if (style.charAt(style.length - 1) !== ';') {\n          style += ';';\n        }\n      }\n      style += 'display: -ms-flexbox; display: -webkit-flex; display: flex;';\n      this.setAttribute('style', style);\n    } else {\n      this.$.chart.setAttribute('style', 'height:100%; width:100%;');\n    }\n  }\n}\n\ncustomElements.define(ChartElement.is, ChartElement);\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-charts/theme/vaadin-chart-default-theme.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-charts/theme/vaadin-chart-default-theme.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n\n\nconst $_documentContainer = _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_0__.html`<dom-module id=\"vaadin-chart-default-theme\" theme-for=\"vaadin-chart\">\n    <template>\n      <style>\n/* When updating this file do not override vaadin-charts custom properties section */\n/* disable stylelint for highcharts css */\n/* stylelint-disable */\n/**\n * @license Highcharts\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n .highcharts-container {\n  position: relative;\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n  text-align: left;\n  line-height: normal;\n  z-index: 0;\n  /* #1072 */\n  -webkit-tap-highlight-color: transparent;\n  font-family: \"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif;\n  font-size: 12px;\n}\n\n.highcharts-root {\n  display: block;\n}\n\n.highcharts-root text {\n  stroke-width: 0;\n}\n\n.highcharts-strong {\n  font-weight: bold;\n}\n\n.highcharts-emphasized {\n  font-style: italic;\n}\n\n.highcharts-anchor {\n  cursor: pointer;\n}\n\n.highcharts-background {\n  fill: #ffffff;\n}\n\n.highcharts-plot-border, .highcharts-plot-background {\n  fill: none;\n}\n\n.highcharts-label-box {\n  fill: none;\n}\n\n.highcharts-button-box {\n  fill: inherit;\n}\n\n.highcharts-tracker-line {\n  stroke-linejoin: round;\n  stroke: rgba(192, 192, 192, 0.0001);\n  stroke-width: 22;\n  fill: none;\n}\n\n.highcharts-tracker-area {\n  fill: rgba(192, 192, 192, 0.0001);\n  stroke-width: 0;\n}\n\n/* Titles */\n.highcharts-title {\n  fill: #333333;\n  font-size: 1.5em;\n}\n\n.highcharts-subtitle {\n  fill: #666666;\n}\n\n/* Axes */\n.highcharts-axis-line {\n  fill: none;\n  stroke: #ccd6eb;\n}\n\n.highcharts-yaxis .highcharts-axis-line {\n  stroke-width: 0;\n}\n\n.highcharts-axis-title {\n  fill: #666666;\n}\n\n.highcharts-axis-labels {\n  fill: #666666;\n  cursor: default;\n  font-size: 0.9em;\n}\n\n.highcharts-grid-line {\n  fill: none;\n  stroke: #e6e6e6;\n}\n\n.highcharts-xaxis-grid .highcharts-grid-line {\n  stroke-width: 0px;\n}\n\n.highcharts-tick {\n  stroke: #ccd6eb;\n}\n\n.highcharts-yaxis .highcharts-tick {\n  stroke-width: 0;\n}\n\n.highcharts-minor-grid-line {\n  stroke: #f2f2f2;\n}\n\n.highcharts-crosshair-thin {\n  stroke-width: 1px;\n  stroke: #cccccc;\n}\n\n.highcharts-crosshair-category {\n  stroke: #ccd6eb;\n  stroke-opacity: 0.25;\n}\n\n/* Credits */\n.highcharts-credits {\n  cursor: pointer;\n  fill: #999999;\n  font-size: 0.7em;\n  transition: fill 250ms, font-size 250ms;\n}\n\n.highcharts-credits:hover {\n  fill: black;\n  font-size: 1em;\n}\n\n/* Tooltip */\n.highcharts-tooltip {\n  cursor: default;\n  pointer-events: none;\n  white-space: nowrap;\n  transition: stroke 150ms;\n}\n\n.highcharts-tooltip text {\n  fill: #333333;\n}\n\n.highcharts-tooltip .highcharts-header {\n  font-size: 0.85em;\n}\n\n.highcharts-tooltip-box {\n  stroke-width: 1px;\n  fill: #f7f7f7;\n  fill-opacity: 0.85;\n}\n\n.highcharts-tooltip-box .highcharts-label-box {\n  fill: #f7f7f7;\n  fill-opacity: 0.85;\n}\n\n.highcharts-selection-marker {\n  fill: #335cad;\n  fill-opacity: 0.25;\n}\n\n.highcharts-graph {\n  fill: none;\n  stroke-width: 2px;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n\n.highcharts-state-hover .highcharts-graph {\n  stroke-width: 3;\n}\n\n.highcharts-state-hover path {\n  transition: stroke-width 50;\n  /* quick in */\n}\n\n.highcharts-state-normal path {\n  transition: stroke-width 250ms;\n  /* slow out */\n}\n\n/* Legend hover affects points and series */\ng.highcharts-series,\n.highcharts-point,\n.highcharts-markers,\n.highcharts-data-labels {\n  transition: opacity 250ms;\n}\n\n.highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),\n.highcharts-legend-point-active .highcharts-point:not(.highcharts-point-hover),\n.highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),\n.highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {\n  opacity: 0.2;\n}\n\n/* Series options */\n/* Default colors */\n/* vaadin-charts custom properties */\n.highcharts-color-0 {\n  fill: var(--vaadin-charts-color-0, #7cb5ec);\n  stroke: var(--vaadin-charts-color-0, #7cb5ec);\n}\n\n.highcharts-color-1 {\n  fill: var(--vaadin-charts-color-1, #434348);\n  stroke: var(--vaadin-charts-color-1, #434348);\n}\n\n.highcharts-color-2 {\n  fill: var(--vaadin-charts-color-2, #90ed7d);\n  stroke: var(--vaadin-charts-color-2, #90ed7d);\n}\n\n.highcharts-color-3 {\n  fill: var(--vaadin-charts-color-3, #f7a35c);\n  stroke: var(--vaadin-charts-color-3, #f7a35c);\n}\n\n.highcharts-color-4 {\n  fill: var(--vaadin-charts-color-4, #8085e9);\n  stroke: var(--vaadin-charts-color-4, #8085e9);\n}\n\n.highcharts-color-5 {\n  fill: var(--vaadin-charts-color-5, #f15c80);\n  stroke: var(--vaadin-charts-color-5, #f15c80);\n}\n\n.highcharts-color-6 {\n  fill: var(--vaadin-charts-color-6, #e4d354);\n  stroke: var(--vaadin-charts-color-6, #e4d354);\n}\n\n.highcharts-color-7 {\n  fill: var(--vaadin-charts-color-7, #2b908f);\n  stroke: var(--vaadin-charts-color-7, #2b908f);\n}\n\n.highcharts-color-8 {\n  fill: var(--vaadin-charts-color-8, #f45b5b);\n  stroke: var(--vaadin-charts-color-8, #f45b5b);\n}\n\n.highcharts-color-9 {\n  fill: var(--vaadin-charts-color-9, #91e8e1);\n  stroke: var(--vaadin-charts-color-9, #91e8e1);\n}\n/* end of vaadin-charts custom properties */\n\n.highcharts-area {\n  fill-opacity: 0.75;\n  stroke-width: 0;\n}\n\n.highcharts-markers {\n  stroke-width: 1px;\n  stroke: #ffffff;\n}\n\n.highcharts-point {\n  stroke-width: 1px;\n}\n\n.highcharts-dense-data .highcharts-point {\n  stroke-width: 0;\n}\n\n.highcharts-data-label {\n  font-size: 0.9em;\n  font-weight: bold;\n}\n\n.highcharts-data-label-box {\n  fill: none;\n  stroke-width: 0;\n}\n\n.highcharts-data-label text, text.highcharts-data-label {\n  fill: #333333;\n}\n\n.highcharts-data-label-connector {\n  fill: none;\n}\n\n.highcharts-halo {\n  fill-opacity: 0.25;\n  stroke-width: 0;\n}\n\n.highcharts-series:not(.highcharts-pie-series) .highcharts-point-select {\n  fill: #cccccc;\n  stroke: #000000;\n}\n\n.highcharts-column-series rect.highcharts-point {\n  stroke: #ffffff;\n}\n\n.highcharts-column-series .highcharts-point {\n  transition: fill-opacity 250ms;\n}\n\n.highcharts-column-series .highcharts-point-hover {\n  fill-opacity: 0.75;\n  transition: fill-opacity 50ms;\n}\n\n.highcharts-pie-series .highcharts-point {\n  stroke-linejoin: round;\n  stroke: #ffffff;\n}\n\n.highcharts-pie-series .highcharts-point-hover {\n  fill-opacity: 0.75;\n  transition: fill-opacity 50ms;\n}\n\n.highcharts-funnel-series .highcharts-point {\n  stroke-linejoin: round;\n  stroke: #ffffff;\n}\n\n.highcharts-funnel-series .highcharts-point-hover {\n  fill-opacity: 0.75;\n  transition: fill-opacity 50ms;\n}\n\n.highcharts-funnel-series .highcharts-point-select {\n  fill: inherit;\n  stroke: inherit;\n}\n\n.highcharts-pyramid-series .highcharts-point {\n  stroke-linejoin: round;\n  stroke: #ffffff;\n}\n\n.highcharts-pyramid-series .highcharts-point-hover {\n  fill-opacity: 0.75;\n  transition: fill-opacity 50ms;\n}\n\n.highcharts-pyramid-series .highcharts-point-select {\n  fill: inherit;\n  stroke: inherit;\n}\n\n.highcharts-solidgauge-series .highcharts-point {\n  stroke-width: 0;\n}\n\n.highcharts-treemap-series .highcharts-point {\n  stroke-width: 1px;\n  stroke: #e6e6e6;\n  transition: stroke 250ms, fill 250ms, fill-opacity 250ms;\n}\n\n.highcharts-treemap-series .highcharts-point-hover {\n  stroke: #999999;\n  transition: stroke 25ms, fill 25ms, fill-opacity 25ms;\n}\n\n.highcharts-treemap-series .highcharts-above-level {\n  display: none;\n}\n\n.highcharts-treemap-series .highcharts-internal-node {\n  fill: none;\n}\n\n.highcharts-treemap-series .highcharts-internal-node-interactive {\n  fill-opacity: 0.15;\n  cursor: pointer;\n}\n\n.highcharts-treemap-series .highcharts-internal-node-interactive:hover {\n  fill-opacity: 0.75;\n}\n\n/* Legend */\n.highcharts-legend-box {\n  fill: none;\n  stroke-width: 0;\n}\n\n.highcharts-legend-item text {\n  fill: #333333;\n  font-weight: bold;\n  font-size: 1em;\n  cursor: pointer;\n  stroke-width: 0;\n}\n\n.highcharts-legend-item:hover text {\n  fill: #000000;\n}\n\n.highcharts-legend-item-hidden * {\n  fill: #cccccc !important;\n  stroke: #cccccc !important;\n  transition: fill 250ms;\n}\n\n.highcharts-legend-nav-active {\n  fill: #003399;\n  cursor: pointer;\n}\n\n.highcharts-legend-nav-inactive {\n  fill: #cccccc;\n}\n\n.highcharts-legend-title-box {\n  fill: none;\n  stroke-width: 0;\n}\n\n/* Loading */\n.highcharts-loading {\n  position: absolute;\n  background-color: #ffffff;\n  opacity: 0.5;\n  text-align: center;\n  z-index: 10;\n  transition: opacity 250ms;\n}\n\n.highcharts-loading-hidden {\n  height: 0 !important;\n  opacity: 0;\n  overflow: hidden;\n  transition: opacity 250ms, height 250ms step-end;\n}\n\n.highcharts-loading-inner {\n  font-weight: bold;\n  position: relative;\n  top: 45%;\n}\n\n/* Plot bands and polar pane backgrounds */\n.highcharts-plot-band, .highcharts-pane {\n  fill: #000000;\n  fill-opacity: 0.05;\n}\n\n.highcharts-plot-line {\n  fill: none;\n  stroke: #999999;\n  stroke-width: 1px;\n}\n\n/* Highcharts More and modules */\n.highcharts-boxplot-box {\n  fill: #ffffff;\n}\n\n.highcharts-boxplot-median {\n  stroke-width: 2px;\n}\n\n.highcharts-bubble-series .highcharts-point {\n  fill-opacity: 0.5;\n}\n\n.highcharts-errorbar-series .highcharts-point {\n  stroke: #000000;\n}\n\n.highcharts-gauge-series .highcharts-data-label-box {\n  stroke: #cccccc;\n  stroke-width: 1px;\n}\n\n.highcharts-gauge-series .highcharts-dial {\n  fill: #000000;\n  stroke-width: 0;\n}\n\n.highcharts-polygon-series .highcharts-graph {\n  fill: inherit;\n  stroke-width: 0;\n}\n\n.highcharts-waterfall-series .highcharts-graph {\n  stroke: #333333;\n  stroke-dasharray: 1, 3;\n}\n\n.highcharts-sankey-series .highcharts-point {\n  stroke-width: 0;\n}\n\n.highcharts-sankey-series .highcharts-link {\n  transition: fill 250ms, fill-opacity 250ms;\n  fill-opacity: 0.5;\n}\n\n.highcharts-sankey-series .highcharts-point-hover.highcharts-link {\n  transition: fill 50ms, fill-opacity 50ms;\n  fill-opacity: 1;\n}\n\n/* Highstock */\n.highcharts-navigator-mask-outside {\n  fill-opacity: 0;\n}\n\n.highcharts-navigator-mask-inside {\n  fill: #6685c2;\n  /* navigator.maskFill option */\n  fill-opacity: 0.25;\n  cursor: ew-resize;\n}\n\n.highcharts-navigator-outline {\n  stroke: #cccccc;\n  fill: none;\n}\n\n.highcharts-navigator-handle {\n  stroke: #cccccc;\n  fill: #f2f2f2;\n  cursor: ew-resize;\n}\n\n.highcharts-navigator-series {\n  fill: #335cad;\n  stroke: #335cad;\n}\n\n.highcharts-navigator-series .highcharts-graph {\n  stroke-width: 1px;\n}\n\n.highcharts-navigator-series .highcharts-area {\n  fill-opacity: 0.05;\n}\n\n.highcharts-navigator-xaxis .highcharts-axis-line {\n  stroke-width: 0;\n}\n\n.highcharts-navigator-xaxis .highcharts-grid-line {\n  stroke-width: 1px;\n  stroke: #e6e6e6;\n}\n\n.highcharts-navigator-xaxis.highcharts-axis-labels {\n  fill: #999999;\n}\n\n.highcharts-navigator-yaxis .highcharts-grid-line {\n  stroke-width: 0;\n}\n\n.highcharts-scrollbar-thumb {\n  fill: #cccccc;\n  stroke: #cccccc;\n  stroke-width: 1px;\n}\n\n.highcharts-scrollbar-button {\n  fill: #e6e6e6;\n  stroke: #cccccc;\n  stroke-width: 1px;\n}\n\n.highcharts-scrollbar-arrow {\n  fill: #666666;\n}\n\n.highcharts-scrollbar-rifles {\n  stroke: #666666;\n  stroke-width: 1px;\n}\n\n.highcharts-scrollbar-track {\n  fill: #f2f2f2;\n  stroke: #f2f2f2;\n  stroke-width: 1px;\n}\n\n.highcharts-button {\n  fill: #f7f7f7;\n  stroke: #cccccc;\n  cursor: default;\n  stroke-width: 1px;\n  transition: fill 250ms;\n}\n\n.highcharts-button text {\n  fill: #333333;\n}\n\n.highcharts-button-hover {\n  transition: fill 0ms;\n  fill: #e6e6e6;\n  stroke: #cccccc;\n}\n\n.highcharts-button-hover text {\n  fill: #333333;\n}\n\n.highcharts-button-pressed {\n  font-weight: bold;\n  fill: #e6ebf5;\n  stroke: #cccccc;\n}\n\n.highcharts-button-pressed text {\n  fill: #333333;\n  font-weight: bold;\n}\n\n.highcharts-button-disabled text {\n  fill: #333333;\n}\n\n.highcharts-range-selector-buttons .highcharts-button {\n  stroke-width: 0px;\n}\n\n.highcharts-range-label rect {\n  fill: none;\n}\n\n.highcharts-range-label text {\n  fill: #666666;\n}\n\n.highcharts-range-input rect {\n  fill: none;\n}\n\n.highcharts-range-input text {\n  fill: #333333;\n}\n\n.highcharts-range-input {\n  stroke-width: 1px;\n  stroke: #cccccc;\n}\n\ninput.highcharts-range-selector {\n  position: absolute;\n  border: 0;\n  width: 1px;\n  /* Chrome needs a pixel to see it */\n  height: 1px;\n  padding: 0;\n  text-align: center;\n  left: -9em;\n  /* #4798 */\n}\n\n.highcharts-crosshair-label text {\n  fill: #ffffff;\n  font-size: 1.1em;\n}\n\n.highcharts-crosshair-label .highcharts-label-box {\n  fill: inherit;\n}\n\n.highcharts-candlestick-series .highcharts-point {\n  stroke: #000000;\n  stroke-width: 1px;\n}\n\n.highcharts-candlestick-series .highcharts-point-up {\n  fill: #ffffff;\n}\n\n.highcharts-ohlc-series .highcharts-point-hover {\n  stroke-width: 3px;\n}\n\n.highcharts-flags-series .highcharts-point .highcharts-label-box {\n  stroke: #999999;\n  fill: #ffffff;\n  transition: fill 250ms;\n}\n\n.highcharts-flags-series .highcharts-point-hover .highcharts-label-box {\n  stroke: #000000;\n  fill: #ccd6eb;\n}\n\n.highcharts-flags-series .highcharts-point text {\n  fill: #000000;\n  font-size: 0.9em;\n  font-weight: bold;\n}\n\n/* Highmaps */\n.highcharts-map-series .highcharts-point {\n  transition: fill 500ms, fill-opacity 500ms, stroke-width 250ms;\n  stroke: #cccccc;\n}\n\n.highcharts-map-series .highcharts-point-hover {\n  transition: fill 0ms, fill-opacity 0ms;\n  fill-opacity: 0.5;\n  stroke-width: 2px;\n}\n\n.highcharts-mapline-series .highcharts-point {\n  fill: none;\n}\n\n.highcharts-heatmap-series .highcharts-point {\n  stroke-width: 0;\n}\n\n.highcharts-map-navigation {\n  font-size: 1.3em;\n  font-weight: bold;\n  text-align: center;\n}\n\n.highcharts-coloraxis {\n  stroke-width: 0;\n}\n\n.highcharts-coloraxis-marker {\n  fill: #999999;\n}\n\n.highcharts-null-point {\n  fill: #f7f7f7;\n}\n\n/* 3d charts */\n.highcharts-3d-frame {\n  fill: transparent;\n}\n\n/* Exporting module */\n.highcharts-contextbutton {\n  fill: #ffffff;\n  /* needed to capture hover */\n  stroke: none;\n  stroke-linecap: round;\n}\n\n.highcharts-contextbutton:hover {\n  fill: #e6e6e6;\n  stroke: #e6e6e6;\n}\n\n.highcharts-button-symbol {\n  stroke: #666666;\n  stroke-width: 3px;\n}\n\n.highcharts-menu {\n  border: 1px solid #999999;\n  background: #ffffff;\n  padding: 5px 0;\n  box-shadow: 3px 3px 10px #888;\n}\n\n.highcharts-menu-item {\n  padding: 0.5em 1em;\n  background: none;\n  color: #333333;\n  cursor: pointer;\n  transition: background 250ms, color 250ms;\n}\n\n.highcharts-menu-item:hover {\n  background: #335cad;\n  color: #ffffff;\n}\n\n/* Drilldown module */\n.highcharts-drilldown-point {\n  cursor: pointer;\n}\n\n.highcharts-drilldown-data-label text,\ntext.highcharts-drilldown-data-label,\n.highcharts-drilldown-axis-label {\n  cursor: pointer;\n  fill: #003399;\n  font-weight: bold;\n  text-decoration: underline;\n}\n\n/* No-data module */\n.highcharts-no-data text {\n  font-weight: bold;\n  font-size: 12px;\n  fill: #666666;\n}\n\n/* Drag-panes module */\n.highcharts-axis-resizer {\n  cursor: ns-resize;\n  stroke: black;\n  stroke-width: 2px;\n}\n\n/* Bullet type series */\n.highcharts-bullet-target {\n  stroke-width: 0;\n}\n\n/* Lineargauge type series */\n.highcharts-lineargauge-target {\n  stroke-width: 1px;\n  stroke: #333333;\n}\n\n.highcharts-lineargauge-target-line {\n  stroke-width: 1px;\n  stroke: #333333;\n}\n\n/* Annotations module */\n.highcharts-annotation-label-box {\n  stroke-width: 1px;\n  stroke: #000000;\n  fill: #000000;\n  fill-opacity: 0.75;\n}\n\n.highcharts-annotation-label text {\n  fill: #e6e6e6;\n}\n\n\n/* RTL styles */\n:host([dir=\"rtl\"]) .highcharts-container {\n  text-align: right;\n}\n\n:host([dir=\"rtl\"]) input.highcharts-range-selector {\n  left: auto;\n  right: -9em;\n}\n\n:host([dir=\"rtl\"]) .highcharts-menu {\n  box-shadow: -3px 3px 10px #888;\n}\n\n\n/* stylelint-enable */\n    </style>\n  </template>\n</dom-module>`;\n\ndocument.head.appendChild($_documentContainer.content);\n\n/**\n@license\nVaadin Charts\nCopyright (C) 2015 Vaadin Ltd\nThis program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).\nSee the file LICENSE.md distributed with this software for more information about licensing.\nSee <a href=\"https://vaadin.com/license/cval-3\">the website</a> for the complete license.\n*/\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-charts/theme/vaadin-chart-default-theme.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-charts/vaadin-chart-default-theme.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-charts/vaadin-chart-default-theme.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _theme_vaadin_chart_default_theme_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./theme/vaadin-chart-default-theme.js */ \"./node_modules/@vaadin/vaadin-charts/theme/vaadin-chart-default-theme.js\");\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-charts/vaadin-chart-default-theme.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-charts/vaadin-chart.js":
/*!************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-charts/vaadin-chart.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_chart_default_theme_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-chart-default-theme.js */ \"./node_modules/@vaadin/vaadin-charts/vaadin-chart-default-theme.js\");\n/* harmony import */ var _src_vaadin_chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/vaadin-chart.js */ \"./node_modules/@vaadin/vaadin-charts/src/vaadin-chart.js\");\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-charts/vaadin-chart.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"runIfDevelopmentMode\": () => (/* binding */ runIfDevelopmentMode)\n/* harmony export */ });\nconst DEV_MODE_CODE_REGEXP =\n  /\\/\\*\\*\\s+vaadin-dev-mode:start([\\s\\S]*)vaadin-dev-mode:end\\s+\\*\\*\\//i;\n\nconst FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;\n\nfunction isMinified() {\n  function test() {\n    /** vaadin-dev-mode:start\n    return false;\n    vaadin-dev-mode:end **/\n    return true;\n  }\n  return uncommentAndRun(test);\n}\n\nfunction isDevelopmentMode() {\n  try {\n    if (isForcedDevelopmentMode()) {\n      return true;\n    }\n\n    if (!isLocalhost()) {\n      return false;\n    }\n\n    if (FlowClients) {\n      return !isFlowProductionMode();\n    }\n\n    return !isMinified();\n  } catch (e) {\n    // Some error in this code, assume production so no further actions will be taken\n    return false;\n  }\n}\n\nfunction isForcedDevelopmentMode() {\n  return localStorage.getItem(\"vaadin.developmentmode.force\");\n}\n\nfunction isLocalhost() {\n  return ([\"localhost\",\"127.0.0.1\"].indexOf(window.location.hostname) >= 0);\n}\n\nfunction isFlowProductionMode() {\n  if (FlowClients) {\n    const productionModeApps = Object.keys(FlowClients)\n      .map(key => FlowClients[key])\n      .filter(client => client.productionMode);\n    if (productionModeApps.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction uncommentAndRun(callback, args) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n\n  const match = DEV_MODE_CODE_REGEXP.exec(callback.toString());\n  if (match) {\n    try {\n      // requires CSP: script-src 'unsafe-eval'\n      callback = new Function(match[1]);\n    } catch (e) {\n      // eat the exception\n      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e)\n    }\n  }\n\n  return callback(args);\n}\n\n// A guard against polymer-modulizer removing the window.Vaadin\n// initialization above.\nwindow['Vaadin'] = window['Vaadin'] || {};\n\n/**\n * Inspects the source code of the given `callback` function for\n * specially-marked _commented_ code. If such commented code is found in the\n * callback source, uncomments and runs that code instead of the callback\n * itself. Otherwise runs the callback as is.\n *\n * The optional arguments are passed into the callback / uncommented code,\n * the result is returned.\n *\n * See the `isMinified()` function source code in this file for an example.\n *\n */\nconst runIfDevelopmentMode = function(callback, args) {\n  if (window.Vaadin.developmentMode) {\n    return uncommentAndRun(callback, args);\n  }\n};\n\nif (window.Vaadin.developmentMode === undefined) {\n  window.Vaadin.developmentMode = isDevelopmentMode();\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirHelper\": () => (/* binding */ DirHelper)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Helper that provides a set of functions for RTL.\n */\nclass DirHelper {\n  /**\n   * Get the scroll type in the current browser view.\n   *\n   * @return {string} the scroll type. Possible values are `default|reverse|negative`\n   */\n  static detectScrollType() {\n    const dummy = document.createElement('div');\n    dummy.textContent = 'ABCD';\n    dummy.dir = 'rtl';\n    dummy.style.fontSize = '14px';\n    dummy.style.width = '4px';\n    dummy.style.height = '1px';\n    dummy.style.position = 'absolute';\n    dummy.style.top = '-1000px';\n    dummy.style.overflow = 'scroll';\n    document.body.appendChild(dummy);\n\n    let cachedType = 'reverse';\n    if (dummy.scrollLeft > 0) {\n      cachedType = 'default';\n    } else {\n      dummy.scrollLeft = 2;\n      if (dummy.scrollLeft < 2) {\n        cachedType = 'negative';\n      }\n    }\n    document.body.removeChild(dummy);\n    return cachedType;\n  }\n\n  /**\n   * Get the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @return {number} the scrollLeft value.\n   */\n  static getNormalizedScrollLeft(scrollType, direction, element) {\n    const { scrollLeft } = element;\n    if (direction !== 'rtl' || !scrollType) {\n      return scrollLeft;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        return element.scrollWidth - element.clientWidth + scrollLeft;\n      case 'reverse':\n        return element.scrollWidth - element.clientWidth - scrollLeft;\n    }\n    return scrollLeft;\n  }\n\n  /**\n   * Set the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @param {number} scrollLeft the scrollLeft value to be set\n   */\n  static setNormalizedScrollLeft(scrollType, direction, element, scrollLeft) {\n    if (direction !== 'rtl' || !scrollType) {\n      element.scrollLeft = scrollLeft;\n      return;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;\n        break;\n      case 'reverse':\n        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\n        break;\n      default:\n        element.scrollLeft = scrollLeft;\n        break;\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirMixin\": () => (/* binding */ DirMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_dir_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-dir-helper.js */ \"./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js\");\n/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\nconst directionSubscribers = [];\nconst directionUpdater = function () {\n  const documentDir = getDocumentDir();\n  directionSubscribers.forEach((element) => {\n    alignDirs(element, documentDir);\n  });\n};\n\nlet scrollType;\n\nconst directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['dir'] });\n\nconst alignDirs = function (element, documentDir, elementDir = element.getAttribute('dir')) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else if (elementDir != null) {\n    element.removeAttribute('dir');\n  }\n};\n\nconst getDocumentDir = function () {\n  return document.documentElement.getAttribute('dir');\n};\n\n/**\n * @polymerMixin\n */\nconst DirMixin = (superClass) =>\n  class VaadinDirMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * @protected\n         */\n        dir: {\n          type: String,\n          value: '',\n          reflectToAttribute: true\n        }\n      };\n    }\n\n    /** @protected */\n    static finalize() {\n      super.finalize();\n\n      if (!scrollType) {\n        scrollType = _vaadin_dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.detectScrollType();\n      }\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (!this.hasAttribute('dir')) {\n        this.__subscribe();\n        alignDirs(this, getDocumentDir(), null);\n      }\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n      if (name !== 'dir') {\n        return;\n      }\n\n      const documentDir = getDocumentDir();\n\n      // New value equals to the document direction and the element is not subscribed to the changes\n      const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;\n      // Value was emptied and the element is not subscribed to the changes\n      const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;\n      // New value is different and the old equals to document direction and the element is not subscribed to the changes\n      const newDiffValue = newValue !== documentDir && oldValue === documentDir;\n\n      if (newValueEqlDocDir || newValueEmptied) {\n        this.__subscribe();\n        alignDirs(this, documentDir, newValue);\n      } else if (newDiffValue) {\n        this.__subscribe(false);\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__subscribe(false);\n      this.removeAttribute('dir');\n    }\n\n    /** @protected */\n    _valueToNodeAttribute(node, value, attribute) {\n      // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n      // If the property contains an empty string then it should not create an empty attribute\n      if (attribute === 'dir' && value === '' && !node.hasAttribute('dir')) {\n        return;\n      }\n      super._valueToNodeAttribute(node, value, attribute);\n    }\n\n    /** @protected */\n    _attributeToProperty(attribute, value, type) {\n      // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n      // If the attribute is removed, then the dir property should contain an empty string instead of null\n      if (attribute === 'dir' && !value) {\n        this.dir = '';\n      } else {\n        super._attributeToProperty(attribute, value, type);\n      }\n    }\n\n    /** @private */\n    __subscribe(push = true) {\n      if (push) {\n        directionSubscribers.indexOf(this) === -1 && directionSubscribers.push(this);\n      } else {\n        directionSubscribers.indexOf(this) > -1 && directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n      }\n    }\n\n    /**\n     * @param {Element} element\n     * @return {number}\n     * @protected\n     */\n    __getNormalizedScrollLeft(element) {\n      return _vaadin_dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element);\n    }\n\n    /**\n     * @param {Element} element\n     * @param {number} scrollLeft\n     * @protected\n     */\n    __setNormalizedScrollLeft(element, scrollLeft) {\n      return _vaadin_dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element, scrollLeft);\n    }\n  };\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementMixin\": () => (/* binding */ ElementMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/debounce.js */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n/* harmony import */ var _vaadin_vaadin_usage_statistics_vaadin_usage_statistics_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js */ \"./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js\");\n/* harmony import */ var _vaadin_dir_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaadin-dir-mixin.js */ \"./node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\nwindow.Vaadin = window.Vaadin || {};\n\n/**\n * Array of Vaadin custom element classes that have been finalized.\n */\nwindow.Vaadin.registrations = window.Vaadin.registrations || [];\n\nwindow.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};\n\nwindow.Vaadin.developmentModeCallback['vaadin-usage-statistics'] = function () {\n  (0,_vaadin_vaadin_usage_statistics_vaadin_usage_statistics_js__WEBPACK_IMPORTED_MODULE_2__.usageStatistics)();\n};\n\nlet statsJob;\n\nconst registered = new Set();\n\n/**\n * @polymerMixin\n * @mixes DirMixin\n */\nconst ElementMixin = (superClass) =>\n  class VaadinElementMixin extends (0,_vaadin_dir_mixin_js__WEBPACK_IMPORTED_MODULE_3__.DirMixin)(superClass) {\n    /** @protected */\n    static finalize() {\n      super.finalize();\n\n      const { is } = this;\n\n      // Registers a class prototype for telemetry purposes.\n      if (is && !registered.has(is)) {\n        window.Vaadin.registrations.push(this);\n        registered.add(is);\n\n        if (window.Vaadin.developmentModeCallback) {\n          statsJob = _polymer_polymer_lib_utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__.Debouncer.debounce(statsJob, _polymer_polymer_lib_utils_async_js__WEBPACK_IMPORTED_MODULE_0__.idlePeriod, () => {\n            window.Vaadin.developmentModeCallback['vaadin-usage-statistics']();\n          });\n          (0,_polymer_polymer_lib_utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__.enqueueDebouncer)(statsJob);\n        }\n      }\n    }\n\n    constructor() {\n      super();\n      if (document.doctype === null) {\n        console.warn(\n          'Vaadin components require the \"standards mode\" declaration. Please add <!DOCTYPE html> to the HTML document.'\n        );\n      }\n    }\n  };\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js */ \"./node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js\");\n/* This file is autogenerated from src/vaadin-license-checker.tpl.html */\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n\nfunction maybeCheckLicenses() {\n  /** vaadin-dev-mode:start\n  (function () {\n'use strict';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nfunction _CustomElement() {\n  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);\n}\nObject.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(_CustomElement, HTMLElement);\nvar licenseBoxTemplate = document.createElement('template');\nlicenseBoxTemplate.innerHTML = '\\n  <style>\\n    :host {\\n      font: 16px/1.625 -apple-system, BlinkMacSystemFont, \"Roboto\", \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n      position: fixed;\\n      top: .5em;\\n      right: .5em;\\n      z-index: 10000;\\n      cursor: pointer;\\n      backface-visibility: hidden;\\n    }\\n\\n    #content {\\n      padding: 1em 1.5em;\\n      margin: 0;\\n      display: flex;\\n      flex-direction:row;\\n      align-items: center;\\n      text-align: left;\\n      font-size: inherit;\\n      line-height: inherit;\\n      font-weight: inherit;\\n      -webkit-font-smoothing: antialiased;\\n      -moz-osx-font-smoothin: grayscale;\\n      white-space: nowrap;\\n      letter-spacing: 0;\\n      border-radius: 5px;\\n    }\\n\\n    #content[type=\"needsvalidation\"] {\\n      background-color: #FFD5D8;\\n      color: #591217;\\n      box-shadow: 0 0 20px 1px rgba(242,51,51,0.10);\\n    }\\n\\n    #content[type=\"ok\"] {\\n      background-color: #B2F5C2;\\n      color: #1C562A;\\n      box-shadow: 0 0 20px 1px rgba(43,193,78,0.10);\\n    }\\n\\n    #content > svg {\\n      display: none;\\n      fill: currentColor;\\n      stroke: currentColor 1px;\\n      padding-left: 1.25em;\\n    }\\n\\n    #content[type=\"needsvalidation\"] > #link {\\n      display: inline;\\n    }\\n\\n    #content[type=\"ok\"] > #close {\\n      display: inline;\\n      vertical-align: -.125em;\\n    }\\n  </style>\\n\\n  <div id=\"content\">\\n    <div></div>\\n    <svg id=\"link\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"external-link\"><path d=\"M8.6 3.5l3.5 3.5h-12.1v2h12.1l-3.5 3.5 1.4 1.4 6-5.9-6-5.9z\"></path></g>\\n    </svg>\\n    <svg id=\"close\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\\n      <g id=\"close-big\"><path d=\"M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z\"></path></g>\\n    </svg>\\n  </div>\\n';\nwindow.ShadyCSS && window.ShadyCSS.prepareTemplate(licenseBoxTemplate, 'vaadin-license-box');\n\nvar LicenseBoxElement = function (_CustomElement2) {\n  inherits(LicenseBoxElement, _CustomElement2);\n\n  function LicenseBoxElement() {\n    classCallCheck(this, LicenseBoxElement);\n    return possibleConstructorReturn(this, (LicenseBoxElement.__proto__ || Object.getPrototypeOf(LicenseBoxElement)).apply(this, arguments));\n  }\n\n  createClass(LicenseBoxElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      window.ShadyCSS && window.ShadyCSS.styleElement(this);\n\n      if (!this.shadowRoot) {\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(document.importNode(licenseBoxTemplate.content, true));\n        this._contentElement = this.shadowRoot.querySelector('#content');\n        this._render();\n      }\n    }\n  }, {\n    key: '_render',\n    value: function _render() {\n      if (!this._contentElement) {\n        return;\n      }\n\n      if (this._type) {\n        this._contentElement.setAttribute('type', this._type);\n      } else {\n        this._contentElement.removeAttribute('type');\n      }\n\n      this._contentElement.firstElementChild.innerHTML = this._content;\n    }\n  }, {\n    key: 'type',\n    get: function () {\n      return this._type;\n    },\n    set: function (type) {\n      this._type = type;\n      this._render();\n    }\n  }, {\n    key: 'content',\n    get: function () {\n      return this._content;\n    },\n    set: function (content) {\n      this._content = content;\n      this._render();\n    }\n  }]);\n  return LicenseBoxElement;\n}(_CustomElement);\n\ncustomElements.define('vaadin-license-box', LicenseBoxElement);\n\nvar LicenseCheckerLogger = function () {\n  function LicenseCheckerLogger() {\n    classCallCheck(this, LicenseCheckerLogger);\n\n    this.id = \"vaadin-license-checker\";\n  }\n\n  createClass(LicenseCheckerLogger, [{\n    key: 'isDebug',\n    value: function isDebug() {\n      return localStorage.getItem(\"vaadin.licenses.debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this.isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return LicenseCheckerLogger;\n}();\n\nvar LicenseCheckerStorage = function () {\n  function LicenseCheckerStorage() {\n    classCallCheck(this, LicenseCheckerStorage);\n\n    this.logger = new LicenseCheckerLogger();\n  }\n\n  createClass(LicenseCheckerStorage, [{\n    key: 'getLastCheckKey',\n    value: function getLastCheckKey(productInfo) {\n      return \"vaadin.licenses.{product}.lastCheck\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getLastCheck',\n    value: function getLastCheck(productInfo) {\n      return Number(localStorage.getItem(this.getLastCheckKey(productInfo)));\n    }\n  }, {\n    key: 'setLastCheck',\n    value: function setLastCheck(productInfo, timestamp) {\n      this.logger.debug(\"Setting last check time to \" + new Date(timestamp));\n      localStorage.setItem(this.getLastCheckKey(productInfo), timestamp);\n    }\n  }]);\n  return LicenseCheckerStorage;\n}();\n\nvar VaadinLicenseChecker = function () {\n  function VaadinLicenseChecker() {\n    classCallCheck(this, VaadinLicenseChecker);\n\n    this.okNotifier = new LicenseOkNotifier();\n    this.validationNeededNotifier = new LicenseValidationNeededNotifier();\n    this.storage = new LicenseCheckerStorage();\n    this.checkInterval = 1000 * 60 * 60 * 24;\n    this.firstCheckDelay = 1000 * 60 * 1;\n    this.logger = new LicenseCheckerLogger();\n    this.url = \"https://tools.vaadin.com/vaadin-license-server/licenses/pro\";\n  }\n\n  createClass(VaadinLicenseChecker, [{\n    key: 'getForcedResponseKey',\n    value: function getForcedResponseKey(productInfo) {\n      return 'vaadin.licenses.{product}.forcedResponse'.replace('{product}', productInfo.name);\n    }\n  }, {\n    key: 'getForcedResponse',\n    value: function getForcedResponse(productInfo) {\n      return localStorage.getItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'clearForcedResponse',\n    value: function clearForcedResponse(productInfo) {\n      return localStorage.removeItem(this.getForcedResponseKey(productInfo));\n    }\n  }, {\n    key: 'maybeCheck',\n    value: function maybeCheck(productInfo) {\n      this.logger.debug(\"maybeCheck(\" + JSON.stringify(productInfo) + \")\");\n      // Defer first check until interval has expired to avoid interfering with tests etc\n      var now = new Date().getTime();\n      var lastCheck = this.storage.getLastCheck(productInfo);\n      if (!lastCheck) {\n        this.logger.debug(\"Deferring first check until \" + new Date(now + this.firstCheckDelay));\n        this.storage.setLastCheck(productInfo, now - this.checkInterval + this.firstCheckDelay);\n        return;\n      } else {\n        var sinceLastCheck = Math.round((now - lastCheck) / 1000);\n        var nextCheck = Math.round(this.checkInterval / 1000 - sinceLastCheck);\n        if (nextCheck > 0) {\n          // Checked recently\n          var nextCheckDate = new Date(lastCheck + this.checkInterval);\n          this.logger.debug(\"Checked \" + sinceLastCheck + \"s ago. Next check in \" + nextCheck + \"s at \" + nextCheckDate + \".\");\n          return;\n        } else {\n          this.logger.debug(\"Last check was \" + sinceLastCheck + \"s ago.\");\n        }\n      }\n      this.check(productInfo);\n    }\n  }, {\n    key: 'check',\n    value: function check(productInfo) {\n      this.logger.debug(\"check(\" + JSON.stringify(productInfo) + \")\");\n\n      // Only show an ok notification if the \"validation needed\" notification was shown.\n      // For background checks, show no visual notification if all goes well\n      var showOkOnSuccess = this.validationNeededNotifier.isVisible(productInfo);\n\n      var checker = this;\n      var onerror = function () {\n        // Offline or blocked, just log to console and let people get work done\n        console.error(\"Unable to validate the license for \" + productInfo.name + \". Check your internet access.\");\n      };\n      var onresponse = function (responseText) {\n        var response = JSON.parse(responseText);\n        if (response.result == \"ok\") {\n          // Everything is fine, stop\n          checker.logger.debug(\"License check ok for \" + JSON.stringify(productInfo));\n          checker.storage.setLastCheck(productInfo, new Date().getTime());\n          if (showOkOnSuccess) {\n            checker.logger.debug(\"Showing validation-ok dialog\");\n            checker.okNotifier.show(productInfo);\n          }\n        } else {\n          checker.logger.debug(\"License check failed for \" + JSON.stringify(productInfo));\n          checker.logger.debug(\"Showing validation-needed dialog\");\n          checker.validationNeededNotifier.show(productInfo);\n        }\n        if (response.message) {\n          console.log(response.message);\n        }\n      };\n\n      // This is typically hidden already but when receiving a window message it is not\n      this.logger.debug(\"Ensuring validation-needed dialog is hidden\");\n      this.validationNeededNotifier.hide(productInfo);\n\n      if (this.logger.isDebug() && this.getForcedResponse(productInfo)) {\n        var respJson = this.getForcedResponse(productInfo);\n        this.clearForcedResponse(productInfo);\n        if (JSON.parse(respJson).type == \"error\") {\n          this.logger.debug(\"Forced error for check\");\n          onerror();\n        } else {\n          this.logger.debug(\"Forced response for check: \" + respJson);\n          onresponse(respJson);\n        }\n      } else {\n        this.send(this.url, productInfo, onresponse, onerror);\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(url, productInfo, onsuccess, onerror) {\n      this.logger.debug(\"Sending request to \" + url);\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"readystatechange\", function () {\n        if (req.readyState === XMLHttpRequest.DONE && req.status === 200) {\n          onsuccess(req.responseText);\n        }\n      });\n      req.addEventListener(\"error\", function () {\n        onerror();\n      });\n      req.open(\"GET\", url);\n      req.setRequestHeader(\"check-source\", \"webcomponent\");\n      req.setRequestHeader(\"product-name\", productInfo.name);\n      req.setRequestHeader(\"product-version\", productInfo.version);\n\n      req.send();\n    }\n  }], [{\n    key: 'version',\n    get: function () {\n      return '2.1.2';\n    }\n  }]);\n  return VaadinLicenseChecker;\n}();\n\nvar LicenseOkNotifier = function () {\n  function LicenseOkNotifier() {\n    classCallCheck(this, LicenseOkNotifier);\n  }\n\n  createClass(LicenseOkNotifier, [{\n    key: 'getInstance',\n    value: function getInstance() {\n      return document.getElementById(LicenseOkNotifier.id);\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      // Only show one ok box even if multiple licenses were checked\n      if (this.getInstance()) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = LicenseOkNotifier.id;\n      instance.type = \"ok\";\n      instance.content = \"Your license has been validated\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        instance.parentElement.removeChild(instance);\n      });\n    }\n  }], [{\n    key: 'id',\n    get: function () {\n      return 'vaadin-license-validation-ok';\n    }\n  }]);\n  return LicenseOkNotifier;\n}();\n\nvar LicenseValidationNeededNotifier = function () {\n  function LicenseValidationNeededNotifier() {\n    classCallCheck(this, LicenseValidationNeededNotifier);\n  }\n\n  createClass(LicenseValidationNeededNotifier, [{\n    key: 'id',\n    value: function id(productInfo) {\n      return \"vaadin-license-validation-notification-{product}\".replace(\"{product}\", productInfo.name);\n    }\n  }, {\n    key: 'getInstance',\n    value: function getInstance(productInfo) {\n      return document.getElementById(this.id(productInfo));\n    }\n  }, {\n    key: 'show',\n    value: function show(productInfo) {\n      if (this.getInstance(productInfo)) {\n        // Already shown\n        return;\n      }\n      var instance = document.createElement(\"vaadin-license-box\");\n      instance.id = this.id(productInfo);\n      instance.type = \"needsvalidation\";\n      instance.content = \"This application is using components which are part of a Vaadin subscription.<br>Click here to get a trial or validate your subscription\";\n      document.body.appendChild(instance);\n      instance.addEventListener(\"click\", function () {\n        window.open(\"https://vaadin.com/pro/validate-license\", \"_blank\");\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide(productInfo) {\n      var instance = this.getInstance(productInfo);\n      if (instance) {\n        instance.parentElement.removeChild(instance);\n      }\n    }\n  }, {\n    key: 'isVisible',\n    value: function isVisible(productInfo) {\n      return !!this.getInstance(productInfo);\n    }\n  }]);\n  return LicenseValidationNeededNotifier;\n}();\n\nvar proProducts = [];\n\nwindow.Vaadin = window.Vaadin || {};\nwindow.Vaadin.LicenseChecker = window.Vaadin.VaadinLicenseChecker || new VaadinLicenseChecker();\nwindow.Vaadin.LicenseCheckerClass = window.Vaadin.LicenseCheckerClass || VaadinLicenseChecker;\nwindow.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};\nwindow.Vaadin.developmentModeCallback[\"vaadin-license-checker\"] = function (cls) {\n  var productInfo = { name: cls.is, version: cls.version };\n  proProducts.push(productInfo);\n  window.addEventListener(\"message\", function (e) {\n    if (e.data == \"validate-license\") {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    }\n  }, false);\n\n  window.Vaadin.checkLicenses = function () {\n    // Force checking of all licenses to avoid e.g. popups during presentations when the grace period just has ended\n    proProducts.forEach(function (productInfo) {\n      window.Vaadin.LicenseChecker.check(productInfo);\n    });\n  };\n\n  window.Vaadin.LicenseChecker.maybeCheck(productInfo);\n};\n\n}());\n\n  vaadin-dev-mode:end **/\n}\n\nif (typeof _vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__.runIfDevelopmentMode === 'function') {\n  (0,_vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__.runIfDevelopmentMode)(maybeCheckLicenses);\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-license-checker/vaadin-license-checker.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/elements/dom-module.js */ \"./node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n\n\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = (superClass) =>\n  class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n    /** @protected */\n    static finalize() {\n      super.finalize();\n\n      const template = this.prototype._template;\n\n      const inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;\n      if (inheritedTemplate) {\n        // Include the theme modules from the inherited template\n        Array.from(inheritedTemplate.content.querySelectorAll('style[include]')).forEach((s) => {\n          this._includeStyle(s.getAttribute('include'), template);\n        });\n      }\n\n      this._includeMatchingThemes(template);\n    }\n\n    /** @private */\n    static _includeMatchingThemes(template) {\n      const domModule = _polymer_polymer_lib_elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__.DomModule;\n      const modules = domModule.prototype.modules;\n\n      let hasThemes = false;\n      const defaultModuleName = this.is + '-default-theme';\n\n      Object.keys(modules)\n        .sort((moduleNameA, moduleNameB) => {\n          const vaadinA = moduleNameA.indexOf('vaadin-') === 0;\n          const vaadinB = moduleNameB.indexOf('vaadin-') === 0;\n\n          const vaadinThemePrefixes = ['lumo-', 'material-'];\n          const vaadinThemeA = vaadinThemePrefixes.filter((prefix) => moduleNameA.indexOf(prefix) === 0).length > 0;\n          const vaadinThemeB = vaadinThemePrefixes.filter((prefix) => moduleNameB.indexOf(prefix) === 0).length > 0;\n\n          if (vaadinA !== vaadinB) {\n            // Include vaadin core styles first\n            return vaadinA ? -1 : 1;\n          } else if (vaadinThemeA !== vaadinThemeB) {\n            // Include vaadin theme styles after that\n            return vaadinThemeA ? -1 : 1;\n          } else {\n            // Lastly include custom styles so they override all vaadin styles\n            return 0;\n          }\n        })\n        .forEach((moduleName) => {\n          if (moduleName !== defaultModuleName) {\n            const themeFor = modules[moduleName].getAttribute('theme-for');\n            if (themeFor) {\n              themeFor.split(' ').forEach((themeForToken) => {\n                if (new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(this.is)) {\n                  hasThemes = true;\n                  this._includeStyle(moduleName, template);\n                }\n              });\n            }\n          }\n        });\n\n      if (!hasThemes && modules[defaultModuleName]) {\n        // No theme modules found, include the default module if it exists\n        this._includeStyle(defaultModuleName, template);\n      }\n    }\n\n    /** @private */\n    static _includeStyle(moduleName, template) {\n      if (template && !template.content.querySelector(`style[include=\"${moduleName}\"]`)) {\n        const styleEl = document.createElement('style');\n        styleEl.setAttribute('include', moduleName);\n        template.content.appendChild(styleEl);\n      }\n    }\n  };\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = (superClass) =>\n  class VaadinThemePropertyMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Helper property with theme attribute value facilitating propagation\n         * in shadow DOM.\n         *\n         * Enables the component implementation to propagate the `theme`\n         * attribute value to the subcomponents in Shadow DOM by binding\n         * the subcomponents \"theme\" attribute to the `theme` property of\n         * the host.\n         *\n         * **NOTE:** Extending the mixin only provides the property for binding,\n         * and does not make the propagation alone.\n         *\n         * See [Theme Attribute and Subcomponents](https://github.com/vaadin/vaadin-themable-mixin/wiki/5.-Theme-Attribute-and-Subcomponents).\n         * page for more information.\n         *\n         * @protected\n         */\n        theme: {\n          type: String,\n          readOnly: true\n        }\n      };\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n\n      if (name === 'theme') {\n        this._setTheme(newValue);\n      }\n    }\n  };\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics-collect.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics-collect.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usageStatistics\": () => (/* binding */ usageStatistics)\n/* harmony export */ });\n/* harmony import */ var _vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js */ \"./node_modules/@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js\");\n/* This file is autogenerated from src/vaadin-usage-statistics.tpl.html */\n/*\n\nThis script gathers usage statistics from the application running in development mode.\n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\n\n\nfunction maybeGatherAndSendStats() {\n  /** vaadin-dev-mode:start\n  (function () {\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar getPolymerVersion = function getPolymerVersion() {\n  return window.Polymer && window.Polymer.version;\n};\n\nvar StatisticsGatherer = function () {\n  function StatisticsGatherer(logger) {\n    classCallCheck(this, StatisticsGatherer);\n\n    this.now = new Date().getTime();\n    this.logger = logger;\n  }\n\n  createClass(StatisticsGatherer, [{\n    key: 'frameworkVersionDetectors',\n    value: function frameworkVersionDetectors() {\n      return {\n        'Flow': function Flow() {\n          if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {\n            var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {\n              return window.Vaadin.Flow.clients[key];\n            }).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().flow;\n            });\n            if (flowVersions.length > 0) {\n              return flowVersions[0];\n            }\n          }\n        },\n        'Vaadin Framework': function VaadinFramework() {\n          if (window.vaadin && window.vaadin.clients) {\n            var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().vaadinVersion;\n            });\n            if (frameworkVersions.length > 0) {\n              return frameworkVersions[0];\n            }\n          }\n        },\n        'AngularJs': function AngularJs() {\n          if (window.angular && window.angular.version && window.angular.version) {\n            return window.angular.version.full;\n          }\n        },\n        'Angular': function Angular() {\n          if (window.ng) {\n            var tags = document.querySelectorAll(\"[ng-version]\");\n            if (tags.length > 0) {\n              return tags[0].getAttribute(\"ng-version\");\n            }\n            return \"Unknown\";\n          }\n        },\n        'Backbone.js': function BackboneJs() {\n          if (window.Backbone) {\n            return window.Backbone.VERSION;\n          }\n        },\n        'React': function React() {\n          var reactSelector = '[data-reactroot], [data-reactid]';\n          if (!!document.querySelector(reactSelector)) {\n            // React does not publish the version by default\n            return \"unknown\";\n          }\n        },\n        'Ember': function Ember() {\n          if (window.Em && window.Em.VERSION) {\n            return window.Em.VERSION;\n          } else if (window.Ember && window.Ember.VERSION) {\n            return window.Ember.VERSION;\n          }\n        },\n        'jQuery': function (_jQuery) {\n          function jQuery() {\n            return _jQuery.apply(this, arguments);\n          }\n\n          jQuery.toString = function () {\n            return _jQuery.toString();\n          };\n\n          return jQuery;\n        }(function () {\n          if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {\n            return jQuery.prototype.jquery;\n          }\n        }),\n        'Polymer': function Polymer() {\n          var version = getPolymerVersion();\n          if (version) {\n            return version;\n          }\n        },\n        'LitElement': function LitElement() {\n          var version = window.litElementVersions && window.litElementVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'LitHtml': function LitHtml() {\n          var version = window.litHtmlVersions && window.litHtmlVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'Vue.js': function VueJs() {\n          if (window.Vue) {\n            return window.Vue.version;\n          }\n        }\n      };\n    }\n  }, {\n    key: 'getUsedVaadinElements',\n    value: function getUsedVaadinElements(elements) {\n      var version = getPolymerVersion();\n      var elementClasses = void 0;\n      // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.\n      // Check all locations calling the method getEntries() in\n      // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106\n      // Currently it is only used by BootstrapHandler.\n      if (version && version.indexOf('2') === 0) {\n        // Polymer 2: components classes are stored in window.Vaadin\n        elementClasses = Object.keys(window.Vaadin).map(function (c) {\n          return window.Vaadin[c];\n        }).filter(function (c) {\n          return c.is;\n        });\n      } else {\n        // Polymer 3: components classes are stored in window.Vaadin.registrations\n        elementClasses = window.Vaadin.registrations || [];\n      }\n      elementClasses.forEach(function (klass) {\n        var version = klass.version ? klass.version : \"0.0.0\";\n        elements[klass.is] = { version: version };\n      });\n    }\n  }, {\n    key: 'getUsedVaadinThemes',\n    value: function getUsedVaadinThemes(themes) {\n      ['Lumo', 'Material'].forEach(function (themeName) {\n        var theme;\n        var version = getPolymerVersion();\n        if (version && version.indexOf('2') === 0) {\n          // Polymer 2: themes are stored in window.Vaadin\n          theme = window.Vaadin[themeName];\n        } else {\n          // Polymer 3: themes are stored in custom element registry\n          theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');\n        }\n        if (theme && theme.version) {\n          themes[themeName] = { version: theme.version };\n        }\n      });\n    }\n  }, {\n    key: 'getFrameworks',\n    value: function getFrameworks(frameworks) {\n      var detectors = this.frameworkVersionDetectors();\n      Object.keys(detectors).forEach(function (framework) {\n        var detector = detectors[framework];\n        try {\n          var version = detector();\n          if (version) {\n            frameworks[framework] = { version: version };\n          }\n        } catch (e) {}\n      });\n    }\n  }, {\n    key: 'gather',\n    value: function gather(storage) {\n      var storedStats = storage.read();\n      var gatheredStats = {};\n      var types = [\"elements\", \"frameworks\", \"themes\"];\n\n      types.forEach(function (type) {\n        gatheredStats[type] = {};\n        if (!storedStats[type]) {\n          storedStats[type] = {};\n        }\n      });\n\n      var previousStats = JSON.stringify(storedStats);\n\n      this.getUsedVaadinElements(gatheredStats.elements);\n      this.getFrameworks(gatheredStats.frameworks);\n      this.getUsedVaadinThemes(gatheredStats.themes);\n\n      var now = this.now;\n      types.forEach(function (type) {\n        var keys = Object.keys(gatheredStats[type]);\n        keys.forEach(function (key) {\n          if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {\n            storedStats[type][key] = { firstUsed: now };\n          }\n          // Discards any previously logged version number\n          storedStats[type][key].version = gatheredStats[type][key].version;\n          storedStats[type][key].lastUsed = now;\n        });\n      });\n\n      var newStats = JSON.stringify(storedStats);\n      storage.write(newStats);\n      if (newStats != previousStats && Object.keys(storedStats).length > 0) {\n        this.logger.debug(\"New stats: \" + newStats);\n      }\n    }\n  }]);\n  return StatisticsGatherer;\n}();\n\nvar StatisticsStorage = function () {\n  function StatisticsStorage(key) {\n    classCallCheck(this, StatisticsStorage);\n\n    this.key = key;\n  }\n\n  createClass(StatisticsStorage, [{\n    key: 'read',\n    value: function read() {\n      var localStorageStatsString = localStorage.getItem(this.key);\n      try {\n        return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');\n      } catch (e) {\n        return {};\n      }\n    }\n  }, {\n    key: 'write',\n    value: function write(data) {\n      localStorage.setItem(this.key, data);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      localStorage.removeItem(this.key);\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      var storedStats = this.read();\n      var empty = true;\n      Object.keys(storedStats).forEach(function (key) {\n        if (Object.keys(storedStats[key]).length > 0) {\n          empty = false;\n        }\n      });\n\n      return empty;\n    }\n  }]);\n  return StatisticsStorage;\n}();\n\nvar StatisticsSender = function () {\n  function StatisticsSender(url, logger) {\n    classCallCheck(this, StatisticsSender);\n\n    this.url = url;\n    this.logger = logger;\n  }\n\n  createClass(StatisticsSender, [{\n    key: 'send',\n    value: function send(data, errorHandler) {\n      var logger = this.logger;\n\n      if (navigator.onLine === false) {\n        logger.debug(\"Offline, can't send\");\n        errorHandler();\n        return;\n      }\n      logger.debug(\"Sending data to \" + this.url);\n\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"load\", function () {\n        // Stats sent, nothing more to do\n        logger.debug(\"Response: \" + req.responseText);\n      });\n      req.addEventListener(\"error\", function () {\n        logger.debug(\"Send failed\");\n        errorHandler();\n      });\n      req.addEventListener(\"abort\", function () {\n        logger.debug(\"Send aborted\");\n        errorHandler();\n      });\n      req.open(\"POST\", this.url);\n      req.setRequestHeader(\"Content-Type\", \"application/json\");\n      req.send(data);\n    }\n  }]);\n  return StatisticsSender;\n}();\n\nvar StatisticsLogger = function () {\n  function StatisticsLogger(id) {\n    classCallCheck(this, StatisticsLogger);\n\n    this.id = id;\n  }\n\n  createClass(StatisticsLogger, [{\n    key: '_isDebug',\n    value: function _isDebug() {\n      return localStorage.getItem(\"vaadin.\" + this.id + \".debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this._isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return StatisticsLogger;\n}();\n\nvar UsageStatistics = function () {\n  function UsageStatistics() {\n    classCallCheck(this, UsageStatistics);\n\n    this.now = new Date();\n    this.timeNow = this.now.getTime();\n    this.gatherDelay = 10; // Delay between loading this file and gathering stats\n    this.initialDelay = 24 * 60 * 60;\n\n    this.logger = new StatisticsLogger(\"statistics\");\n    this.storage = new StatisticsStorage(\"vaadin.statistics.basket\");\n    this.gatherer = new StatisticsGatherer(this.logger);\n    this.sender = new StatisticsSender(\"https://tools.vaadin.com/usage-stats/submit\", this.logger);\n  }\n\n  createClass(UsageStatistics, [{\n    key: 'maybeGatherAndSend',\n    value: function maybeGatherAndSend() {\n      var _this = this;\n\n      if (localStorage.getItem(UsageStatistics.optOutKey)) {\n        return;\n      }\n      this.gatherer.gather(this.storage);\n      setTimeout(function () {\n        _this.maybeSend();\n      }, this.gatherDelay * 1000);\n    }\n  }, {\n    key: 'lottery',\n    value: function lottery() {\n      return true;\n    }\n  }, {\n    key: 'currentMonth',\n    value: function currentMonth() {\n      return this.now.getYear() * 12 + this.now.getMonth();\n    }\n  }, {\n    key: 'maybeSend',\n    value: function maybeSend() {\n      var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));\n\n      if (!firstUse) {\n        // Use a grace period to avoid interfering with tests, incognito mode etc\n        firstUse = this.timeNow;\n        localStorage.setItem(UsageStatistics.firstUseKey, firstUse);\n      }\n\n      if (this.timeNow < firstUse + this.initialDelay * 1000) {\n        this.logger.debug(\"No statistics will be sent until the initial delay of \" + this.initialDelay + \"s has passed\");\n        return;\n      }\n      if (this.currentMonth() <= monthProcessed) {\n        this.logger.debug(\"This month has already been processed\");\n        return;\n      }\n      localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());\n      // Use random sampling\n      if (this.lottery()) {\n        this.logger.debug(\"Congratulations, we have a winner!\");\n      } else {\n        this.logger.debug(\"Sorry, no stats from you this time\");\n        return;\n      }\n\n      this.send();\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      // Ensure we have the latest data\n      this.gatherer.gather(this.storage);\n\n      // Read, send and clean up\n      var data = this.storage.read();\n      data[\"firstUse\"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      data[\"usageStatisticsVersion\"] = UsageStatistics.version;\n      var info = 'This request contains usage statistics gathered from the application running in development mode. \\n\\nStatistics gathering is automatically disabled and excluded from production builds.\\n\\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\\n\\n\\n\\n';\n      var self = this;\n      this.sender.send(info + JSON.stringify(data), function () {\n        // Revert the 'month processed' flag\n        localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);\n      });\n    }\n  }], [{\n    key: 'version',\n    get: function get$1() {\n      return '2.1.0';\n    }\n  }, {\n    key: 'firstUseKey',\n    get: function get$1() {\n      return 'vaadin.statistics.firstuse';\n    }\n  }, {\n    key: 'monthProcessedKey',\n    get: function get$1() {\n      return 'vaadin.statistics.monthProcessed';\n    }\n  }, {\n    key: 'optOutKey',\n    get: function get$1() {\n      return 'vaadin.statistics.optout';\n    }\n  }]);\n  return UsageStatistics;\n}();\n\ntry {\n  window.Vaadin = window.Vaadin || {};\n  window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();\n  window.Vaadin.usageStatsChecker.maybeGatherAndSend();\n} catch (e) {\n  // Intentionally ignored as this is not a problem in the app being developed\n}\n\n}());\n\n  vaadin-dev-mode:end **/\n}\n\nconst usageStatistics = function() {\n  if (typeof _vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__.runIfDevelopmentMode === 'function') {\n    return (0,_vaadin_vaadin_development_mode_detector_vaadin_development_mode_detector_js__WEBPACK_IMPORTED_MODULE_0__.runIfDevelopmentMode)(maybeGatherAndSendStats);\n  }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics-collect.js?");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usageStatistics\": () => (/* reexport safe */ _vaadin_usage_statistics_collect_js__WEBPACK_IMPORTED_MODULE_0__.usageStatistics)\n/* harmony export */ });\n/* harmony import */ var _vaadin_usage_statistics_collect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-usage-statistics-collect.js */ \"./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics-collect.js\");\n\n\n\n//# sourceURL=webpack://test/./node_modules/@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/apply-shim-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/apply-shim-utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"invalidate\": () => (/* binding */ invalidate),\n/* harmony export */   \"invalidateTemplate\": () => (/* binding */ invalidateTemplate),\n/* harmony export */   \"isValid\": () => (/* binding */ isValid),\n/* harmony export */   \"templateIsValid\": () => (/* binding */ templateIsValid),\n/* harmony export */   \"isValidating\": () => (/* binding */ isValidating),\n/* harmony export */   \"templateIsValidating\": () => (/* binding */ templateIsValidating),\n/* harmony export */   \"startValidating\": () => (/* binding */ startValidating),\n/* harmony export */   \"startValidatingTemplate\": () => (/* binding */ startValidatingTemplate),\n/* harmony export */   \"elementsAreInvalid\": () => (/* binding */ elementsAreInvalid)\n/* harmony export */ });\n/* harmony import */ var _template_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-map.js */ \"./node_modules/@webcomponents/shadycss/src/template-map.js\");\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\nconst CURRENT_VERSION = '_applyShimCurrentVersion';\n\n/** @const {string} */\nconst NEXT_VERSION = '_applyShimNextVersion';\n\n/** @const {string} */\nconst VALIDATING_VERSION = '_applyShimValidatingVersion';\n\n/**\n * @const {Promise<void>}\n */\nconst promise = Promise.resolve();\n\n/**\n * @param {string} elementName\n */\nfunction invalidate(elementName) {\n  let template = _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][elementName];\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\nfunction invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;\n  // ensure the \"validating for\" flag exists\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;\n  // increment the next version\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nfunction isValid(elementName) {\n  let template = _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][elementName];\n  if (template) {\n    return templateIsValid(template);\n  }\n  return true;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nfunction templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nfunction isValidating(elementName) {\n  let template = _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][elementName];\n  if (template) {\n    return templateIsValidating(template);\n  }\n  return false;\n}\n\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nfunction templateIsValidating(template) {\n  return (\n    !templateIsValid(template) &&\n    template[VALIDATING_VERSION] === template[NEXT_VERSION]\n  );\n}\n\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n */\nfunction startValidating(elementName) {\n  let template = _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][elementName];\n  startValidatingTemplate(template);\n}\n\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\nfunction startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION];\n  // however, there only needs to be one async task to clear the counters\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function () {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n\n/**\n * @return {boolean}\n */\nfunction elementsAreInvalid() {\n  for (let elementName in _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    let template = _template_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][elementName];\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/apply-shim-utils.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/common-regex.js":
/*!******************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/common-regex.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VAR_ASSIGN\": () => (/* binding */ VAR_ASSIGN),\n/* harmony export */   \"MIXIN_MATCH\": () => (/* binding */ MIXIN_MATCH),\n/* harmony export */   \"VAR_CONSUMED\": () => (/* binding */ VAR_CONSUMED),\n/* harmony export */   \"ANIMATION_MATCH\": () => (/* binding */ ANIMATION_MATCH),\n/* harmony export */   \"MEDIA_MATCH\": () => (/* binding */ MEDIA_MATCH),\n/* harmony export */   \"IS_VAR\": () => (/* binding */ IS_VAR),\n/* harmony export */   \"BRACKETED\": () => (/* binding */ BRACKETED),\n/* harmony export */   \"HOST_PREFIX\": () => (/* binding */ HOST_PREFIX),\n/* harmony export */   \"HOST_SUFFIX\": () => (/* binding */ HOST_SUFFIX)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gi;\nconst MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nconst VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nconst ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nconst MEDIA_MATCH = /@media\\s(.*)/;\nconst IS_VAR = /^--/;\nconst BRACKETED = /\\{[^}]*\\}/g;\nconst HOST_PREFIX = '(?:^|[^.#[:])';\nconst HOST_SUFFIX = '($|[.:[\\\\s>+~])';\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/common-regex.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/common-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/common-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"updateNativeProperties\": () => (/* binding */ updateNativeProperties),\n/* harmony export */   \"getComputedStyleValue\": () => (/* binding */ getComputedStyleValue),\n/* harmony export */   \"detectMixin\": () => (/* binding */ detectMixin)\n/* harmony export */ });\n/* harmony import */ var _common_regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common-regex.js */ \"./node_modules/@webcomponents/shadycss/src/common-regex.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * @param {Element} element\n * @param {Object=} properties\n */\nfunction updateNativeProperties(element, properties) {\n  // remove previous properties\n  for (let p in properties) {\n    // NOTE: for bc with shim, don't apply null values.\n    if (p === null) {\n      element.style.removeProperty(p);\n    } else {\n      element.style.setProperty(p, properties[p]);\n    }\n  }\n}\n\n/**\n * @param {Element} element\n * @param {string} property\n * @return {string}\n */\nfunction getComputedStyleValue(element, property) {\n  /**\n   * @const {string}\n   */\n  const value = window.getComputedStyle(element).getPropertyValue(property);\n  if (!value) {\n    return '';\n  } else {\n    return value.trim();\n  }\n}\n\n/**\n * return true if `cssText` contains a mixin definition or consumption\n * @param {string} cssText\n * @return {boolean}\n */\nfunction detectMixin(cssText) {\n  const has = _common_regex_js__WEBPACK_IMPORTED_MODULE_0__.MIXIN_MATCH.test(cssText) || _common_regex_js__WEBPACK_IMPORTED_MODULE_0__.VAR_ASSIGN.test(cssText);\n  // reset state of the regexes\n  _common_regex_js__WEBPACK_IMPORTED_MODULE_0__.MIXIN_MATCH.lastIndex = 0;\n  _common_regex_js__WEBPACK_IMPORTED_MODULE_0__.VAR_ASSIGN.lastIndex = 0;\n  return has;\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/common-utils.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/css-parse.js":
/*!***************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/css-parse.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StyleNode\": () => (/* binding */ StyleNode),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify),\n/* harmony export */   \"removeCustomPropAssignment\": () => (/* binding */ removeCustomPropAssignment),\n/* harmony export */   \"types\": () => (/* binding */ types)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\n\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous']\n      ? node['previous']['end']\n      : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = (node['parsedSelector'] = node['selector'] = t.trim());\n    node['atRule'] = s.indexOf(AT_START) === 0;\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nfunction stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties\n        ? node['cssText']\n        : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return (\n    Boolean(r) &&\n    Boolean(r['selector']) &&\n    r['selector'].indexOf(VAR_START) === 0\n  );\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nconst types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000,\n};\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g,\n};\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/css-parse.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/custom-style-interface.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/custom-style-interface.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CustomStyleProvider\": () => (/* binding */ CustomStyleProvider),\n/* harmony export */   \"default\": () => (/* binding */ CustomStyleInterface),\n/* harmony export */   \"CustomStyleInterfaceInterface\": () => (/* binding */ CustomStyleInterfaceInterface)\n/* harmony export */ });\n/* harmony import */ var _document_wait_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./document-wait.js */ \"./node_modules/@webcomponents/shadycss/src/document-wait.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}\n */\nlet CustomStyleProvider;\n\nconst SEEN_MARKER = '__seenByShadyCSS';\nconst CACHED_STYLE = '__shadyCSSCachedStyle';\n\n/** @type {?function(!HTMLStyleElement)} */\nlet transformFn = null;\n\n/** @type {?function()} */\nlet validateFn = null;\n\n/**\nThis interface is provided to add document-level <style> elements to ShadyCSS for processing.\nThese styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles\nIn addition, these styles may also need to be processed for @apply rules and CSS Custom Properties\n\nTo add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`\n\nIn addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.\nThis function will be called when calculating styles.\n\nAn example usage of the document-level styling api can be found in `examples/document-style-lib.js`\n\n@unrestricted\n*/\nclass CustomStyleInterface {\n  constructor() {\n    /** @type {!Array<!CustomStyleProvider>} */\n    this['customStyles'] = [];\n    this['enqueued'] = false;\n    // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;\n    (0,_document_wait_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(() => {\n      if (window['ShadyCSS']['flushCustomStyles']) {\n        window['ShadyCSS']['flushCustomStyles']();\n      }\n    });\n  }\n  /**\n   * Queue a validation for new custom styles to batch style recalculations\n   */\n  enqueueDocumentValidation() {\n    if (this['enqueued'] || !validateFn) {\n      return;\n    }\n    this['enqueued'] = true;\n    (0,_document_wait_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(validateFn);\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   */\n  addCustomStyle(style) {\n    if (!style[SEEN_MARKER]) {\n      style[SEEN_MARKER] = true;\n      this['customStyles'].push(style);\n      this.enqueueDocumentValidation();\n    }\n  }\n  /**\n   * @param {!CustomStyleProvider} customStyle\n   * @return {HTMLStyleElement}\n   */\n  getStyleForCustomStyle(customStyle) {\n    if (customStyle[CACHED_STYLE]) {\n      return customStyle[CACHED_STYLE];\n    }\n    let style;\n    if (customStyle['getStyle']) {\n      style = customStyle['getStyle']();\n    } else {\n      style = customStyle;\n    }\n    return style;\n  }\n  /**\n   * @return {!Array<!CustomStyleProvider>}\n   */\n  processStyles() {\n    const cs = this['customStyles'];\n    for (let i = 0; i < cs.length; i++) {\n      const customStyle = cs[i];\n      if (customStyle[CACHED_STYLE]) {\n        continue;\n      }\n      const style = this.getStyleForCustomStyle(customStyle);\n      if (style) {\n        // HTMLImports polyfill may have cloned the style into the main document,\n        // which is referenced with __appliedElement.\n        const styleToTransform = /** @type {!HTMLStyleElement} */ (style[\n          '__appliedElement'\n        ] || style);\n        if (transformFn) {\n          transformFn(styleToTransform);\n        }\n        customStyle[CACHED_STYLE] = styleToTransform;\n      }\n    }\n    return cs;\n  }\n}\n\n/* eslint-disable no-self-assign */\nCustomStyleInterface.prototype['addCustomStyle'] =\n  CustomStyleInterface.prototype.addCustomStyle;\nCustomStyleInterface.prototype['getStyleForCustomStyle'] =\n  CustomStyleInterface.prototype.getStyleForCustomStyle;\nCustomStyleInterface.prototype['processStyles'] =\n  CustomStyleInterface.prototype.processStyles;\n/* eslint-enable no-self-assign */\n\nObject.defineProperties(CustomStyleInterface.prototype, {\n  'transformCallback': {\n    /** @return {?function(!HTMLStyleElement)} */\n    get() {\n      return transformFn;\n    },\n    /** @param {?function(!HTMLStyleElement)} fn */\n    set(fn) {\n      transformFn = fn;\n    },\n  },\n  'validateCallback': {\n    /** @return {?function()} */\n    get() {\n      return validateFn;\n    },\n    /**\n     * @param {?function()} fn\n     * @this {CustomStyleInterface}\n     */\n    set(fn) {\n      let needsEnqueue = false;\n      if (!validateFn) {\n        needsEnqueue = true;\n      }\n      validateFn = fn;\n      if (needsEnqueue) {\n        this.enqueueDocumentValidation();\n      }\n    },\n  },\n});\n\n/** @typedef {{\n * customStyles: !Array<!CustomStyleProvider>,\n * addCustomStyle: function(!CustomStyleProvider),\n * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,\n * findStyles: function(),\n * transformCallback: ?function(!HTMLStyleElement),\n * validateCallback: ?function()\n * }}\n */\nconst CustomStyleInterfaceInterface = {};\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/custom-style-interface.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/document-wait.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/document-wait.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ documentWait)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/** @type {Promise<void>} */\nlet readyPromise = null;\n\n/** @type {?function(?function())} */\nlet whenReady =\n  (window['HTMLImports'] && window['HTMLImports']['whenReady']) || null;\n\n/** @type {function()} */\nlet resolveFn;\n\n/**\n * @param {?function()} callback\n */\nfunction documentWait(callback) {\n  requestAnimationFrame(function () {\n    if (whenReady) {\n      whenReady(callback);\n    } else {\n      if (!readyPromise) {\n        readyPromise = new Promise((resolve) => {\n          resolveFn = resolve;\n        });\n        if (document.readyState === 'complete') {\n          resolveFn();\n        } else {\n          document.addEventListener('readystatechange', () => {\n            if (document.readyState === 'complete') {\n              resolveFn();\n            }\n          });\n        }\n      }\n      readyPromise.then(function () {\n        callback && callback();\n      });\n    }\n  });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/document-wait.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/document-watcher.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/document-watcher.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flush\": () => (/* binding */ flush),\n/* harmony export */   \"getCurrentScope\": () => (/* binding */ getCurrentScope),\n/* harmony export */   \"getOwnerScope\": () => (/* binding */ getOwnerScope),\n/* harmony export */   \"ensureCorrectScope\": () => (/* binding */ ensureCorrectScope),\n/* harmony export */   \"ensureCorrectSubtreeScoping\": () => (/* binding */ ensureCorrectSubtreeScoping)\n/* harmony export */ });\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/* harmony import */ var _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style-transformer.js */ \"./node_modules/@webcomponents/shadycss/src/style-transformer.js\");\n/* harmony import */ var _style_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style-util.js */ \"./node_modules/@webcomponents/shadycss/src/style-util.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\nlet flush = function () {};\n\n/**\n * @param {!Element} element\n * @return {string}\n */\nfunction getClasses(element) {\n  if (element.classList && element.classList.value) {\n    return element.classList.value;\n  } else {\n    // NOTE: className is patched to remove scoping classes in ShadyDOM\n    // use getAttribute('class') instead, which is unpatched\n    return element.getAttribute('class') || '';\n  }\n}\n\nconst scopeRegExp = new RegExp(`${_style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SCOPE_NAME}\\\\s*([^\\\\s]*)`);\n\n/**\n * @param {!Element} element\n * @return {string}\n */\nfunction getCurrentScope(element) {\n  const match = getClasses(element).match(scopeRegExp);\n  if (match) {\n    return match[1];\n  } else {\n    return '';\n  }\n}\n\n/**\n * @param {!Node} node\n */\nfunction getOwnerScope(node) {\n  const ownerRoot = (0,_style_util_js__WEBPACK_IMPORTED_MODULE_2__.wrap)(node).getRootNode();\n  if (ownerRoot === node || ownerRoot === node.ownerDocument) {\n    return '';\n  }\n  const host = /** @type {!ShadowRoot} */ (ownerRoot).host;\n  if (!host) {\n    // this may actually be a document fragment\n    return '';\n  }\n  return (0,_style_util_js__WEBPACK_IMPORTED_MODULE_2__.getIsExtends)(host).is;\n}\n\n/**\n * @param {!Element} element\n */\nfunction ensureCorrectScope(element) {\n  const currentScope = getCurrentScope(element);\n  const ownerRoot = (0,_style_util_js__WEBPACK_IMPORTED_MODULE_2__.wrap)(element).getRootNode();\n  if (ownerRoot === element) {\n    return;\n  }\n  if (currentScope && ownerRoot === element.ownerDocument) {\n    // node was scoped, but now is in document\n    _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].domRemoveScope(element, currentScope);\n  } else if (ownerRoot instanceof ShadowRoot) {\n    const ownerScope = getOwnerScope(element);\n    if (ownerScope !== currentScope) {\n      // node was scoped, but not by its current owner\n      _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].domReplaceScope(element, currentScope, ownerScope);\n    }\n  }\n}\n\n/**\n * @param {!HTMLElement|!HTMLDocument} element\n */\nfunction ensureCorrectSubtreeScoping(element) {\n  // find unscoped subtree nodes\n  const unscopedNodes = window['ShadyDOM']['nativeMethods'][\n    'querySelectorAll'\n  ].call(element, `:not(.${_style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SCOPE_NAME})`);\n\n  for (let j = 0; j < unscopedNodes.length; j++) {\n    // it's possible, during large batch inserts, that nodes that aren't\n    // scoped within the current scope were added.\n    // To make sure that any unscoped nodes that were inserted in the current batch are correctly styled,\n    // query all unscoped nodes and force their style-scope to be applied.\n    // This could happen if a sub-element appended an unscoped node in its shadowroot and this function\n    // runs on a parent element of the host of that unscoped node:\n    // parent-element -> element -> unscoped node\n    // Here unscoped node should have the style-scope element, not parent-element.\n    const unscopedNode = unscopedNodes[j];\n    const scopeForPreviouslyUnscopedNode = getOwnerScope(unscopedNode);\n    if (scopeForPreviouslyUnscopedNode) {\n      _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].element(unscopedNode, scopeForPreviouslyUnscopedNode);\n    }\n  }\n}\n\n/**\n * @param {HTMLElement} el\n * @return {boolean}\n */\nfunction isElementWithBuiltCss(el) {\n  if (el.localName === 'style' || el.localName === 'template') {\n    return (0,_style_util_js__WEBPACK_IMPORTED_MODULE_2__.elementHasBuiltCss)(el);\n  }\n  return false;\n}\n\n/**\n * @param {Array<MutationRecord|null>|null} mxns\n */\nfunction handler(mxns) {\n  for (let x = 0; x < mxns.length; x++) {\n    let mxn = mxns[x];\n    if (\n      mxn.target === document.documentElement ||\n      mxn.target === document.head\n    ) {\n      continue;\n    }\n    for (let i = 0; i < mxn.addedNodes.length; i++) {\n      let n = mxn.addedNodes[i];\n      if (n.nodeType !== Node.ELEMENT_NODE) {\n        continue;\n      }\n      n = /** @type {HTMLElement} */ (n); // eslint-disable-line no-self-assign\n      let root = n.getRootNode();\n      let currentScope = getCurrentScope(n);\n      // node was scoped, but now is in document\n      // If this element has built css, we must not remove scoping as this node\n      // will be used as a template or style without re - applying scoping as an optimization\n      if (\n        currentScope &&\n        root === n.ownerDocument &&\n        !isElementWithBuiltCss(n)\n      ) {\n        _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].domRemoveScope(n, currentScope);\n      } else if (root instanceof ShadowRoot) {\n        const newScope = getOwnerScope(n);\n        // rescope current node and subtree if necessary\n        if (newScope !== currentScope) {\n          _style_transformer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].domReplaceScope(n, currentScope, newScope);\n        }\n        // make sure all the subtree elements are scoped correctly\n        ensureCorrectSubtreeScoping(n);\n      }\n    }\n  }\n}\n\n// if native Shadow DOM is being used, or ShadyDOM handles dynamic scoiping, do not activate the MutationObserver\nif (\n  !_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeShadow &&\n  !(window['ShadyDOM'] && window['ShadyDOM']['handlesDynamicScoping'])\n) {\n  let observer = new MutationObserver(handler);\n  let start = (node) => {\n    observer.observe(node, {childList: true, subtree: true});\n  };\n  let nativeCustomElements =\n    window['customElements'] &&\n    !window['customElements']['polyfillWrapFlushCallback'];\n  // need to start immediately with native custom elements\n  // TODO(dfreedm): with polyfilled HTMLImports and native custom elements\n  // excessive mutations may be observed; this can be optimized via cooperation\n  // with the HTMLImports polyfill.\n  if (nativeCustomElements) {\n    start(document);\n  } else {\n    let delayedStart = () => {\n      start(document.body);\n    };\n    // use polyfill timing if it's available\n    if (window['HTMLImports']) {\n      window['HTMLImports']['whenReady'](delayedStart);\n      // otherwise push beyond native imports being ready\n      // which requires RAF + readystate interactive.\n    } else {\n      requestAnimationFrame(function () {\n        if (document.readyState === 'loading') {\n          let listener = function () {\n            delayedStart();\n            document.removeEventListener('readystatechange', listener);\n          };\n          document.addEventListener('readystatechange', listener);\n        } else {\n          delayedStart();\n        }\n      });\n    }\n  }\n\n  flush = function () {\n    handler(observer.takeRecords());\n  };\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/document-watcher.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/scoping-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/scoping-shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ScopingShim)\n/* harmony export */ });\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/* harmony import */ var _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style-transformer.js */ \"./node_modules/@webcomponents/shadycss/src/style-transformer.js\");\n/* harmony import */ var _style_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style-util.js */ \"./node_modules/@webcomponents/shadycss/src/style-util.js\");\n/* harmony import */ var _style_properties_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style-properties.js */ \"./node_modules/@webcomponents/shadycss/src/style-properties.js\");\n/* harmony import */ var _style_placeholder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style-placeholder.js */ \"./node_modules/@webcomponents/shadycss/src/style-placeholder.js\");\n/* harmony import */ var _style_info_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style-info.js */ \"./node_modules/@webcomponents/shadycss/src/style-info.js\");\n/* harmony import */ var _style_cache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./style-cache.js */ \"./node_modules/@webcomponents/shadycss/src/style-cache.js\");\n/* harmony import */ var _document_watcher_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./document-watcher.js */ \"./node_modules/@webcomponents/shadycss/src/document-watcher.js\");\n/* harmony import */ var _template_map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./template-map.js */ \"./node_modules/@webcomponents/shadycss/src/template-map.js\");\n/* harmony import */ var _apply_shim_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./apply-shim-utils.js */ \"./node_modules/@webcomponents/shadycss/src/apply-shim-utils.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./common-utils.js */ \"./node_modules/@webcomponents/shadycss/src/common-utils.js\");\n/* harmony import */ var _custom_style_interface_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./custom-style-interface.js */ \"./node_modules/@webcomponents/shadycss/src/custom-style-interface.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n// prettier-ignore\n\n\n\n\n// prettier-ignore\n\n\n\n// prettier-ignore\n\n\n\n\n// prettier-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n/** @type {!Object<string, string>} */\nconst adoptedCssTextMap = {};\n\n/**\n * @const {StyleCache}\n */\nconst styleCache = new _style_cache_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n\nclass ScopingShim {\n  constructor() {\n    this._scopeCounter = {};\n    this._documentOwner = /** @type {!HTMLElement} */ (document.documentElement);\n    let ast = new _css_parse_js__WEBPACK_IMPORTED_MODULE_0__.StyleNode();\n    ast['rules'] = [];\n    this._documentOwnerStyleInfo = _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].set(\n      this._documentOwner,\n      new _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](ast)\n    );\n    this._elementsHaveApplied = false;\n    /** @type {?Object} */\n    this._applyShim = null;\n    /** @type {?CustomStyleInterfaceInterface} */\n    this._customStyleInterface = null;\n  }\n  flush() {\n    (0,_document_watcher_js__WEBPACK_IMPORTED_MODULE_8__.flush)();\n  }\n  _generateScopeSelector(name) {\n    let id = (this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1);\n    return `${name}-${id}`;\n  }\n  getStyleAst(style) {\n    return _style_util_js__WEBPACK_IMPORTED_MODULE_3__.rulesForStyle(style);\n  }\n  styleAstToString(ast) {\n    return _style_util_js__WEBPACK_IMPORTED_MODULE_3__.toCssText(ast);\n  }\n  _gatherStyles(template) {\n    return _style_util_js__WEBPACK_IMPORTED_MODULE_3__.gatherStyleText(template.content);\n  }\n  /**\n   * Prepare the styling and template for the given element type\n   *\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @param {string=} typeExtension\n   */\n  prepareTemplate(template, elementName, typeExtension) {\n    this.prepareTemplateDom(template, elementName);\n    this.prepareTemplateStyles(template, elementName, typeExtension);\n  }\n  /**\n   * Prepare styling for the given element type\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @param {string=} typeExtension\n   */\n  prepareTemplateStyles(template, elementName, typeExtension) {\n    if (template._prepared || _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.disableRuntime) {\n      return;\n    }\n    // style placeholders are only used when ShadyDOM is active\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow) {\n      (0,_style_placeholder_js__WEBPACK_IMPORTED_MODULE_5__.ensureStylePlaceholder)(elementName);\n    }\n    template._prepared = true;\n    template.name = elementName;\n    template.extends = typeExtension;\n    _template_map_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"][elementName] = template;\n    let cssBuild = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getCssBuild(template);\n    const optimalBuild = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.isOptimalCssBuild(cssBuild);\n    let info = {\n      is: elementName,\n      extends: typeExtension,\n    };\n    let cssText =\n      this._gatherStyles(template) + (adoptedCssTextMap[elementName] || '');\n    // check if the styling has mixin definitions or uses\n    this._ensure();\n    if (!optimalBuild) {\n      let hasMixins = !cssBuild && (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.detectMixin)(cssText);\n      let ast = (0,_css_parse_js__WEBPACK_IMPORTED_MODULE_0__.parse)(cssText);\n      // only run the applyshim transforms if there is a mixin involved\n      if (hasMixins && _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables && this._applyShim) {\n        this._applyShim['transformRules'](ast, elementName);\n      }\n      template['_styleAst'] = ast;\n    }\n    let ownPropertyNames = [];\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      ownPropertyNames = _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].decorateStyles(template['_styleAst']);\n    }\n    if (!ownPropertyNames.length || _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      let root = _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow ? template.content : null;\n      let placeholder = (0,_style_placeholder_js__WEBPACK_IMPORTED_MODULE_5__.getStylePlaceholder)(elementName);\n      let style = this._generateStaticStyle(\n        info,\n        template['_styleAst'],\n        root,\n        placeholder,\n        cssBuild,\n        optimalBuild ? cssText : ''\n      );\n      template._style = style;\n    }\n    template._ownPropertyNames = ownPropertyNames;\n  }\n\n  /**\n   * @param {!Array<string>} cssTextArray\n   * @param {string} elementName\n   */\n  prepareAdoptedCssText(cssTextArray, elementName) {\n    adoptedCssTextMap[elementName] = cssTextArray.join(' ');\n  }\n  /**\n   * Prepare template for the given element type\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   */\n  prepareTemplateDom(template, elementName) {\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.disableRuntime) {\n      return;\n    }\n    const cssBuild = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getCssBuild(template);\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow && cssBuild !== 'shady' && !template._domPrepared) {\n      template._domPrepared = true;\n      _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].domAddScope(template.content, elementName);\n    }\n  }\n  /**\n   * @param {!{is: string, extends: (string|undefined)}} info\n   * @param {!StyleNode} rules\n   * @param {DocumentFragment} shadowroot\n   * @param {Node} placeholder\n   * @param {string} cssBuild\n   * @param {string=} cssText\n   * @return {?HTMLStyleElement}\n   */\n  _generateStaticStyle(\n    info,\n    rules,\n    shadowroot,\n    placeholder,\n    cssBuild,\n    cssText\n  ) {\n    cssText = _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].elementStyles(\n      info,\n      rules,\n      null,\n      cssBuild,\n      cssText\n    );\n    if (cssText.length) {\n      return _style_util_js__WEBPACK_IMPORTED_MODULE_3__.applyCss(cssText, info.is, shadowroot, placeholder);\n    }\n    return null;\n  }\n  _prepareHost(host) {\n    const {is, typeExtension} = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getIsExtends(host);\n    const placeholder = (0,_style_placeholder_js__WEBPACK_IMPORTED_MODULE_5__.getStylePlaceholder)(is);\n    const template = _template_map_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"][is];\n    if (!template) {\n      return;\n    }\n    const ast = template['_styleAst'];\n    const ownStylePropertyNames = template._ownPropertyNames;\n    const cssBuild = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getCssBuild(template);\n    const styleInfo = new _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ast,\n      placeholder,\n      ownStylePropertyNames,\n      is,\n      typeExtension,\n      cssBuild\n    );\n    _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].set(host, styleInfo);\n    return styleInfo;\n  }\n  /**\n   * Returns a boolean that indicates if styles need to be reprocessed because\n   * the apply shim is now available.\n   * @return {boolean}\n   */\n  _ensureApplyShim() {\n    if (!this._applyShim && window.ShadyCSS && window.ShadyCSS.ApplyShim) {\n      this._applyShim = /** @type {!Object} */ (window.ShadyCSS.ApplyShim);\n      this._applyShim['invalidCallback'] = _apply_shim_utils_js__WEBPACK_IMPORTED_MODULE_10__.invalidate;\n      return true;\n    }\n    return false;\n  }\n  _ensureCustomStyleInterface() {\n    if (this._customStyleInterface) {\n      return;\n    } else if (window.ShadyCSS && window.ShadyCSS.CustomStyleInterface) {\n      this._customStyleInterface = /** @type {!CustomStyleInterfaceInterface} */ (window\n        .ShadyCSS.CustomStyleInterface);\n      /** @type {function(!HTMLStyleElement)} */\n      this._customStyleInterface['transformCallback'] = (style) => {\n        this.transformCustomStyleForDocument(style);\n      };\n      this._customStyleInterface['validateCallback'] = () => {\n        requestAnimationFrame(() => {\n          if (\n            this._customStyleInterface['enqueued'] ||\n            this._elementsHaveApplied\n          ) {\n            this.flushCustomStyles();\n          }\n        });\n      };\n    }\n  }\n  /**\n   * Returns a boolean that indicates if styles need to be reprocessed because\n   * the apply shim is now available.\n   * @return {boolean}\n   */\n  _ensure() {\n    const needsApplyShimUpdate = this._ensureApplyShim();\n    this._ensureCustomStyleInterface();\n    return needsApplyShimUpdate;\n  }\n  /**\n   * Flush and apply custom styles to document\n   */\n  flushCustomStyles() {\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.disableRuntime) {\n      return;\n    }\n    const needsApplyShimUpdate = this._ensure();\n    if (!this._customStyleInterface) {\n      return;\n    }\n    let customStyles = this._customStyleInterface['processStyles']();\n    // early return if custom-styles don't need validation\n    if (!needsApplyShimUpdate && !this._customStyleInterface['enqueued']) {\n      return;\n    }\n    // bail if custom styles are built optimally\n    if (_style_util_js__WEBPACK_IMPORTED_MODULE_3__.isOptimalCssBuild(this._documentOwnerStyleInfo.cssBuild)) {\n      return;\n    }\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      this._reorderCustomStylesRules(customStyles);\n      this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n      this._applyCustomStyles(customStyles);\n      if (this._elementsHaveApplied) {\n        // if custom elements have upgraded and there are no native css variables, we must recalculate the whole tree\n        this.styleDocument();\n      }\n    } else if (!this._documentOwnerStyleInfo.cssBuild) {\n      this._revalidateCustomStyleApplyShim(customStyles);\n    }\n    this._customStyleInterface['enqueued'] = false;\n  }\n  /**\n   * Reorder of custom styles for Custom Property shim\n   * @param {!Array<!CustomStyleProvider>} customStyles\n   */\n  _reorderCustomStylesRules(customStyles) {\n    const styles = customStyles\n      .map((c) => this._customStyleInterface['getStyleForCustomStyle'](c))\n      .filter((s) => !!s);\n    // sort styles in document order\n    styles.sort((a, b) => {\n      // use `b.compare(a)` to be more straightforward\n      const position = b.compareDocumentPosition(a);\n      if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n        // A is after B, A should be higher sorted\n        return 1;\n      } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n        // A is before B, A should be lower sorted\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    // sort ast ordering for document\n    this._documentOwnerStyleInfo.styleRules['rules'] = styles.map((s) =>\n      _style_util_js__WEBPACK_IMPORTED_MODULE_3__.rulesForStyle(s)\n    );\n  }\n  /**\n   * Apply styles for the given element\n   *\n   * @param {!HTMLElement} host\n   * @param {Object=} overrideProps\n   */\n  styleElement(host, overrideProps) {\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.disableRuntime) {\n      if (overrideProps) {\n        if (!_style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(host)) {\n          _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].set(host, new _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](null));\n        }\n        const styleInfo = /** @type {!StyleInfo} */ (_style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(host));\n        this._mixOverrideStyleProps(styleInfo, overrideProps);\n        this.styleElementNativeVariables(host, styleInfo);\n      }\n      return;\n    }\n    const styleInfo = _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(host) || this._prepareHost(host);\n    // if there is no style info at this point, bail\n    if (!styleInfo) {\n      return;\n    }\n    // Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called\n    if (!this._isRootOwner(host)) {\n      this._elementsHaveApplied = true;\n    }\n    if (overrideProps) {\n      this._mixOverrideStyleProps(styleInfo, overrideProps);\n    }\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      this.styleElementShimVariables(host, styleInfo);\n    } else {\n      this.styleElementNativeVariables(host, styleInfo);\n    }\n  }\n  /**\n   * @param {!StyleInfo} styleInfo\n   * @param {Object} overrideProps\n   */\n  _mixOverrideStyleProps(styleInfo, overrideProps) {\n    styleInfo.overrideStyleProperties = styleInfo.overrideStyleProperties || {};\n    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n  }\n  /**\n   * @param {!HTMLElement} host\n   * @param {!StyleInfo} styleInfo\n   */\n  styleElementShimVariables(host, styleInfo) {\n    this.flush();\n    this._updateProperties(host, styleInfo);\n    if (\n      styleInfo.ownStylePropertyNames &&\n      styleInfo.ownStylePropertyNames.length\n    ) {\n      this._applyStyleProperties(host, styleInfo);\n    }\n  }\n  /**\n   * @param {!HTMLElement} host\n   * @param {!StyleInfo} styleInfo\n   */\n  styleElementNativeVariables(host, styleInfo) {\n    const {is} = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getIsExtends(host);\n    if (styleInfo.overrideStyleProperties) {\n      (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.updateNativeProperties)(host, styleInfo.overrideStyleProperties);\n    }\n    const template = _template_map_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"][is];\n    // bail early if there is no shadowroot for this element\n    if (!template && !this._isRootOwner(host)) {\n      return;\n    }\n    // bail early if the template was built with polymer-css-build\n    if (template && _style_util_js__WEBPACK_IMPORTED_MODULE_3__.elementHasBuiltCss(template)) {\n      return;\n    }\n    if (\n      template &&\n      template._style &&\n      !_apply_shim_utils_js__WEBPACK_IMPORTED_MODULE_10__.templateIsValid(template)\n    ) {\n      // update template\n      if (!_apply_shim_utils_js__WEBPACK_IMPORTED_MODULE_10__.templateIsValidating(template)) {\n        this._ensure();\n        this._applyShim &&\n          this._applyShim['transformRules'](template['_styleAst'], is);\n        template._style.textContent = _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].elementStyles(\n          host,\n          styleInfo.styleRules\n        );\n        _apply_shim_utils_js__WEBPACK_IMPORTED_MODULE_10__.startValidatingTemplate(template);\n      }\n      // update instance if native shadowdom\n      if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow) {\n        let root = host.shadowRoot;\n        if (root) {\n          let style = root.querySelector('style');\n          if (style) {\n            style.textContent = _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].elementStyles(\n              host,\n              styleInfo.styleRules\n            );\n          }\n        }\n      }\n      styleInfo.styleRules = template['_styleAst'];\n    }\n  }\n  _styleOwnerForNode(node) {\n    let root = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.wrap(node).getRootNode();\n    let host = root.host;\n    if (host) {\n      if (_style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(host) || this._prepareHost(host)) {\n        return host;\n      } else {\n        return this._styleOwnerForNode(host);\n      }\n    }\n    return this._documentOwner;\n  }\n  _isRootOwner(node) {\n    return node === this._documentOwner;\n  }\n  _applyStyleProperties(host, styleInfo) {\n    let is = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getIsExtends(host).is;\n    let cacheEntry = styleCache.fetch(\n      is,\n      styleInfo.styleProperties,\n      styleInfo.ownStylePropertyNames\n    );\n    let cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n    let cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n    let oldScopeSelector = styleInfo.scopeSelector;\n    // only generate new scope if cached style is not found\n    styleInfo.scopeSelector =\n      cachedScopeSelector || this._generateScopeSelector(is);\n    let style = _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].applyElementStyle(\n      host,\n      styleInfo.styleProperties,\n      styleInfo.scopeSelector,\n      cachedStyle\n    );\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow) {\n      _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].applyElementScopeSelector(\n        host,\n        styleInfo.scopeSelector,\n        oldScopeSelector\n      );\n    }\n    if (!cacheEntry) {\n      styleCache.store(\n        is,\n        styleInfo.styleProperties,\n        style,\n        styleInfo.scopeSelector\n      );\n    }\n    return style;\n  }\n  _updateProperties(host, styleInfo) {\n    let owner = this._styleOwnerForNode(host);\n    let ownerStyleInfo = _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(owner);\n    let ownerProperties = ownerStyleInfo.styleProperties;\n    // style owner has not updated properties yet\n    // go up the chain and force property update,\n    // except if the owner is the document\n    if (owner !== this._documentOwner && !ownerProperties) {\n      this._updateProperties(owner, ownerStyleInfo);\n      ownerProperties = ownerStyleInfo.styleProperties;\n    }\n    let props = Object.create(ownerProperties || null);\n    let hostAndRootProps = _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hostAndRootPropertiesForScope(\n      host,\n      styleInfo.styleRules,\n      styleInfo.cssBuild\n    );\n    let propertyData = _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].propertyDataFromStyles(\n      ownerStyleInfo.styleRules,\n      host\n    );\n    let propertiesMatchingHost = propertyData.properties;\n    Object.assign(\n      props,\n      hostAndRootProps.hostProps,\n      propertiesMatchingHost,\n      hostAndRootProps.rootProps\n    );\n    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n    _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].reify(props);\n    styleInfo.styleProperties = props;\n  }\n  _mixinOverrideStyles(props, overrides) {\n    for (let p in overrides) {\n      let v = overrides[p];\n      // skip override props if they are not truthy or 0\n      // in order to fall back to inherited values\n      if (v || v === 0) {\n        props[p] = v;\n      }\n    }\n  }\n  /**\n   * Update styles of the whole document\n   *\n   * @param {Object=} properties\n   */\n  styleDocument(properties) {\n    this.styleSubtree(this._documentOwner, properties);\n  }\n  /**\n   * Update styles of a subtree\n   *\n   * @param {!HTMLElement} host\n   * @param {Object=} properties\n   */\n  styleSubtree(host, properties) {\n    const wrappedHost = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.wrap(host);\n    const root = wrappedHost.shadowRoot;\n    const isRootOwner = this._isRootOwner(host);\n    if (root || isRootOwner) {\n      this.styleElement(host, properties);\n    }\n    const descendantRoot = isRootOwner ? wrappedHost : root;\n    if (descendantRoot) {\n      const descendantHosts = Array.from(\n        descendantRoot.querySelectorAll('*')\n      ).filter((x) => _style_util_js__WEBPACK_IMPORTED_MODULE_3__.wrap(x).shadowRoot);\n      for (let i = 0; i < descendantHosts.length; i++) {\n        this.styleSubtree(descendantHosts[i]);\n      }\n    }\n  }\n  /* Custom Style operations */\n  _revalidateCustomStyleApplyShim(customStyles) {\n    for (let i = 0; i < customStyles.length; i++) {\n      let c = customStyles[i];\n      let s = this._customStyleInterface['getStyleForCustomStyle'](c);\n      if (s) {\n        this._revalidateApplyShim(s);\n      }\n    }\n  }\n  _applyCustomStyles(customStyles) {\n    for (let i = 0; i < customStyles.length; i++) {\n      let c = customStyles[i];\n      let s = this._customStyleInterface['getStyleForCustomStyle'](c);\n      if (s) {\n        _style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].applyCustomStyle(\n          s,\n          this._documentOwnerStyleInfo.styleProperties\n        );\n      }\n    }\n  }\n  transformCustomStyleForDocument(style) {\n    const cssBuild = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getCssBuild(style);\n    if (cssBuild !== this._documentOwnerStyleInfo.cssBuild) {\n      this._documentOwnerStyleInfo.cssBuild = cssBuild;\n    }\n    if (_style_util_js__WEBPACK_IMPORTED_MODULE_3__.isOptimalCssBuild(cssBuild)) {\n      return;\n    }\n    let ast = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.rulesForStyle(style);\n    _style_util_js__WEBPACK_IMPORTED_MODULE_3__.forEachRule(ast, (rule) => {\n      if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow) {\n        _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizeRootSelector(rule);\n      } else {\n        _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].documentRule(rule);\n      }\n      if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables && cssBuild === '') {\n        this._ensure();\n        this._applyShim && this._applyShim['transformRule'](rule);\n      }\n    });\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      style.textContent = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.toCssText(ast);\n    } else {\n      this._documentOwnerStyleInfo.styleRules['rules'].push(ast);\n    }\n  }\n  _revalidateApplyShim(style) {\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables && this._applyShim) {\n      let ast = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.rulesForStyle(style);\n      this._ensure();\n      this._applyShim['transformRules'](ast);\n      style.textContent = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.toCssText(ast);\n    }\n  }\n  getComputedStyleValue(element, property) {\n    let value;\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      // element is either a style host, or an ancestor of a style host\n      let styleInfo =\n        _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(element) ||\n        _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(this._styleOwnerForNode(element));\n      value = styleInfo.styleProperties[property];\n    }\n    // fall back to the property value from the computed styling\n    value =\n      value || window.getComputedStyle(element).getPropertyValue(property);\n    // trim whitespace that can come after the `:` in css\n    // example: padding: 2px -> \" 2px\"\n    return value ? value.trim() : '';\n  }\n  // given an element and a classString, replaces\n  // the element's class with the provided classString and adds\n  // any necessary ShadyCSS static and property based scoping selectors\n  setElementClass(element, classString) {\n    let root = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.wrap(element).getRootNode();\n    let classes;\n    if (classString) {\n      let definitelyString =\n        typeof classString === 'string' ? classString : String(classString);\n      classes = definitelyString.split(/\\s/);\n    } else {\n      classes = [];\n    }\n    let scopeName = root.host && root.host.localName;\n    // If no scope, try to discover scope name from existing class.\n    // This can occur if, for example, a template stamped element that\n    // has been scoped is manipulated when not in a root.\n    if (!scopeName) {\n      var classAttr = element.getAttribute('class');\n      if (classAttr) {\n        let k$ = classAttr.split(/\\s/);\n        for (let i = 0; i < k$.length; i++) {\n          if (k$[i] === _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].SCOPE_NAME) {\n            scopeName = k$[i + 1];\n            break;\n          }\n        }\n      }\n    }\n    if (scopeName) {\n      classes.push(_style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].SCOPE_NAME, scopeName);\n    }\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables) {\n      let styleInfo = _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(element);\n      if (styleInfo && styleInfo.scopeSelector) {\n        classes.push(_style_properties_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].XSCOPE_NAME, styleInfo.scopeSelector);\n      }\n    }\n    _style_util_js__WEBPACK_IMPORTED_MODULE_3__.setElementClassRaw(element, classes.join(' '));\n  }\n  _styleInfoForNode(node) {\n    return _style_info_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(node);\n  }\n  /**\n   * @param {!Element} node\n   * @param {string} scope\n   */\n  scopeNode(node, scope) {\n    _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].element(node, scope);\n  }\n  /**\n   * @param {!Element} node\n   * @param {string} scope\n   */\n  unscopeNode(node, scope) {\n    _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].element(node, scope, true);\n  }\n  /**\n   * @param {!Node} node\n   * @return {string}\n   */\n  scopeForNode(node) {\n    return (0,_document_watcher_js__WEBPACK_IMPORTED_MODULE_8__.getOwnerScope)(node);\n  }\n  /**\n   * @param {!Element} node\n   * @return {string}\n   */\n  currentScopeForNode(node) {\n    return (0,_document_watcher_js__WEBPACK_IMPORTED_MODULE_8__.getCurrentScope)(node);\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nScopingShim.prototype['flush'] = ScopingShim.prototype.flush;\nScopingShim.prototype['prepareTemplate'] =\n  ScopingShim.prototype.prepareTemplate;\nScopingShim.prototype['styleElement'] = ScopingShim.prototype.styleElement;\nScopingShim.prototype['styleDocument'] = ScopingShim.prototype.styleDocument;\nScopingShim.prototype['styleSubtree'] = ScopingShim.prototype.styleSubtree;\nScopingShim.prototype['getComputedStyleValue'] =\n  ScopingShim.prototype.getComputedStyleValue;\nScopingShim.prototype['setElementClass'] =\n  ScopingShim.prototype.setElementClass;\nScopingShim.prototype['_styleInfoForNode'] =\n  ScopingShim.prototype._styleInfoForNode;\nScopingShim.prototype['transformCustomStyleForDocument'] =\n  ScopingShim.prototype.transformCustomStyleForDocument;\nScopingShim.prototype['getStyleAst'] = ScopingShim.prototype.getStyleAst;\nScopingShim.prototype['styleAstToString'] =\n  ScopingShim.prototype.styleAstToString;\nScopingShim.prototype['flushCustomStyles'] =\n  ScopingShim.prototype.flushCustomStyles;\nScopingShim.prototype['scopeNode'] = ScopingShim.prototype.scopeNode;\nScopingShim.prototype['unscopeNode'] = ScopingShim.prototype.unscopeNode;\nScopingShim.prototype['scopeForNode'] = ScopingShim.prototype.scopeForNode;\nScopingShim.prototype['currentScopeForNode'] =\n  ScopingShim.prototype.currentScopeForNode;\nScopingShim.prototype['prepareAdoptedCssText'] =\n  ScopingShim.prototype.prepareAdoptedCssText;\n/* eslint-enable no-self-assign */\nObject.defineProperties(ScopingShim.prototype, {\n  'nativeShadow': {\n    get() {\n      return _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow;\n    },\n  },\n  'nativeCss': {\n    get() {\n      return _style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeCssVariables;\n    },\n  },\n});\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/scoping-shim.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-cache.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-cache.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StyleCache)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nclass StyleCache {\n  constructor(typeMax = 100) {\n    // map element name -> [{properties, styleElement, scopeSelector}]\n    this.cache = {};\n    /** @type {number} */\n    this.typeMax = typeMax;\n  }\n\n  _validate(cacheEntry, properties, ownPropertyNames) {\n    for (let idx = 0; idx < ownPropertyNames.length; idx++) {\n      let pn = ownPropertyNames[idx];\n      if (cacheEntry.properties[pn] !== properties[pn]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  store(tagname, properties, styleElement, scopeSelector) {\n    let list = this.cache[tagname] || [];\n    list.push({properties, styleElement, scopeSelector});\n    if (list.length > this.typeMax) {\n      list.shift();\n    }\n    this.cache[tagname] = list;\n  }\n\n  fetch(tagname, properties, ownPropertyNames) {\n    let list = this.cache[tagname];\n    if (!list) {\n      return;\n    }\n    // reverse list for most-recent lookups\n    for (let idx = list.length - 1; idx >= 0; idx--) {\n      let entry = list[idx];\n      if (this._validate(entry, properties, ownPropertyNames)) {\n        return entry;\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-cache.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-info.js":
/*!****************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-info.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StyleInfo)\n/* harmony export */ });\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/** @const {string} */\nconst infoKey = '__styleInfo';\n\nclass StyleInfo {\n  /**\n   * @param {Element} node\n   * @return {StyleInfo}\n   */\n  static get(node) {\n    if (node) {\n      return node[infoKey];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * @param {!Element} node\n   * @param {StyleInfo} styleInfo\n   * @return {StyleInfo}\n   */\n  static set(node, styleInfo) {\n    node[infoKey] = styleInfo;\n    return styleInfo;\n  }\n  /**\n   * @param {StyleNode} ast\n   * @param {Node=} placeholder\n   * @param {Array<string>=} ownStylePropertyNames\n   * @param {string=} elementName\n   * @param {string=} typeExtension\n   * @param {string=} cssBuild\n   */\n  constructor(\n    ast,\n    placeholder,\n    ownStylePropertyNames,\n    elementName,\n    typeExtension,\n    cssBuild\n  ) {\n    /** @type {StyleNode} */\n    this.styleRules = ast || null;\n    /** @type {Node} */\n    this.placeholder = placeholder || null;\n    /** @type {!Array<string>} */\n    this.ownStylePropertyNames = ownStylePropertyNames || [];\n    /** @type {Object} */\n    this.overrideStyleProperties = null;\n    /** @type {string} */\n    this.elementName = elementName || '';\n    /** @type {string} */\n    this.cssBuild = cssBuild || '';\n    /** @type {string} */\n    this.typeExtension = typeExtension || '';\n    /** @type {Object<string, string>} */\n    this.styleProperties = null;\n    /** @type {?string} */\n    this.scopeSelector = null;\n    /** @type {HTMLStyleElement} */\n    this.customStyle = null;\n  }\n  _getStyleRules() {\n    return this.styleRules;\n  }\n}\n\n/* eslint-disable-next-line no-self-assign */\nStyleInfo.prototype['_getStyleRules'] = StyleInfo.prototype._getStyleRules;\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-info.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-placeholder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-placeholder.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getStylePlaceholder\": () => (/* binding */ getStylePlaceholder),\n/* harmony export */   \"ensureStylePlaceholder\": () => (/* binding */ ensureStylePlaceholder)\n/* harmony export */ });\n/* harmony import */ var _style_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style-util.js */ \"./node_modules/@webcomponents/shadycss/src/style-util.js\");\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/** @type {!Object<string, !Node>} */\nconst placeholderMap = {};\n\n/**\n * @param {string} elementName\n * @return {Node}\n */\nfunction getStylePlaceholder(elementName) {\n  return placeholderMap[elementName] || null;\n}\n\n/**\n * @param {string} elementName\n */\nfunction ensureStylePlaceholder(elementName) {\n  if (!placeholderMap[elementName]) {\n    placeholderMap[elementName] = (0,_style_util_js__WEBPACK_IMPORTED_MODULE_0__.applyStylePlaceHolder)(elementName);\n  }\n}\n\n/**\n * @const {CustomElementRegistry}\n */\nconst ce = window['customElements'];\nif (ce && !_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow && !_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.disableRuntime) {\n  /**\n   * @const {function(this:CustomElementRegistry, string,function(new:HTMLElement),{extends: string}=)}\n   */\n  const origDefine = ce['define'];\n  /**\n   * @param {string} name\n   * @param {function(new:HTMLElement)} clazz\n   * @param {{extends: string}=} options\n   */\n  const wrappedDefine = (name, clazz, options) => {\n    ensureStylePlaceholder(name);\n    origDefine.call(\n      /** @type {!CustomElementRegistry} */ (ce),\n      name,\n      clazz,\n      options\n    );\n  };\n  ce['define'] = wrappedDefine;\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-placeholder.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-properties.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/* harmony import */ var _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style-transformer.js */ \"./node_modules/@webcomponents/shadycss/src/style-transformer.js\");\n/* harmony import */ var _style_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style-util.js */ \"./node_modules/@webcomponents/shadycss/src/style-util.js\");\n/* harmony import */ var _common_regex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common-regex.js */ \"./node_modules/@webcomponents/shadycss/src/common-regex.js\");\n/* harmony import */ var _style_info_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style-info.js */ \"./node_modules/@webcomponents/shadycss/src/style-info.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n // eslint-disable-line @typescript-eslint/no-unused-vars\n\n\n\n\n\n\n// TODO: dedupe with shady\n/**\n * @param {string} selector\n * @return {boolean}\n * @this {Element}\n */\nconst matchesSelector = function (selector) {\n  const method =\n    this.matches ||\n    this.matchesSelector ||\n    this.mozMatchesSelector ||\n    this.msMatchesSelector ||\n    this.oMatchesSelector ||\n    this.webkitMatchesSelector;\n  return method && method.call(this, selector);\n};\n\nconst rootSelector = /:host\\s*>\\s*/;\n\nfunction checkRoot(hostScope, selector) {\n  return (\n    Boolean(selector.match(rootSelector)) ||\n    (hostScope === 'html' && selector.indexOf('html') > -1)\n  );\n}\n\nconst IS_IE = navigator.userAgent.match('Trident');\n\nconst XSCOPE_NAME = 'x-scope';\n\nclass StyleProperties {\n  /** @return {string} */\n  get XSCOPE_NAME() {\n    return XSCOPE_NAME;\n  }\n  /**\n   * decorates styles with rule info and returns an array of used style property names\n   *\n   * @param {StyleNode} rules\n   * @return {!Array<string>}\n   */\n  decorateStyles(rules) {\n    let self = this,\n      props = {},\n      keyframes = [],\n      ruleIndex = 0;\n    _style_util_js__WEBPACK_IMPORTED_MODULE_3__.forEachRule(\n      rules,\n      function (rule) {\n        self.decorateRule(rule);\n        // mark in-order position of ast rule in styles block, used for cache key\n        rule.index = ruleIndex++;\n        self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n      },\n      function onKeyframesRule(rule) {\n        keyframes.push(rule);\n      }\n    );\n    // Cache all found keyframes rules for later reference:\n    rules._keyframes = keyframes;\n    // return this list of property names *consumes* in these styles.\n    let names = [];\n    for (let i in props) {\n      names.push(i);\n    }\n    return names;\n  }\n\n  // decorate a single rule with property info\n  decorateRule(rule) {\n    if (rule.propertyInfo) {\n      return rule.propertyInfo;\n    }\n    let info = {},\n      properties = {};\n    let hasProperties = this.collectProperties(rule, properties);\n    if (hasProperties) {\n      info.properties = properties;\n      // TODO(sorvell): workaround parser seeing mixins as additional rules\n      rule['rules'] = null;\n    }\n    info.cssText = this.collectCssText(rule);\n    rule.propertyInfo = info;\n    return info;\n  }\n\n  // collects the custom properties from a rule's cssText\n  collectProperties(rule, properties) {\n    let info = rule.propertyInfo;\n    if (info) {\n      if (info.properties) {\n        Object.assign(properties, info.properties);\n        return true;\n      }\n    } else {\n      let m,\n        rx = _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.VAR_ASSIGN;\n      let cssText = rule['parsedCssText'];\n      let value;\n      let any;\n      while ((m = rx.exec(cssText))) {\n        // note: group 2 is var, 3 is mixin\n        value = (m[2] || m[3]).trim();\n        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n        if (value !== 'inherit' || value !== 'unset') {\n          properties[m[1].trim()] = value;\n        }\n        any = true;\n      }\n      return any;\n    }\n  }\n\n  // returns cssText of properties that consume variables/mixins\n  collectCssText(rule) {\n    return this.collectConsumingCssText(rule['parsedCssText']);\n  }\n\n  // NOTE: we support consumption inside mixin assignment\n  // but not production, so strip out {...}\n  collectConsumingCssText(cssText) {\n    return cssText.replace(_common_regex_js__WEBPACK_IMPORTED_MODULE_4__.BRACKETED, '').replace(_common_regex_js__WEBPACK_IMPORTED_MODULE_4__.VAR_ASSIGN, '');\n  }\n\n  collectPropertiesInCssText(cssText, props) {\n    let m;\n    while ((m = _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.VAR_CONSUMED.exec(cssText))) {\n      let name = m[1];\n      // This regex catches all variable names, and following non-whitespace char\n      // If next char is not ':', then variable is a consumer\n      if (m[2] !== ':') {\n        props[name] = true;\n      }\n    }\n  }\n\n  // turns custom properties into realized values.\n  reify(props) {\n    // big perf optimization here: reify only *own* properties\n    // since this object has __proto__ of the element's scope properties\n    let names = Object.getOwnPropertyNames(props);\n    for (let i = 0, n; i < names.length; i++) {\n      n = names[i];\n      props[n] = this.valueForProperty(props[n], props);\n    }\n  }\n\n  // given a property value, returns the reified value\n  // a property value may be:\n  // (1) a literal value like: red or 5px;\n  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n  // var(--a, var(--b));\n  // (3) a literal mixin value like { properties }. Each of these properties\n  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n  valueForProperty(property, props) {\n    // case (1) default\n    // case (3) defines a mixin and we have to reify the internals\n    if (property) {\n      if (property.indexOf(';') >= 0) {\n        property = this.valueForProperties(property, props);\n      } else {\n        // case (2) variable\n        let self = this;\n        let fn = function (prefix, value, fallback, suffix) {\n          if (!value) {\n            return prefix + suffix;\n          }\n          let propertyValue = self.valueForProperty(props[value], props);\n          // if value is \"initial\", then the variable should be treated as unset\n          if (!propertyValue || propertyValue === 'initial') {\n            // fallback may be --a or var(--a) or literal\n            propertyValue =\n              self.valueForProperty(props[fallback] || fallback, props) ||\n              fallback;\n          } else if (propertyValue === 'apply-shim-inherit') {\n            // CSS build will replace `inherit` with `apply-shim-inherit`\n            // for use with native css variables.\n            // Since we have full control, we can use `inherit` directly.\n            propertyValue = 'inherit';\n          }\n          return prefix + (propertyValue || '') + suffix;\n        };\n        property = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.processVariableAndFallback(property, fn);\n      }\n    }\n    return (property && property.trim()) || '';\n  }\n\n  // note: we do not yet support mixin within mixin\n  valueForProperties(property, props) {\n    let parts = property.split(';');\n    for (let i = 0, p, m; i < parts.length; i++) {\n      if ((p = parts[i])) {\n        _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.MIXIN_MATCH.lastIndex = 0;\n        m = _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.MIXIN_MATCH.exec(p);\n        if (m) {\n          p = this.valueForProperty(props[m[1]], props);\n        } else {\n          let colon = p.indexOf(':');\n          if (colon !== -1) {\n            let pp = p.substring(colon);\n            pp = pp.trim();\n            pp = this.valueForProperty(pp, props) || pp;\n            p = p.substring(0, colon) + pp;\n          }\n        }\n        parts[i] =\n          p && p.lastIndexOf(';') === p.length - 1\n            ? p.slice(0, -1) // strip trailing ;\n            : p || '';\n      }\n    }\n    return parts.join(';');\n  }\n\n  applyProperties(rule, props) {\n    let output = '';\n    // dynamically added sheets may not be decorated so ensure they are.\n    if (!rule.propertyInfo) {\n      this.decorateRule(rule);\n    }\n    if (rule.propertyInfo.cssText) {\n      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n    }\n    rule['cssText'] = output;\n  }\n\n  // Apply keyframe transformations to the cssText of a given rule. The\n  // keyframeTransforms object is a map of keyframe names to transformer\n  // functions which take in cssText and spit out transformed cssText.\n  applyKeyframeTransforms(rule, keyframeTransforms) {\n    let input = rule['cssText'];\n    let output = rule['cssText'];\n    if (rule.hasAnimations == null) {\n      // Cache whether or not the rule has any animations to begin with:\n      rule.hasAnimations = _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.ANIMATION_MATCH.test(input);\n    }\n    // If there are no animations referenced, we can skip transforms:\n    if (rule.hasAnimations) {\n      let transform;\n      // If we haven't transformed this rule before, we iterate over all\n      // transforms:\n      if (rule.keyframeNamesToTransform == null) {\n        rule.keyframeNamesToTransform = [];\n        for (let keyframe in keyframeTransforms) {\n          transform = keyframeTransforms[keyframe];\n          output = transform(input);\n          // If the transform actually changed the CSS text, we cache the\n          // transform name for future use:\n          if (input !== output) {\n            input = output;\n            rule.keyframeNamesToTransform.push(keyframe);\n          }\n        }\n      } else {\n        // If we already have a list of keyframe names that apply to this\n        // rule, we apply only those keyframe name transforms:\n        for (let i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n          input = transform(input);\n        }\n        output = input;\n      }\n    }\n    rule['cssText'] = output;\n  }\n\n  // Test if the rules in these styles matches the given `element` and if so,\n  // collect any custom properties into `props`.\n  /**\n   * @param {StyleNode} rules\n   * @param {Element} element\n   */\n  propertyDataFromStyles(rules, element) {\n    let props = {};\n    // generates a unique key for these matches\n    let o = [];\n    // note: active rules excludes non-matching @media rules\n    _style_util_js__WEBPACK_IMPORTED_MODULE_3__.forEachRule(\n      rules,\n      (rule) => {\n        // TODO(sorvell): we could trim the set of rules at declaration\n        // time to only include ones that have properties\n        if (!rule.propertyInfo) {\n          this.decorateRule(rule);\n        }\n        // match element against transformedSelector: selector may contain\n        // unwanted uniquification and parsedSelector does not directly match\n        // for :host selectors.\n        let selectorToMatch =\n          rule.transformedSelector || rule['parsedSelector'];\n        if (element && rule.propertyInfo.properties && selectorToMatch) {\n          if (matchesSelector.call(element, selectorToMatch)) {\n            this.collectProperties(rule, props);\n            // produce numeric key for these matches for lookup\n            addToBitMask(rule.index, o);\n          }\n        }\n      },\n      null,\n      true\n    );\n    return {properties: props, key: o};\n  }\n\n  /**\n   * @param {Element} scope\n   * @param {StyleNode} rule\n   * @param {string} cssBuild\n   * @param {function(Object)} callback\n   */\n  whenHostOrRootRule(scope, rule, cssBuild, callback) {\n    if (!(/** @type {?} */ (rule.propertyInfo))) {\n      this.decorateRule(rule);\n    }\n    if (!(/** @type {?} */ (rule.propertyInfo).properties)) {\n      return;\n    }\n    let {is, typeExtension} = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getIsExtends(scope);\n    let hostScope = is\n      ? _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._calcHostScope(is, typeExtension)\n      : 'html';\n    let parsedSelector = rule['parsedSelector'];\n    let isRoot = checkRoot(hostScope, parsedSelector);\n    let isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n    // build info is either in scope (when scope is an element) or in the style\n    // when scope is the default scope; note: this allows default scope to have\n    // mixed mode built and unbuilt styles.\n    if (cssBuild === 'shady') {\n      // :root -> x-foo > *.x-foo for elements and html for custom-style\n      isRoot =\n        parsedSelector === hostScope + ' > *.' + hostScope ||\n        parsedSelector.indexOf('html') !== -1;\n      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n    }\n    if (!isRoot && !isHost) {\n      return;\n    }\n    let selectorToMatch = hostScope;\n    if (isHost) {\n      // need to transform :host because `:host` does not work with `matches`\n      if (!(/** @type {?} */ (rule.transformedSelector))) {\n        // transform :host into a matchable selector\n        rule.transformedSelector = _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._transformRuleCss(\n          rule,\n          _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._transformComplexSelector,\n          _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._calcElementScope(is),\n          hostScope\n        );\n      }\n      selectorToMatch =\n        /** @type {?} */ (rule.transformedSelector) || hostScope;\n    }\n    if (isRoot && hostScope === 'html') {\n      selectorToMatch =\n        /** @type {?} */ (rule.transformedSelector) ||\n        /** @type {?} */ (rule.parsedSelector);\n    }\n    callback({\n      selector: selectorToMatch,\n      isHost: isHost,\n      isRoot: isRoot,\n    });\n  }\n  /**\n   * @param {Element} scope\n   * @param {StyleNode} rules\n   * @param {string} cssBuild\n   * @return {!Object}\n   */\n  hostAndRootPropertiesForScope(scope, rules, cssBuild) {\n    let hostProps = {},\n      rootProps = {};\n    // note: active rules excludes non-matching @media rules\n    _style_util_js__WEBPACK_IMPORTED_MODULE_3__.forEachRule(\n      rules,\n      (rule) => {\n        // if scope is StyleDefaults, use _element for matchesSelector\n        this.whenHostOrRootRule(scope, rule, cssBuild, (info) => {\n          let element = scope._element || scope;\n          if (matchesSelector.call(element, info.selector)) {\n            if (info.isHost) {\n              this.collectProperties(rule, hostProps);\n            } else {\n              this.collectProperties(rule, rootProps);\n            }\n          }\n        });\n      },\n      null,\n      true\n    );\n    return {rootProps: rootProps, hostProps: hostProps};\n  }\n\n  /**\n   * @param {Element} element\n   * @param {Object} properties\n   * @param {string} scopeSelector\n   */\n  transformStyles(element, properties, scopeSelector) {\n    let self = this;\n    let {is, typeExtension} = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.getIsExtends(element);\n    let hostSelector = _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]._calcHostScope(is, typeExtension);\n    let rxHostSelector = element.extends\n      ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]'\n      : hostSelector;\n    let hostRx = new RegExp(_common_regex_js__WEBPACK_IMPORTED_MODULE_4__.HOST_PREFIX + rxHostSelector + _common_regex_js__WEBPACK_IMPORTED_MODULE_4__.HOST_SUFFIX);\n    let {styleRules: rules, cssBuild} = _style_info_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(element);\n    let keyframeTransforms = this._elementKeyframeTransforms(\n      element,\n      rules,\n      scopeSelector\n    );\n    return _style_transformer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].elementStyles(\n      element,\n      rules,\n      function (rule) {\n        self.applyProperties(rule, properties);\n        if (\n          !_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow &&\n          !_style_util_js__WEBPACK_IMPORTED_MODULE_3__.isKeyframesSelector(rule) &&\n          rule['cssText']\n        ) {\n          // NOTE: keyframe transforms only scope munge animation names, so it\n          // is not necessary to apply them in ShadowDOM.\n          self.applyKeyframeTransforms(rule, keyframeTransforms);\n          self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n        }\n      },\n      cssBuild\n    );\n  }\n\n  /**\n   * @param {Element} element\n   * @param {StyleNode} rules\n   * @param {string} scopeSelector\n   * @return {!Object}\n   */\n  _elementKeyframeTransforms(element, rules, scopeSelector) {\n    let keyframesRules = rules._keyframes;\n    let keyframeTransforms = {};\n    if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow && keyframesRules) {\n      // For non-ShadowDOM, we transform all known keyframes rules in\n      // advance for the current scope. This allows us to catch keyframes\n      // rules that appear anywhere in the stylesheet:\n      for (\n        let i = 0, keyframesRule = keyframesRules[i];\n        i < keyframesRules.length;\n        keyframesRule = keyframesRules[++i]\n      ) {\n        this._scopeKeyframes(keyframesRule, scopeSelector);\n        keyframeTransforms[\n          keyframesRule['keyframesName']\n        ] = this._keyframesRuleTransformer(keyframesRule);\n      }\n    }\n    return keyframeTransforms;\n  }\n\n  // Generate a factory for transforming a chunk of CSS text to handle a\n  // particular scoped keyframes rule.\n  /**\n   * @param {StyleNode} keyframesRule\n   * @return {function(string):string}\n   */\n  _keyframesRuleTransformer(keyframesRule) {\n    return function (cssText) {\n      return cssText.replace(\n        /** @type {?} */ (keyframesRule.keyframesNameRx),\n        /** @type {?} */ (keyframesRule.transformedKeyframesName)\n      );\n    };\n  }\n\n  /**\n   * Transforms `@keyframes` names to be unique for the current host.\n   * Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n   *\n   * @param {StyleNode} rule\n   * @param {string} scopeId\n   */\n  _scopeKeyframes(rule, scopeId) {\n    // Animation names are of the form [\\w-], so ensure that the name regex does not partially apply\n    // to similarly named keyframe names by checking for a word boundary at the beginning and\n    // a non-word boundary or `-` at the end.\n    rule.keyframesNameRx = new RegExp(\n      `\\\\b${rule['keyframesName']}(?!\\\\B|-)`,\n      'g'\n    );\n    rule.transformedKeyframesName = rule['keyframesName'] + '-' + scopeId;\n    rule.transformedSelector =\n      /** @type {?} */ (rule.transformedSelector) || rule['selector'];\n    rule['selector'] = /** @type {?} */ (rule.transformedSelector).replace(\n      rule['keyframesName'],\n      rule.transformedKeyframesName\n    );\n  }\n\n  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n  // host selector: x-foo.wide -> .x-foo-42.wide\n  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n  // (x-foo) to scope :host rules; this helps make property host rules\n  // have low specificity. They are overrideable by class selectors but,\n  // unfortunately, not by type selectors (e.g. overriding via\n  // `.special` is ok, but not by `x-foo`).\n  /**\n   * @param {StyleNode} rule\n   * @param {RegExp} hostRx\n   * @param {string} hostSelector\n   * @param {string} scopeId\n   */\n  _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n    rule.transformedSelector =\n      /** @type {?} */ (rule.transformedSelector) || rule['selector'];\n    let selector = rule.transformedSelector;\n    let scope = '.' + scopeId;\n    let parts = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.splitSelectorList(selector);\n    for (let i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n      parts[i] = p.match(hostRx)\n        ? p.replace(hostSelector, scope)\n        : scope + ' ' + p;\n    }\n    rule['selector'] = parts.join(',');\n  }\n\n  /**\n   * @param {Element} element\n   * @param {string} selector\n   * @param {string} old\n   */\n  applyElementScopeSelector(element, selector, old) {\n    let c = element.getAttribute('class') || '';\n    let v = c;\n    if (old) {\n      v = c.replace(\n        new RegExp('\\\\s*' + XSCOPE_NAME + '\\\\s*' + old + '\\\\s*', 'g'),\n        ' '\n      );\n    }\n    v += (v ? ' ' : '') + XSCOPE_NAME + ' ' + selector;\n    if (c !== v) {\n      _style_util_js__WEBPACK_IMPORTED_MODULE_3__.setElementClassRaw(element, v);\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object} properties\n   * @param {string} selector\n   * @param {HTMLStyleElement} style\n   * @return {HTMLStyleElement}\n   */\n  applyElementStyle(element, properties, selector, style) {\n    // calculate cssText to apply\n    let cssText = style\n      ? style.textContent || ''\n      : this.transformStyles(element, properties, selector);\n    // if shady and we have a cached style that is not style, decrement\n    let styleInfo = _style_info_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(element);\n    let s = styleInfo.customStyle;\n    if (s && !_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow && s !== style) {\n      s['_useCount']--;\n      if (s['_useCount'] <= 0 && s.parentNode) {\n        s.parentNode.removeChild(s);\n      }\n    }\n    // apply styling always under native or if we generated style\n    // or the cached style is not in document(!)\n    if (_style_settings_js__WEBPACK_IMPORTED_MODULE_1__.nativeShadow) {\n      // update existing style only under native\n      if (styleInfo.customStyle) {\n        styleInfo.customStyle.textContent = cssText;\n        style = styleInfo.customStyle;\n        // otherwise, if we have css to apply, do so\n      } else if (cssText) {\n        // apply css after the scope style of the element to help with\n        // style precedence rules.\n        style = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.applyCss(\n          cssText,\n          selector,\n          element.shadowRoot,\n          styleInfo.placeholder\n        );\n      }\n    } else {\n      // shady and no cache hit\n      if (!style) {\n        // apply css after the scope style of the element to help with\n        // style precedence rules.\n        if (cssText) {\n          style = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.applyCss(\n            cssText,\n            selector,\n            null,\n            styleInfo.placeholder\n          );\n        }\n        // shady and cache hit but not in document\n      } else if (!style.parentNode) {\n        if (IS_IE && cssText.indexOf('@media') > -1) {\n          // @media rules may be stale in IE 10 and 11\n          // refresh the text content of the style to revalidate them.\n          style.textContent = cssText;\n        }\n        _style_util_js__WEBPACK_IMPORTED_MODULE_3__.applyStyle(style, null, styleInfo.placeholder);\n      }\n    }\n    // ensure this style is our custom style and increment its use count.\n    if (style) {\n      style['_useCount'] = style['_useCount'] || 0;\n      // increment use count if we changed styles\n      if (styleInfo.customStyle != style) {\n        style['_useCount']++;\n      }\n      styleInfo.customStyle = style;\n    }\n    return style;\n  }\n\n  /**\n   * @param {Element} style\n   * @param {Object} properties\n   */\n  applyCustomStyle(style, properties) {\n    let rules = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.rulesForStyle(\n      /** @type {HTMLStyleElement} */ (style)\n    );\n    let self = this;\n    style.textContent = _style_util_js__WEBPACK_IMPORTED_MODULE_3__.toCssText(rules, function (\n      /** StyleNode */ rule\n    ) {\n      let css = (rule['cssText'] = rule['parsedCssText']);\n      if (\n        /** @type {?} */ (rule.propertyInfo) &&\n        /** @type {?} */ (rule.propertyInfo).cssText\n      ) {\n        // remove property assignments\n        // so next function isn't confused\n        // NOTE: we have 3 categories of css:\n        // (1) normal properties,\n        // (2) custom property assignments (--foo: red;),\n        // (3) custom property usage: border: var(--foo); @apply(--foo);\n        // In elements, 1 and 3 are separated for efficiency; here they\n        // are not and this makes this case unique.\n        css = (0,_css_parse_js__WEBPACK_IMPORTED_MODULE_0__.removeCustomPropAssignment)(/** @type {string} */ (css));\n        // replace with reified properties, scenario is same as mixin\n        rule['cssText'] = self.valueForProperties(css, properties);\n      }\n    });\n  }\n}\n\n/**\n * @param {number} n\n * @param {Array<number>} bits\n */\nfunction addToBitMask(n, bits) {\n  let o = parseInt(n / 32, 10);\n  let v = 1 << n % 32;\n  bits[o] = (bits[o] || 0) | v;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StyleProperties());\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-properties.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-settings.js":
/*!********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-settings.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"nativeShadow\": () => (/* binding */ nativeShadow),\n/* harmony export */   \"cssBuild\": () => (/* binding */ cssBuild),\n/* harmony export */   \"disableRuntime\": () => (/* binding */ disableRuntime),\n/* harmony export */   \"nativeCssVariables\": () => (/* binding */ nativeCssVariables)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nconst nativeShadow = !(\n  window['ShadyDOM'] && window['ShadyDOM']['inUse']\n);\nlet nativeCssVariables_;\n\n/**\n * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings\n */\nfunction calcCssVariables(settings) {\n  if (settings && settings['shimcssproperties']) {\n    nativeCssVariables_ = false;\n  } else {\n    // chrome 49 has semi-working css vars, check if box-shadow works\n    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n    // However, shim css custom properties are only supported with ShadyDOM enabled,\n    // so fall back on native if we do not detect ShadyDOM\n    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/\n    nativeCssVariables_ =\n      nativeShadow ||\n      Boolean(\n        !navigator.userAgent.match(/AppleWebKit\\/601|Edge\\/15/) &&\n          window.CSS &&\n          CSS.supports &&\n          CSS.supports('box-shadow', '0 0 0 var(--foo)')\n      );\n  }\n}\n\n/** @type {string | undefined} */\nlet cssBuild;\nif (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {\n  cssBuild = window.ShadyCSS.cssBuild;\n}\n\n/** @type {boolean} */\nconst disableRuntime = Boolean(\n  window.ShadyCSS && window.ShadyCSS.disableRuntime\n);\n\nif (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {\n  nativeCssVariables_ = window.ShadyCSS.nativeCss;\n} else if (window.ShadyCSS) {\n  calcCssVariables(window.ShadyCSS);\n  // reset window variable to let ShadyCSS API take its place\n  window.ShadyCSS = undefined;\n} else {\n  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);\n}\n\n// Hack for type error under new type inference which doesn't like that\n// nativeCssVariables is updated in a function and assigns the type\n// `function(): ?` instead of `boolean`.\nconst nativeCssVariables = /** @type {boolean} */ (nativeCssVariables_);\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-settings.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-transformer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-transformer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/* harmony import */ var _style_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style-util.js */ \"./node_modules/@webcomponents/shadycss/src/style-util.js\");\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n // eslint-disable-line @typescript-eslint/no-unused-vars\n\n\n\n/* Transforms ShadowDOM styling into ShadyDOM styling\n\n* scoping:\n\n  * elements in scope get scoping selector class=\"x-foo-scope\"\n  * selectors re-written as follows:\n\n    div button -> div.x-foo-scope button.x-foo-scope\n\n* :host -> scopeName\n\n* :host(...) -> scopeName...\n\n* ::slotted(...) -> scopeName > ...\n\n* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\n* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\n*/\nconst SCOPE_NAME = 'style-scope';\n\nclass StyleTransformer {\n  /** @return {string} */\n  get SCOPE_NAME() {\n    return SCOPE_NAME;\n  }\n  /**\n   * Given a node and scope name, add a scoping class to each node\n   * in the tree. This facilitates transforming css into scoped rules.\n   * @param {!Node} node\n   * @param {string} scope\n   * @param {boolean=} shouldRemoveScope\n   * @deprecated\n   */\n  dom(node, scope, shouldRemoveScope) {\n    const fn = (node) => {\n      this.element(node, scope || '', shouldRemoveScope);\n    };\n    this._transformDom(node, fn);\n  }\n\n  /**\n   * Given a node and scope name, add a scoping class to each node in the tree.\n   * @param {!Node} node\n   * @param {string} scope\n   */\n  domAddScope(node, scope) {\n    const fn = (node) => {\n      this.element(node, scope || '');\n    };\n    this._transformDom(node, fn);\n  }\n\n  /**\n   * @param {!Node} startNode\n   * @param {function(!Node)} transformer\n   */\n  _transformDom(startNode, transformer) {\n    if (startNode.nodeType === Node.ELEMENT_NODE) {\n      transformer(startNode);\n    }\n    let c$;\n    if (startNode.localName === 'template') {\n      const template = /** @type {!HTMLTemplateElement} */ (startNode);\n      // In case the template is in svg context, fall back to the node\n      // since it won't be an HTMLTemplateElement with a .content property\n      c$ = (template.content || template._content || template).childNodes;\n    } else {\n      c$ =\n        /** @type {!ParentNode} */ (startNode).children || startNode.childNodes;\n    }\n    if (c$) {\n      for (let i = 0; i < c$.length; i++) {\n        this._transformDom(c$[i], transformer);\n      }\n    }\n  }\n\n  /**\n   * @param {?} element\n   * @param {?} scope\n   * @param {?=} shouldRemoveScope\n   */\n  element(element, scope, shouldRemoveScope) {\n    // note: if using classes, we add both the general 'style-scope' class\n    // as well as the specific scope. This enables easy filtering of all\n    // `style-scope` elements\n    if (scope) {\n      // note: svg on IE does not have classList so fallback to class\n      if (element.classList) {\n        if (shouldRemoveScope) {\n          element.classList.remove(SCOPE_NAME);\n          element.classList.remove(scope);\n        } else {\n          element.classList.add(SCOPE_NAME);\n          element.classList.add(scope);\n        }\n      } else if (element.getAttribute) {\n        let c = element.getAttribute(CLASS);\n        if (shouldRemoveScope) {\n          if (c) {\n            let newValue = c.replace(SCOPE_NAME, '').replace(scope, '');\n            _style_util_js__WEBPACK_IMPORTED_MODULE_1__.setElementClassRaw(element, newValue);\n          }\n        } else {\n          let newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;\n          _style_util_js__WEBPACK_IMPORTED_MODULE_1__.setElementClassRaw(element, newValue);\n        }\n      }\n    }\n  }\n\n  /**\n   * Given a node, replace the scoping class to each subnode in the tree.\n   * @param {!Node} node\n   * @param {string} oldScope\n   * @param {string} newScope\n   */\n  domReplaceScope(node, oldScope, newScope) {\n    const fn = (node) => {\n      this.element(node, oldScope, true);\n      this.element(node, newScope);\n    };\n    this._transformDom(node, fn);\n  }\n  /**\n   * Given a node, remove the scoping class to each subnode in the tree.\n   * @param {!Node} node\n   * @param {string} oldScope\n   */\n  domRemoveScope(node, oldScope) {\n    const fn = (node) => {\n      this.element(node, oldScope || '', true);\n    };\n    this._transformDom(node, fn);\n  }\n\n  /**\n   * @param {?} element\n   * @param {?} styleRules\n   * @param {?=} callback\n   * @param {string=} cssBuild\n   * @param {string=} cssText\n   * @return {string}\n   */\n  elementStyles(element, styleRules, callback, cssBuild = '', cssText = '') {\n    // no need to shim selectors if settings.useNativeShadow, also\n    // a shady css build will already have transformed selectors\n    // NOTE: This method may be called as part of static or property shimming.\n    // When there is a targeted build it will not be called for static shimming,\n    // but when the property shim is used it is called and should opt out of\n    // static shimming work when a proper build exists.\n    if (cssText === '') {\n      if (_style_settings_js__WEBPACK_IMPORTED_MODULE_2__.nativeShadow || cssBuild === 'shady') {\n        cssText = _style_util_js__WEBPACK_IMPORTED_MODULE_1__.toCssText(styleRules, callback);\n      } else {\n        let {is, typeExtension} = _style_util_js__WEBPACK_IMPORTED_MODULE_1__.getIsExtends(element);\n        cssText = this.css(styleRules, is, typeExtension, callback) + '\\n\\n';\n      }\n    }\n    return cssText.trim();\n  }\n\n  // Given a string of cssText and a scoping string (scope), returns\n  // a string of scoped css where each selector is transformed to include\n  // a class created from the scope. ShadowDOM selectors are also transformed\n  // (e.g. :host) to use the scoping selector.\n  css(rules, scope, ext, callback) {\n    let hostScope = this._calcHostScope(scope, ext);\n    scope = this._calcElementScope(scope);\n    let self = this;\n    return _style_util_js__WEBPACK_IMPORTED_MODULE_1__.toCssText(rules, function (/** StyleNode */ rule) {\n      if (!(/** @type {?} */ (rule.isScoped))) {\n        self.rule(rule, scope, hostScope);\n        rule.isScoped = true;\n      }\n      if (callback) {\n        callback(rule, scope, hostScope);\n      }\n    });\n  }\n\n  _calcElementScope(scope) {\n    if (scope) {\n      return CSS_CLASS_PREFIX + scope;\n    } else {\n      return '';\n    }\n  }\n\n  _calcHostScope(scope, ext) {\n    return ext ? `[is=${scope}]` : scope;\n  }\n\n  rule(rule, scope, hostScope) {\n    this._transformRule(rule, this._transformComplexSelector, scope, hostScope);\n  }\n\n  /**\n   * transforms a css rule to a scoped rule.\n   *\n   * @param {StyleNode} rule\n   * @param {Function} transformer\n   * @param {string=} scope\n   * @param {string=} hostScope\n   */\n  _transformRule(rule, transformer, scope, hostScope) {\n    // NOTE: save transformedSelector for subsequent matching of elements\n    // against selectors (e.g. when calculating style properties)\n    rule[\n      'selector'\n    ] = /** @type {?} */ (rule).transformedSelector = this._transformRuleCss(\n      rule,\n      transformer,\n      scope,\n      hostScope\n    );\n  }\n\n  /**\n   * @param {StyleNode} rule\n   * @param {Function} transformer\n   * @param {string=} scope\n   * @param {string=} hostScope\n   */\n  _transformRuleCss(rule, transformer, scope, hostScope) {\n    let p$ = _style_util_js__WEBPACK_IMPORTED_MODULE_1__.splitSelectorList(rule['selector']);\n    // we want to skip transformation of rules that appear in keyframes,\n    // because they are keyframe selectors, not element selectors.\n    if (!_style_util_js__WEBPACK_IMPORTED_MODULE_1__.isKeyframesSelector(rule)) {\n      for (let i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n        p$[i] = transformer.call(this, p, scope, hostScope);\n      }\n    }\n    return p$.filter((part) => Boolean(part)).join(COMPLEX_SELECTOR_SEP);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {string}\n   */\n  _twiddleNthPlus(selector) {\n    return selector.replace(NTH, (m, type, inside) => {\n      if (inside.indexOf('+') > -1) {\n        inside = inside.replace(/\\+/g, '___');\n      } else if (inside.indexOf('___') > -1) {\n        inside = inside.replace(/___/g, '+');\n      }\n      return `:${type}(${inside})`;\n    });\n  }\n\n  /**\n   * Preserve `:matches()` selectors by replacing them with MATCHES_REPLACMENT\n   * and returning an array of `:matches()` selectors.\n   * Use `_replacesMatchesPseudo` to replace the `:matches()` parts\n   *\n   * @param {string} selector\n   * @return {{selector: string, matches: !Array<string>}}\n   */\n  _preserveMatchesPseudo(selector) {\n    /** @type {!Array<string>} */\n    const matches = [];\n    let match;\n    while ((match = selector.match(MATCHES))) {\n      const start = match.index;\n      const end = _style_util_js__WEBPACK_IMPORTED_MODULE_1__.findMatchingParen(selector, start);\n      if (end === -1) {\n        throw new Error(`${match.input} selector missing ')'`);\n      }\n      const part = selector.slice(start, end + 1);\n      selector = selector.replace(part, MATCHES_REPLACEMENT);\n      matches.push(part);\n    }\n    return {selector, matches};\n  }\n\n  /**\n   * Replace MATCHES_REPLACMENT character with the given set of `:matches()`\n   * selectors.\n   *\n   * @param {string} selector\n   * @param {!Array<string>} matches\n   * @return {string}\n   */\n  _replaceMatchesPseudo(selector, matches) {\n    const parts = selector.split(MATCHES_REPLACEMENT);\n    return matches.reduce(\n      (acc, cur, idx) => acc + cur + parts[idx + 1],\n      parts[0]\n    );\n  }\n\n  /**\n   * @param {string} selector\n   * @param {string} scope\n   * @param {string=} hostScope\n   */\n  _transformComplexSelector(selector, scope, hostScope) {\n    let stop = false;\n    selector = selector.trim();\n    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n    let isNth = NTH.test(selector);\n    if (isNth) {\n      selector = selector.replace(\n        NTH,\n        (m, type, inner) => `:${type}(${inner.replace(/\\s/g, '')})`\n      );\n      selector = this._twiddleNthPlus(selector);\n    }\n    // Preserve selectors like `:-webkit-any` so that SIMPLE_SELECTOR_SEP does\n    // not get confused by spaces inside the pseudo selector\n    const isMatches = MATCHES.test(selector);\n    /** @type {!Array<string>} */\n    let matches;\n    if (isMatches) {\n      ({selector, matches} = this._preserveMatchesPseudo(selector));\n    }\n    selector = selector.replace(SLOTTED_START, `${HOST} $1`);\n    selector = selector.replace(SIMPLE_SELECTOR_SEP, (m, c, s) => {\n      if (!stop) {\n        let info = this._transformCompoundSelector(s, c, scope, hostScope);\n        stop = stop || info.stop;\n        c = info.combinator;\n        s = info.value;\n      }\n      return c + s;\n    });\n    // replace `:matches()` selectors\n    if (isMatches) {\n      selector = this._replaceMatchesPseudo(selector, matches);\n    }\n    if (isNth) {\n      selector = this._twiddleNthPlus(selector);\n    }\n    selector = selector.replace(\n      DIR_PAREN,\n      (m, before, dir, after) =>\n        `[dir=\"${dir}\"] ${before}${after}, ${before}[dir=\"${dir}\"]${after}`\n    );\n    return selector;\n  }\n\n  _transformCompoundSelector(selector, combinator, scope, hostScope) {\n    // replace :host with host scoping class\n    let slottedIndex = selector.indexOf(SLOTTED);\n    if (selector.indexOf(HOST) >= 0) {\n      selector = this._transformHostSelector(selector, hostScope);\n      // replace other selectors with scoping class\n    } else if (slottedIndex !== 0) {\n      selector = scope\n        ? this._transformSimpleSelector(selector, scope)\n        : selector;\n    }\n    // mark ::slotted() scope jump to replace with descendant selector + arg\n    // also ignore left-side combinator\n    let slotted = false;\n    if (slottedIndex >= 0) {\n      combinator = '';\n      slotted = true;\n    }\n    // process scope jumping selectors up to the scope jump and then stop\n    let stop;\n    if (slotted) {\n      stop = true;\n      if (slotted) {\n        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n        selector = selector.replace(SLOTTED_PAREN, (m, paren) => ` > ${paren}`);\n      }\n    }\n    return {value: selector, combinator, stop};\n  }\n\n  _transformSimpleSelector(selector, scope) {\n    const attributes = selector.split(/(\\[.+?\\])/);\n\n    const output = [];\n    for (let i = 0; i < attributes.length; i++) {\n      // Do not attempt to transform any attribute selector content\n      if (i % 2 === 1) {\n        output.push(attributes[i]);\n      } else {\n        const part = attributes[i];\n\n        if (!(part === '' && i === attributes.length - 1)) {\n          let p$ = part.split(PSEUDO_PREFIX);\n          p$[0] += scope;\n          output.push(p$.join(PSEUDO_PREFIX));\n        }\n      }\n    }\n\n    return output.join('');\n  }\n\n  // :host(...) -> scopeName...\n  _transformHostSelector(selector, hostScope) {\n    let m = selector.match(HOST_PAREN);\n    let paren = (m && m[2].trim()) || '';\n    if (paren) {\n      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n        // paren starts with a type selector\n        let typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n        // if the type selector is our hostScope then avoid pre-pending it\n        if (typeSelector === hostScope) {\n          return paren;\n        }\n        // otherwise, this selector should not match in this scope so\n        // output a bogus selector.\n        else {\n          return SELECTOR_NO_MATCH;\n        }\n      } else {\n        // make sure to do a replace here to catch selectors like:\n        // `:host(.foo)::before`\n        return selector.replace(HOST_PAREN, function (m, host, paren) {\n          return hostScope + paren;\n        });\n      }\n    }\n    // if no paren, do a straight :host replacement.\n    // TODO(sorvell): this should not strictly be necessary but\n    // it's needed to maintain support for `:host[foo]` type selectors\n    // which have been improperly used under Shady DOM. This should be\n    // deprecated.\n    else {\n      return selector.replace(HOST, hostScope);\n    }\n  }\n\n  /**\n   * @param {StyleNode} rule\n   */\n  documentRule(rule) {\n    // reset selector in case this is redone.\n    rule['selector'] = rule['parsedSelector'];\n    this.normalizeRootSelector(rule);\n    this._transformRule(rule, this._transformDocumentSelector);\n  }\n\n  /**\n   * @param {StyleNode} rule\n   */\n  normalizeRootSelector(rule) {\n    if (rule['selector'] === ROOT) {\n      rule['selector'] = 'html';\n    }\n  }\n\n  /**\n   * @param {string} selector\n   */\n  _transformDocumentSelector(selector) {\n    if (selector.match(HOST)) {\n      // remove ':host' type selectors in document rules\n      return '';\n    } else if (selector.match(SLOTTED)) {\n      return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR);\n    } else {\n      return this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n    }\n  }\n}\n\nconst NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\nconst SCOPE_DOC_SELECTOR = `:not(.${SCOPE_NAME})`;\nconst COMPLEX_SELECTOR_SEP = ',';\nconst SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=[])+)/g;\nconst SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\nconst HOST = ':host';\nconst ROOT = ':root';\nconst SLOTTED = '::slotted';\nconst SLOTTED_START = new RegExp(`^(${SLOTTED})`);\n// NOTE: this supports 1 nested () pair for things like\n// :host(:not([selected]), more general support requires\n// parsing which seems like overkill\nconst HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n// similar to HOST_PAREN\nconst SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\nconst DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)(.*)/;\nconst CSS_CLASS_PREFIX = '.';\nconst PSEUDO_PREFIX = ':';\nconst CLASS = 'class';\nconst SELECTOR_NO_MATCH = 'should_not_match';\nconst MATCHES = /:(?:matches|any|-(?:webkit|moz)-any)/;\nconst MATCHES_REPLACEMENT = '\\u{e000}';\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StyleTransformer());\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-transformer.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/style-util.js":
/*!****************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/style-util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toCssText\": () => (/* binding */ toCssText),\n/* harmony export */   \"rulesForStyle\": () => (/* binding */ rulesForStyle),\n/* harmony export */   \"isKeyframesSelector\": () => (/* binding */ isKeyframesSelector),\n/* harmony export */   \"forEachRule\": () => (/* binding */ forEachRule),\n/* harmony export */   \"applyCss\": () => (/* binding */ applyCss),\n/* harmony export */   \"createScopeStyle\": () => (/* binding */ createScopeStyle),\n/* harmony export */   \"applyStylePlaceHolder\": () => (/* binding */ applyStylePlaceHolder),\n/* harmony export */   \"applyStyle\": () => (/* binding */ applyStyle),\n/* harmony export */   \"isTargetedBuild\": () => (/* binding */ isTargetedBuild),\n/* harmony export */   \"findMatchingParen\": () => (/* binding */ findMatchingParen),\n/* harmony export */   \"processVariableAndFallback\": () => (/* binding */ processVariableAndFallback),\n/* harmony export */   \"setElementClassRaw\": () => (/* binding */ setElementClassRaw),\n/* harmony export */   \"wrap\": () => (/* binding */ wrap),\n/* harmony export */   \"getIsExtends\": () => (/* binding */ getIsExtends),\n/* harmony export */   \"gatherStyleText\": () => (/* binding */ gatherStyleText),\n/* harmony export */   \"splitSelectorList\": () => (/* binding */ splitSelectorList),\n/* harmony export */   \"getCssBuild\": () => (/* binding */ getCssBuild),\n/* harmony export */   \"elementHasBuiltCss\": () => (/* binding */ elementHasBuiltCss),\n/* harmony export */   \"getBuildComment\": () => (/* binding */ getBuildComment),\n/* harmony export */   \"isOptimalCssBuild\": () => (/* binding */ isOptimalCssBuild)\n/* harmony export */ });\n/* harmony import */ var _style_settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style-settings.js */ \"./node_modules/@webcomponents/shadycss/src/style-settings.js\");\n/* harmony import */ var _css_parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-parse.js */ \"./node_modules/@webcomponents/shadycss/src/css-parse.js\");\n/* harmony import */ var _common_regex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common-regex.js */ \"./node_modules/@webcomponents/shadycss/src/common-regex.js\");\n/* harmony import */ var _unscoped_style_handler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unscoped-style-handler.js */ \"./node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n // eslint-disable-line @typescript-eslint/no-unused-vars\n\n// prettier-ignore\n\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nfunction toCssText(rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = (0,_css_parse_js__WEBPACK_IMPORTED_MODULE_1__.parse)(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return (0,_css_parse_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(rules, _style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nfunction rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = (0,_css_parse_js__WEBPACK_IMPORTED_MODULE_1__.parse)(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nfunction isKeyframesSelector(rule) {\n  return (\n    Boolean(rule['parent']) && rule['parent']['type'] === _css_parse_js__WEBPACK_IMPORTED_MODULE_1__.types.KEYFRAMES_RULE\n  );\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nfunction forEachRule(\n  node,\n  styleRuleCallback,\n  keyframesRuleCallback,\n  onlyActiveRules\n) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === _css_parse_js__WEBPACK_IMPORTED_MODULE_1__.types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(_common_regex_js__WEBPACK_IMPORTED_MODULE_2__.MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === _css_parse_js__WEBPACK_IMPORTED_MODULE_1__.types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback && type === _css_parse_js__WEBPACK_IMPORTED_MODULE_1__.types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === _css_parse_js__WEBPACK_IMPORTED_MODULE_1__.types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nfunction applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {!HTMLStyleElement}\n */\nfunction createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */ (document.createElement('style'));\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nfunction applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(\n    ' Shady DOM styles for ' + moniker + ' '\n  );\n  let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nfunction applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) || target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nfunction isTargetedBuild(buildType) {\n  return _style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nfunction findMatchingParen(text, start) {\n  let level = 0;\n  for (let i = start, l = text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nfunction processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nfunction setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(\n      element,\n      'class',\n      value\n    );\n  }\n}\n\n/**\n * @type {function(*):*}\n */\nconst wrap =\n  (window['ShadyDOM'] && window['ShadyDOM']['wrap']) || ((node) => node);\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nfunction getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '',\n    typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = (element.getAttribute && element.getAttribute('is')) || '';\n    }\n  } else {\n    is = /** @type {?} */ (element).is;\n    typeExtension = /** @type {?} */ (element).extends;\n  }\n  return {is, typeExtension};\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nfunction gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */ (element.querySelectorAll(\n    'style'\n  ));\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if ((0,_unscoped_style_handler_js__WEBPACK_IMPORTED_MODULE_3__.isUnscopedStyle)(style)) {\n      if (!_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeShadow) {\n        (0,_unscoped_style_handler_js__WEBPACK_IMPORTED_MODULE_3__.processUnscopedStyle)(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n\n/**\n * Split a selector separated by commas into an array in a smart way\n * @param {string} selector\n * @return {!Array<string>}\n */\nfunction splitSelectorList(selector) {\n  const parts = [];\n  let part = '';\n  for (let i = 0; i >= 0 && i < selector.length; i++) {\n    // A selector with parentheses will be one complete part\n    if (selector[i] === '(') {\n      // find the matching paren\n      const end = findMatchingParen(selector, i);\n      // push the paren block into the part\n      part += selector.slice(i, end + 1);\n      // move the index to after the paren block\n      i = end;\n    } else if (selector[i] === ',') {\n      parts.push(part);\n      part = '';\n    } else {\n      part += selector[i];\n    }\n  }\n  // catch any pieces after the last comma\n  if (part) {\n    parts.push(part);\n  }\n  return parts;\n}\n\nconst CSS_BUILD_ATTR = 'css-build';\n\n/**\n * Return the polymer-css-build \"build type\" applied to this element\n *\n * @param {!HTMLElement} element\n * @return {string} Can be \"\", \"shady\", or \"shadow\"\n */\nfunction getCssBuild(element) {\n  if (_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.cssBuild !== undefined) {\n    return /** @type {string} */ (_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.cssBuild);\n  }\n  if (element.__cssBuild === undefined) {\n    // try attribute first, as it is the common case\n    const attrValue = element.getAttribute(CSS_BUILD_ATTR);\n    if (attrValue) {\n      element.__cssBuild = attrValue;\n    } else {\n      const buildComment = getBuildComment(element);\n      if (buildComment !== '') {\n        // remove build comment so it is not needlessly copied into every element instance\n        removeBuildComment(element);\n      }\n      element.__cssBuild = buildComment;\n    }\n  }\n  return element.__cssBuild || '';\n}\n\n/**\n * Check if the given element, either a <template> or <style>, has been processed\n * by polymer-css-build.\n *\n * If so, then we can make a number of optimizations:\n * - polymer-css-build will decompose mixins into individual CSS Custom Properties,\n * so the ApplyShim can be skipped entirely.\n * - Under native ShadowDOM, the style text can just be copied into each instance\n * without modification\n * - If the build is \"shady\" and ShadyDOM is in use, the styling does not need\n * scoping beyond the shimming of CSS Custom Properties\n *\n * @param {!HTMLElement} element\n * @return {boolean}\n */\nfunction elementHasBuiltCss(element) {\n  return getCssBuild(element) !== '';\n}\n\n/**\n * For templates made with tagged template literals, polymer-css-build will\n * insert a comment of the form `<!--css-build:shadow-->`\n *\n * @param {!HTMLElement} element\n * @return {string}\n */\nfunction getBuildComment(element) {\n  const buildComment =\n    element.localName === 'template'\n      ? /** @type {!HTMLTemplateElement} */ (element).content.firstChild\n      : element.firstChild;\n  if (buildComment instanceof Comment) {\n    const commentParts = buildComment.textContent.trim().split(':');\n    if (commentParts[0] === CSS_BUILD_ATTR) {\n      return commentParts[1];\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the css build status is optimal, and do no unneeded work.\n *\n * @param {string=} cssBuild CSS build status\n * @return {boolean} css build is optimal or not\n */\nfunction isOptimalCssBuild(cssBuild = '') {\n  // CSS custom property shim always requires work\n  if (cssBuild === '' || !_style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeCssVariables) {\n    return false;\n  }\n  return _style_settings_js__WEBPACK_IMPORTED_MODULE_0__.nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';\n}\n\n/**\n * @param {!HTMLElement} element\n */\nfunction removeBuildComment(element) {\n  const buildComment =\n    element.localName === 'template'\n      ? /** @type {!HTMLTemplateElement} */ (element).content.firstChild\n      : element.firstChild;\n  buildComment.parentNode.removeChild(buildComment);\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/style-util.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/template-map.js":
/*!******************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/template-map.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/**\n * @const {!Object<string, !HTMLTemplateElement>}\n */\nconst templateMap = {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (templateMap);\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/template-map.js?");

/***/ }),

/***/ "./node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scopingAttribute\": () => (/* binding */ scopingAttribute),\n/* harmony export */   \"processUnscopedStyle\": () => (/* binding */ processUnscopedStyle),\n/* harmony export */   \"isUnscopedStyle\": () => (/* binding */ isUnscopedStyle)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/** @type {!Set<string>} */\nconst styleTextSet = new Set();\n\nconst scopingAttribute = 'shady-unscoped';\n\n/**\n * Add a specifically-marked style to the document directly, and only one copy of that style.\n *\n * @param {!HTMLStyleElement} style\n * @return {undefined}\n */\nfunction processUnscopedStyle(style) {\n  const text = style.textContent;\n  if (!styleTextSet.has(text)) {\n    styleTextSet.add(text);\n    const newStyle = document.createElement('style');\n    newStyle.setAttribute('shady-unscoped', '');\n    newStyle.textContent = text;\n    document.head.appendChild(newStyle);\n  }\n}\n\n/**\n * Check if a style is supposed to be unscoped\n * @param {!HTMLStyleElement} style\n * @return {boolean} true if the style has the unscoping attribute\n */\nfunction isUnscopedStyle(style) {\n  return style.hasAttribute(scopingAttribute);\n}\n\n\n//# sourceURL=webpack://test/./node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js":
/*!****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_3d_Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts-3d/Math.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Math.js\");\n/* harmony import */ var _parts_3d_SVGRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts-3d/SVGRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/SVGRenderer.js\");\n/* harmony import */ var _parts_3d_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts-3d/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Chart.js\");\n/* harmony import */ var _parts_3d_Axis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts-3d/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Axis.js\");\n/* harmony import */ var _parts_3d_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts-3d/Series.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Series.js\");\n/* harmony import */ var _parts_3d_Column_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts-3d/Column.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Column.js\");\n/* harmony import */ var _parts_3d_Pie_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts-3d/Pie.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Pie.js\");\n/* harmony import */ var _parts_3d_Scatter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../parts-3d/Scatter.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/Scatter.js\");\n/* harmony import */ var _parts_3d_VMLRenderer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../parts-3d/VMLRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts-3d/VMLRenderer.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * 3D features for Highcharts JS\n *\n * @license: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/highcharts-3d.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_more_Pane_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts-more/Pane.js */ \"./node_modules/highcharts/js/es-modules/parts-more/Pane.js\");\n/* harmony import */ var _parts_more_RadialAxis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts-more/RadialAxis.js */ \"./node_modules/highcharts/js/es-modules/parts-more/RadialAxis.js\");\n/* harmony import */ var _parts_more_AreaRangeSeries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts-more/AreaRangeSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/AreaRangeSeries.js\");\n/* harmony import */ var _parts_more_AreaSplineRangeSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts-more/AreaSplineRangeSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/AreaSplineRangeSeries.js\");\n/* harmony import */ var _parts_more_ColumnRangeSeries_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts-more/ColumnRangeSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/ColumnRangeSeries.js\");\n/* harmony import */ var _parts_more_GaugeSeries_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts-more/GaugeSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js\");\n/* harmony import */ var _parts_more_BoxPlotSeries_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts-more/BoxPlotSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/BoxPlotSeries.js\");\n/* harmony import */ var _parts_more_ErrorBarSeries_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../parts-more/ErrorBarSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/ErrorBarSeries.js\");\n/* harmony import */ var _parts_more_WaterfallSeries_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../parts-more/WaterfallSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/WaterfallSeries.js\");\n/* harmony import */ var _parts_more_PolygonSeries_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../parts-more/PolygonSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/PolygonSeries.js\");\n/* harmony import */ var _parts_more_BubbleSeries_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../parts-more/BubbleSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/BubbleSeries.js\");\n/* harmony import */ var _parts_more_Polar_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../parts-more/Polar.js */ \"./node_modules/highcharts/js/es-modules/parts-more/Polar.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/highcharts-more.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/highcharts.src.js":
/*!*************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/highcharts.src.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_SvgRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/* harmony import */ var _parts_Html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Html.js */ \"./node_modules/highcharts/js/es-modules/parts/Html.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_DateTimeAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/DateTimeAxis.js */ \"./node_modules/highcharts/js/es-modules/parts/DateTimeAxis.js\");\n/* harmony import */ var _parts_LogarithmicAxis_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/LogarithmicAxis.js */ \"./node_modules/highcharts/js/es-modules/parts/LogarithmicAxis.js\");\n/* harmony import */ var _parts_PlotLineOrBand_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts/PlotLineOrBand.js */ \"./node_modules/highcharts/js/es-modules/parts/PlotLineOrBand.js\");\n/* harmony import */ var _parts_Tooltip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../parts/Tooltip.js */ \"./node_modules/highcharts/js/es-modules/parts/Tooltip.js\");\n/* harmony import */ var _parts_Pointer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../parts/Pointer.js */ \"./node_modules/highcharts/js/es-modules/parts/Pointer.js\");\n/* harmony import */ var _parts_TouchPointer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../parts/TouchPointer.js */ \"./node_modules/highcharts/js/es-modules/parts/TouchPointer.js\");\n/* harmony import */ var _parts_MSPointer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../parts/MSPointer.js */ \"./node_modules/highcharts/js/es-modules/parts/MSPointer.js\");\n/* harmony import */ var _parts_Legend_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../parts/Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_ScrollablePlotArea_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../parts/ScrollablePlotArea.js */ \"./node_modules/highcharts/js/es-modules/parts/ScrollablePlotArea.js\");\n/* harmony import */ var _parts_Stacking_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../parts/Stacking.js */ \"./node_modules/highcharts/js/es-modules/parts/Stacking.js\");\n/* harmony import */ var _parts_Dynamics_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../parts/Dynamics.js */ \"./node_modules/highcharts/js/es-modules/parts/Dynamics.js\");\n/* harmony import */ var _parts_AreaSeries_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../parts/AreaSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/AreaSeries.js\");\n/* harmony import */ var _parts_SplineSeries_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../parts/SplineSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/SplineSeries.js\");\n/* harmony import */ var _parts_AreaSplineSeries_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../parts/AreaSplineSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/AreaSplineSeries.js\");\n/* harmony import */ var _parts_ColumnSeries_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../parts/ColumnSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js\");\n/* harmony import */ var _parts_BarSeries_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../parts/BarSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/BarSeries.js\");\n/* harmony import */ var _parts_ScatterSeries_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../parts/ScatterSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js\");\n/* harmony import */ var _parts_PieSeries_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../parts/PieSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/PieSeries.js\");\n/* harmony import */ var _parts_DataLabels_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../parts/DataLabels.js */ \"./node_modules/highcharts/js/es-modules/parts/DataLabels.js\");\n/* harmony import */ var _modules_overlapping_datalabels_src_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../modules/overlapping-datalabels.src.js */ \"./node_modules/highcharts/js/es-modules/modules/overlapping-datalabels.src.js\");\n/* harmony import */ var _parts_Interaction_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../parts/Interaction.js */ \"./node_modules/highcharts/js/es-modules/parts/Interaction.js\");\n/* harmony import */ var _parts_Responsive_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../parts/Responsive.js */ \"./node_modules/highcharts/js/es-modules/parts/Responsive.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/highcharts.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/highstock.src.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/highstock.src.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _highcharts_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./highcharts.src.js */ \"./node_modules/highcharts/js/es-modules/masters/highcharts.src.js\");\n/* harmony import */ var _modules_stock_src_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/stock.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/stock.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_highcharts_src_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/highstock.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js":
/*!************************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_a11y_i18n_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/a11y-i18n.src.js */ \"./node_modules/highcharts/js/es-modules/modules/a11y-i18n.src.js\");\n/* harmony import */ var _modules_screen_reader_src_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../modules/screen-reader.src.js */ \"./node_modules/highcharts/js/es-modules/modules/screen-reader.src.js\");\n/* harmony import */ var _modules_keyboard_navigation_src_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../modules/keyboard-navigation.src.js */ \"./node_modules/highcharts/js/es-modules/modules/keyboard-navigation.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Accessibility module\n *\n * (c) 2010-2017 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/accessibility.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/broken-axis.src.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/broken-axis.src.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_broken_axis_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/broken-axis.src.js */ \"./node_modules/highcharts/js/es-modules/modules/broken-axis.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2009-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/broken-axis.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/data.src.js":
/*!***************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/data.src.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_data_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/data.src.js */ \"./node_modules/highcharts/js/es-modules/modules/data.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Data module\n *\n * (c) 2012-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/data.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js":
/*!********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_drilldown_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/drilldown.src.js */ \"./node_modules/highcharts/js/es-modules/modules/drilldown.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Highcharts Drilldown module\n *\n * Author: Torstein Honsi\n * License: www.highcharts.com/license\n *\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/drilldown.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js":
/*!********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_exporting_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/exporting.src.js */ \"./node_modules/highcharts/js/es-modules/modules/exporting.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Exporting module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/exporting.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_funnel_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/funnel.src.js */ \"./node_modules/highcharts/js/es-modules/modules/funnel.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Highcharts funnel module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/funnel.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_map_ColorAxis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../parts-map/ColorAxis.js */ \"./node_modules/highcharts/js/es-modules/parts-map/ColorAxis.js\");\n/* harmony import */ var _parts_map_ColorSeriesMixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../parts-map/ColorSeriesMixin.js */ \"./node_modules/highcharts/js/es-modules/parts-map/ColorSeriesMixin.js\");\n/* harmony import */ var _parts_map_HeatmapSeries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../parts-map/HeatmapSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-map/HeatmapSeries.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2009-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/heatmap.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_no_data_to_display_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/no-data-to-display.src.js */ \"./node_modules/highcharts/js/es-modules/modules/no-data-to-display.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Plugin for displaying a message when there is no data visible in chart.\n *\n * (c) 2010-2017 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/no-data-to-display.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_solid_gauge_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/solid-gauge.src.js */ \"./node_modules/highcharts/js/es-modules/modules/solid-gauge.src.js\");\n/**\n * @license  @product.name@ JS v@product.version@ (@product.date@)\n * Solid angular gauge module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/solid-gauge.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/stock.src.js":
/*!****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/stock.src.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_OrdinalAxis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../parts/OrdinalAxis.js */ \"./node_modules/highcharts/js/es-modules/parts/OrdinalAxis.js\");\n/* harmony import */ var _broken_axis_src_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./broken-axis.src.js */ \"./node_modules/highcharts/js/es-modules/masters/modules/broken-axis.src.js\");\n/* harmony import */ var _parts_DataGrouping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../parts/DataGrouping.js */ \"./node_modules/highcharts/js/es-modules/parts/DataGrouping.js\");\n/* harmony import */ var _parts_OHLCSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../parts/OHLCSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/OHLCSeries.js\");\n/* harmony import */ var _parts_CandlestickSeries_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../parts/CandlestickSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/CandlestickSeries.js\");\n/* harmony import */ var _parts_FlagsSeries_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../parts/FlagsSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/FlagsSeries.js\");\n/* harmony import */ var _parts_Scrollbar_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../parts/Scrollbar.js */ \"./node_modules/highcharts/js/es-modules/parts/Scrollbar.js\");\n/* harmony import */ var _parts_Navigator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../parts/Navigator.js */ \"./node_modules/highcharts/js/es-modules/parts/Navigator.js\");\n/* harmony import */ var _parts_RangeSelector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../parts/RangeSelector.js */ \"./node_modules/highcharts/js/es-modules/parts/RangeSelector.js\");\n/* harmony import */ var _parts_StockChart_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../parts/StockChart.js */ \"./node_modules/highcharts/js/es-modules/parts/StockChart.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n * Highstock as a plugin for Highcharts\n *\n * (c) 2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/stock.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_treemap_src_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/treemap.src.js */ \"./node_modules/highcharts/js/es-modules/modules/treemap.src.js\");\n/**\n * @license @product.name@ JS v@product.version@ (@product.date@)\n *\n * (c) 2014 Highsoft AS\n * Authors: Jon Arild Nygard / Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/masters/modules/treemap.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/mixins/ajax.js":
/*!**************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/mixins/ajax.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/**\n * (c) 2010-2017 Christer Vasseng, Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n/**\n * @typedef {Object} AjaxSettings\n * @property {String} url - The URL to call\n * @property {('get'|'post'|'update'|'delete')} type - The verb to use\n * @property {('json'|'xml'|'text'|'octet')} dataType - The data type expected\n * @property {Function} success - Function to call on success\n * @property {Function} error - Function to call on error\n * @property {Object} data - The payload to send\n * @property {Object} headers - The headers; keyed on header name\n */\n\n/**\n * Perform an Ajax call.\n *\n * @memberof Highcharts\n * @param {AjaxSettings} - The Ajax settings to use\n *\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ajax = function (attr) {\n    var options = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(true, {\n            url: false,\n            type: 'GET',\n            dataType: 'json',\n            success: false,\n            error: false,\n            data: false,\n            headers: {}\n        }, attr),\n        headers = {\n            json: 'application/json',\n            xml: 'application/xml',\n            text: 'text/plain',\n            octet: 'application/octet-stream'\n        },\n        r = new XMLHttpRequest();\n\n    function handleError(xhr, err) {\n        if (options.error) {\n            options.error(xhr, err);\n        } else {\n            // Maybe emit a highcharts error event here\n        }\n    }\n\n    if (!options.url) {\n        return false;\n    }\n\n    r.open(options.type.toUpperCase(), options.url, true);\n    r.setRequestHeader(\n        'Content-Type',\n        headers[options.dataType] || headers.text\n    );\n\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(options.headers, function (val, key) {\n        r.setRequestHeader(key, val);\n    });\n\n    r.onreadystatechange = function () {\n        var res;\n\n        if (r.readyState === 4) {\n            if (r.status === 200) {\n                res = r.responseText;\n                if (options.dataType === 'json') {\n                    try {\n                        res = JSON.parse(res);\n                    } catch (e) {\n                        return handleError(r, e);\n                    }\n                }\n                return options.success && options.success(res);\n            }\n\n            handleError(r, r.responseText);\n        }\n    };\n\n    try {\n        options.data = JSON.stringify(options.data);\n    } catch (e) {}\n\n    r.send(options.data || true);\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/mixins/ajax.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/mixins/centered-series.js":
/*!*************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/mixins/centered-series.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * @private\n * @typedef Highcharts.RadianAngles\n *\n * @property {number} start\n *\n * @property {number} end\n */\n\n\n\n\n\n\nvar deg2rad = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    relativeLength = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength;\n\n/**\n * @private\n * @mixin Highcharts.CenteredSeriesMixin\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CenteredSeriesMixin = {\n\n    /**\n     * Get the center of the pie based on the size and center options relative\n     * to the plot area. Borrowed by the polar and gauge series types.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getCenter\n     *\n     * @return {Array<number>}\n     */\n    getCenter: function () {\n\n        var options = this.options,\n            chart = this.chart,\n            slicingRoom = 2 * (options.slicedOffset || 0),\n            handleSlicingRoom,\n            plotWidth = chart.plotWidth - 2 * slicingRoom,\n            plotHeight = chart.plotHeight - 2 * slicingRoom,\n            centerOption = options.center,\n            positions = [\n                pick(centerOption[0], '50%'),\n                pick(centerOption[1], '50%'),\n                options.size || '100%',\n                options.innerSize || 0\n            ],\n            smallestSize = Math.min(plotWidth, plotHeight),\n            i,\n            value;\n\n        for (i = 0; i < 4; ++i) {\n            value = positions[i];\n            handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n            // i == 0: centerX, relative to width\n            // i == 1: centerY, relative to height\n            // i == 2: size, relative to smallestSize\n            // i == 3: innerSize, relative to size\n            positions[i] = relativeLength(\n                value,\n                [plotWidth, plotHeight, smallestSize, positions[2]][i]\n            ) + (handleSlicingRoom ? slicingRoom : 0);\n\n        }\n        // innerSize cannot be larger than size (#3632)\n        if (positions[3] > positions[2]) {\n            positions[3] = positions[2];\n        }\n        return positions;\n    },\n\n    /**\n     * getStartAndEndRadians - Calculates start and end angles in radians.\n     * Used in series types such as pie and sunburst.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians\n     *\n     * @param {number} start\n     *        Start angle in degrees.\n     *\n     * @param {number} end\n     *        Start angle in degrees.\n     *\n     * @return {Highcharts.RadianAngles}\n     *         Returns an object containing start and end angles as radians.\n     */\n    getStartAndEndRadians: function getStartAndEndRadians(start, end) {\n        var startAngle = isNumber(start) ? start : 0, // must be a number\n            endAngle = (\n                (\n                    isNumber(end) && // must be a number\n                    end > startAngle && // must be larger than the start angle\n                    // difference must be less than 360 degrees\n                    (end - startAngle) < 360\n                ) ?\n                end :\n                startAngle + 360\n            ),\n            correction = -90;\n        return {\n            start: deg2rad * (startAngle + correction),\n            end: deg2rad * (endAngle + correction)\n        };\n    }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/mixins/centered-series.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/mixins/on-series.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/mixins/on-series.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    defined = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    stableSort = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stableSort;\n\nvar onSeriesMixin = {\n\n    /**\n     * Override getPlotBox. If the onSeries option is valid, return the plot box\n     * of the onSeries, otherwise proceed as usual.\n     */\n    getPlotBox: function () {\n        return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.getPlotBox.call(\n            (\n                this.options.onSeries &&\n                this.chart.get(this.options.onSeries)\n            ) || this\n        );\n    },\n\n    /**\n     * Extend the translate method by placing the point on the related series\n     */\n    translate: function () {\n\n        seriesTypes.column.prototype.translate.apply(this);\n\n        var series = this,\n            options = series.options,\n            chart = series.chart,\n            points = series.points,\n            cursor = points.length - 1,\n            point,\n            lastPoint,\n            optionsOnSeries = options.onSeries,\n            onSeries = optionsOnSeries && chart.get(optionsOnSeries),\n            onKey = options.onKey || 'y',\n            step = onSeries && onSeries.options.step,\n            onData = onSeries && onSeries.points,\n            i = onData && onData.length,\n            inverted = chart.inverted,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            xOffset = 0,\n            leftPoint,\n            lastX,\n            rightPoint,\n            currentDataGrouping,\n            distanceRatio;\n\n        // relate to a master series\n        if (onSeries && onSeries.visible && i) {\n            xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;\n            currentDataGrouping = onSeries.currentDataGrouping;\n            lastX = (\n                onData[i - 1].x +\n                (currentDataGrouping ? currentDataGrouping.totalRange : 0)\n            ); // #2374\n\n            // sort the data points\n            stableSort(points, function (a, b) {\n                return (a.x - b.x);\n            });\n\n            onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);\n            while (i-- && points[cursor]) {\n                leftPoint = onData[i];\n                point = points[cursor];\n                point.y = leftPoint.y;\n\n                if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {\n                    if (point.x <= lastX) { // #803\n\n                        point.plotY = leftPoint[onKey];\n\n                        // interpolate between points, #666\n                        if (leftPoint.x < point.x && !step) {\n                            rightPoint = onData[i + 1];\n                            if (rightPoint && rightPoint[onKey] !== undefined) {\n                                // the distance ratio, between 0 and 1\n                                distanceRatio = (point.x - leftPoint.x) /\n                                    (rightPoint.x - leftPoint.x);\n                                point.plotY +=\n                                    distanceRatio *\n                                    // the plotY distance\n                                    (rightPoint[onKey] - leftPoint[onKey]);\n                                point.y +=\n                                    distanceRatio *\n                                    (rightPoint.y - leftPoint.y);\n                            }\n                        }\n                    }\n                    cursor--;\n                    i++; // check again for points in the same x position\n                    if (cursor < 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Add plotY position and handle stacking\n        each(points, function (point, i) {\n\n            var stackIndex;\n\n            point.plotX += xOffset; // #2049\n\n            // Undefined plotY means the point is either on axis, outside series\n            // range or hidden series. If the series is outside the range of the\n            // x axis it should fall through with an undefined plotY, but then\n            // we must remove the shapeArgs (#847). For inverted charts, we need\n            // to calculate position anyway, because series.invertGroups is not\n            // defined\n            if (point.plotY === undefined || inverted) {\n                if (point.plotX >= 0 && point.plotX <= xAxis.len) {\n                    // We're inside xAxis range\n                    if (inverted) {\n                        point.plotY = xAxis.translate(point.x, 0, 1, 0, 1);\n                        point.plotX = defined(point.y) ?\n                            yAxis.translate(point.y, 0, 0, 0, 1) : 0;\n                    } else {\n                        point.plotY = chart.chartHeight - xAxis.bottom -\n                            (xAxis.opposite ? xAxis.height : 0) +\n                            xAxis.offset - yAxis.top; // #3517\n                    }\n                } else {\n                    point.shapeArgs = {}; // 847\n                }\n            }\n\n            // if multiple flags appear at the same x, order them into a stack\n            lastPoint = points[i - 1];\n            if (lastPoint && lastPoint.plotX === point.plotX) {\n                if (lastPoint.stackIndex === undefined) {\n                    lastPoint.stackIndex = 0;\n                }\n                stackIndex = lastPoint.stackIndex + 1;\n            }\n            point.stackIndex = stackIndex; // #3639\n        });\n\n        this.onSeries = onSeries;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onSeriesMixin);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/mixins/on-series.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/mixins/tree-series.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/mixins/tree-series.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isBoolean = function (x) {\n        return typeof x === 'boolean';\n    },\n    isFn = function (x) {\n        return typeof x === 'function';\n    },\n    isObject = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    reduce = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reduce;\n// TODO Combine buildTree and buildNode with setTreeValues\n// TODO Remove logic from Treemap and make it utilize this mixin.\nvar setTreeValues = function setTreeValues(tree, options) {\n    var before = options.before,\n        idRoot = options.idRoot,\n        mapIdToNode = options.mapIdToNode,\n        nodeRoot = mapIdToNode[idRoot],\n        levelIsConstant = (\n            isBoolean(options.levelIsConstant) ?\n            options.levelIsConstant :\n            true\n        ),\n        points = options.points,\n        point = points[tree.i],\n        optionsPoint = point && point.options || {},\n        childrenTotal = 0,\n        children = [],\n        value;\n    extend(tree, {\n        levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),\n        name: pick(point && point.name, ''),\n        visible: (\n            idRoot === tree.id ||\n            (isBoolean(options.visible) ? options.visible : false)\n        )\n    });\n    if (isFn(before)) {\n        tree = before(tree, options);\n    }\n    // First give the children some values\n    each(tree.children, function (child, i) {\n        var newOptions = extend({}, options);\n        extend(newOptions, {\n            index: i,\n            siblings: tree.children.length,\n            visible: tree.visible\n        });\n        child = setTreeValues(child, newOptions);\n        children.push(child);\n        if (child.visible) {\n            childrenTotal += child.val;\n        }\n    });\n    tree.visible = childrenTotal > 0 || tree.visible;\n    // Set the values\n    value = pick(optionsPoint.value, childrenTotal);\n    extend(tree, {\n        children: children,\n        childrenTotal: childrenTotal,\n        isLeaf: tree.visible && !childrenTotal,\n        val: value\n    });\n    return tree;\n};\n\nvar getColor = function getColor(node, options) {\n    var index = options.index,\n        mapOptionsToLevel = options.mapOptionsToLevel,\n        parentColor = options.parentColor,\n        parentColorIndex = options.parentColorIndex,\n        series = options.series,\n        colors = options.colors,\n        siblings = options.siblings,\n        points = series.points,\n        getColorByPoint,\n        point,\n        level,\n        colorByPoint,\n        colorIndexByPoint,\n        color,\n        colorIndex;\n    function variation(color) {\n        var colorVariation = level && level.colorVariation;\n        if (colorVariation) {\n            if (colorVariation.key === 'brightness') {\n                return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(color).brighten(\n                    colorVariation.to * (index / siblings)\n                ).get();\n            }\n        }\n\n        return color;\n    }\n\n    if (node) {\n        point = points[node.i];\n        level = mapOptionsToLevel[node.level] || {};\n        getColorByPoint = point && level.colorByPoint;\n\n        if (getColorByPoint) {\n            colorIndexByPoint = point.index % (colors ?\n                colors.length :\n                series.chart.options.chart.colorCount\n            );\n            colorByPoint = colors && colors[colorIndexByPoint];\n        }\n\n        \n        colorIndex = pick(\n            point && point.options.colorIndex,\n            level && level.colorIndex,\n            colorIndexByPoint,\n            parentColorIndex,\n            options.colorIndex\n        );\n    }\n    return {\n        color: color,\n        colorIndex: colorIndex\n    };\n};\n\n/**\n * getLevelOptions - Creates a map from level number to its given options.\n * @param {Object} params Object containing parameters.\n * @param {Object} params.defaults Object containing default options. The\n * default options are merged with the userOptions to get the final options for\n * a specific level.\n * @param {Number} params.from The lowest level number.\n * @param {Array} params.levels User options from series.levels.\n * @param {Number} params.to The highest level number.\n * @return {null|Object} Returns a map from level number to its given options.\n * Returns null if invalid input parameters.\n */\nvar getLevelOptions = function getLevelOptions(params) {\n    var result = null,\n        defaults,\n        converted,\n        i,\n        from,\n        to,\n        levels;\n    if (isObject(params)) {\n        result = {};\n        from = isNumber(params.from) ? params.from : 1;\n        levels = params.levels;\n        converted = {};\n        defaults = isObject(params.defaults) ? params.defaults : {};\n        if (isArray(levels)) {\n            converted = reduce(levels, function (obj, item) {\n                var level,\n                    levelIsConstant,\n                    options;\n                if (isObject(item) && isNumber(item.level)) {\n                    options = merge({}, item);\n                    levelIsConstant = (\n                        isBoolean(options.levelIsConstant) ?\n                        options.levelIsConstant :\n                        defaults.levelIsConstant\n                    );\n                    // Delete redundant properties.\n                    delete options.levelIsConstant;\n                    delete options.level;\n                    // Calculate which level these options apply to.\n                    level = item.level + (levelIsConstant ? 0 : from - 1);\n                    if (isObject(obj[level])) {\n                        extend(obj[level], options);\n                    } else {\n                        obj[level] = options;\n                    }\n                }\n                return obj;\n            }, {});\n        }\n        to = isNumber(params.to) ? params.to : 1;\n        for (i = 0; i <= to; i++) {\n            result[i] = merge(\n                {},\n                defaults,\n                isObject(converted[i]) ? converted[i] : {}\n            );\n        }\n    }\n    return result;\n};\n\n/**\n * Update the rootId property on the series. Also makes sure that it is\n * accessible to exporting.\n * @param {object} series The series to operate on.\n * @returns Returns the resulting rootId after update.\n */\nvar updateRootId = function (series) {\n    var rootId,\n        options;\n    if (isObject(series)) {\n        // Get the series options.\n        options = isObject(series.options) ? series.options : {};\n\n        // Calculate the rootId.\n        rootId = pick(series.rootNode, options.rootId, '');\n\n        // Set rootId on series.userOptions to pick it up in exporting.\n        if (isObject(series.userOptions)) {\n            series.userOptions.rootId = rootId;\n        }\n        // Set rootId on series to pick it up on next update.\n        series.rootNode = rootId;\n    }\n    return rootId;\n};\n\nvar result = {\n    getColor: getColor,\n    getLevelOptions: getLevelOptions,\n    setTreeValues: setTreeValues,\n    updateRootId: updateRootId\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (result);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/mixins/tree-series.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/a11y-i18n.src.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/a11y-i18n.src.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * Accessibility module - internationalization support\n *\n * (c) 2010-2018 Highsoft AS\n * Author: ystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n\n/**\n * String trim that works for IE6-8 as well.\n * @param  {string} str The input string\n * @return {string} The trimmed string\n */\nfunction stringTrim(str) {\n    return str.trim && str.trim() || str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * i18n utility function. Format a single array or plural statement in a format\n * string. If the statement is not an array or plural statement, returns the\n * statement within brackets. Invalid array statements return an empty string.\n */\nfunction formatExtendedStatement(statement, ctx) {\n    var eachStart = statement.indexOf('#each('),\n        pluralStart = statement.indexOf('#plural('),\n        indexStart = statement.indexOf('['),\n        indexEnd = statement.indexOf(']'),\n        arr,\n        result;\n\n    // Dealing with an each-function?\n    if (eachStart > -1) {\n        var eachEnd = statement.slice(eachStart).indexOf(')') + eachStart,\n            preEach = statement.substring(0, eachStart),\n            postEach = statement.substring(eachEnd + 1),\n            eachStatement = statement.substring(eachStart + 6, eachEnd),\n            eachArguments = eachStatement.split(','),\n            lenArg = Number(eachArguments[1]),\n            len;\n        result = '';\n        arr = ctx[eachArguments[0]];\n        if (arr) {\n            lenArg = isNaN(lenArg) ? arr.length : lenArg;\n            len = lenArg < 0 ?\n                arr.length + lenArg :\n                Math.min(lenArg, arr.length); // Overshoot\n            // Run through the array for the specified length\n            for (var i = 0; i < len; ++i) {\n                result += preEach + arr[i] + postEach;\n            }\n        }\n        return result.length ? result : '';\n    }\n\n    // Dealing with a plural-function?\n    if (pluralStart > -1) {\n        var pluralEnd = statement.slice(pluralStart).indexOf(')') + pluralStart,\n            pluralStatement = statement.substring(pluralStart + 8, pluralEnd),\n            pluralArguments = pluralStatement.split(','),\n            num = Number(ctx[pluralArguments[0]]);\n        switch (num) {\n            case 0:\n                result = pick(pluralArguments[4], pluralArguments[1]);\n                break;\n            case 1:\n                result = pick(pluralArguments[2], pluralArguments[1]);\n                break;\n            case 2:\n                result = pick(pluralArguments[3], pluralArguments[1]);\n                break;\n            default:\n                result = pluralArguments[1];\n        }\n        return result ? stringTrim(result) : '';\n    }\n\n    // Array index\n    if (indexStart > -1) {\n        var arrayName = statement.substring(0, indexStart),\n            ix = Number(statement.substring(indexStart + 1, indexEnd)),\n            val;\n        arr = ctx[arrayName];\n        if (!isNaN(ix) && arr) {\n            if (ix < 0) {\n                val = arr[arr.length + ix];\n                // Handle negative overshoot\n                if (val === undefined) {\n                    val = arr[0];\n                }\n            } else {\n                val = arr[ix];\n                // Handle positive overshoot\n                if (val === undefined) {\n                    val = arr[arr.length - 1];\n                }\n            }\n        }\n        return val !== undefined ? val : '';\n    }\n\n    // Standard substitution, delegate to H.format or similar\n    return '{' + statement + '}';\n}\n\n\n/**\n * i18n formatting function. Extends H.format() functionality by also handling\n * arrays and plural conditionals. Arrays can be indexed as follows:\n *\n *  Format: 'This is the first index: {myArray[0]}. The last: {myArray[-1]}.'\n *  Context: { myArray: [0, 1, 2, 3, 4, 5] }\n *  Result: 'This is the first index: 0. The last: 5.'\n *\n * They can also be iterated using the #each() function. This will repeat the\n * contents of the bracket expression for each element. Example:\n *\n *  Format: 'List contains: {#each(myArray)cm }'\n *  Context: { myArray: [0, 1, 2] }\n *  Result: 'List contains: 0cm 1cm 2cm '\n *\n * The #each() function optionally takes a length parameter. If positive, this\n * parameter specifies the max number of elements to iterate through. If\n * negative, the function will subtract the number from the length of the array.\n * Use this to stop iterating before the array ends. Example:\n *\n *  Format: 'List contains: {#each(myArray, -1) }and {myArray[-1]}.'\n *  Context: { myArray: [0, 1, 2, 3] }\n *  Result: 'List contains: 0, 1, 2, and 3.'\n *\n * Use the #plural() function to pick a string depending on whether or not a\n * context object is 1. Arguments are #plural(obj, plural, singular). Example:\n *\n *  Format: 'Has {numPoints} {#plural(numPoints, points, point}.'\n *  Context: { numPoints: 5 }\n *  Result: 'Has 5 points.'\n *\n * Optionally there are additional parameters for dual and none:\n *  #plural(obj,plural,singular,dual,none)\n * Example:\n *\n *  Format: 'Has {#plural(numPoints, many points, one point, two points, none}.'\n *  Context: { numPoints: 2 }\n *  Result: 'Has two points.'\n *\n * The dual or none parameters will take precedence if they are supplied.\n *\n * @param   {string} formatString The string to format.\n * @param   {object} context Context to apply to the format string.\n * @param   {Time} time A `Time` instance for date formatting, passed on to\n *                 H.format().\n * @return  {string} The formatted string.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].i18nFormat = function (formatString, context, time) {\n    var getFirstBracketStatement = function (sourceStr, offset) {\n            var str = sourceStr.slice(offset || 0),\n                startBracket = str.indexOf('{'),\n                endBracket = str.indexOf('}');\n            if (startBracket > -1 && endBracket > startBracket) {\n                return {\n                    statement: str.substring(startBracket + 1, endBracket),\n                    begin: offset + startBracket + 1,\n                    end: offset + endBracket\n                };\n            }\n        },\n        tokens = [],\n        bracketRes,\n        constRes,\n        cursor = 0;\n\n    // Tokenize format string into bracket statements and constants\n    do {\n        bracketRes = getFirstBracketStatement(formatString, cursor);\n        constRes = formatString.substring(\n            cursor,\n            bracketRes && bracketRes.begin - 1\n        );\n\n        // If we have constant content before this bracket statement, add it\n        if (constRes.length) {\n            tokens.push({\n                value: constRes,\n                type: 'constant'\n            });\n        }\n\n        // Add the bracket statement\n        if (bracketRes) {\n            tokens.push({\n                value: bracketRes.statement,\n                type: 'statement'\n            });\n        }\n\n        cursor = bracketRes && bracketRes.end + 1;\n    } while (bracketRes);\n\n    // Perform the formatting. The formatArrayStatement function returns the\n    // statement in brackets if it is not an array statement, which means it\n    // gets picked up by H.format below.\n    each(tokens, function (token) {\n        if (token.type === 'statement') {\n            token.value = formatExtendedStatement(token.value, context);\n        }\n    });\n\n    // Join string back together and pass to H.format to pick up non-array\n    // statements.\n    return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reduce(tokens, function (acc, cur) {\n        return acc + cur.value;\n    }, ''), context, time);\n};\n\n\n/**\n * Apply context to a format string from lang options of the chart.\n * @param  {string} langKey Key (using dot notation) into lang option structure\n * @param  {object} context Context to apply to the format string\n * @return {string} The formatted string\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.langFormat = function (langKey, context, time) {\n    var keys = langKey.split('.'),\n        formatString = this.options.lang,\n        i = 0;\n    for (; i < keys.length; ++i) {\n        formatString = formatString && formatString[keys[i]];\n    }\n    return typeof formatString === 'string' && _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].i18nFormat(\n        formatString, context, time\n    );\n};\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setOptions({\n    lang: {\n        /**\n         * Configure the accessibility strings in the chart. Requires the\n         * [accessibility module](//code.highcharts.com/modules/accessibility.\n         * js) to be loaded. For a description of the module and information\n         * on its features, see [Highcharts Accessibility](http://www.highcharts.\n         * com/docs/chart-concepts/accessibility).\n         *\n         * For more dynamic control over the accessibility functionality, see\n         * [accessibility.pointDescriptionFormatter](\n         * accessibility.pointDescriptionFormatter),\n         * [accessibility.seriesDescriptionFormatter](\n         * accessibility.seriesDescriptionFormatter), and\n         * [accessibility.screenReaderSectionFormatter](\n         * accessibility.screenReaderSectionFormatter).\n         *\n         * @since 6.0.6\n         * @type {Object}\n         * @optionparent lang.accessibility\n         */\n        accessibility: {\n            /* eslint-disable max-len */\n\n            screenReaderRegionLabel: 'Chart screen reader information.',\n            navigationHint: 'Use regions/landmarks to skip ahead to chart {#plural(numSeries, and navigate between data series,)}',\n            defaultChartTitle: 'Chart',\n            longDescriptionHeading: 'Long description.',\n            noDescription: 'No description available.',\n            structureHeading: 'Structure.',\n            viewAsDataTable: 'View as data table.',\n            chartHeading: 'Chart graphic.',\n            chartContainerLabel: 'Interactive chart. {title}. Use up and down arrows to navigate with most screen readers.',\n            rangeSelectorMinInput: 'Select start date.',\n            rangeSelectorMaxInput: 'Select end date.',\n            tableSummary: 'Table representation of chart.',\n            mapZoomIn: 'Zoom chart',\n            mapZoomOut: 'Zoom out chart',\n            rangeSelectorButton: 'Select range {buttonText}',\n            legendItem: 'Toggle visibility of series {itemName}',\n\n            /**\n             * Title element text for the chart SVG element. Leave this\n             * empty to disable adding the title element. Browsers will display\n             * this content when hovering over elements in the chart. Assistive\n             * technology may use this element to label the chart.\n             *\n             * @since 6.0.8\n             */\n            svgContainerTitle: '{chartTitle}',\n\n            /**\n             * Descriptions of lesser known series types. The relevant\n             * description is added to the screen reader information region\n             * when these series types are used.\n             *\n             * @since 6.0.6\n             * @type {Object}\n             * @optionparent lang.accessibility.seriesTypeDescriptions\n             */\n            seriesTypeDescriptions: {\n                boxplot: 'Box plot charts are typically used to display ' +\n                    'groups of statistical data. Each data point in the ' +\n                    'chart can have up to 5 values: minimum, lower quartile, ' +\n                    'median, upper quartile, and maximum.',\n                arearange: 'Arearange charts are line charts displaying a ' +\n                    'range between a lower and higher value for each point.',\n                areasplinerange: 'These charts are line charts displaying a ' +\n                    'range between a lower and higher value for each point.',\n                bubble: 'Bubble charts are scatter charts where each data ' +\n                    'point also has a size value.',\n                columnrange: 'Columnrange charts are column charts ' +\n                    'displaying a range between a lower and higher value for ' +\n                    'each point.',\n                errorbar: 'Errorbar series are used to display the ' +\n                    'variability of the data.',\n                funnel: 'Funnel charts are used to display reduction of data ' +\n                    'in stages.',\n                pyramid: 'Pyramid charts consist of a single pyramid with ' +\n                    'item heights corresponding to each point value.',\n                waterfall: 'A waterfall chart is a column chart where each ' +\n                    'column contributes towards a total end value.'\n            },\n\n            /**\n             * Chart type description strings. This is added to the chart\n             * information region.\n             *\n             * If there is only a single series type used in the chart, we use\n             * the format string for the series type, or default if missing.\n             * There is one format string for cases where there is only a single\n             * series in the chart, and one for multiple series of the same\n             * type.\n             *\n             * @since 6.0.6\n             * @type {Object}\n             * @optionparent lang.accessibility.chartTypes\n             */\n            chartTypes: {\n                emptyChart: 'Empty chart',\n                mapTypeDescription: 'Map of {mapTitle} with {numSeries} data series.',\n                unknownMap: 'Map of unspecified region with {numSeries} data series.',\n                combinationChart: 'Combination chart with {numSeries} data series.',\n                defaultSingle: 'Chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                defaultMultiple: 'Chart with {numSeries} data series.',\n                splineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                splineMultiple: 'Line chart with {numSeries} lines.',\n                lineSingle: 'Line chart with {numPoints} data {#plural(numPoints, points, point)}.',\n                lineMultiple: 'Line chart with {numSeries} lines.',\n                columnSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',\n                columnMultiple: 'Bar chart with {numSeries} data series.',\n                barSingle: 'Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.',\n                barMultiple: 'Bar chart with {numSeries} data series.',\n                pieSingle: 'Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.',\n                pieMultiple: 'Pie chart with {numSeries} pies.',\n                scatterSingle: 'Scatter chart with {numPoints} {#plural(numPoints, points, point)}.',\n                scatterMultiple: 'Scatter chart with {numSeries} data series.',\n                boxplotSingle: 'Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.',\n                boxplotMultiple: 'Boxplot with {numSeries} data series.',\n                bubbleSingle: 'Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.',\n                bubbleMultiple: 'Bubble chart with {numSeries} data series.'\n            },\n\n            /**\n             * Axis description format strings.\n             *\n             * @since 6.0.6\n             * @type {Object}\n             * @optionparent lang.accessibility.axis\n             */\n            axis: {\n                xAxisDescriptionSingular: 'The chart has 1 X axis displaying {names[0]}.',\n                xAxisDescriptionPlural: 'The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}',\n                yAxisDescriptionSingular: 'The chart has 1 Y axis displaying {names[0]}.',\n                yAxisDescriptionPlural: 'The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}'\n            },\n\n            /**\n             * Exporting menu format strings for accessibility module.\n             *\n             * @since 6.0.6\n             * @type {Object}\n             * @optionparent lang.accessibility.exporting\n             */\n            exporting: {\n                chartMenuLabel: 'Chart export',\n                menuButtonLabel: 'View export menu',\n                exportRegionLabel: 'Chart export menu'\n            },\n\n            /**\n             * Lang configuration for different series types. For more dynamic\n             * control over the series element descriptions, see\n             * [accessibility.seriesDescriptionFormatter](\n             * accessibility.seriesDescriptionFormatter).\n             *\n             * @since 6.0.6\n             * @type {Object}\n             * @optionparent lang.accessibility.series\n             */\n            series: {\n                /**\n                 * Lang configuration for the series main summary. Each series\n                 * type has two modes:\n                 *     1. This series type is the only series type used in the\n                 *        chart\n                 *    2. This is a combination chart with multiple series types\n                 *\n                 * If a definition does not exist for the specific series type\n                 * and mode, the 'default' lang definitions are used.\n                 *\n                 * @since 6.0.6\n                 * @type {Object}\n                 * @optionparent lang.accessibility.series.summary\n                 */\n                summary: {\n                    default: '{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',\n                    defaultCombination: '{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',\n                    line: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',\n                    lineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',\n                    spline: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',\n                    splineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',\n                    column: '{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    columnCombination: '{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    bar: '{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    barCombination: '{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.',\n                    pie: '{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.',\n                    pieCombination: '{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.',\n                    scatter: '{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.',\n                    scatterCombination: '{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.',\n                    boxplot: '{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.',\n                    boxplotCombination: '{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.',\n                    bubble: '{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.',\n                    bubbleCombination: '{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.',\n                    map: '{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.',\n                    mapCombination: '{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.',\n                    mapline: '{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.',\n                    maplineCombination: '{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.',\n                    mapbubble: '{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.',\n                    mapbubbleCombination: '{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.'\n                },\n                /* eslint-enable max-len */\n\n                /**\n                 * User supplied description text. This is added after the main\n                 * summary if present.\n                 *\n                 * @type {String}\n                 * @since 6.0.6\n                 */\n                description: '{description}',\n\n                /**\n                 * xAxis description for series if there are multiple xAxes in\n                 * the chart.\n                 *\n                 * @type {String}\n                 * @since 6.0.6\n                 */\n                xAxisDescription: 'X axis, {name}',\n\n                /**\n                 * yAxis description for series if there are multiple yAxes in\n                 * the chart.\n                 *\n                 * @type {String}\n                 * @since 6.0.6\n                 */\n                yAxisDescription: 'Y axis, {name}'\n            }\n        }\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/a11y-i18n.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/broken-axis.src.js":
/*!**************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/broken-axis.src.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2009-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    fireEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    Axis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series;\n\nfunction stripArguments() {\n    return Array.prototype.slice.call(arguments, 1);\n}\n\nextend(Axis.prototype, {\n    isInBreak: function (brk, val) {\n        var ret,\n            repeat = brk.repeat || Infinity,\n            from = brk.from,\n            length = brk.to - brk.from,\n            test = (\n                val >= from ?\n                    (val - from) % repeat :\n                    repeat - ((from - val) % repeat)\n            );\n\n        if (!brk.inclusive) {\n            ret = test < length && test !== 0;\n        } else {\n            ret = test <= length;\n        }\n        return ret;\n    },\n\n    isInAnyBreak: function (val, testKeep) {\n\n        var breaks = this.options.breaks,\n            i = breaks && breaks.length,\n            inbrk,\n            keep,\n            ret;\n\n\n        if (i) {\n\n            while (i--) {\n                if (this.isInBreak(breaks[i], val)) {\n                    inbrk = true;\n                    if (!keep) {\n                        keep = pick(\n                            breaks[i].showPoints,\n                            this.isXAxis ? false : true\n                        );\n                    }\n                }\n            }\n\n            if (inbrk && testKeep) {\n                ret = inbrk && !keep;\n            } else {\n                ret = inbrk;\n            }\n        }\n        return ret;\n    }\n});\n\naddEvent(Axis, 'afterSetTickPositions', function () {\n    if (this.options.breaks) {\n        var axis = this,\n            tickPositions = this.tickPositions,\n            info = this.tickPositions.info,\n            newPositions = [],\n            i;\n\n        for (i = 0; i < tickPositions.length; i++) {\n            if (!axis.isInAnyBreak(tickPositions[i])) {\n                newPositions.push(tickPositions[i]);\n            }\n        }\n\n        this.tickPositions = newPositions;\n        this.tickPositions.info = info;\n    }\n});\n\n// Force Axis to be not-ordinal when breaks are defined\naddEvent(Axis, 'afterSetOptions', function () {\n    if (this.options.breaks && this.options.breaks.length) {\n        this.options.ordinal = false;\n    }\n});\n\naddEvent(Axis, 'afterInit', function () {\n    var axis = this,\n        breaks;\n\n    breaks = this.options.breaks;\n    axis.isBroken = (isArray(breaks) && !!breaks.length);\n    if (axis.isBroken) {\n        axis.val2lin = function (val) {\n            var nval = val,\n                brk,\n                i;\n\n            for (i = 0; i < axis.breakArray.length; i++) {\n                brk = axis.breakArray[i];\n                if (brk.to <= val) {\n                    nval -= brk.len;\n                } else if (brk.from >= val) {\n                    break;\n                } else if (axis.isInBreak(brk, val)) {\n                    nval -= (val - brk.from);\n                    break;\n                }\n            }\n\n            return nval;\n        };\n\n        axis.lin2val = function (val) {\n            var nval = val,\n                brk,\n                i;\n\n            for (i = 0; i < axis.breakArray.length; i++) {\n                brk = axis.breakArray[i];\n                if (brk.from >= nval) {\n                    break;\n                } else if (brk.to < nval) {\n                    nval += brk.len;\n                } else if (axis.isInBreak(brk, nval)) {\n                    nval += brk.len;\n                }\n            }\n            return nval;\n        };\n\n        axis.setExtremes = function (\n            newMin,\n            newMax,\n            redraw,\n            animation,\n            eventArguments\n        ) {\n            // If trying to set extremes inside a break, extend it to before and\n            // after the break ( #3857 )\n            while (this.isInAnyBreak(newMin)) {\n                newMin -= this.closestPointRange;\n            }\n            while (this.isInAnyBreak(newMax)) {\n                newMax -= this.closestPointRange;\n            }\n            Axis.prototype.setExtremes.call(\n                this,\n                newMin,\n                newMax,\n                redraw,\n                animation,\n                eventArguments\n            );\n        };\n\n        axis.setAxisTranslation = function (saveOld) {\n            Axis.prototype.setAxisTranslation.call(this, saveOld);\n\n            var breaks = axis.options.breaks,\n                breakArrayT = [],    // Temporary one\n                breakArray = [],\n                length = 0,\n                inBrk,\n                repeat,\n                min = axis.userMin || axis.min,\n                max = axis.userMax || axis.max,\n                pointRangePadding = pick(axis.pointRangePadding, 0),\n                start,\n                i;\n\n            // Min & max check (#4247)\n            each(breaks, function (brk) {\n                repeat = brk.repeat || Infinity;\n                if (axis.isInBreak(brk, min)) {\n                    min += (brk.to % repeat) - (min % repeat);\n                }\n                if (axis.isInBreak(brk, max)) {\n                    max -= (max % repeat) - (brk.from % repeat);\n                }\n            });\n\n            // Construct an array holding all breaks in the axis\n            each(breaks, function (brk) {\n                start = brk.from;\n                repeat = brk.repeat || Infinity;\n\n                while (start - repeat > min) {\n                    start -= repeat;\n                }\n                while (start < min) {\n                    start += repeat;\n                }\n\n                for (i = start; i < max; i += repeat) {\n                    breakArrayT.push({\n                        value: i,\n                        move: 'in'\n                    });\n                    breakArrayT.push({\n                        value: i + (brk.to - brk.from),\n                        move: 'out',\n                        size: brk.breakSize\n                    });\n                }\n            });\n\n            breakArrayT.sort(function (a, b) {\n                var ret;\n                if (a.value === b.value) {\n                    ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);\n                } else {\n                    ret = a.value - b.value;\n                }\n                return ret;\n            });\n\n            // Simplify the breaks\n            inBrk = 0;\n            start = min;\n\n            each(breakArrayT, function (brk) {\n                inBrk += (brk.move === 'in' ? 1 : -1);\n\n                if (inBrk === 1 && brk.move === 'in') {\n                    start = brk.value;\n                }\n                if (inBrk === 0) {\n                    breakArray.push({\n                        from: start,\n                        to: brk.value,\n                        len: brk.value - start - (brk.size || 0)\n                    });\n                    length += brk.value - start - (brk.size || 0);\n                }\n            });\n\n            axis.breakArray = breakArray;\n\n            // Used with staticScale, and below, the actual axis length when\n            // breaks are substracted.\n            axis.unitLength = max - min - length + pointRangePadding;\n\n            fireEvent(axis, 'afterBreaks');\n\n            if (axis.options.staticScale) {\n                axis.transA = axis.options.staticScale;\n            } else if (axis.unitLength) {\n                axis.transA *= (max - axis.min + pointRangePadding) /\n                    axis.unitLength;\n            }\n\n            if (pointRangePadding) {\n                axis.minPixelPadding = axis.transA * axis.minPointOffset;\n            }\n\n            axis.min = min;\n            axis.max = max;\n        };\n    }\n});\n\nwrap(Series.prototype, 'generatePoints', function (proceed) {\n\n    proceed.apply(this, stripArguments(arguments));\n\n    var series = this,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis,\n        points = series.points,\n        point,\n        i = points.length,\n        connectNulls = series.options.connectNulls,\n        nullGap;\n\n\n    if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {\n        while (i--) {\n            point = points[i];\n\n            // Respect nulls inside the break (#4275)\n            nullGap = point.y === null && connectNulls === false;\n            if (\n                !nullGap &&\n                (\n                    xAxis.isInAnyBreak(point.x, true) ||\n                    yAxis.isInAnyBreak(point.y, true)\n                )\n            ) {\n                points.splice(i, 1);\n                if (this.data[i]) {\n                    // Removes the graphics for this point if they exist\n                    this.data[i].destroyElements();\n                }\n            }\n        }\n    }\n\n});\n\nfunction drawPointsWrapped(proceed) {\n    proceed.apply(this);\n    this.drawBreaks(this.xAxis, ['x']);\n    this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n}\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.drawBreaks = function (axis, keys) {\n    var series = this,\n        points = series.points,\n        breaks,\n        threshold,\n        eventName,\n        y;\n\n    if (!axis) {\n        return; // #5950\n    }\n\n    each(keys, function (key) {\n        breaks = axis.breakArray || [];\n        threshold = axis.isXAxis ?\n            axis.min :\n            pick(series.options.threshold, axis.min);\n        each(points, function (point) {\n            y = pick(point['stack' + key.toUpperCase()], point[key]);\n            each(breaks, function (brk) {\n                eventName = false;\n\n                if (\n                    (threshold < brk.from && y > brk.to) ||\n                    (threshold > brk.from && y < brk.from)\n                ) {\n                    eventName = 'pointBreak';\n\n                } else if (\n                    (threshold < brk.from && y > brk.from && y < brk.to) ||\n                    (threshold > brk.from && y > brk.to && y < brk.from)\n                ) {\n                    eventName = 'pointInBreak';\n                }\n                if (eventName) {\n                    fireEvent(axis, eventName, { point: point, brk: brk });\n                }\n            });\n        });\n    });\n};\n\n\n/**\n * Extend getGraphPath by identifying gaps in the data so that we can draw a gap\n * in the line or area. This was moved from ordinal axis module to broken axis\n * module as of #5045.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.gappedPath = function () {\n    var currentDataGrouping = this.currentDataGrouping,\n        groupingSize = currentDataGrouping && currentDataGrouping.totalRange,\n        gapSize = this.options.gapSize,\n        points = this.points.slice(),\n        i = points.length - 1,\n        yAxis = this.yAxis,\n        xRange,\n        stack;\n\n    /**\n     * Defines when to display a gap in the graph, together with the\n     * [gapUnit](plotOptions.series.gapUnit) option.\n     *\n     * In case when `dataGrouping` is enabled, points can be grouped into a\n     * larger time span. This can make the grouped points to have a greater\n     * distance than the absolute value of `gapSize` property, which will result\n     * in disappearing graph completely. To prevent this situation the mentioned\n     * distance between grouped points is used instead of previously defined\n     * `gapSize`.\n     *\n     * In practice, this option is most often used to visualize gaps in\n     * time series. In a stock chart, intraday data is available for daytime\n     * hours, while gaps will appear in nights and weekends.\n     *\n     * @type    {Number}\n     * @see     [gapUnit](plotOptions.series.gapUnit) and\n     *          [xAxis.breaks](#xAxis.breaks)\n     * @sample  {highstock} stock/plotoptions/series-gapsize/\n     *          Setting the gap size to 2 introduces gaps for weekends in daily\n     *          datasets.\n     * @default 0\n     * @product highstock\n     * @apioption plotOptions.series.gapSize\n     */\n\n    /**\n     * Together with [gapSize](plotOptions.series.gapSize), this option defines\n     * where to draw gaps in the graph.\n     *\n     * When the `gapUnit` is `relative` (default), a gap size of 5 means\n     * that if the distance between two points is greater than five times\n     * that of the two closest points, the graph will be broken.\n     *\n     * When the `gapUnit` is `value`, the gap is based on absolute axis values,\n     * which on a datetime axis is milliseconds. This also applies to the\n     * navigator series that inherits gap options from the base series.\n     *\n     * @type {String}\n     * @see [gapSize](plotOptions.series.gapSize)\n     * @default relative\n     * @validvalue [\"relative\", \"value\"]\n     * @since 5.0.13\n     * @product highstock\n     * @apioption plotOptions.series.gapUnit\n     */\n\n    if (gapSize && i > 0) { // #5008\n\n        // Gap unit is relative\n        if (this.options.gapUnit !== 'value') {\n            gapSize *= this.closestPointRange;\n        }\n\n        // Setting a new gapSize in case dataGrouping is enabled (#7686)\n        if (groupingSize && groupingSize > gapSize) {\n            gapSize = groupingSize;\n        }\n\n        // extension for ordinal breaks\n        while (i--) {\n            if (points[i + 1].x - points[i].x > gapSize) {\n                xRange = (points[i].x + points[i + 1].x) / 2;\n\n                points.splice( // insert after this one\n                    i + 1,\n                    0,\n                    {\n                        isNull: true,\n                        x: xRange\n                    }\n                );\n\n                // For stacked chart generate empty stack items, #6546\n                if (this.options.stacking) {\n                    stack = yAxis.stacks[this.stackKey][xRange] =\n                        new _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StackItem(\n                            yAxis,\n                            yAxis.options.stackLabels,\n                            false,\n                            xRange,\n                            this.stack\n                        );\n                    stack.total = 0;\n                }\n            }\n        }\n    }\n\n    // Call base method\n    return this.getGraphPath(points);\n};\n\nwrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);\nwrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype, 'drawPoints', drawPointsWrapped);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/broken-axis.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/data.src.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/data.src.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _mixins_ajax_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixins/ajax.js */ \"./node_modules/highcharts/js/es-modules/mixins/ajax.js\");\n/**\n * Data module\n *\n * (c) 2012-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n// Utilities\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    win = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    doc = win.document,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    objectEach = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    inArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    splat = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    fireEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    some = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].some,\n    SeriesBuilder;\n\n\n/**\n * The Data module provides a simplified interface for adding data to\n * a chart from sources like CVS, HTML tables or grid views. See also\n * the [tutorial article on the Data module](https://www.highcharts.com/docs/working-\n * with-data/data-module).\n *\n * It requires the `modules/data.js` file to be loaded.\n *\n * Please note that the default way of adding data in Highcharts, without\n * the need of a module, is through the [series.data](#series.data)\n * option.\n *\n * @sample {highcharts} highcharts/demo/column-parsed/ HTML table\n * @sample {highcharts} highcharts/data/csv/ CSV\n * @since 4.0\n * @apioption data\n */\n\n/**\n * A callback function to modify the CSV before parsing it. Return the modified\n * string.\n *\n * @type {Function}\n * @sample {highcharts} highcharts/demo/line-ajax/ Modify CSV before parse\n * @since 6.1\n * @apioption data.beforeParse\n */\n\n/**\n * A two-dimensional array representing the input data on tabular form.\n * This input can be used when the data is already parsed, for example\n * from a grid view component. Each cell can be a string or number.\n * If not switchRowsAndColumns is set, the columns are interpreted as\n * series.\n *\n * @type {Array<Array<Mixed>>}\n * @see [data.rows](#data.rows)\n * @sample {highcharts} highcharts/data/columns/ Columns\n * @since 4.0\n * @apioption data.columns\n */\n\n/**\n * The callback that is evaluated when the data is finished loading,\n * optionally from an external source, and parsed. The first argument\n * passed is a finished chart options object, containing the series.\n * These options can be extended with additional options and passed\n * directly to the chart constructor.\n *\n * @type {Function}\n * @see [data.parsed](#data.parsed)\n * @sample {highcharts} highcharts/data/complete/ Modify data on complete\n * @since 4.0\n * @apioption data.complete\n */\n\n/**\n * A comma delimited string to be parsed. Related options are [startRow](\n * #data.startRow), [endRow](#data.endRow), [startColumn](#data.startColumn)\n * and [endColumn](#data.endColumn) to delimit what part of the table\n * is used. The [lineDelimiter](#data.lineDelimiter) and [itemDelimiter](\n * #data.itemDelimiter) options define the CSV delimiter formats.\n *\n * The built-in CSV parser doesn't support all flavours of CSV, so in\n * some cases it may be necessary to use an external CSV parser. See\n * [this example](https://jsfiddle.net/highcharts/u59176h4/) of parsing\n * CSV through the MIT licensed [Papa Parse](http://papaparse.com/)\n * library.\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/csv/ Data from CSV\n * @since 4.0\n * @apioption data.csv\n */\n\n/**\n * Which of the predefined date formats in Date.prototype.dateFormats\n * to use to parse date values. Defaults to a best guess based on what\n * format gives valid and ordered dates.\n *\n * Valid options include:\n *\n * *   `YYYY/mm/dd`\n * *   `dd/mm/YYYY`\n * *   `mm/dd/YYYY`\n * *   `dd/mm/YY`\n * *   `mm/dd/YY`\n *\n * @validvalue [undefined, \"YYYY/mm/dd\", \"dd/mm/YYYY\", \"mm/dd/YYYY\",\n *             \"dd/mm/YYYY\", \"dd/mm/YY\", \"mm/dd/YY\"]\n * @type {String}\n * @see [data.parseDate](#data.parseDate)\n * @sample {highcharts} highcharts/data/dateformat-auto/ Best guess date format\n * @since 4.0\n * @apioption data.dateFormat\n */\n\n/**\n * The decimal point used for parsing numbers in the CSV.\n *\n * If both this and data.delimiter is set to false, the parser will\n * attempt to deduce the decimal point automatically.\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/delimiters/ Comma as decimal point\n * @default .\n * @since 4.1.0\n * @apioption data.decimalPoint\n */\n\n/**\n * In tabular input data, the last column (indexed by 0) to use. Defaults\n * to the last column containing data.\n *\n * @type {Number}\n * @sample {highcharts} highcharts/data/start-end/ Limited data\n * @since 4.0\n * @apioption data.endColumn\n */\n\n/**\n * In tabular input data, the last row (indexed by 0) to use. Defaults\n * to the last row containing data.\n *\n * @type {Number}\n * @sample {highcharts} highcharts/data/start-end/ Limited data\n * @since 4.0.4\n * @apioption data.endRow\n */\n\n/**\n * Whether to use the first row in the data set as series names.\n *\n * @type {Boolean}\n * @sample {highcharts} highcharts/data/start-end/ Don't get series names from the CSV\n * @sample {highstock} highcharts/data/start-end/ Don't get series names from the CSV\n * @default true\n * @since 4.1.0\n * @product highcharts highstock\n * @apioption data.firstRowAsNames\n */\n\n/**\n * The key for a Google Spreadsheet to load. See [general information\n * on GS](https://developers.google.com/gdata/samples/spreadsheet_sample).\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/google-spreadsheet/\n *         Load a Google Spreadsheet\n * @since 4.0\n * @apioption data.googleSpreadsheetKey\n */\n\n/**\n * The Google Spreadsheet worksheet to use in combination with\n * [googleSpreadsheetKey](#data.googleSpreadsheetKey). The available id's from\n * your sheet can be read from `https://spreadsheets.google.com/feeds/worksheets/{key}/public/basic`.\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/google-spreadsheet/ Load a Google Spreadsheet\n * @since 4.0\n * @apioption data.googleSpreadsheetWorksheet\n */\n\n/**\n * Item or cell delimiter for parsing CSV. Defaults to the tab character\n * `\\t` if a tab character is found in the CSV string, if not it defaults\n * to `,`.\n *\n * If this is set to false or undefined, the parser will attempt to deduce\n * the delimiter automatically.\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/delimiters/ Delimiters\n * @since 4.0\n * @apioption data.itemDelimiter\n */\n\n/**\n * Line delimiter for parsing CSV.\n *\n * @type {String}\n * @sample {highcharts} highcharts/data/delimiters/ Delimiters\n * @default \\n\n * @since 4.0\n * @apioption data.lineDelimiter\n */\n\n/**\n * A callback function to parse string representations of dates into\n * JavaScript timestamps. Should return an integer timestamp on success.\n *\n * @type {Function}\n * @see [dateFormat](#data.dateFormat)\n * @since 4.0\n * @apioption data.parseDate\n */\n\n/**\n * A callback function to access the parsed columns, the two-dimentional\n * input data array directly, before they are interpreted into series\n * data and categories. Return `false` to stop completion, or call\n * `this.complete()` to continue async.\n *\n * @type {Function}\n * @see [data.complete](#data.complete)\n * @sample {highcharts} highcharts/data/parsed/ Modify data after parse\n * @since 4.0\n * @apioption data.parsed\n */\n\n/**\n * The same as the columns input option, but defining rows intead of\n * columns.\n *\n * @type {Array<Array<Mixed>>}\n * @see [data.columns](#data.columns)\n * @sample {highcharts} highcharts/data/rows/ Data in rows\n * @since 4.0\n * @apioption data.rows\n */\n\n/**\n * An array containing object with Point property names along with what\n * column id the property should be taken from.\n *\n * @type {Array<Object>}\n * @sample {highcharts} highcharts/data/seriesmapping-label/ Label from data set\n * @since 4.0.4\n * @apioption data.seriesMapping\n */\n\n/**\n * In tabular input data, the first column (indexed by 0) to use.\n *\n * @type {Number}\n * @sample {highcharts} highcharts/data/start-end/ Limited data\n * @default 0\n * @since 4.0\n * @apioption data.startColumn\n */\n\n/**\n * In tabular input data, the first row (indexed by 0) to use.\n *\n * @type {Number}\n * @sample {highcharts} highcharts/data/start-end/ Limited data\n * @default 0\n * @since 4.0\n * @apioption data.startRow\n */\n\n/**\n * Switch rows and columns of the input data, so that `this.columns`\n * effectively becomes the rows of the data set, and the rows are interpreted\n * as series.\n *\n * @type {Boolean}\n * @sample {highcharts} highcharts/data/switchrowsandcolumns/ Switch rows and columns\n * @default false\n * @since 4.0\n * @apioption data.switchRowsAndColumns\n */\n\n/**\n * An HTML table or the id of such to be parsed as input data. Related\n * options are `startRow`, `endRow`, `startColumn` and `endColumn` to\n * delimit what part of the table is used.\n *\n * @type {String|HTMLElement}\n * @sample {highcharts} highcharts/demo/column-parsed/ Parsed table\n * @since 4.0\n * @apioption data.table\n */\n\n/**\n * A URL to a remote CSV dataset.\n * Will be fetched when the chart is created using Ajax.\n *\n * @type {String}\n * @sample highcharts/data/livedata-columns\n *           Categorized bar chart with CSV and live polling\n * @sample highcharts/data/livedata-csv\n *         Time based line chart with CSV and live polling\n * @apioption data.csvURL\n */\n\n/**\n * A URL to a remote JSON dataset, structured as a row array.\n * Will be fetched when the chart is created using Ajax.\n *\n * @type {String}\n * @sample highcharts/data/livedata-rows\n *         Rows with live polling\n * @apioption data.rowsURL\n */\n\n/**\n * A URL to a remote JSON dataset, structured as a column array.\n * Will be fetched when the chart is created using Ajax.\n *\n * @type {String}\n * @sample highcharts/data/livedata-columns\n *         Columns with live polling\n * @apioption data.columnsURL\n */\n\n/**\n * Sets the refresh rate for data polling when importing remote dataset by\n * setting [data.csvURL](data.csvURL), [data.rowsURL](data.rowsURL),\n * [data.columnsURL](data.columnsURL), or\n * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).\n *\n * Note that polling must be enabled by setting\n * [data.enablePolling](data.enablePolling) to true.\n *\n * The value is the number of seconds between pollings.\n * It cannot be set to less than 1 second.\n *\n * @default 1\n * @type {Number}\n * @sample highcharts/demo/live-data\n *         Live data with user set refresh rate\n * @apioption data.dataRefreshRate\n */\n\n/**\n * Enables automatic refetching of remote datasets every _n_ seconds (defined by\n * setting [data.dataRefreshRate](data.dataRefreshRate)).\n *\n * Only works when either [data.csvURL](data.csvURL),\n * [data.rowsURL](data.rowsURL), [data.columnsURL](data.columnsURL), or\n * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).\n *\n * @sample highcharts/demo/live-data\n *         Live data\n * @sample highcharts/data/livedata-columns\n *           Categorized bar chart with CSV and live polling\n *\n * @type {Boolean}\n * @default false\n * @apioption data.enablePolling\n */\n\n// The Data constructor\nvar Data = function (dataOptions, chartOptions, chart) {\n    this.init(dataOptions, chartOptions, chart);\n};\n\n// Set the prototype properties\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(Data.prototype, {\n\n    /**\n     * Initialize the Data object with the given options\n     */\n    init: function (options, chartOptions, chart) {\n\n        var decimalPoint = options.decimalPoint,\n            hasData;\n\n        if (chartOptions) {\n            this.chartOptions = chartOptions;\n        }\n        if (chart) {\n            this.chart = chart;\n        }\n\n        if (decimalPoint !== '.' && decimalPoint !== ',') {\n            decimalPoint = undefined;\n        }\n\n        this.options = options;\n        this.columns = (\n            options.columns ||\n            this.rowsToColumns(options.rows) ||\n            []\n        );\n\n        this.firstRowAsNames = pick(\n            options.firstRowAsNames,\n            this.firstRowAsNames,\n            true\n        );\n\n        this.decimalRegex = (\n            decimalPoint &&\n            new RegExp('^(-?[0-9]+)' + decimalPoint + '([0-9]+)$') // eslint-disable-line security/detect-non-literal-regexp\n        );\n\n        // This is a two-dimensional array holding the raw, trimmed string\n        // values with the same organisation as the columns array. It makes it\n        // possible for example to revert from interpreted timestamps to\n        // string-based categories.\n        this.rawColumns = [];\n\n        // No need to parse or interpret anything\n        if (this.columns.length) {\n            this.dataFound();\n            hasData = true;\n        }\n\n        if (!hasData) {\n            // Fetch live data\n            hasData = this.fetchLiveData();\n        }\n\n        if (!hasData) {\n            // Parse a CSV string if options.csv is given. The parseCSV function\n            // returns a columns array, if it has no length, we have no data\n            hasData = Boolean(this.parseCSV().length);\n        }\n\n        if (!hasData) {\n            // Parse a HTML table if options.table is given\n            hasData = Boolean(this.parseTable().length);\n        }\n\n        if (!hasData) {\n            // Parse a Google Spreadsheet\n            hasData = this.parseGoogleSpreadsheet();\n        }\n\n        if (!hasData && options.afterComplete) {\n            options.afterComplete();\n        }\n    },\n\n    /**\n     * Get the column distribution. For example, a line series takes a single\n     * column for Y values. A range series takes two columns for low and high\n     * values respectively, and an OHLC series takes four columns.\n     */\n    getColumnDistribution: function () {\n        var chartOptions = this.chartOptions,\n            options = this.options,\n            xColumns = [],\n            getValueCount = function (type) {\n                return (\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes[type || 'line'].prototype\n                        .pointArrayMap ||\n                    [0]\n                ).length;\n            },\n            getPointArrayMap = function (type) {\n                return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes[type || 'line']\n                    .prototype.pointArrayMap;\n            },\n            globalType = (\n                chartOptions &&\n                chartOptions.chart &&\n                chartOptions.chart.type\n            ),\n            individualCounts = [],\n            seriesBuilders = [],\n            seriesIndex = 0,\n\n            // If no series mapping is defined, check if the series array is\n            // defined with types.\n            seriesMapping = (\n                (options && options.seriesMapping) ||\n                (\n                    chartOptions &&\n                    chartOptions.series &&\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map(chartOptions.series, function () {\n                        return { x: 0 };\n                    })\n                ) ||\n                []\n            ),\n            i;\n\n        each((chartOptions && chartOptions.series) || [], function (series) {\n            individualCounts.push(getValueCount(series.type || globalType));\n        });\n\n        // Collect the x-column indexes from seriesMapping\n        each(seriesMapping, function (mapping) {\n            xColumns.push(mapping.x || 0);\n        });\n\n        // If there are no defined series with x-columns, use the first column\n        // as x column\n        if (xColumns.length === 0) {\n            xColumns.push(0);\n        }\n\n        // Loop all seriesMappings and constructs SeriesBuilders from\n        // the mapping options.\n        each(seriesMapping, function (mapping) {\n            var builder = new SeriesBuilder(),\n                numberOfValueColumnsNeeded = individualCounts[seriesIndex] ||\n                    getValueCount(globalType),\n                seriesArr = (chartOptions && chartOptions.series) || [],\n                series = seriesArr[seriesIndex] || {},\n                pointArrayMap = getPointArrayMap(series.type || globalType) ||\n                    ['y'];\n\n            // Add an x reader from the x property or from an undefined column\n            // if the property is not set. It will then be auto populated later.\n            builder.addColumnReader(mapping.x, 'x');\n\n            // Add all column mappings\n            objectEach(mapping, function (val, name) {\n                if (name !== 'x') {\n                    builder.addColumnReader(val, name);\n                }\n            });\n\n            // Add missing columns\n            for (i = 0; i < numberOfValueColumnsNeeded; i++) {\n                if (!builder.hasReader(pointArrayMap[i])) {\n                    // Create and add a column reader for the next free column\n                    // index\n                    builder.addColumnReader(undefined, pointArrayMap[i]);\n                }\n            }\n\n            seriesBuilders.push(builder);\n            seriesIndex++;\n        });\n\n        var globalPointArrayMap = getPointArrayMap(globalType);\n        if (globalPointArrayMap === undefined) {\n            globalPointArrayMap = ['y'];\n        }\n\n        this.valueCount = {\n            global: getValueCount(globalType),\n            xColumns: xColumns,\n            individual: individualCounts,\n            seriesBuilders: seriesBuilders,\n            globalPointArrayMap: globalPointArrayMap\n        };\n    },\n\n    /**\n     * When the data is parsed into columns, either by CSV, table, GS or direct\n     * input, continue with other operations.\n     */\n    dataFound: function () {\n        if (this.options.switchRowsAndColumns) {\n            this.columns = this.rowsToColumns(this.columns);\n        }\n\n        // Interpret the info about series and columns\n        this.getColumnDistribution();\n\n        // Interpret the values into right types\n        this.parseTypes();\n\n        // Handle columns if a handleColumns callback is given\n        if (this.parsed() !== false) {\n\n            // Complete if a complete callback is given\n            this.complete();\n        }\n\n    },\n\n    /**\n     * Parse a CSV input string\n     */\n    parseCSV: function (inOptions) {\n        var self = this,\n            options = inOptions || this.options,\n            csv = options.csv,\n            columns,\n            startRow = (\n                typeof options.startRow !== 'undefined' && options.startRow ?\n                    options.startRow :\n                    0\n            ),\n            endRow = options.endRow || Number.MAX_VALUE,\n            startColumn = (\n                typeof options.startColumn !== 'undefined' &&\n                options.startColumn\n            ) ? options.startColumn : 0,\n            endColumn = options.endColumn || Number.MAX_VALUE,\n            itemDelimiter,\n            lines,\n            rowIt = 0,\n            // activeRowNo = 0,\n            dataTypes = [],\n            // We count potential delimiters in the prepass, and use the\n            // result as the basis of half-intelligent guesses.\n            potDelimiters = {\n                ',': 0,\n                ';': 0,\n                '\\t': 0\n            };\n\n        columns = this.columns = [];\n\n        /*\n            This implementation is quite verbose. It will be shortened once\n            it's stable and passes all the test.\n\n            It's also not written with speed in mind, instead everything is\n            very seggregated, and there a several redundant loops.\n            This is to make it easier to stabilize the code initially.\n\n            We do a pre-pass on the first 4 rows to make some intelligent\n            guesses on the set. Guessed delimiters are in this pass counted.\n\n            Auto detecting delimiters\n                - If we meet a quoted string, the next symbol afterwards\n                  (that's not \\s, \\t) is the delimiter\n                - If we meet a date, the next symbol afterwards is the delimiter\n\n            Date formats\n                - If we meet a column with date formats, check all of them to\n                  see if one of the potential months crossing 12. If it does,\n                  we now know the format\n\n            It would make things easier to guess the delimiter before\n            doing the actual parsing.\n\n            General rules:\n                - Quoting is allowed, e.g: \"Col 1\",123,321\n                - Quoting is optional, e.g.: Col1,123,321\n                - Doubble quoting is escaping, e.g. \"Col \"\"Hello world\"\"\",123\n                - Spaces are considered part of the data: Col1 ,123\n                - New line is always the row delimiter\n                - Potential column delimiters are , ; \\t\n                - First row may optionally contain headers\n                - The last row may or may not have a row delimiter\n                - Comments are optionally supported, in which case the comment\n                  must start at the first column, and the rest of the line will\n                  be ignored\n        */\n\n        // Parse a single row\n        function parseRow(columnStr, rowNumber, noAdd, callbacks) {\n            var i = 0,\n                c = '',\n                cl = '',\n                cn = '',\n                token = '',\n                actualColumn = 0,\n                column = 0;\n\n            function read(j) {\n                c = columnStr[j];\n                cl = columnStr[j - 1];\n                cn = columnStr[j + 1];\n            }\n\n            function pushType(type) {\n                if (dataTypes.length < column + 1) {\n                    dataTypes.push([type]);\n                }\n                if (dataTypes[column][dataTypes[column].length - 1] !== type) {\n                    dataTypes[column].push(type);\n                }\n            }\n\n            function push() {\n                if (startColumn > actualColumn || actualColumn > endColumn) {\n                    // Skip this column, but increment the column count (#7272)\n                    ++actualColumn;\n                    token = '';\n                    return;\n                }\n\n                if (!isNaN(parseFloat(token)) && isFinite(token)) {\n                    token = parseFloat(token);\n                    pushType('number');\n                } else if (!isNaN(Date.parse(token))) {\n                    token = token.replace(/\\//g, '-');\n                    pushType('date');\n                } else {\n                    pushType('string');\n                }\n\n\n                if (columns.length < column + 1) {\n                    columns.push([]);\n                }\n\n                if (!noAdd) {\n                    // Don't push - if there's a varrying amount of columns\n                    // for each row, pushing will skew everything down n slots\n                    columns[column][rowNumber] = token;\n                }\n\n                token = '';\n                ++column;\n                ++actualColumn;\n            }\n\n            if (!columnStr.trim().length) {\n                return;\n            }\n\n            if (columnStr.trim()[0] === '#') {\n                return;\n            }\n\n            for (; i < columnStr.length; i++) {\n                read(i);\n\n                // Quoted string\n                if (c === '#') {\n                    // The rest of the row is a comment\n                    push();\n                    return;\n                } else if (c === '\"') {\n                    read(++i);\n\n                    while (i < columnStr.length) {\n                        if (c === '\"' && cl !== '\"' && cn !== '\"') {\n                            break;\n                        }\n\n                        if (c !== '\"' || (c === '\"' && cl !== '\"')) {\n                            token += c;\n                        }\n\n                        read(++i);\n                    }\n\n                // Perform \"plugin\" handling\n                } else if (callbacks && callbacks[c]) {\n                    if (callbacks[c](c, token)) {\n                        push();\n                    }\n\n                // Delimiter - push current token\n                } else if (c === itemDelimiter) {\n                    push();\n\n                // Actual column data\n                } else {\n                    token += c;\n                }\n            }\n\n            push();\n\n        }\n\n        // Attempt to guess the delimiter\n        // We do a separate parse pass here because we need\n        // to count potential delimiters softly without making any assumptions.\n        function guessDelimiter(lines) {\n            var points = 0,\n                commas = 0,\n                guessed = false;\n\n            some(lines, function (columnStr, i) {\n                var inStr = false,\n                    c,\n                    cn,\n                    cl,\n                    token = ''\n                    ;\n\n\n                // We should be able to detect dateformats within 13 rows\n                if (i > 13) {\n                    return true;\n                }\n\n                for (var j = 0; j < columnStr.length; j++) {\n                    c = columnStr[j];\n                    cn = columnStr[j + 1];\n                    cl = columnStr[j - 1];\n\n                    if (c === '#') {\n                        // Skip the rest of the line - it's a comment\n                        return;\n                    } else if (c === '\"') {\n                        if (inStr) {\n                            if (cl !== '\"' && cn !== '\"') {\n                                while (cn === ' ' && j < columnStr.length) {\n                                    cn = columnStr[++j];\n                                }\n\n                                // After parsing a string, the next non-blank\n                                // should be a delimiter if the CSV is properly\n                                // formed.\n\n                                if (typeof potDelimiters[cn] !== 'undefined') {\n                                    potDelimiters[cn]++;\n                                }\n\n                                inStr = false;\n                            }\n                        } else {\n                            inStr = true;\n                        }\n                    } else if (typeof potDelimiters[c] !== 'undefined') {\n\n                        token = token.trim();\n\n                        if (!isNaN(Date.parse(token))) {\n                            potDelimiters[c]++;\n                        } else if (isNaN(token) || !isFinite(token)) {\n                            potDelimiters[c]++;\n                        }\n\n                        token = '';\n\n                    } else {\n                        token += c;\n                    }\n\n                    if (c === ',') {\n                        commas++;\n                    }\n\n                    if (c === '.') {\n                        points++;\n                    }\n                }\n            });\n\n            // Count the potential delimiters.\n            // This could be improved by checking if the number of delimiters\n            // equals the number of columns - 1\n\n            if (potDelimiters[';'] > potDelimiters[',']) {\n                guessed = ';';\n            } else if (potDelimiters[','] > potDelimiters[';']) {\n                guessed = ',';\n            } else {\n                // No good guess could be made..\n                guessed = ',';\n            }\n\n            // Try to deduce the decimal point if it's not explicitly set.\n            // If both commas or points is > 0 there is likely an issue\n            if (!options.decimalPoint) {\n                if (points > commas) {\n                    options.decimalPoint = '.';\n                } else {\n                    options.decimalPoint = ',';\n                }\n\n                // Apply a new decimal regex based on the presumed decimal sep.\n                self.decimalRegex = new RegExp( // eslint-disable-line security/detect-non-literal-regexp\n                    '^(-?[0-9]+)' +\n                    options.decimalPoint +\n                    '([0-9]+)$'\n                );\n            }\n\n            return guessed;\n        }\n\n        /* Tries to guess the date format\n         *    - Check if either month candidate exceeds 12\n         *  - Check if year is missing (use current year)\n         *  - Check if a shortened year format is used (e.g. 1/1/99)\n         *  - If no guess can be made, the user must be prompted\n         * data is the data to deduce a format based on\n         */\n        function deduceDateFormat(data, limit) {\n            var format = 'YYYY/mm/dd',\n                thing,\n                guessedFormat,\n                calculatedFormat,\n                i = 0,\n                madeDeduction = false,\n                // candidates = {},\n                stable = [],\n                max = [],\n                j;\n\n            if (!limit || limit > data.length) {\n                limit = data.length;\n            }\n\n            for (; i < limit; i++) {\n                if (\n                    typeof data[i] !== 'undefined' &&\n                    data[i] && data[i].length\n                ) {\n                    thing = data[i]\n                            .trim()\n                            .replace(/\\//g, ' ')\n                            .replace(/\\-/g, ' ')\n                            .split(' ');\n\n                    guessedFormat = [\n                        '',\n                        '',\n                        ''\n                    ];\n\n\n                    for (j = 0; j < thing.length; j++) {\n                        if (j < guessedFormat.length) {\n                            thing[j] = parseInt(thing[j], 10);\n\n                            if (thing[j]) {\n\n                                max[j] = (!max[j] || max[j] < thing[j]) ?\n                                    thing[j] :\n                                    max[j];\n\n                                if (typeof stable[j] !== 'undefined') {\n                                    if (stable[j] !== thing[j]) {\n                                        stable[j] = false;\n                                    }\n                                } else {\n                                    stable[j] = thing[j];\n                                }\n\n                                if (thing[j] > 31) {\n                                    if (thing[j] < 100) {\n                                        guessedFormat[j] = 'YY';\n                                    } else {\n                                        guessedFormat[j] = 'YYYY';\n                                    }\n                                    // madeDeduction = true;\n                                } else if (thing[j] > 12 && thing[j] <= 31) {\n                                    guessedFormat[j] = 'dd';\n                                    madeDeduction = true;\n                                } else if (!guessedFormat[j].length) {\n                                    guessedFormat[j] = 'mm';\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (madeDeduction) {\n\n                // This handles a few edge cases with hard to guess dates\n                for (j = 0; j < stable.length; j++) {\n                    if (stable[j] !== false) {\n                        if (\n                            max[j] > 12 &&\n                            guessedFormat[j] !== 'YY' &&\n                            guessedFormat[j] !== 'YYYY'\n                        ) {\n                            guessedFormat[j] = 'YY';\n                        }\n                    } else if (max[j] > 12 && guessedFormat[j] === 'mm') {\n                        guessedFormat[j] = 'dd';\n                    }\n                }\n\n                // If the middle one is dd, and the last one is dd,\n                // the last should likely be year.\n                if (guessedFormat.length === 3 &&\n                    guessedFormat[1] === 'dd' &&\n                    guessedFormat[2] === 'dd') {\n                    guessedFormat[2] = 'YY';\n                }\n\n                calculatedFormat = guessedFormat.join('/');\n\n                // If the caculated format is not valid, we need to present an\n                // error.\n\n                if (\n                    !(options.dateFormats || self.dateFormats)[calculatedFormat]\n                ) {\n                    // This should emit an event instead\n                    fireEvent('deduceDateFailed');\n                    return format;\n                }\n\n                return calculatedFormat;\n            }\n\n            return format;\n        }\n\n        /* Figure out the best axis types for the data\n         * - If the first column is a number, we're good\n         * - If the first column is a date, set to date/time\n         * - If the first column is a string, set to categories\n         */\n        function deduceAxisTypes() {\n\n        }\n\n        if (csv && options.beforeParse) {\n            csv = options.beforeParse.call(this, csv);\n        }\n\n        if (csv) {\n\n            lines = csv\n                .replace(/\\r\\n/g, '\\n') // Unix\n                .replace(/\\r/g, '\\n') // Mac\n                .split(options.lineDelimiter || '\\n');\n\n            if (!startRow || startRow < 0) {\n                startRow = 0;\n            }\n\n            if (!endRow || endRow >= lines.length) {\n                endRow = lines.length - 1;\n            }\n\n            if (options.itemDelimiter) {\n                itemDelimiter = options.itemDelimiter;\n            } else {\n                itemDelimiter = null;\n                itemDelimiter = guessDelimiter(lines);\n            }\n\n            var offset = 0;\n\n            for (rowIt = startRow; rowIt <= endRow; rowIt++) {\n                if (lines[rowIt][0] === '#') {\n                    offset++;\n                } else {\n                    parseRow(lines[rowIt], rowIt - startRow - offset);\n                }\n            }\n\n            // //Make sure that there's header columns for everything\n            // each(columns, function (col) {\n\n            // });\n\n            deduceAxisTypes();\n\n            if ((!options.columnTypes || options.columnTypes.length === 0) &&\n                dataTypes.length &&\n                dataTypes[0].length &&\n                dataTypes[0][1] === 'date' &&\n                !options.dateFormat) {\n                options.dateFormat = deduceDateFormat(columns[0]);\n            }\n\n\n            // each(lines, function (line, rowNo) {\n            //    var trimmed = self.trim(line),\n            //        isComment = trimmed.indexOf('#') === 0,\n            //        isBlank = trimmed === '',\n            //        items;\n\n            //    if (\n            //        rowNo >= startRow &&\n            //        rowNo <= endRow &&\n            //        !isComment && !isBlank\n            //    ) {\n            //        items = line.split(itemDelimiter);\n            //        each(items, function (item, colNo) {\n            //            if (colNo >= startColumn && colNo <= endColumn) {\n            //                if (!columns[colNo - startColumn]) {\n            //                    columns[colNo - startColumn] = [];\n            //                }\n\n            //                columns[colNo - startColumn][activeRowNo] = item;\n            //            }\n            //        });\n            //        activeRowNo += 1;\n            //    }\n            // });\n            //\n\n            this.dataFound();\n        }\n\n        return columns;\n    },\n\n    /**\n     * Parse a HTML table\n     */\n    parseTable: function () {\n        var options = this.options,\n            table = options.table,\n            columns = this.columns,\n            startRow = options.startRow || 0,\n            endRow = options.endRow || Number.MAX_VALUE,\n            startColumn = options.startColumn || 0,\n            endColumn = options.endColumn || Number.MAX_VALUE;\n\n        if (table) {\n\n            if (typeof table === 'string') {\n                table = doc.getElementById(table);\n            }\n\n            each(table.getElementsByTagName('tr'), function (tr, rowNo) {\n                if (rowNo >= startRow && rowNo <= endRow) {\n                    each(tr.children, function (item, colNo) {\n                        if (\n                            (item.tagName === 'TD' || item.tagName === 'TH') &&\n                            colNo >= startColumn &&\n                            colNo <= endColumn\n                        ) {\n                            if (!columns[colNo - startColumn]) {\n                                columns[colNo - startColumn] = [];\n                            }\n\n                            columns[colNo - startColumn][rowNo - startRow] =\n                                item.innerHTML;\n                        }\n                    });\n                }\n            });\n\n            this.dataFound(); // continue\n        }\n        return columns;\n    },\n\n\n    /**\n     * Fetch or refetch live data\n     */\n    fetchLiveData: function () {\n        var chart = this.chart,\n            options = this.options,\n            maxRetries = 3,\n            currentRetries = 0,\n            pollingEnabled = options.enablePolling,\n            updateIntervalMs = (options.dataRefreshRate || 2) * 1000,\n            originalOptions = merge(options);\n\n        if (!options ||\n            (!options.csvURL && !options.rowsURL && !options.columnsURL)\n        ) {\n            return false;\n        }\n\n        // Do not allow polling more than once a second\n        if (updateIntervalMs < 1000) {\n            updateIntervalMs = 1000;\n        }\n\n        delete options.csvURL;\n        delete options.rowsURL;\n        delete options.columnsURL;\n\n        function performFetch(initialFetch) {\n\n            // Helper function for doing the data fetch + polling\n            function request(url, done, tp) {\n                if (!url || url.indexOf('http') !== 0) {\n                    if (url && options.error) {\n                        options.error('Invalid URL');\n                    }\n                    return false;\n                }\n\n                if (initialFetch) {\n                    clearTimeout(chart.liveDataTimeout);\n                    chart.liveDataURL = url;\n                }\n\n                function poll() {\n                    // Poll\n                    if (pollingEnabled && chart.liveDataURL === url) {\n                        // We need to stop doing this if the URL has changed\n                        chart.liveDataTimeout =\n                            setTimeout(performFetch, updateIntervalMs);\n                    }\n                }\n\n                _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ajax({\n                    url: url,\n                    dataType: tp || 'json',\n                    success: function (res) {\n                        if (chart && chart.series) {\n                            done(res);\n                        }\n\n                        poll();\n\n                    },\n                    error: function (xhr, text) {\n                        if (++currentRetries < maxRetries) {\n                            poll();\n                        }\n\n                        return options.error && options.error(text, xhr);\n                    }\n                });\n\n                return true;\n            }\n\n            if (!request(originalOptions.csvURL, function (res) {\n                chart.update({\n                    data: {\n                        csv: res\n                    }\n                });\n            }, 'text')) {\n                if (!request(originalOptions.rowsURL, function (res) {\n                    chart.update({\n                        data: {\n                            rows: res\n                        }\n                    });\n                })) {\n                    request(originalOptions.columnsURL, function (res) {\n                        chart.update({\n                            data: {\n                                columns: res\n                            }\n                        });\n                    });\n                }\n            }\n        }\n\n        performFetch(true);\n\n        return (options &&\n            (options.csvURL || options.rowsURL || options.columnsURL)\n        );\n    },\n\n\n    /**\n     * Parse a Google spreadsheet.\n     */\n    parseGoogleSpreadsheet: function () {\n        var data = this,\n            options = this.options,\n            googleSpreadsheetKey = options.googleSpreadsheetKey,\n            chart = this.chart,\n            // use sheet 1 as the default rather than od6\n            // as the latter sometimes cause issues (it looks like it can\n            // be renamed in some cases, ref. a fogbugz case).\n            worksheet = options.googleSpreadsheetWorksheet || 1,\n            startRow = options.startRow || 0,\n            endRow = options.endRow || Number.MAX_VALUE,\n            startColumn = options.startColumn || 0,\n            endColumn = options.endColumn || Number.MAX_VALUE,\n            refreshRate = (options.dataRefreshRate || 2) * 1000;\n\n        if (refreshRate < 4000) {\n            refreshRate = 4000;\n        }\n\n        /*\n         * Fetch the actual spreadsheet using XMLHttpRequest\n         */\n        function fetchSheet(fn) {\n            var url = [\n                'https://spreadsheets.google.com/feeds/cells',\n                googleSpreadsheetKey,\n                worksheet,\n                'public/values?alt=json'\n            ].join('/');\n\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ajax({\n                url: url,\n                dataType: 'json',\n                success: function (json) {\n                    fn(json);\n\n                    if (options.enablePolling) {\n                        setTimeout(function () {\n                            fetchSheet(fn);\n                        }, options.dataRefreshRate);\n                    }\n                },\n                error: function (xhr, text) {\n                    return options.error && options.error(text, xhr);\n                }\n            });\n        }\n\n        if (googleSpreadsheetKey) {\n\n            delete options.googleSpreadsheetKey;\n\n            fetchSheet(function (json) {\n                // Prepare the data from the spreadsheat\n                var columns = [],\n                    cells = json.feed.entry,\n                    cell,\n                    cellCount = (cells || []).length,\n                    colCount = 0,\n                    rowCount = 0,\n                    val,\n                    gr,\n                    gc,\n                    cellInner,\n                    i;\n\n                if (!cells || cells.length === 0) {\n                    return false;\n                }\n\n                // First, find the total number of columns and rows that\n                // are actually filled with data\n                for (i = 0; i < cellCount; i++) {\n                    cell = cells[i];\n                    colCount = Math.max(colCount, cell.gs$cell.col);\n                    rowCount = Math.max(rowCount, cell.gs$cell.row);\n                }\n\n                // Set up arrays containing the column data\n                for (i = 0; i < colCount; i++) {\n                    if (i >= startColumn && i <= endColumn) {\n                        // Create new columns with the length of either\n                        // end-start or rowCount\n                        columns[i - startColumn] = [];\n                    }\n                }\n\n                // Loop over the cells and assign the value to the right\n                // place in the column arrays\n                for (i = 0; i < cellCount; i++) {\n                    cell = cells[i];\n                    gr = cell.gs$cell.row - 1; // rows start at 1\n                    gc = cell.gs$cell.col - 1; // columns start at 1\n\n                    // If both row and col falls inside start and end set the\n                    // transposed cell value in the newly created columns\n                    if (gc >= startColumn && gc <= endColumn &&\n                        gr >= startRow && gr <= endRow) {\n\n                        cellInner = cell.gs$cell || cell.content;\n\n                        val = null;\n\n                        if (cellInner.numericValue) {\n                            if (cellInner.$t.indexOf('/') >= 0 ||\n                                cellInner.$t.indexOf('-') >= 0) {\n                                // This is a date - for future reference.\n                                val = cellInner.$t;\n                            } else if (cellInner.$t.indexOf('%') > 0) {\n                                // Percentage\n                                val = parseFloat(cellInner.numericValue) * 100;\n                            } else {\n                                val = parseFloat(cellInner.numericValue);\n                            }\n                        } else if (cellInner.$t && cellInner.$t.length) {\n                            val = cellInner.$t;\n                        }\n\n                        columns[gc - startColumn][gr - startRow] = val;\n                    }\n                }\n\n                // Insert null for empty spreadsheet cells (#5298)\n                each(columns, function (column) {\n                    for (i = 0; i < column.length; i++) {\n                        if (column[i] === undefined) {\n                            column[i] = null;\n                        }\n                    }\n                });\n\n                if (chart && chart.series) {\n                    chart.update({\n                        data: {\n                            columns: columns\n                        }\n                    });\n                } else { // #8245\n                    data.columns = columns;\n                    data.dataFound();\n                }\n            });\n        }\n\n        // This is an intermediate fetch, so always return false.\n        return false;\n    },\n\n    /**\n     * Trim a string from whitespace\n     */\n    trim: function (str, inside) {\n        if (typeof str === 'string') {\n            str = str.replace(/^\\s+|\\s+$/g, '');\n\n            // Clear white space insdie the string, like thousands separators\n            if (inside && /^[0-9\\s]+$/.test(str)) {\n                str = str.replace(/\\s/g, '');\n            }\n\n            if (this.decimalRegex) {\n                str = str.replace(this.decimalRegex, '$1.$2');\n            }\n        }\n        return str;\n    },\n\n    /**\n     * Parse numeric cells in to number types and date types in to true dates.\n     */\n    parseTypes: function () {\n        var columns = this.columns,\n            col = columns.length;\n\n        while (col--) {\n            this.parseColumn(columns[col], col);\n        }\n\n    },\n\n    /**\n     * Parse a single column. Set properties like .isDatetime and .isNumeric.\n     */\n    parseColumn: function (column, col) {\n        var rawColumns = this.rawColumns,\n            columns = this.columns,\n            row = column.length,\n            val,\n            floatVal,\n            trimVal,\n            trimInsideVal,\n            firstRowAsNames = this.firstRowAsNames,\n            isXColumn = inArray(col, this.valueCount.xColumns) !== -1,\n            dateVal,\n            backup = [],\n            diff,\n            chartOptions = this.chartOptions,\n            descending,\n            columnTypes = this.options.columnTypes || [],\n            columnType = columnTypes[col],\n            forceCategory = isXColumn && ((\n                chartOptions &&\n                chartOptions.xAxis &&\n                splat(chartOptions.xAxis)[0].type === 'category'\n            ) || columnType === 'string');\n\n        if (!rawColumns[col]) {\n            rawColumns[col] = [];\n        }\n        while (row--) {\n            val = backup[row] || column[row];\n\n            trimVal = this.trim(val);\n            trimInsideVal = this.trim(val, true);\n            floatVal = parseFloat(trimInsideVal);\n\n            // Set it the first time\n            if (rawColumns[col][row] === undefined) {\n                rawColumns[col][row] = trimVal;\n            }\n\n            // Disable number or date parsing by setting the X axis type to\n            // category\n            if (forceCategory || (row === 0 && firstRowAsNames)) {\n                column[row] = '' + trimVal;\n\n            } else if (+trimInsideVal === floatVal) { // is numeric\n\n                column[row] = floatVal;\n\n                // If the number is greater than milliseconds in a year, assume\n                // datetime\n                if (\n                    floatVal > 365 * 24 * 3600 * 1000 &&\n                    columnType !== 'float'\n                ) {\n                    column.isDatetime = true;\n                } else {\n                    column.isNumeric = true;\n                }\n\n                if (column[row + 1] !== undefined) {\n                    descending = floatVal > column[row + 1];\n                }\n\n            // String, continue to determine if it is a date string or really a\n            // string\n            } else {\n                if (trimVal && trimVal.length) {\n                    dateVal = this.parseDate(val);\n                }\n\n                // Only allow parsing of dates if this column is an x-column\n                if (isXColumn && isNumber(dateVal) && columnType !== 'float') {\n                    backup[row] = val;\n                    column[row] = dateVal;\n                    column.isDatetime = true;\n\n                    // Check if the dates are uniformly descending or ascending.\n                    // If they are not, chances are that they are a different\n                    // time format, so check for alternative.\n                    if (column[row + 1] !== undefined) {\n                        diff = dateVal > column[row + 1];\n                        if (diff !== descending && descending !== undefined) {\n                            if (this.alternativeFormat) {\n                                this.dateFormat = this.alternativeFormat;\n                                row = column.length;\n                                this.alternativeFormat =\n                                    this.dateFormats[this.dateFormat]\n                                        .alternative;\n                            } else {\n                                column.unsorted = true;\n                            }\n                        }\n                        descending = diff;\n                    }\n\n                } else { // string\n                    column[row] = trimVal === '' ? null : trimVal;\n                    if (row !== 0 && (column.isDatetime || column.isNumeric)) {\n                        column.mixed = true;\n                    }\n                }\n            }\n        }\n\n        // If strings are intermixed with numbers or dates in a parsed column,\n        // it is an indication that parsing went wrong or the data was not\n        // intended to display as numbers or dates and parsing is too\n        // aggressive. Fall back to categories. Demonstrated in the\n        // highcharts/demo/column-drilldown sample.\n        if (isXColumn && column.mixed) {\n            columns[col] = rawColumns[col];\n        }\n\n        // If the 0 column is date or number and descending, reverse all\n        // columns.\n        if (isXColumn && descending && this.options.sort) {\n            for (col = 0; col < columns.length; col++) {\n                columns[col].reverse();\n                if (firstRowAsNames) {\n                    columns[col].unshift(columns[col].pop());\n                }\n            }\n        }\n    },\n\n    /**\n     * A collection of available date formats, extendable from the outside to\n     * support custom date formats.\n     */\n    dateFormats: {\n        'YYYY/mm/dd': {\n            regex: /^([0-9]{4})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})$/,\n            parser: function (match) {\n                return Date.UTC(+match[1], match[2] - 1, +match[3]);\n            }\n        },\n        'dd/mm/YYYY': {\n            regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{4})$/,\n            parser: function (match) {\n                return Date.UTC(+match[3], match[2] - 1, +match[1]);\n            },\n            alternative: 'mm/dd/YYYY' // different format with the same regex\n        },\n        'mm/dd/YYYY': {\n            regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{4})$/,\n            parser: function (match) {\n                return Date.UTC(+match[3], match[1] - 1, +match[2]);\n            }\n        },\n        'dd/mm/YY': {\n            regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{2})$/,\n            parser: function (match) {\n                var year = +match[3],\n                    d = new Date()\n                ;\n\n                if (year > (d.getFullYear() - 2000)) {\n                    year += 1900;\n                } else {\n                    year += 2000;\n                }\n\n                return Date.UTC(year, match[2] - 1, +match[1]);\n            },\n            alternative: 'mm/dd/YY' // different format with the same regex\n        },\n        'mm/dd/YY': {\n            regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{2})$/,\n            parser: function (match) {\n                return Date.UTC(+match[3] + 2000, match[1] - 1, +match[2]);\n            }\n        }\n    },\n\n    /**\n     * Parse a date and return it as a number. Overridable through\n     * `options.parseDate`.\n     */\n    parseDate: function (val) {\n        var parseDate = this.options.parseDate,\n            ret,\n            key,\n            format,\n            dateFormat = this.options.dateFormat || this.dateFormat,\n            match;\n\n        if (parseDate) {\n            ret = parseDate(val);\n\n        } else if (typeof val === 'string') {\n            // Auto-detect the date format the first time\n            if (!dateFormat) {\n                for (key in this.dateFormats) {\n                    format = this.dateFormats[key];\n                    match = val.match(format.regex);\n                    if (match) {\n                        this.dateFormat = dateFormat = key;\n                        this.alternativeFormat = format.alternative;\n                        ret = format.parser(match);\n                        break;\n                    }\n                }\n            // Next time, use the one previously found\n            } else {\n                format = this.dateFormats[dateFormat];\n\n\n                if (!format) {\n                    // The selected format is invalid\n                    format = this.dateFormats['YYYY/mm/dd'];\n                }\n\n                match = val.match(format.regex);\n                if (match) {\n                    ret = format.parser(match);\n                }\n\n            }\n            // Fall back to Date.parse\n            if (!match) {\n                match = Date.parse(val);\n                // External tools like Date.js and MooTools extend Date object\n                // and returns a date.\n                if (\n                    typeof match === 'object' &&\n                    match !== null &&\n                    match.getTime\n                ) {\n                    ret = match.getTime() - match.getTimezoneOffset() * 60000;\n\n                // Timestamp\n                } else if (isNumber(match)) {\n                    ret = match - (new Date(match)).getTimezoneOffset() * 60000;\n                }\n            }\n        }\n        return ret;\n    },\n\n    /**\n     * Reorganize rows into columns\n     */\n    rowsToColumns: function (rows) {\n        var row,\n            rowsLength,\n            col,\n            colsLength,\n            columns;\n\n        if (rows) {\n            columns = [];\n            rowsLength = rows.length;\n            for (row = 0; row < rowsLength; row++) {\n                colsLength = rows[row].length;\n                for (col = 0; col < colsLength; col++) {\n                    if (!columns[col]) {\n                        columns[col] = [];\n                    }\n                    columns[col][row] = rows[row][col];\n                }\n            }\n        }\n        return columns;\n    },\n\n    /**\n     * A hook for working directly on the parsed columns\n     */\n    parsed: function () {\n        if (this.options.parsed) {\n            return this.options.parsed.call(this, this.columns);\n        }\n    },\n\n    getFreeIndexes: function (numberOfColumns, seriesBuilders) {\n        var s,\n            i,\n            freeIndexes = [],\n            freeIndexValues = [],\n            referencedIndexes;\n\n        // Add all columns as free\n        for (i = 0; i < numberOfColumns; i = i + 1) {\n            freeIndexes.push(true);\n        }\n\n        // Loop all defined builders and remove their referenced columns\n        for (s = 0; s < seriesBuilders.length; s = s + 1) {\n            referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();\n\n            for (i = 0; i < referencedIndexes.length; i = i + 1) {\n                freeIndexes[referencedIndexes[i]] = false;\n            }\n        }\n\n        // Collect the values for the free indexes\n        for (i = 0; i < freeIndexes.length; i = i + 1) {\n            if (freeIndexes[i]) {\n                freeIndexValues.push(i);\n            }\n        }\n\n        return freeIndexValues;\n    },\n\n    /**\n     * If a complete callback function is provided in the options, interpret the\n     * columns into a Highcharts options object.\n     */\n    complete: function () {\n\n        var columns = this.columns,\n            xColumns = [],\n            type,\n            options = this.options,\n            series,\n            data,\n            i,\n            j,\n            r,\n            seriesIndex,\n            chartOptions,\n            allSeriesBuilders = [],\n            builder,\n            freeIndexes,\n            typeCol,\n            index;\n\n        xColumns.length = columns.length;\n        if (options.complete || options.afterComplete) {\n\n            // Get the names and shift the top row\n            if (this.firstRowAsNames) {\n                for (i = 0; i < columns.length; i++) {\n                    columns[i].name = columns[i].shift();\n                }\n            }\n\n            // Use the next columns for series\n            series = [];\n            freeIndexes = this.getFreeIndexes(\n                columns.length,\n                this.valueCount.seriesBuilders\n            );\n\n            // Populate defined series\n            for (\n                seriesIndex = 0;\n                seriesIndex < this.valueCount.seriesBuilders.length;\n                seriesIndex++\n            ) {\n                builder = this.valueCount.seriesBuilders[seriesIndex];\n\n                // If the builder can be populated with remaining columns, then\n                // add it to allBuilders\n                if (builder.populateColumns(freeIndexes)) {\n                    allSeriesBuilders.push(builder);\n                }\n            }\n\n            // Populate dynamic series\n            while (freeIndexes.length > 0) {\n                builder = new SeriesBuilder();\n                builder.addColumnReader(0, 'x');\n\n                // Mark index as used (not free)\n                index = inArray(0, freeIndexes);\n                if (index !== -1) {\n                    freeIndexes.splice(index, 1);\n                }\n\n                for (i = 0; i < this.valueCount.global; i++) {\n                    // Create and add a column reader for the next free column\n                    // index\n                    builder.addColumnReader(\n                        undefined,\n                        this.valueCount.globalPointArrayMap[i]\n                    );\n                }\n\n                // If the builder can be populated with remaining columns, then\n                // add it to allBuilders\n                if (builder.populateColumns(freeIndexes)) {\n                    allSeriesBuilders.push(builder);\n                }\n            }\n\n            // Get the data-type from the first series x column\n            if (\n                allSeriesBuilders.length > 0 &&\n                allSeriesBuilders[0].readers.length > 0\n            ) {\n                typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];\n                if (typeCol !== undefined) {\n                    if (typeCol.isDatetime) {\n                        type = 'datetime';\n                    } else if (!typeCol.isNumeric) {\n                        type = 'category';\n                    }\n                }\n            }\n            // Axis type is category, then the \"x\" column should be called\n            // \"name\"\n            if (type === 'category') {\n                for (\n                    seriesIndex = 0;\n                    seriesIndex < allSeriesBuilders.length;\n                    seriesIndex++\n                ) {\n                    builder = allSeriesBuilders[seriesIndex];\n                    for (r = 0; r < builder.readers.length; r++) {\n                        if (builder.readers[r].configName === 'x') {\n                            builder.readers[r].configName = 'name';\n                        }\n                    }\n                }\n            }\n\n            // Read data for all builders\n            for (\n                seriesIndex = 0;\n                seriesIndex < allSeriesBuilders.length;\n                seriesIndex++\n            ) {\n                builder = allSeriesBuilders[seriesIndex];\n\n                // Iterate down the cells of each column and add data to the\n                // series\n                data = [];\n                for (j = 0; j < columns[0].length; j++) {\n                    data[j] = builder.read(columns, j);\n                }\n\n                // Add the series\n                series[seriesIndex] = {\n                    data: data\n                };\n                if (builder.name) {\n                    series[seriesIndex].name = builder.name;\n                }\n                if (type === 'category') {\n                    series[seriesIndex].turboThreshold = 0;\n                }\n            }\n\n\n\n            // Do the callback\n            chartOptions = {\n                series: series\n            };\n            if (type) {\n                chartOptions.xAxis = {\n                    type: type\n                };\n                if (type === 'category') {\n                    chartOptions.xAxis.uniqueNames = false;\n                }\n            }\n\n            if (options.complete) {\n                options.complete(chartOptions);\n            }\n\n            // The afterComplete hook is used internally to avoid conflict with\n            // the externally available complete option.\n            if (options.afterComplete) {\n                options.afterComplete(chartOptions);\n            }\n        }\n\n    },\n\n    update: function (options, redraw) {\n        var chart = this.chart;\n        if (options) {\n            // Set the complete handler\n            options.afterComplete = function (dataOptions) {\n                // Avoid setting axis options unless the type changes. Running\n                // Axis.update will cause the whole structure to be destroyed\n                // and rebuilt, and animation is lost.\n                if (\n                    dataOptions.xAxis &&\n                    chart.xAxis[0] &&\n                    dataOptions.xAxis.type === chart.xAxis[0].options.type\n                ) {\n                    delete dataOptions.xAxis;\n                }\n\n                chart.update(dataOptions, redraw, true);\n            };\n            // Apply it\n            merge(true, this.options, options);\n            this.init(this.options);\n        }\n    }\n});\n\n// Register the Data prototype and data function on Highcharts\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Data = Data;\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].data = function (options, chartOptions) {\n    return new Data(options, chartOptions);\n};\n\n// Extend Chart.init so that the Chart constructor accepts a new configuration\n// option group, data.\naddEvent(\n    Chart,\n    'init',\n    function (e) {\n        var chart = this,\n            userOptions = e.args[0],\n            callback = e.args[1];\n\n        if (userOptions && userOptions.data && !chart.hasDataDef) {\n            chart.hasDataDef = true;\n            chart.data = new Data(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(userOptions.data, {\n\n                afterComplete: function (dataOptions) {\n                    var i, series;\n\n                    // Merge series configs\n                    if (userOptions.hasOwnProperty('series')) {\n                        if (typeof userOptions.series === 'object') {\n                            i = Math.max(\n                                userOptions.series.length,\n                                dataOptions && dataOptions.series ?\n                                    dataOptions.series.length :\n                                    0\n                            );\n                            while (i--) {\n                                series = userOptions.series[i] || {};\n                                userOptions.series[i] = merge(\n                                    series,\n                                    dataOptions && dataOptions.series ?\n                                        dataOptions.series[i] :\n                                        {}\n                                );\n                            }\n                        } else { // Allow merging in dataOptions.series (#2856)\n                            delete userOptions.series;\n                        }\n                    }\n\n                    // Do the merge\n                    userOptions = merge(dataOptions, userOptions);\n\n                    // Run chart.init again\n                    chart.init(userOptions, callback);\n                }\n            }), userOptions, chart);\n\n            e.preventDefault();\n        }\n    }\n);\n\n/**\n * Creates a new SeriesBuilder. A SeriesBuilder consists of a number\n * of ColumnReaders that reads columns and give them a name.\n * Ex: A series builder can be constructed to read column 3 as 'x' and\n * column 7 and 8 as 'y1' and 'y2'.\n * The output would then be points/rows of the form {x: 11, y1: 22, y2: 33}\n *\n * The name of the builder is taken from the second column. In the above\n * example it would be the column with index 7.\n * @constructor\n */\nSeriesBuilder = function () {\n    this.readers = [];\n    this.pointIsArray = true;\n};\n\n/**\n * Populates readers with column indexes. A reader can be added without\n * a specific index and for those readers the index is taken sequentially\n * from the free columns (this is handled by the ColumnCursor instance).\n * @returns {boolean}\n */\nSeriesBuilder.prototype.populateColumns = function (freeIndexes) {\n    var builder = this,\n        enoughColumns = true;\n\n    // Loop each reader and give it an index if its missing.\n    // The freeIndexes.shift() will return undefined if there\n    // are no more columns.\n    each(builder.readers, function (reader) {\n        if (reader.columnIndex === undefined) {\n            reader.columnIndex = freeIndexes.shift();\n        }\n    });\n\n    // Now, all readers should have columns mapped. If not\n    // then return false to signal that this series should\n    // not be added.\n    each(builder.readers, function (reader) {\n        if (reader.columnIndex === undefined) {\n            enoughColumns = false;\n        }\n    });\n\n    return enoughColumns;\n};\n\n/**\n * Reads a row from the dataset and returns a point or array depending\n * on the names of the readers.\n * @param columns\n * @param rowIndex\n * @returns {Array | Object}\n */\nSeriesBuilder.prototype.read = function (columns, rowIndex) {\n    var builder = this,\n        pointIsArray = builder.pointIsArray,\n        point = pointIsArray ? [] : {},\n        columnIndexes;\n\n    // Loop each reader and ask it to read its value.\n    // Then, build an array or point based on the readers names.\n    each(builder.readers, function (reader) {\n        var value = columns[reader.columnIndex][rowIndex];\n        if (pointIsArray) {\n            point.push(value);\n        } else {\n            if (reader.configName.indexOf('.') > 0) {\n                // Handle nested property names\n                _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.setNestedProperty(\n                    point, value, reader.configName\n                );\n            } else {\n                point[reader.configName] = value;\n            }\n        }\n    });\n\n    // The name comes from the first column (excluding the x column)\n    if (this.name === undefined && builder.readers.length >= 2) {\n        columnIndexes = builder.getReferencedColumnIndexes();\n        if (columnIndexes.length >= 2) {\n            // remove the first one (x col)\n            columnIndexes.shift();\n\n            // Sort the remaining\n            columnIndexes.sort(function (a, b) {\n                return a - b;\n            });\n\n            // Now use the lowest index as name column\n            this.name = columns[columnIndexes.shift()].name;\n        }\n    }\n\n    return point;\n};\n\n/**\n * Creates and adds ColumnReader from the given columnIndex and configName.\n * ColumnIndex can be undefined and in that case the reader will be given\n * an index when columns are populated.\n * @param columnIndex {Number | undefined}\n * @param configName\n */\nSeriesBuilder.prototype.addColumnReader = function (columnIndex, configName) {\n    this.readers.push({\n        columnIndex: columnIndex,\n        configName: configName\n    });\n\n    if (\n        !(configName === 'x' || configName === 'y' || configName === undefined)\n    ) {\n        this.pointIsArray = false;\n    }\n};\n\n/**\n * Returns an array of column indexes that the builder will use when\n * reading data.\n * @returns {Array}\n */\nSeriesBuilder.prototype.getReferencedColumnIndexes = function () {\n    var i,\n        referencedColumnIndexes = [],\n        columnReader;\n\n    for (i = 0; i < this.readers.length; i = i + 1) {\n        columnReader = this.readers[i];\n        if (columnReader.columnIndex !== undefined) {\n            referencedColumnIndexes.push(columnReader.columnIndex);\n        }\n    }\n\n    return referencedColumnIndexes;\n};\n\n/**\n * Returns true if the builder has a reader for the given configName.\n * @param configName\n * @returns {boolean}\n */\nSeriesBuilder.prototype.hasReader = function (configName) {\n    var i, columnReader;\n    for (i = 0; i < this.readers.length; i = i + 1) {\n        columnReader = this.readers[i];\n        if (columnReader.configName === configName) {\n            return true;\n        }\n    }\n    // Else return undefined\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/data.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/drilldown.src.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/drilldown.src.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_ColumnSeries_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/ColumnSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js\");\n/* harmony import */ var _parts_Tick_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts/Tick.js */ \"./node_modules/highcharts/js/es-modules/parts/Tick.js\");\n/**\n * Highcharts Drilldown module\n *\n * Author: Torstein Honsi\n * License: www.highcharts.com/license\n *\n */\n\n\n\n\n\n\n\n\n\n\nvar animObject = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    defaultOptions = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    format = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    objectEach = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    PieSeries = seriesTypes.pie,\n    ColumnSeries = seriesTypes.column,\n    Tick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick,\n    fireEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    inArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    ddSeriesId = 1;\n\n// Add language\nextend(defaultOptions.lang, {\n    /**\n     * The text for the button that appears when drilling down, linking\n     * back to the parent series. The parent series' name is inserted for\n     * `{series.name}`.\n     *\n     * @type {String}\n     * @default Back to {series.name}\n     * @since 3.0.8\n     * @product highcharts highmaps\n     * @apioption lang.drillUpText\n     */\n    drillUpText: ' Back to {series.name}'\n});\n\n/**\n * Options for drill down, the concept of inspecting increasingly high\n * resolution data through clicking on chart items like columns or pie slices.\n *\n * The drilldown feature requires the drilldown.js file to be loaded,\n * found in the modules directory of the download package, or online at\n * [code.highcharts.com/modules/drilldown.js\n * ](code.highcharts.com/modules/drilldown.js).\n *\n * @type {Object}\n * @optionparent drilldown\n */\ndefaultOptions.drilldown = {\n\n    /**\n     * When this option is false, clicking a single point will drill down\n     * all points in the same category, equivalent to clicking the X axis\n     * label.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/drilldown/allowpointdrilldown-false/\n     *         Don't allow point drilldown\n     * @default true\n     * @since 4.1.7\n     * @product highcharts\n     * @apioption drilldown.allowPointDrilldown\n     */\n\n    /**\n     * An array of series configurations for the drill down. Each series\n     * configuration uses the same syntax as the [series](#series) option\n     * set. These drilldown series are hidden by default. The drilldown\n     * series is linked to the parent series' point by its `id`.\n     *\n     * @type {Array<Object>}\n     * @since 3.0.8\n     * @product highcharts highmaps\n     * @apioption drilldown.series\n     */\n\n    \n\n    /**\n     * Set the animation for all drilldown animations. Animation of a drilldown\n     * occurs when drilling between a column point and a column series,\n     * or a pie slice and a full pie series. Drilldown can still be used\n     * between series and points of different types, but animation will\n     * not occur.\n     *\n     * The animation can either be set as a boolean or a configuration\n     * object. If `true`, it will use the 'swing' jQuery easing and a duration\n     * of 500 ms. If used as a configuration object, the following properties\n     * are supported:\n     *\n     * <dl>\n     *\n     * <dt>duration</dt>\n     *\n     * <dd>The duration of the animation in milliseconds.</dd>\n     *\n     * <dt>easing</dt>\n     *\n     * <dd>A string reference to an easing function set on the `Math` object.\n     * See [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-\n     * animation-easing/).</dd>\n     *\n     * </dl>\n     *\n     * @type {Boolean|AnimationOptions}\n     * @since 3.0.8\n     * @product highcharts highmaps\n     */\n    animation: {\n\n        /**\n         * Duration for the drilldown animation.\n         * @default 500\n         */\n        duration: 500\n    },\n\n    /**\n     * Options for the drill up button that appears when drilling down\n     * on a series. The text for the button is defined in\n     * [lang.drillUpText](#lang.drillUpText).\n     *\n     * @type {Object}\n     * @sample {highcharts} highcharts/drilldown/drillupbutton/ Drill up button\n     * @sample {highmaps} highcharts/drilldown/drillupbutton/ Drill up button\n     * @since 3.0.8\n     * @product highcharts highmaps\n     */\n    drillUpButton: {\n        /**\n         * What box to align the button to. Can be either `plotBox` or\n         * `spacingBox`.\n         *\n         * @type {String}\n         * @default plotBox\n         * @validvalue [\"plotBox\", \"spacingBox\"]\n         * @since 3.0.8\n         * @product highcharts highmaps\n         * @apioption drilldown.drillUpButton.relativeTo\n         */\n\n        /**\n         * A collection of attributes for the button. The object takes SVG\n         * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border\n         * radius. The theme also supports `style`, a collection of CSS\n         * properties for the text. Equivalent attributes for the hover state\n         * are given in `theme.states.hover`.\n         *\n         * @type {Object}\n         * @see    In styled mode, drill-up button styles can be applied with\n         *         the `.highcharts-drillup-button` class.\n         * @sample {highcharts} highcharts/drilldown/drillupbutton/\n         *         Button theming\n         * @sample {highmaps} highcharts/drilldown/drillupbutton/\n         *         Button theming\n         * @since 3.0.8\n         * @product highcharts highmaps\n         * @apioption drilldown.drillUpButton.theme\n         */\n\n        /**\n         * Positioning options for the button within the `relativeTo` box.\n         * Available properties are `x`, `y`, `align` and `verticalAlign`.\n         *\n         * @type {Object}\n         * @since 3.0.8\n         * @product highcharts highmaps\n         */\n        position: {\n\n            /**\n             * Vertical alignment of the button.\n             *\n             * @type {String}\n             * @default top\n             * @validvalue [\"top\", \"middle\", \"bottom\"]\n             * @product highcharts highmaps\n             * @apioption drilldown.drillUpButton.position.verticalAlign\n             */\n\n            /**\n             * Horizontal alignment.\n             * @validvalue [\"left\", \"center\", \"right\"]\n             * @type {String}\n             */\n            align: 'right',\n\n            /**\n             * The X offset of the button.\n             * @type {Number}\n             */\n            x: -10,\n\n            /**\n             * The Y offset of the button.\n             * @type {Number}\n             */\n            y: 10\n        }\n    }\n};\n\n\n\n/**\n * Fires when a drilldown point is clicked, before the new series is\n * added. This event is also utilized for async drilldown, where the\n * seriesOptions are not added by option, but rather loaded async. Note\n * that when clicking a category label to trigger multiple series drilldown,\n * one `drilldown` event is triggered per point in the category.\n *\n * Event arguments:\n *\n * <dl>\n *\n * <dt>`category`</dt>\n *\n * <dd>If a category label was clicked, which index.</dd>\n *\n * <dt>`point`</dt>\n *\n * <dd>The originating point.</dd>\n *\n * <dt>`originalEvent`</dt>\n *\n * <dd>The original browser event (usually click) that triggered the\n * drilldown.</dd>\n *\n * <dt>`points`</dt>\n *\n * <dd>If a category label was clicked, this array holds all points\n * corresponing to the category.</dd>\n *\n * <dt>`seriesOptions`</dt>\n *\n * <dd>Options for the new series</dd>\n *\n * </dl>\n *\n * @type {Function}\n * @context Chart\n * @sample {highcharts} highcharts/drilldown/async/ Async drilldown\n * @since 3.0.8\n * @product highcharts highmaps\n * @apioption chart.events.drilldown\n */\n\n /**\n * Fires when drilling up from a drilldown series.\n *\n * @type {Function}\n * @context Chart\n * @since 3.0.8\n * @product highcharts highmaps\n * @apioption chart.events.drillup\n */\n\n/**\n * In a chart with multiple drilldown series, this event fires after\n * all the series have been drilled up.\n *\n * @type {Function}\n * @context Chart\n * @since 4.2.4\n * @product highcharts highmaps\n * @apioption chart.events.drillupall\n */\n\n/**\n * The `id` of a series in the [drilldown.series](#drilldown.series)\n * array to use for a drilldown for this point.\n *\n * @type {String}\n * @sample {highcharts} highcharts/drilldown/basic/ Basic drilldown\n * @since 3.0.8\n * @product highcharts\n * @apioption series.line.data.drilldown\n */\n\n/**\n * A general fadeIn method\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer.prototype.Element.prototype.fadeIn = function (animation) {\n    this\n    .attr({\n        opacity: 0.1,\n        visibility: 'inherit'\n    })\n    .animate({\n        opacity: pick(this.newOpacity, 1) // newOpacity used in maps\n    }, animation || {\n        duration: 250\n    });\n};\n\n/**\n * Add a series to the chart as drilldown from a specific point in the parent\n * series. This method is used for async drilldown, when clicking a point in a\n * series should result in loading and displaying a more high-resolution series.\n * When not async, the setup is simpler using the {@link\n * https://api.highcharts.com/highcharts/drilldown.series|drilldown.series}\n * options structure.\n *\n * @memberof Highcharts.Chart\n * @function #addSeriesAsDrilldown\n *\n * @param  {Highcharts.Point} point\n *         The point from which the drilldown will start.\n * @param  {SeriesOptions} options\n *         The series options for the new, detailed series.\n *\n * @sample highcharts/drilldown/async/ Async drilldown\n */\nChart.prototype.addSeriesAsDrilldown = function (point, options) {\n    this.addSingleSeriesAsDrilldown(point, options);\n    this.applyDrilldown();\n};\nChart.prototype.addSingleSeriesAsDrilldown = function (point, ddOptions) {\n    var oldSeries = point.series,\n        xAxis = oldSeries.xAxis,\n        yAxis = oldSeries.yAxis,\n        newSeries,\n        pointIndex,\n        levelSeries = [],\n        levelSeriesOptions = [],\n        level,\n        levelNumber,\n        last,\n        colorProp;\n\n\n    \n    colorProp = { colorIndex: pick(point.colorIndex, oldSeries.colorIndex) };\n    \n\n    if (!this.drilldownLevels) {\n        this.drilldownLevels = [];\n    }\n\n    levelNumber = oldSeries.options._levelNumber || 0;\n\n    // See if we can reuse the registered series from last run\n    last = this.drilldownLevels[this.drilldownLevels.length - 1];\n    if (last && last.levelNumber !== levelNumber) {\n        last = undefined;\n    }\n\n    ddOptions = extend(extend({\n        _ddSeriesId: ddSeriesId++\n    }, colorProp), ddOptions);\n    pointIndex = inArray(point, oldSeries.points);\n\n    // Record options for all current series\n    each(oldSeries.chart.series, function (series) {\n        if (series.xAxis === xAxis && !series.isDrilling) {\n            series.options._ddSeriesId =\n                series.options._ddSeriesId || ddSeriesId++;\n            series.options._colorIndex = series.userOptions._colorIndex;\n            series.options._levelNumber =\n                series.options._levelNumber || levelNumber; // #3182\n\n            if (last) {\n                levelSeries = last.levelSeries;\n                levelSeriesOptions = last.levelSeriesOptions;\n            } else {\n                levelSeries.push(series);\n                levelSeriesOptions.push(series.options);\n            }\n        }\n    });\n\n    // Add a record of properties for each drilldown level\n    level = extend({\n        levelNumber: levelNumber,\n        seriesOptions: oldSeries.options,\n        levelSeriesOptions: levelSeriesOptions,\n        levelSeries: levelSeries,\n        shapeArgs: point.shapeArgs,\n        // no graphic in line series with markers disabled\n        bBox: point.graphic ? point.graphic.getBBox() : {},\n        color: point.isNull ? new _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color(color).setOpacity(0).get() : color,\n        lowerSeriesOptions: ddOptions,\n        pointOptions: oldSeries.options.data[pointIndex],\n        pointIndex: pointIndex,\n        oldExtremes: {\n            xMin: xAxis && xAxis.userMin,\n            xMax: xAxis && xAxis.userMax,\n            yMin: yAxis && yAxis.userMin,\n            yMax: yAxis && yAxis.userMax\n        },\n        resetZoomButton: this.resetZoomButton\n    }, colorProp);\n\n    // Push it to the lookup array\n    this.drilldownLevels.push(level);\n\n    // Reset names to prevent extending (#6704)\n    if (xAxis && xAxis.names) {\n        xAxis.names.length = 0;\n    }\n\n    newSeries = level.lowerSeries = this.addSeries(ddOptions, false);\n    newSeries.options._levelNumber = levelNumber + 1;\n    if (xAxis) {\n        xAxis.oldPos = xAxis.pos;\n        xAxis.userMin = xAxis.userMax = null;\n        yAxis.userMin = yAxis.userMax = null;\n    }\n\n    // Run fancy cross-animation on supported and equal types\n    if (oldSeries.type === newSeries.type) {\n        newSeries.animate = newSeries.animateDrilldown || noop;\n        newSeries.options.animation = true;\n    }\n};\n\nChart.prototype.applyDrilldown = function () {\n    var drilldownLevels = this.drilldownLevels,\n        levelToRemove;\n\n    if (drilldownLevels && drilldownLevels.length > 0) { // #3352, async loading\n        levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;\n        each(this.drilldownLevels, function (level) {\n            if (level.levelNumber === levelToRemove) {\n                each(level.levelSeries, function (series) {\n                    // Not removed, not added as part of a multi-series\n                    // drilldown\n                    if (\n                        series.options &&\n                        series.options._levelNumber === levelToRemove\n                    ) {\n                        series.remove(false);\n                    }\n                });\n            }\n        });\n    }\n\n    // We have a reset zoom button. Hide it and detatch it from the chart. It\n    // is preserved to the layer config above.\n    if (this.resetZoomButton) {\n        this.resetZoomButton.hide();\n        delete this.resetZoomButton;\n    }\n\n    this.pointer.reset();\n    this.redraw();\n    this.showDrillUpButton();\n};\n\nChart.prototype.getDrilldownBackText = function () {\n    var drilldownLevels = this.drilldownLevels,\n        lastLevel;\n    if (drilldownLevels && drilldownLevels.length > 0) { // #3352, async loading\n        lastLevel = drilldownLevels[drilldownLevels.length - 1];\n        lastLevel.series = lastLevel.seriesOptions;\n        return format(this.options.lang.drillUpText, lastLevel);\n    }\n\n};\n\nChart.prototype.showDrillUpButton = function () {\n    var chart = this,\n        backText = this.getDrilldownBackText(),\n        buttonOptions = chart.options.drilldown.drillUpButton,\n        attr,\n        states;\n\n\n    if (!this.drillUpButton) {\n        attr = buttonOptions.theme;\n        states = attr && attr.states;\n\n        this.drillUpButton = this.renderer.button(\n            backText,\n            null,\n            null,\n            function () {\n                chart.drillUp();\n            },\n            attr,\n            states && states.hover,\n            states && states.select\n        )\n        .addClass('highcharts-drillup-button')\n        .attr({\n            align: buttonOptions.position.align,\n            zIndex: 7\n        })\n        .add()\n        .align(\n            buttonOptions.position,\n            false,\n            buttonOptions.relativeTo || 'plotBox'\n        );\n    } else {\n        this.drillUpButton.attr({\n            text: backText\n        })\n        .align();\n    }\n};\n\n/**\n * When the chart is drilled down to a child series, calling `chart.drillUp()`\n * will drill up to the parent series. Requires the drilldown module.\n *\n * @function drillUp\n * @memberof Highcharts.Chart\n */\nChart.prototype.drillUp = function () {\n    if (!this.drilldownLevels || this.drilldownLevels.length === 0) {\n        return;\n    }\n\n    var chart = this,\n        drilldownLevels = chart.drilldownLevels,\n        levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber,\n        i = drilldownLevels.length,\n        chartSeries = chart.series,\n        seriesI,\n        level,\n        oldSeries,\n        newSeries,\n        oldExtremes,\n        addSeries = function (seriesOptions) {\n            var addedSeries;\n            each(chartSeries, function (series) {\n                if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {\n                    addedSeries = series;\n                }\n            });\n\n            addedSeries = addedSeries || chart.addSeries(seriesOptions, false);\n            if (\n                addedSeries.type === oldSeries.type &&\n                addedSeries.animateDrillupTo\n            ) {\n                addedSeries.animate = addedSeries.animateDrillupTo;\n            }\n            if (seriesOptions === level.seriesOptions) {\n                newSeries = addedSeries;\n            }\n        };\n\n    while (i--) {\n\n        level = drilldownLevels[i];\n        if (level.levelNumber === levelNumber) {\n            drilldownLevels.pop();\n\n            // Get the lower series by reference or id\n            oldSeries = level.lowerSeries;\n            if (!oldSeries.chart) {  // #2786\n                seriesI = chartSeries.length; // #2919\n                while (seriesI--) {\n                    if (\n                        chartSeries[seriesI].options.id ===\n                            level.lowerSeriesOptions.id &&\n                        chartSeries[seriesI].options._levelNumber ===\n                            levelNumber + 1\n                    ) { // #3867\n                        oldSeries = chartSeries[seriesI];\n                        break;\n                    }\n                }\n            }\n            oldSeries.xData = []; // Overcome problems with minRange (#2898)\n\n            each(level.levelSeriesOptions, addSeries);\n\n            fireEvent(chart, 'drillup', { seriesOptions: level.seriesOptions });\n\n            if (newSeries.type === oldSeries.type) {\n                newSeries.drilldownLevel = level;\n                newSeries.options.animation = chart.options.drilldown.animation;\n\n                if (oldSeries.animateDrillupFrom && oldSeries.chart) { // #2919\n                    oldSeries.animateDrillupFrom(level);\n                }\n            }\n            newSeries.options._levelNumber = levelNumber;\n\n            oldSeries.remove(false);\n\n            // Reset the zoom level of the upper series\n            if (newSeries.xAxis) {\n                oldExtremes = level.oldExtremes;\n                newSeries.xAxis.setExtremes(\n                    oldExtremes.xMin,\n                    oldExtremes.xMax,\n                    false\n                );\n                newSeries.yAxis.setExtremes(\n                    oldExtremes.yMin,\n                    oldExtremes.yMax,\n                    false\n                );\n            }\n\n            // We have a resetZoomButton tucked away for this level. Attatch\n            // it to the chart and show it.\n            if (level.resetZoomButton) {\n                chart.resetZoomButton = level.resetZoomButton;\n                chart.resetZoomButton.show();\n            }\n        }\n    }\n\n    // Fire a once-off event after all series have been drilled up (#5158)\n    fireEvent(chart, 'drillupall');\n\n    this.redraw();\n\n    if (this.drilldownLevels.length === 0) {\n        this.drillUpButton = this.drillUpButton.destroy();\n    } else {\n        this.drillUpButton.attr({\n            text: this.getDrilldownBackText()\n        })\n        .align();\n    }\n\n    this.ddDupes.length = []; // #3315\n};\n\n// Add update function to be called internally from Chart.update (#7600)\nChart.prototype.callbacks.push(function () {\n    var chart = this;\n    chart.drilldown = {\n        update: function (options, redraw) {\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(true, chart.options.drilldown, options);\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        }\n    };\n});\n\n// Don't show the reset button if we already are displaying the drillUp button.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(Chart, 'beforeShowResetZoom', function () {\n    if (this.drillUpButton) {\n        return false;\n    }\n});\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(Chart, 'render', function setDDPoints() {\n    each(this.xAxis || [], function (axis) {\n        axis.ddPoints = {};\n        each(axis.series, function (series) {\n            var i,\n                xData = series.xData || [],\n                points = series.points,\n                p;\n\n            for (i = 0; i < xData.length; i++) {\n                p = series.options.data[i];\n\n                // The `drilldown` property can only be set on an array or an\n                // object\n                if (typeof p !== 'number') {\n\n                    // Convert array to object (#8008)\n                    p = series.pointClass.prototype.optionsToObject\n                        .call({ series: series }, p);\n\n                    if (p.drilldown) {\n                        if (!axis.ddPoints[xData[i]]) {\n                            axis.ddPoints[xData[i]] = [];\n                        }\n                        axis.ddPoints[xData[i]].push(points ? points[i] : true);\n                    }\n                }\n            }\n        });\n\n        // Add drillability to ticks, and always keep it drillability updated\n        // (#3951)\n        objectEach(axis.ticks, Tick.prototype.drillable);\n    });\n});\n\n\n/**\n * When drilling up, keep the upper series invisible until the lower series has\n * moved into place\n */\nColumnSeries.prototype.animateDrillupTo = function (init) {\n    if (!init) {\n        var newSeries = this,\n            level = newSeries.drilldownLevel;\n\n        // First hide all items before animating in again\n        each(this.points, function (point) {\n            var dataLabel = point.dataLabel;\n\n            if (point.graphic) { // #3407\n                point.graphic.hide();\n            }\n\n            if (dataLabel) {\n                // The data label is initially hidden, make sure it is not faded\n                // in (#6127)\n                dataLabel.hidden = dataLabel.attr('visibility') === 'hidden';\n\n                if (!dataLabel.hidden) {\n                    dataLabel.hide();\n                    if (point.connector) {\n                        point.connector.hide();\n                    }\n                }\n            }\n        });\n\n\n        // Do dummy animation on first point to get to complete\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout(function () {\n            if (newSeries.points) { // May be destroyed in the meantime, #3389\n                each(newSeries.points, function (point, i) {\n                    // Fade in other points\n                    var verb =\n                        i === (level && level.pointIndex) ? 'show' : 'fadeIn',\n                        inherit = verb === 'show' ? true : undefined,\n                        dataLabel = point.dataLabel;\n\n\n                    if (point.graphic) { // #3407\n                        point.graphic[verb](inherit);\n                    }\n\n                    if (dataLabel && !dataLabel.hidden) { // #6127\n                        dataLabel.fadeIn(); // #7384\n                        if (point.connector) {\n                            point.connector.fadeIn();\n                        }\n                    }\n                });\n            }\n        }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));\n\n        // Reset\n        this.animate = noop;\n    }\n\n};\n\nColumnSeries.prototype.animateDrilldown = function (init) {\n    var series = this,\n        drilldownLevels = this.chart.drilldownLevels,\n        animateFrom,\n        animationOptions = animObject(this.chart.options.drilldown.animation),\n        xAxis = this.xAxis;\n\n    if (!init) {\n        each(drilldownLevels, function (level) {\n            if (\n                series.options._ddSeriesId ===\n                    level.lowerSeriesOptions._ddSeriesId\n            ) {\n                animateFrom = level.shapeArgs;\n                \n            }\n        });\n\n        animateFrom.x += (pick(xAxis.oldPos, xAxis.pos) - xAxis.pos);\n\n        each(this.points, function (point) {\n            var animateTo = point.shapeArgs;\n\n            \n\n            if (point.graphic) {\n                point.graphic\n                    .attr(animateFrom)\n                    .animate(\n                        extend(\n                            point.shapeArgs,\n                            { fill: point.color || series.color }\n                        ),\n                        animationOptions\n                    );\n            }\n            if (point.dataLabel) {\n                point.dataLabel.fadeIn(animationOptions);\n            }\n        });\n        this.animate = null;\n    }\n\n};\n\n/**\n * When drilling up, pull out the individual point graphics from the lower\n * series and animate them into the origin point in the upper series.\n */\nColumnSeries.prototype.animateDrillupFrom = function (level) {\n    var animationOptions = animObject(this.chart.options.drilldown.animation),\n        group = this.group,\n        // For 3d column series all columns are added to one group\n        // so we should not delete the whole group. #5297\n        removeGroup = group !== this.chart.columnGroup,\n        series = this;\n\n    // Cancel mouse events on the series group (#2787)\n    each(series.trackerGroups, function (key) {\n        if (series[key]) { // we don't always have dataLabelsGroup\n            series[key].on('mouseover');\n        }\n    });\n\n    if (removeGroup) {\n        delete this.group;\n    }\n\n    each(this.points, function (point) {\n        var graphic = point.graphic,\n            animateTo = level.shapeArgs,\n            complete = function () {\n                graphic.destroy();\n                if (group && removeGroup) {\n                    group = group.destroy();\n                }\n            };\n\n        if (graphic) {\n\n            delete point.graphic;\n\n            \n\n            if (animationOptions.duration) {\n                graphic.animate(\n                    animateTo,\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(animationOptions, { complete: complete })\n                );\n            } else {\n                graphic.attr(animateTo);\n                complete();\n            }\n        }\n    });\n};\n\nif (PieSeries) {\n    extend(PieSeries.prototype, {\n        animateDrillupTo: ColumnSeries.prototype.animateDrillupTo,\n        animateDrillupFrom: ColumnSeries.prototype.animateDrillupFrom,\n\n        animateDrilldown: function (init) {\n            var level = this.chart.drilldownLevels[\n                    this.chart.drilldownLevels.length - 1\n                ],\n                animationOptions = this.chart.options.drilldown.animation,\n                animateFrom = level.shapeArgs,\n                start = animateFrom.start,\n                angle = animateFrom.end - start,\n                startAngle = angle / this.points.length;\n\n            if (!init) {\n                each(this.points, function (point, i) {\n                    var animateTo = point.shapeArgs;\n\n                    \n\n                    if (point.graphic) {\n                        point.graphic\n                            .attr(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(animateFrom, {\n                                start: start + i * startAngle,\n                                end: start + (i + 1) * startAngle\n                            }))[animationOptions ? 'animate' : 'attr'](\n                                animateTo,\n                                animationOptions\n                            );\n                    }\n                });\n                this.animate = null;\n            }\n        }\n    });\n}\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.doDrilldown = function (\n    _holdRedraw,\n    category,\n    originalEvent\n) {\n    var series = this.series,\n        chart = series.chart,\n        drilldown = chart.options.drilldown,\n        i = (drilldown.series || []).length,\n        seriesOptions;\n\n    if (!chart.ddDupes) {\n        chart.ddDupes = [];\n    }\n\n    while (i-- && !seriesOptions) {\n        if (\n            drilldown.series[i].id === this.drilldown &&\n            inArray(this.drilldown, chart.ddDupes) === -1\n        ) {\n            seriesOptions = drilldown.series[i];\n            chart.ddDupes.push(this.drilldown);\n        }\n    }\n\n    // Fire the event. If seriesOptions is undefined, the implementer can check\n    // for  seriesOptions, and call addSeriesAsDrilldown async if necessary.\n    fireEvent(chart, 'drilldown', {\n        point: this,\n        seriesOptions: seriesOptions,\n        category: category,\n        originalEvent: originalEvent,\n        points: (\n            category !== undefined &&\n            this.series.xAxis.getDDPoints(category).slice(0)\n        )\n    }, function (e) {\n        var chart = e.point.series && e.point.series.chart,\n            seriesOptions = e.seriesOptions;\n        if (chart && seriesOptions) {\n            if (_holdRedraw) {\n                chart.addSingleSeriesAsDrilldown(e.point, seriesOptions);\n            } else {\n                chart.addSeriesAsDrilldown(e.point, seriesOptions);\n            }\n        }\n    });\n\n\n};\n\n/**\n * Drill down to a given category. This is the same as clicking on an axis\n * label.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.prototype.drilldownCategory = function (x, e) {\n    objectEach(this.getDDPoints(x), function (point) {\n        if (\n            point &&\n            point.series &&\n            point.series.visible &&\n            point.doDrilldown\n        ) { // #3197\n            point.doDrilldown(true, x, e);\n        }\n    });\n    this.chart.applyDrilldown();\n};\n\n/**\n * Return drillable points for this specific X value\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.prototype.getDDPoints = function (x) {\n    return this.ddPoints && this.ddPoints[x];\n};\n\n\n/**\n * Make a tick label drillable, or remove drilling on update\n */\nTick.prototype.drillable = function () {\n    var pos = this.pos,\n        label = this.label,\n        axis = this.axis,\n        isDrillable = axis.coll === 'xAxis' && axis.getDDPoints,\n        ddPointsX = isDrillable && axis.getDDPoints(pos);\n\n    if (isDrillable) {\n        if (label && ddPointsX && ddPointsX.length) {\n            label.drillable = true;\n\n            \n\n            label\n                .addClass('highcharts-drilldown-axis-label')\n                \n                .on('click', function (e) {\n                    axis.drilldownCategory(pos, e);\n                });\n\n        } else if (label && label.drillable) {\n\n            \n\n            label.on('click', null); // #3806\n            label.removeClass('highcharts-drilldown-axis-label');\n        }\n    }\n};\n\n\n/**\n * On initialization of each point, identify its label and make it clickable.\n * Also, provide a list of points associated to that label.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point, 'afterInit', function () {\n    var point = this,\n        series = point.series;\n\n    if (point.drilldown) {\n\n        // Add the click event to the point\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(point, 'click', function (e) {\n            if (\n                series.xAxis &&\n                series.chart.options.drilldown.allowPointDrilldown === false\n            ) {\n                series.xAxis.drilldownCategory(point.x, e); // #5822, x changed\n            } else {\n                point.doDrilldown(undefined, undefined, e);\n            }\n        });\n\n    }\n\n    return point;\n});\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'afterDrawDataLabels', function () {\n    var css = this.chart.options.drilldown.activeDataLabelStyle,\n        renderer = this.chart.renderer;\n\n    each(this.points, function (point) {\n        var dataLabelsOptions = point.options.dataLabels,\n            pointCSS = pick(\n                point.dlOptions,\n                dataLabelsOptions && dataLabelsOptions.style,\n                {}\n            );\n\n        if (point.drilldown && point.dataLabel) {\n            \n            if (dataLabelsOptions && dataLabelsOptions.color) {\n                pointCSS.color = dataLabelsOptions.color;\n            }\n            point.dataLabel\n                .addClass('highcharts-drilldown-data-label');\n\n            \n        }\n    }, this);\n});\n\n\nvar applyCursorCSS = function (element, cursor, addClass) {\n    element[addClass ? 'addClass' : 'removeClass'](\n        'highcharts-drilldown-point'\n    );\n\n    \n};\n\n// Mark the trackers with a pointer\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'afterDrawTracker', function () {\n    each(this.points, function (point) {\n        if (point.drilldown && point.graphic) {\n            applyCursorCSS(point.graphic, 'pointer', true);\n        }\n    });\n});\n\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point, 'afterSetState', function () {\n    if (this.drilldown && this.series.halo && this.state === 'hover') {\n        applyCursorCSS(this.series.halo, 'pointer', true);\n    } else if (this.series.halo) {\n        applyCursorCSS(this.series.halo, 'auto', false);\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/drilldown.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/exporting.src.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/exporting.src.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/**\n * Exporting module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/* eslint indent:0 */\n\n\n\n\n\n\n// create shortcuts\nvar defaultOptions = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    doc = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    removeEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    fireEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    createElement = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    discardElement = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].discardElement,\n    css = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    objectEach = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isTouchDevice = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isTouchDevice,\n    win = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    userAgent = win.navigator.userAgent,\n    SVGRenderer = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer,\n    symbols = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer.prototype.symbols,\n    isMSBrowser = /Edge\\/|Trident\\/|MSIE /.test(userAgent),\n    isFirefoxBrowser = /firefox/i.test(userAgent);\n\n// Add language\nextend(defaultOptions.lang, {\n    /**\n     * Exporting module only. The text for the menu item to print the chart.\n     *\n     * @type {String}\n     * @default Print chart\n     * @since 3.0.1\n     * @apioption lang.printChart\n     */\n    printChart: 'Print chart',\n    /**\n     * Exporting module only. The text for the PNG download menu item.\n     *\n     * @type {String}\n     * @default Download PNG image\n     * @since 2.0\n     * @apioption lang.downloadPNG\n     */\n    downloadPNG: 'Download PNG image',\n    /**\n     * Exporting module only. The text for the JPEG download menu item.\n     *\n     * @type {String}\n     * @default Download JPEG image\n     * @since 2.0\n     * @apioption lang.downloadJPEG\n     */\n    downloadJPEG: 'Download JPEG image',\n    /**\n     * Exporting module only. The text for the PDF download menu item.\n     *\n     * @type {String}\n     * @default Download PDF document\n     * @since 2.0\n     * @apioption lang.downloadPDF\n     */\n    downloadPDF: 'Download PDF document',\n    /**\n     * Exporting module only. The text for the SVG download menu item.\n     *\n     * @type {String}\n     * @default Download SVG vector image\n     * @since 2.0\n     * @apioption lang.downloadSVG\n     */\n    downloadSVG: 'Download SVG vector image',\n    /**\n     * Exporting module menu. The tooltip title for the context menu holding\n     * print and export menu items.\n     *\n     * @type {String}\n     * @default Chart context menu\n     * @since 3.0\n     * @apioption lang.contextButtonTitle\n     */\n    contextButtonTitle: 'Chart context menu'\n});\n\n// Buttons and menus are collected in a separate config option set called\n// 'navigation'. This can be extended later to add control buttons like zoom and\n// pan right click menus.\ndefaultOptions.navigation = {\n    buttonOptions: {\n        theme: {},\n\n        /**\n         * Whether to enable buttons.\n         *\n         * @type {Boolean}\n         * @sample highcharts/navigation/buttonoptions-enabled/\n         *         Exporting module loaded but buttons disabled\n         * @default true\n         * @since 2.0\n         * @apioption navigation.buttonOptions.enabled\n         */\n\n        /**\n         * The pixel size of the symbol on the button.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-height/\n         *         Bigger buttons\n         * @default 14\n         * @since 2.0\n         * @apioption navigation.buttonOptions.symbolSize\n         */\n        symbolSize: 14,\n\n        /**\n         * The x position of the center of the symbol inside the button.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-height/\n         *         Bigger buttons\n         * @default 12.5\n         * @since 2.0\n         * @apioption navigation.buttonOptions.symbolX\n         */\n        symbolX: 12.5,\n\n        /**\n         * The y position of the center of the symbol inside the button.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-height/\n         *         Bigger buttons\n         * @default 10.5\n         * @since 2.0\n         * @apioption navigation.buttonOptions.symbolY\n         */\n        symbolY: 10.5,\n\n        /**\n         * Alignment for the buttons.\n         *\n         * @validvalue [\"left\", \"center\", \"right\"]\n         * @type {String}\n         * @sample highcharts/navigation/buttonoptions-align/\n         *         Center aligned\n         * @default right\n         * @since 2.0\n         * @apioption navigation.buttonOptions.align\n         */\n        align: 'right',\n\n        /**\n         * The pixel spacing between buttons.\n         *\n         * @type {Number}\n         * @default 3\n         * @since 2.0\n         * @apioption navigation.buttonOptions.buttonSpacing\n         */\n        buttonSpacing: 3,\n\n        /**\n         * Pixel height of the buttons.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-height/\n         *         Bigger buttons\n         * @default 22\n         * @since 2.0\n         * @apioption navigation.buttonOptions.height\n         */\n        height: 22,\n\n        /**\n         * A text string to add to the individual button.\n         *\n         * @type {String}\n         * @sample highcharts/exporting/buttons-text/\n         *         Full text button\n         * @sample highcharts/exporting/buttons-text-symbol/\n         *         Combined symbol and text\n         * @default null\n         * @since 3.0\n         * @apioption navigation.buttonOptions.text\n         */\n\n        /**\n         * The vertical offset of the button's position relative to its\n         * `verticalAlign`.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-verticalalign/\n         *         Buttons at lower right\n         * @default 0\n         * @since 2.0\n         * @apioption navigation.buttonOptions.y\n         */\n\n        /**\n         * The vertical alignment of the buttons. Can be one of \"top\", \"middle\"\n         * or \"bottom\".\n         *\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @type {String}\n         * @sample highcharts/navigation/buttonoptions-verticalalign/\n         *         Buttons at lower right\n         * @default top\n         * @since 2.0\n         * @apioption navigation.buttonOptions.verticalAlign\n         */\n        verticalAlign: 'top',\n\n        /**\n         * The pixel width of the button.\n         *\n         * @type {Number}\n         * @sample highcharts/navigation/buttonoptions-height/\n         *         Bigger buttons\n         * @default 24\n         * @since 2.0\n         * @apioption navigation.buttonOptions.width\n         */\n        width: 24\n    }\n};\n\n\n\n\n// Add the export related options\n\n/**\n * Options for the exporting module. For an overview on the matter, see\n * [the docs](https://www.highcharts.com/docs/export-module/export-module-overview).\n * @type {Object}\n * @optionparent exporting\n */\ndefaultOptions.exporting = {\n\n    /**\n     * Experimental setting to allow HTML inside the chart (added through\n     * the `useHTML` options), directly in the exported image. This allows\n     * you to preserve complicated HTML structures like tables or bi-directional\n     * text in exported charts.\n     *\n     * Disclaimer: The HTML is rendered in a `foreignObject` tag in the\n     * generated SVG. The official export server is based on PhantomJS,\n     * which supports this, but other SVG clients, like Batik, does not\n     * support it. This also applies to downloaded SVG that you want to\n     * open in a desktop client.\n     *\n     * @type {Boolean}\n     * @default false\n     * @since 4.1.8\n     * @apioption exporting.allowHTML\n     */\n\n    /**\n     * Additional chart options to be merged into an exported chart. For\n     * example, a common use case is to add data labels to improve readability\n     * of the exported chart, or to add a printer-friendly color scheme.\n     *\n     * @type {Object}\n     * @sample {highcharts} highcharts/exporting/chartoptions-data-labels/\n     *         Added data labels\n     * @sample {highstock} highcharts/exporting/chartoptions-data-labels/\n     *         Added data labels\n     * @default null\n     * @apioption exporting.chartOptions\n     */\n\n    /**\n     * Whether to enable the exporting module. Disabling the module will\n     * hide the context button, but API methods will still be available.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/exporting/enabled-false/\n     *         Exporting module is loaded but disabled\n     * @sample {highstock} highcharts/exporting/enabled-false/\n     *         Exporting module is loaded but disabled\n     * @default true\n     * @since 2.0\n     * @apioption exporting.enabled\n     */\n\n    /**\n     * Function to call if the offline-exporting module fails to export\n     * a chart on the client side, and [fallbackToExportServer](\n     * #exporting.fallbackToExportServer) is disabled. If left undefined, an\n     * exception is thrown instead. Receives two parameters, the exporting\n     * options, and the error from the module.\n     *\n     * @type {Function}\n     * @see [fallbackToExportServer](#exporting.fallbackToExportServer)\n     * @default undefined\n     * @since 5.0.0\n     * @apioption exporting.error\n     */\n\n    /**\n     * Whether or not to fall back to the export server if the offline-exporting\n     * module is unable to export the chart on the client side. This happens for\n     * certain browsers, and certain features (e.g.\n     * [allowHTML](#exporting.allowHTML)), depending on the image type exporting\n     * to. For very complex charts, it is possible that export can fail in\n     * browsers that don't support Blob objects, due to data URL length limits.\n     * It is recommended to define the [exporting.error](#exporting.error)\n     * handler if disabling fallback, in order to notify users in case export\n     * fails.\n     *\n     * @type {Boolean}\n     * @default true\n     * @since 4.1.8\n     * @apioption exporting.fallbackToExportServer\n     */\n\n    /**\n     * The filename, without extension, to use for the exported chart.\n     *\n     * @type {String}\n     * @sample {highcharts} highcharts/exporting/filename/ Custom file name\n     * @sample {highstock} highcharts/exporting/filename/ Custom file name\n     * @default chart\n     * @since 2.0\n     * @apioption exporting.filename\n     */\n\n    /**\n     * An object containing additional attributes for the POST form that\n     * sends the SVG to the export server. For example, a `target` can be\n     * set to make sure the generated image is received in another frame,\n     *  or a custom `enctype` or `encoding` can be set.\n     *\n     * @type {Object}\n     * @since 3.0.8\n     * @apioption exporting.formAttributes\n     */\n\n    /**\n     * Path where Highcharts will look for export module dependencies to\n     * load on demand if they don't already exist on `window`. Should currently\n     * point to location of [CanVG](https://github.com/canvg/canvg) library,\n     * [RGBColor.js](https://github.com/canvg/canvg), [jsPDF](https://github.\n     * com/yWorks/jsPDF) and [svg2pdf.js](https://github.com/yWorks/svg2pdf.\n     * js), required for client side export in certain browsers.\n     *\n     * @type {String}\n     * @default https://code.highcharts.com/{version}/lib\n     * @since 5.0.0\n     * @apioption exporting.libURL\n     */\n\n    /**\n     * Analogous to [sourceWidth](#exporting.sourceWidth).\n     *\n     * @type {Number}\n     * @since 3.0\n     * @apioption exporting.sourceHeight\n     */\n\n    /**\n     * The width of the original chart when exported, unless an explicit\n     * [chart.width](#chart.width) is set. The width exported raster image\n     * is then multiplied by [scale](#exporting.scale).\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/exporting/sourcewidth/ Source size demo\n     * @sample {highstock} highcharts/exporting/sourcewidth/ Source size demo\n     * @sample {highmaps} maps/exporting/sourcewidth/ Source size demo\n     * @since 3.0\n     * @apioption exporting.sourceWidth\n     */\n\n    /**\n     * The pixel width of charts exported to PNG or JPG. As of Highcharts\n     * 3.0, the default pixel width is a function of the [chart.width](\n     * #chart.width) or [exporting.sourceWidth](#exporting.sourceWidth) and the\n     * [exporting.scale](#exporting.scale).\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/exporting/width/\n     *         Export to 200px wide images\n     * @sample {highstock} highcharts/exporting/width/\n     *         Export to 200px wide images\n     * @default undefined\n     * @since 2.0\n     * @apioption exporting.width\n     */\n\n    /**\n     * Default MIME type for exporting if `chart.exportChart()` is called\n     * without specifying a `type` option. Possible values are `image/png`,\n     *  `image/jpeg`, `application/pdf` and `image/svg+xml`.\n     *\n     * @validvalue [\"image/png\", \"image/jpeg\", \"application/pdf\", \"image/svg+xml\"]\n     * @since 2.0\n     */\n    type: 'image/png',\n\n    /**\n     * The URL for the server module converting the SVG string to an image\n     * format. By default this points to Highchart's free web service.\n     *\n     * @type {String}\n     * @default https://export.highcharts.com\n     * @since 2.0\n     */\n    url: 'https://export.highcharts.com/',\n    /**\n     * When printing the chart from the menu item in the burger menu, if\n     * the on-screen chart exceeds this width, it is resized. After printing\n     * or cancelled, it is restored. The default width makes the chart\n     * fit into typical paper format. Note that this does not affect the\n     * chart when printing the web page as a whole.\n     *\n     * @type {Number}\n     * @default 780\n     * @since 4.2.5\n     */\n    printMaxWidth: 780,\n\n    /**\n     * Defines the scale or zoom factor for the exported image compared\n     * to the on-screen display. While for instance a 600px wide chart\n     * may look good on a website, it will look bad in print. The default\n     * scale of 2 makes this chart export to a 1200px PNG or JPG.\n     *\n     * @see    [chart.width](#chart.width),\n     *         [exporting.sourceWidth](#exporting.sourceWidth)\n     * @sample {highcharts} highcharts/exporting/scale/ Scale demonstrated\n     * @sample {highstock} highcharts/exporting/scale/ Scale demonstrated\n     * @sample {highmaps} maps/exporting/scale/ Scale demonstrated\n     * @since 3.0\n     */\n    scale: 2,\n\n    /**\n     * Options for the export related buttons, print and export. In addition\n     * to the default buttons listed here, custom buttons can be added.\n     * See [navigation.buttonOptions](#navigation.buttonOptions) for general\n     * options.\n     *\n     */\n    buttons: {\n\n        /**\n         * Options for the export button.\n         *\n         * In styled mode, export button styles can be applied with the\n         * `.highcharts-contextbutton` class.\n         *\n         * @extends navigation.buttonOptions\n         */\n        contextButton: {\n\n            /**\n             * A click handler callback to use on the button directly instead of\n             * the popup menu.\n             *\n             * @type {Function}\n             * @sample highcharts/exporting/buttons-contextbutton-onclick/\n             *         Skip the menu and export the chart directly\n             * @since 2.0\n             * @apioption exporting.buttons.contextButton.onclick\n             */\n\n            /**\n             * See [navigation.buttonOptions.symbolFill](\n             * #navigation.buttonOptions.symbolFill).\n             *\n             * @type {Color}\n             * @default #666666\n             * @since 2.0\n             * @apioption exporting.buttons.contextButton.symbolFill\n             */\n\n            /**\n             * The horizontal position of the button relative to the `align`\n             * option.\n             *\n             * @type {Number}\n             * @default -10\n             * @since 2.0\n             * @apioption exporting.buttons.contextButton.x\n             */\n\n            /**\n             * The class name of the context button.\n             * @type {String}\n             */\n            className: 'highcharts-contextbutton',\n\n            /**\n             * The class name of the menu appearing from the button.\n             * @type {String}\n             */\n            menuClassName: 'highcharts-contextmenu',\n\n            /**\n             * The symbol for the button. Points to a definition function in\n             * the `Highcharts.Renderer.symbols` collection. The default\n             * `exportIcon` function is part of the exporting module.\n             *\n             * @validvalue [\"exportIcon\", \"circle\", \"square\", \"diamond\", \"triangle\", \"triangle-down\", \"menu\"]\n             * @type {String}\n             * @sample highcharts/exporting/buttons-contextbutton-symbol/\n             *         Use a circle for symbol\n             * @sample highcharts/exporting/buttons-contextbutton-symbol-custom/\n             *         Custom shape as symbol\n             * @default menu\n             * @since 2.0\n             */\n            symbol: 'menu',\n\n            /**\n             * The key to a [lang](#lang) option setting that is used for the\n             * button's title tooltip. When the key is `contextButtonTitle`, it\n             * refers to [lang.contextButtonTitle](#lang.contextButtonTitle)\n             * that defaults to \"Chart context menu\".\n             *\n             * @since 6.1.4\n             */\n            titleKey: 'contextButtonTitle',\n\n            /**\n             * This option is deprecated, use\n             * [titleKey](#exporting.buttons.contextButton.titleKey) instead.\n             *\n             * @deprecated\n             * @type      {string}\n             * @apioption exporting.buttons.contextButton._titleKey\n             */\n\n            /**\n             * A collection of strings pointing to config options for the menu\n             * items. The config options are defined in the\n             * `menuItemDefinitions` option.\n             *\n             * By default, there is the \"Print\" menu item plus one menu item\n             * for each of the available export types.\n             *\n             * Defaults to\n             * <pre>\n             * [\n             *    'printChart',\n             *    'separator',\n             *    'downloadPNG',\n             *    'downloadJPEG',\n             *    'downloadPDF',\n             *    'downloadSVG'\n             * ]\n             * </pre>\n             *\n             * @type {Array<String>|Array<Object>}\n              * @sample {highcharts} highcharts/exporting/menuitemdefinitions/\n              *         Menu item definitions\n              * @sample {highstock} highcharts/exporting/menuitemdefinitions/\n              *         Menu item definitions\n              * @sample {highmaps} highcharts/exporting/menuitemdefinitions/\n              *         Menu item definitions\n             * @since 2.0\n             */\n            menuItems: [\n                'printChart',\n                'separator',\n                'downloadPNG',\n                'downloadJPEG',\n                'downloadPDF',\n                'downloadSVG'\n            ]\n        }\n    },\n    /**\n     * An object consisting of definitions for the menu items in the context\n     * menu. Each key value pair has a `key` that is referenced in the\n     * [menuItems](#exporting.buttons.contextButton.menuItems) setting,\n     * and a `value`, which is an object with the following properties:\n     *\n     * <dl>\n     *\n     * <dt>onclick</dt>\n     *\n     * <dd>The click handler for the menu item</dd>\n     *\n     * <dt>text</dt>\n     *\n     * <dd>The text for the menu item</dd>\n     *\n     * <dt>textKey</dt>\n     *\n     * <dd>If internationalization is required, the key to a language string\n     * </dd>\n     *\n     * </dl>\n     *\n     * @type {Object}\n     * @sample {highcharts} highcharts/exporting/menuitemdefinitions/\n     *         Menu item definitions\n     * @sample {highstock} highcharts/exporting/menuitemdefinitions/\n     *         Menu item definitions\n     * @sample {highmaps} highcharts/exporting/menuitemdefinitions/\n     *         Menu item definitions\n     * @since 5.0.13\n     */\n    menuItemDefinitions: {\n\n        /**\n         * @ignore\n         */\n        printChart: {\n            textKey: 'printChart',\n            onclick: function () {\n                this.print();\n            }\n        },\n\n        /**\n         * @ignore\n         */\n        separator: {\n            separator: true\n        },\n\n        /**\n         * @ignore\n         */\n        downloadPNG: {\n            textKey: 'downloadPNG',\n            onclick: function () {\n                this.exportChart();\n            }\n        },\n\n        /**\n         * @ignore\n         */\n        downloadJPEG: {\n            textKey: 'downloadJPEG',\n            onclick: function () {\n                this.exportChart({\n                    type: 'image/jpeg'\n                });\n            }\n        },\n\n        /**\n         * @ignore\n         */\n        downloadPDF: {\n            textKey: 'downloadPDF',\n            onclick: function () {\n                this.exportChart({\n                    type: 'application/pdf'\n                });\n            }\n        },\n\n        /**\n         * @ignore\n         */\n        downloadSVG: {\n            textKey: 'downloadSVG',\n            onclick: function () {\n                this.exportChart({\n                    type: 'image/svg+xml'\n                });\n            }\n        }\n    }\n};\n\n/**\n * Fires after a chart is printed through the context menu item or the\n * `Chart.print` method. Requires the exporting module.\n *\n * @type {Function}\n * @context Chart\n * @sample highcharts/chart/events-beforeprint-afterprint/\n *         Rescale the chart to print\n * @since 4.1.0\n * @apioption chart.events.afterPrint\n */\n\n/**\n * Fires before a chart is printed through the context menu item or\n * the `Chart.print` method. Requires the exporting module.\n *\n * @type {Function}\n * @context Chart\n * @sample highcharts/chart/events-beforeprint-afterprint/\n *         Rescale the chart to print\n * @since 4.1.0\n * @apioption chart.events.beforePrint\n */\n\n\n// Add the H.post utility\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post = function (url, data, formAttributes) {\n    // create the form\n    var form = createElement('form', merge({\n        method: 'post',\n        action: url,\n        enctype: 'multipart/form-data'\n    }, formAttributes), {\n        display: 'none'\n    }, doc.body);\n\n    // add the data\n    objectEach(data, function (val, name) {\n        createElement('input', {\n            type: 'hidden',\n            name: name,\n            value: val\n        }, null, form);\n    });\n\n    // submit\n    form.submit();\n\n    // clean up\n    discardElement(form);\n};\n\nextend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n    /**\n     * Exporting module only. A collection of fixes on the produced SVG to\n     * account for expando properties, browser bugs, VML problems and other.\n     * Returns a cleaned SVG.\n     *\n     * @private\n     */\n    sanitizeSVG: function (svg, options) {\n        // Move HTML into a foreignObject\n        if (options && options.exporting && options.exporting.allowHTML) {\n            var html = svg.match(/<\\/svg>(.*?$)/);\n            if (html && html[1]) {\n                html = '<foreignObject x=\"0\" y=\"0\" ' +\n                            'width=\"' + options.chart.width + '\" ' +\n                            'height=\"' + options.chart.height + '\">' +\n                    '<body xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                    html[1] +\n                    '</body>' +\n                    '</foreignObject>';\n                svg = svg.replace('</svg>', html + '</svg>');\n            }\n        }\n\n        svg = svg\n            .replace(/zIndex=\"[^\"]+\"/g, '')\n            .replace(/symbolName=\"[^\"]+\"/g, '')\n            .replace(/jQuery[0-9]+=\"[^\"]+\"/g, '')\n            .replace(/url\\((\"|&quot;)(\\S+)(\"|&quot;)\\)/g, 'url($2)')\n            .replace(/url\\([^#]+#/g, 'url(#')\n            .replace(\n                /<svg /,\n                '<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n            )\n            .replace(/ (|NS[0-9]+\\:)href=/g, ' xlink:href=') // #3567\n            .replace(/\\n/, ' ')\n            // Any HTML added to the container after the SVG (#894)\n            .replace(/<\\/svg>.*?$/, '</svg>')\n            // Batik doesn't support rgba fills and strokes (#3095)\n            .replace(\n                /(fill|stroke)=\"rgba\\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\\.]+)\\)\"/g, // eslint-disable-line max-len\n                '$1=\"rgb($2)\" $1-opacity=\"$3\"'\n            )\n\n            // Replace HTML entities, issue #347\n            .replace(/&nbsp;/g, '\\u00A0') // no-break space\n            .replace(/&shy;/g, '\\u00AD'); // soft hyphen\n\n        \n\n        return svg;\n    },\n\n    /**\n     * Return the unfiltered innerHTML of the chart container. Used as hook for\n     * plugins. In styled mode, it also takes care of inlining CSS style rules.\n     *\n     * @see  Chart#getSVG\n     *\n     * @returns {String}\n     *          The unfiltered SVG of the chart.\n     */\n    getChartHTML: function () {\n        \n        this.inlineStyles();\n        \n        return this.container.innerHTML;\n    },\n\n    /**\n     * Return an SVG representation of the chart.\n     *\n     * @param  chartOptions {Options}\n     *         Additional chart options for the generated SVG representation.\n     *         For collections like `xAxis`, `yAxis` or `series`, the additional\n     *         options is either merged in to the orininal item of the same\n     *         `id`, or to the first item if a common id is not found.\n     * @return {String}\n     *         The SVG representation of the rendered chart.\n     * @sample highcharts/members/chart-getsvg/\n     *         View the SVG from a button\n     */\n    getSVG: function (chartOptions) {\n        var chart = this,\n            chartCopy,\n            sandbox,\n            svg,\n            seriesOptions,\n            sourceWidth,\n            sourceHeight,\n            cssWidth,\n            cssHeight,\n            // Copy the options and add extra options\n            options = merge(chart.options, chartOptions);\n\n\n        // create a sandbox where a new chart will be generated\n        sandbox = createElement('div', null, {\n            position: 'absolute',\n            top: '-9999em',\n            width: chart.chartWidth + 'px',\n            height: chart.chartHeight + 'px'\n        }, doc.body);\n\n        // get the source size\n        cssWidth = chart.renderTo.style.width;\n        cssHeight = chart.renderTo.style.height;\n        sourceWidth = options.exporting.sourceWidth ||\n            options.chart.width ||\n            (/px$/.test(cssWidth) && parseInt(cssWidth, 10)) ||\n            600;\n        sourceHeight = options.exporting.sourceHeight ||\n            options.chart.height ||\n            (/px$/.test(cssHeight) && parseInt(cssHeight, 10)) ||\n            400;\n\n        // override some options\n        extend(options.chart, {\n            animation: false,\n            renderTo: sandbox,\n            forExport: true,\n            renderer: 'SVGRenderer',\n            width: sourceWidth,\n            height: sourceHeight\n        });\n        options.exporting.enabled = false; // hide buttons in print\n        delete options.data; // #3004\n\n        // prepare for replicating the chart\n        options.series = [];\n        each(chart.series, function (serie) {\n            seriesOptions = merge(serie.userOptions, { // #4912\n                animation: false, // turn off animation\n                enableMouseTracking: false,\n                showCheckbox: false,\n                visible: serie.visible\n            });\n\n            // Used for the navigator series that has its own option set\n            if (!seriesOptions.isInternal) {\n                options.series.push(seriesOptions);\n            }\n        });\n\n        // Assign an internal key to ensure a one-to-one mapping (#5924)\n        each(chart.axes, function (axis) {\n            if (!axis.userOptions.internalKey) { // #6444\n                axis.userOptions.internalKey = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey();\n            }\n        });\n\n        // generate the chart copy\n        chartCopy = new _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart(options, chart.callback);\n\n        // Axis options and series options  (#2022, #3900, #5982)\n        if (chartOptions) {\n            each(['xAxis', 'yAxis', 'series'], function (coll) {\n                var collOptions = {};\n                if (chartOptions[coll]) {\n                    collOptions[coll] = chartOptions[coll];\n                    chartCopy.update(collOptions);\n                }\n            });\n        }\n\n        // Reflect axis extremes in the export (#5924)\n        each(chart.axes, function (axis) {\n            var axisCopy = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(chartCopy.axes, function (copy) {\n                    return copy.options.internalKey ===\n                        axis.userOptions.internalKey;\n                }),\n                extremes = axis.getExtremes(),\n                userMin = extremes.userMin,\n                userMax = extremes.userMax;\n\n            if (\n                axisCopy &&\n                (\n                    (userMin !== undefined && userMin !== axisCopy.min) ||\n                    (userMax !== undefined && userMax !== axisCopy.max)\n                )\n            ) {\n                axisCopy.setExtremes(userMin, userMax, true, false);\n            }\n        });\n\n        // Get the SVG from the container's innerHTML\n        svg = chartCopy.getChartHTML();\n        fireEvent(this, 'getSVG', { chartCopy: chartCopy });\n\n        svg = chart.sanitizeSVG(svg, options);\n\n        // free up memory\n        options = null;\n        chartCopy.destroy();\n        discardElement(sandbox);\n\n        return svg;\n    },\n\n    getSVGForExport: function (options, chartOptions) {\n        var chartExportingOptions = this.options.exporting;\n\n        return this.getSVG(merge(\n            { chart: { borderRadius: 0 } },\n            chartExportingOptions.chartOptions,\n            chartOptions,\n            {\n                exporting: {\n                    sourceWidth: (\n                        (options && options.sourceWidth) ||\n                        chartExportingOptions.sourceWidth\n                    ),\n                    sourceHeight: (\n                        (options && options.sourceHeight) ||\n                        chartExportingOptions.sourceHeight\n                    )\n                }\n            }\n        ));\n    },\n\n    /**\n     * Exporting module required. Submit an SVG version of the chart to a server\n     * along with some parameters for conversion.\n     * @param  {Object} exportingOptions\n     *         Exporting options in addition to those defined in {@link\n     *         https://api.highcharts.com/highcharts/exporting|exporting}.\n     * @param  {String} exportingOptions.filename\n     *         The file name for the export without extension.\n     * @param  {String} exportingOptions.url\n     *         The URL for the server module to do the conversion.\n     * @param  {Number} exportingOptions.width\n     *         The width of the PNG or JPG image generated on the server.\n     * @param  {String} exportingOptions.type\n     *         The MIME type of the converted image.\n     * @param  {Number} exportingOptions.sourceWidth\n     *         The pixel width of the source (in-page) chart.\n     * @param  {Number} exportingOptions.sourceHeight\n     *         The pixel height of the source (in-page) chart.\n     * @param  {Options} chartOptions\n     *         Additional chart options for the exported chart. For example a\n     *         different background color can be added here, or `dataLabels`\n     *         for export only.\n     *\n     * @sample highcharts/members/chart-exportchart/\n     *         Export with no options\n     * @sample highcharts/members/chart-exportchart-filename/\n     *         PDF type and custom filename\n     * @sample highcharts/members/chart-exportchart-custom-background/\n     *         Different chart background in export\n     * @sample stock/members/chart-exportchart/\n     *         Export with Highstock\n     */\n    exportChart: function (exportingOptions, chartOptions) {\n\n        var svg = this.getSVGForExport(exportingOptions, chartOptions);\n\n        // merge the options\n        exportingOptions = merge(this.options.exporting, exportingOptions);\n\n        // do the post\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(exportingOptions.url, {\n            filename: exportingOptions.filename || 'chart',\n            type: exportingOptions.type,\n            // IE8 fails to post undefined correctly, so use 0\n            width: exportingOptions.width || 0,\n            scale: exportingOptions.scale,\n            svg: svg\n        }, exportingOptions.formAttributes);\n\n    },\n\n    /**\n     * Exporting module required. Clears away other elements in the page and\n     * prints the chart as it is displayed. By default, when the exporting\n     * module is enabled, a context button with a drop down menu in the upper\n     * right corner accesses this function.\n     *\n     * @sample highcharts/members/chart-print/\n     *         Print from a HTML button\n     */\n    print: function () {\n\n        var chart = this,\n            container = chart.container,\n            origDisplay = [],\n            origParent = container.parentNode,\n            body = doc.body,\n            childNodes = body.childNodes,\n            printMaxWidth = chart.options.exporting.printMaxWidth,\n            resetParams,\n            handleMaxWidth;\n\n        if (chart.isPrinting) { // block the button while in printing mode\n            return;\n        }\n\n        chart.isPrinting = true;\n        chart.pointer.reset(null, 0);\n\n        fireEvent(chart, 'beforePrint');\n\n        // Handle printMaxWidth\n        handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;\n        if (handleMaxWidth) {\n            resetParams = [chart.options.chart.width, undefined, false];\n            chart.setSize(printMaxWidth, undefined, false);\n        }\n\n        // hide all body content\n        each(childNodes, function (node, i) {\n            if (node.nodeType === 1) {\n                origDisplay[i] = node.style.display;\n                node.style.display = 'none';\n            }\n        });\n\n        // pull out the chart\n        body.appendChild(container);\n\n        // Give the browser time to draw WebGL content, an issue that randomly\n        // appears (at least) in Chrome ~67 on the Mac (#8708).\n        setTimeout(function () {\n\n            win.focus(); // #1510\n            win.print();\n\n            // allow the browser to prepare before reverting\n            setTimeout(function () {\n\n                // put the chart back in\n                origParent.appendChild(container);\n\n                // restore all body content\n                each(childNodes, function (node, i) {\n                    if (node.nodeType === 1) {\n                        node.style.display = origDisplay[i];\n                    }\n                });\n\n                chart.isPrinting = false;\n\n                // Reset printMaxWidth\n                if (handleMaxWidth) {\n                    chart.setSize.apply(chart, resetParams);\n                }\n\n                fireEvent(chart, 'afterPrint');\n\n            }, 1000);\n        }, 1);\n\n    },\n\n    /**\n     * Display a popup menu for choosing the export type.\n     *\n     * @private\n     *\n     * @param {String} className An identifier for the menu\n     * @param {Array} items A collection with text and onclicks for the items\n     * @param {Number} x The x position of the opener button\n     * @param {Number} y The y position of the opener button\n     * @param {Number} width The width of the opener button\n     * @param {Number} height The height of the opener button\n     */\n    contextMenu: function (className, items, x, y, width, height, button) {\n        var chart = this,\n            navOptions = chart.options.navigation,\n            chartWidth = chart.chartWidth,\n            chartHeight = chart.chartHeight,\n            cacheName = 'cache-' + className,\n            menu = chart[cacheName],\n            menuPadding = Math.max(width, height), // for mouse leave detection\n            innerMenu,\n            menuStyle;\n\n        // create the menu only the first time\n        if (!menu) {\n\n            // create a HTML element above the SVG\n            chart.exportContextMenu = chart[cacheName] = menu =\n            createElement('div', {\n                className: className\n            }, {\n                position: 'absolute',\n                zIndex: 1000,\n                padding: menuPadding + 'px',\n                pointerEvents: 'auto'\n            }, chart.fixedDiv || chart.container);\n\n            innerMenu = createElement(\n                'div',\n                { className: 'highcharts-menu' },\n                null,\n                menu\n            );\n\n            \n\n            // hide on mouse out\n            menu.hideMenu = function () {\n                css(menu, { display: 'none' });\n                if (button) {\n                    button.setState(0);\n                }\n                chart.openMenu = false;\n                _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(menu.hideTimer);\n            };\n\n            // Hide the menu some time after mouse leave (#1357)\n            chart.exportEvents.push(\n                addEvent(menu, 'mouseleave', function () {\n                    menu.hideTimer = setTimeout(menu.hideMenu, 500);\n                }),\n                addEvent(menu, 'mouseenter', function () {\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(menu.hideTimer);\n                }),\n\n                // Hide it on clicking or touching outside the menu (#2258,\n                // #2335, #2407)\n                addEvent(doc, 'mouseup', function (e) {\n                    if (!chart.pointer.inClass(e.target, className)) {\n                        menu.hideMenu();\n                    }\n                }),\n\n                addEvent(menu, 'click', function () {\n                    if (chart.openMenu) {\n                        menu.hideMenu();\n                    }\n                })\n            );\n\n            // create the items\n            each(items, function (item) {\n\n                if (typeof item === 'string') {\n                    item = chart.options.exporting.menuItemDefinitions[item];\n                }\n\n                if (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(item, true)) {\n                    var element;\n\n                    if (item.separator) {\n                        element = createElement('hr', null, null, innerMenu);\n\n                    } else {\n                        element = createElement('div', {\n                            className: 'highcharts-menu-item',\n                            onclick: function (e) {\n                                if (e) { // IE7\n                                    e.stopPropagation();\n                                }\n                                menu.hideMenu();\n                                if (item.onclick) {\n                                    item.onclick.apply(chart, arguments);\n                                }\n                            },\n                            innerHTML: (\n                                item.text ||\n                                chart.options.lang[item.textKey]\n                            )\n                        }, null, innerMenu);\n\n                        \n                    }\n\n                    // Keep references to menu divs to be able to destroy them\n                    chart.exportDivElements.push(element);\n                }\n            });\n\n            // Keep references to menu and innerMenu div to be able to destroy\n            // them\n            chart.exportDivElements.push(innerMenu, menu);\n\n            chart.exportMenuWidth = menu.offsetWidth;\n            chart.exportMenuHeight = menu.offsetHeight;\n        }\n\n        menuStyle = { display: 'block' };\n\n        // if outside right, right align it\n        if (x + chart.exportMenuWidth > chartWidth) {\n            menuStyle.right = (chartWidth - x - width - menuPadding) + 'px';\n        } else {\n            menuStyle.left = (x - menuPadding) + 'px';\n        }\n        // if outside bottom, bottom align it\n        if (\n            y + height + chart.exportMenuHeight > chartHeight &&\n            button.alignOptions.verticalAlign !== 'top'\n        ) {\n            menuStyle.bottom = (chartHeight - y - menuPadding) + 'px';\n        } else {\n            menuStyle.top = (y + height - menuPadding) + 'px';\n        }\n\n        css(menu, menuStyle);\n        chart.openMenu = true;\n    },\n\n    /**\n     * Add the export button to the chart, with options.\n     *\n     * @private\n     */\n    addButton: function (options) {\n        var chart = this,\n            renderer = chart.renderer,\n            btnOptions = merge(chart.options.navigation.buttonOptions, options),\n            onclick = btnOptions.onclick,\n            menuItems = btnOptions.menuItems,\n            symbol,\n            button,\n            symbolSize = btnOptions.symbolSize || 12;\n        if (!chart.btnCount) {\n            chart.btnCount = 0;\n        }\n\n        // Keeps references to the button elements\n        if (!chart.exportDivElements) {\n            chart.exportDivElements = [];\n            chart.exportSVGElements = [];\n        }\n\n        if (btnOptions.enabled === false) {\n            return;\n        }\n\n\n        var attr = btnOptions.theme,\n            states = attr.states,\n            hover = states && states.hover,\n            select = states && states.select,\n            callback;\n\n        delete attr.states;\n\n        if (onclick) {\n            callback = function (e) {\n                if (e) {\n                    e.stopPropagation();\n                }\n                onclick.call(chart, e);\n            };\n\n        } else if (menuItems) {\n            callback = function (e) {\n                // consistent with onclick call (#3495)\n                if (e) {\n                    e.stopPropagation();\n                }\n\n                chart.contextMenu(\n                    button.menuClassName,\n                    menuItems,\n                    button.translateX,\n                    button.translateY,\n                    button.width,\n                    button.height,\n                    button\n                );\n                button.setState(2);\n            };\n        }\n\n\n        if (btnOptions.text && btnOptions.symbol) {\n            attr.paddingLeft = pick(attr.paddingLeft, 25);\n\n        } else if (!btnOptions.text) {\n            extend(attr, {\n                width: btnOptions.width,\n                height: btnOptions.height,\n                padding: 0\n            });\n        }\n\n        button = renderer\n            .button(btnOptions.text, 0, 0, callback, attr, hover, select)\n            .addClass(options.className)\n            .attr({\n                \n                title: pick(\n                    chart.options.lang[\n                        btnOptions._titleKey || btnOptions.titleKey\n                    ],\n                    ''\n                )\n            });\n        button.menuClassName = (\n            options.menuClassName ||\n            'highcharts-menu-' + chart.btnCount++\n        );\n\n        if (btnOptions.symbol) {\n            symbol = renderer.symbol(\n                    btnOptions.symbol,\n                    btnOptions.symbolX - (symbolSize / 2),\n                    btnOptions.symbolY - (symbolSize / 2),\n                    symbolSize,\n                    symbolSize,\n                    // If symbol is an image, scale it (#7957)\n                    {\n                        width: symbolSize,\n                        height: symbolSize\n                    }\n                )\n                .addClass('highcharts-button-symbol')\n                .attr({\n                    zIndex: 1\n                }).add(button);\n\n            \n        }\n\n        button.add(chart.exportingGroup)\n            .align(extend(btnOptions, {\n                width: button.width,\n                x: pick(btnOptions.x, chart.buttonOffset) // #1654\n            }), true, 'spacingBox');\n\n        chart.buttonOffset += (\n            (button.width + btnOptions.buttonSpacing) *\n            (btnOptions.align === 'right' ? -1 : 1)\n        );\n\n        chart.exportSVGElements.push(button, symbol);\n\n    },\n\n    /**\n     * Destroy the export buttons.\n     *\n     * @private\n     */\n    destroyExport: function (e) {\n        var chart = e ? e.target : this,\n            exportSVGElements = chart.exportSVGElements,\n            exportDivElements = chart.exportDivElements,\n            exportEvents = chart.exportEvents,\n            cacheName;\n\n        // Destroy the extra buttons added\n        if (exportSVGElements) {\n            each(exportSVGElements, function (elem, i) {\n\n                // Destroy and null the svg elements\n                if (elem) { // #1822\n                    elem.onclick = elem.ontouchstart = null;\n                    cacheName = 'cache-' + elem.menuClassName;\n\n                    if (chart[cacheName]) {\n                        delete chart[cacheName];\n                    }\n\n                    chart.exportSVGElements[i] = elem.destroy();\n                }\n            });\n            exportSVGElements.length = 0;\n        }\n\n        // Destroy the exporting group\n        if (chart.exportingGroup) {\n            chart.exportingGroup.destroy();\n            delete chart.exportingGroup;\n        }\n\n        // Destroy the divs for the menu\n        if (exportDivElements) {\n            each(exportDivElements, function (elem, i) {\n\n                // Remove the event handler\n                _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(elem.hideTimer); // #5427\n                removeEvent(elem, 'mouseleave');\n\n                // Remove inline events\n                chart.exportDivElements[i] =\n                    elem.onmouseout =\n                    elem.onmouseover =\n                    elem.ontouchstart =\n                    elem.onclick = null;\n\n                // Destroy the div by moving to garbage bin\n                discardElement(elem);\n            });\n            exportDivElements.length = 0;\n        }\n\n        if (exportEvents) {\n            each(exportEvents, function (unbind) {\n                unbind();\n            });\n            exportEvents.length = 0;\n        }\n    }\n});\n\n\n// These ones are translated to attributes rather than styles\nSVGRenderer.prototype.inlineToAttributes = [\n    'fill',\n    'stroke',\n    'strokeLinecap',\n    'strokeLinejoin',\n    'strokeWidth',\n    'textAnchor',\n    'x',\n    'y'\n];\n// These CSS properties are not inlined. Remember camelCase.\nSVGRenderer.prototype.inlineBlacklist = [\n    /-/, // In Firefox, both hyphened and camelCased names are listed\n    /^(clipPath|cssText|d|height|width)$/, // Full words\n    /^font$/, // more specific props are set\n    /[lL]ogical(Width|Height)$/,\n    /perspective/,\n    /TapHighlightColor/,\n    /^transition/,\n    /^length$/ // #7700\n    // /^text (border|color|cursor|height|webkitBorder)/\n];\nSVGRenderer.prototype.unstyledElements = [\n    'clipPath',\n    'defs',\n    'desc'\n];\n\n/**\n * Analyze inherited styles from stylesheets and add them inline\n *\n * @todo: What are the border styles for text about? In general, text has a lot\n * of properties.\n * @todo: Make it work with IE9 and IE10.\n */\nChart.prototype.inlineStyles = function () {\n    var renderer = this.renderer,\n        inlineToAttributes = renderer.inlineToAttributes,\n        blacklist = renderer.inlineBlacklist,\n        whitelist = renderer.inlineWhitelist, // For IE\n        unstyledElements = renderer.unstyledElements,\n        defaultStyles = {},\n        dummySVG,\n        iframe,\n        iframeDoc;\n\n    // Create an iframe where we read default styles without pollution from this\n    // body\n    iframe = doc.createElement('iframe');\n    css(iframe, {\n        width: '1px',\n        height: '1px',\n        visibility: 'hidden'\n    });\n    doc.body.appendChild(iframe);\n    iframeDoc = iframe.contentWindow.document;\n    iframeDoc.open();\n    iframeDoc.write('<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>');\n    iframeDoc.close();\n\n\n    /**\n     * Make hyphenated property names out of camelCase\n     */\n    function hyphenate(prop) {\n        return prop.replace(\n            /([A-Z])/g,\n            function (a, b) {\n                return '-' + b.toLowerCase();\n            }\n        );\n    }\n\n    /**\n     * Call this on all elements and recurse to children\n     */\n    function recurse(node) {\n        var styles,\n            parentStyles,\n            cssText = '',\n            dummy,\n            styleAttr,\n            blacklisted,\n            whitelisted,\n            i;\n\n        // Check computed styles and whether they are in the white/blacklist for\n        // styles or atttributes\n        function filterStyles(val, prop) {\n\n            // Check against whitelist & blacklist\n            blacklisted = whitelisted = false;\n            if (whitelist) {\n                // Styled mode in IE has a whitelist instead.\n                // Exclude all props not in this list.\n                i = whitelist.length;\n                while (i-- && !whitelisted) {\n                    whitelisted = whitelist[i].test(prop);\n                }\n                blacklisted = !whitelisted;\n            }\n\n            // Explicitly remove empty transforms\n            if (prop === 'transform' && val === 'none') {\n                blacklisted = true;\n            }\n\n            i = blacklist.length;\n            while (i-- && !blacklisted) {\n                blacklisted = (\n                    blacklist[i].test(prop) ||\n                    typeof val === 'function'\n                );\n            }\n\n            if (!blacklisted) {\n                // If parent node has the same style, it gets inherited, no need\n                // to inline it. Top-level props should be diffed against parent\n                // (#7687).\n                if (\n                    (parentStyles[prop] !== val || node.nodeName === 'svg') &&\n                    defaultStyles[node.nodeName][prop] !== val\n                ) {\n                    // Attributes\n                    if (inlineToAttributes.indexOf(prop) !== -1) {\n                        node.setAttribute(hyphenate(prop), val);\n                    // Styles\n                    } else {\n                        cssText += hyphenate(prop) + ':' + val + ';';\n                    }\n                }\n            }\n        }\n\n        if (\n            node.nodeType === 1 &&\n            unstyledElements.indexOf(node.nodeName) === -1\n        ) {\n            styles = win.getComputedStyle(node, null);\n            parentStyles = node.nodeName === 'svg' ?\n                {} :\n                win.getComputedStyle(node.parentNode, null);\n\n            // Get default styles from the browser so that we don't have to add\n            // these\n            if (!defaultStyles[node.nodeName]) {\n                /*\n                if (!dummySVG) {\n                    dummySVG = doc.createElementNS(H.SVG_NS, 'svg');\n                    dummySVG.setAttribute('version', '1.1');\n                    doc.body.appendChild(dummySVG);\n                }\n                */\n                dummySVG = iframeDoc.getElementsByTagName('svg')[0];\n                dummy = iframeDoc.createElementNS(\n                    node.namespaceURI,\n                    node.nodeName\n                );\n                dummySVG.appendChild(dummy);\n                // Copy, so we can remove the node\n                defaultStyles[node.nodeName] = merge(\n                    win.getComputedStyle(dummy, null)\n                );\n                // Remove default fill, otherwise text disappears when exported\n                if (node.nodeName === 'text') {\n                    delete defaultStyles.text.fill;\n                }\n                dummySVG.removeChild(dummy);\n            }\n\n            // Loop through all styles and add them inline if they are ok\n            if (isFirefoxBrowser || isMSBrowser) {\n                // Some browsers put lots of styles on the prototype\n                for (var p in styles) {\n                    filterStyles(styles[p], p);\n                }\n            } else {\n                objectEach(styles, filterStyles);\n            }\n\n            // Apply styles\n            if (cssText) {\n                styleAttr = node.getAttribute('style');\n                node.setAttribute(\n                    'style',\n                    (styleAttr ? styleAttr + ';' : '') + cssText\n                );\n            }\n\n            // Set default stroke width (needed at least for IE)\n            if (node.nodeName === 'svg') {\n                node.setAttribute('stroke-width', '1px');\n            }\n\n            if (node.nodeName === 'text') {\n                return;\n            }\n\n            // Recurse\n            each(node.children || node.childNodes, recurse);\n        }\n    }\n\n    /**\n     * Remove the dummy objects used to get defaults\n     */\n    function tearDown() {\n        dummySVG.parentNode.removeChild(dummySVG);\n    }\n\n    recurse(this.container.querySelector('svg'));\n    tearDown();\n\n};\n\n\n\nsymbols.menu = function (x, y, width, height) {\n    var arr = [\n        'M', x, y + 2.5,\n        'L', x + width, y + 2.5,\n        'M', x, y + height / 2 + 0.5,\n        'L', x + width, y + height / 2 + 0.5,\n        'M', x, y + height - 1.5,\n        'L', x + width, y + height - 1.5\n    ];\n    return arr;\n};\n\n// Add the buttons on chart load\nChart.prototype.renderExporting = function () {\n    var chart = this,\n        exportingOptions = chart.options.exporting,\n        buttons = exportingOptions.buttons,\n        isDirty = chart.isDirtyExporting || !chart.exportSVGElements;\n\n    chart.buttonOffset = 0;\n    if (chart.isDirtyExporting) {\n        chart.destroyExport();\n    }\n\n    if (isDirty && exportingOptions.enabled !== false) {\n        chart.exportEvents = [];\n\n        chart.exportingGroup = chart.exportingGroup ||\n            chart.renderer.g('exporting-group').attr({\n                zIndex: 3 // #4955, // #8392\n            }).add();\n\n        objectEach(buttons, function (button) {\n            chart.addButton(button);\n        });\n\n        chart.isDirtyExporting = false;\n    }\n\n    // Destroy the export elements at chart destroy\n    addEvent(chart, 'destroy', chart.destroyExport);\n};\n\n// Add update methods to handle chart.update and chart.exporting.update and\n// chart.navigation.update. These must be added to the chart instance rather\n// than the Chart prototype in order to use the chart instance inside the update\n// function.\naddEvent(Chart, 'init', function () {\n    var chart = this;\n    function update(prop, options, redraw) {\n        chart.isDirtyExporting = true;\n        merge(true, chart.options[prop], options);\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    }\n    each(['exporting', 'navigation'], function (prop) {\n        chart[prop] = {\n            update: function (options, redraw) {\n                update(prop, options, redraw);\n            }\n        };\n    });\n});\n\nChart.prototype.callbacks.push(function (chart) {\n\n    chart.renderExporting();\n\n    addEvent(chart, 'redraw', chart.renderExporting);\n\n\n    // Uncomment this to see a button directly below the chart, for quick\n    // testing of export\n    /*\n    var button, viewImage, viewSource;\n    if (!chart.renderer.forExport) {\n        viewImage = function () {\n            var div = doc.createElement('div');\n            div.innerHTML = chart.getSVGForExport();\n            chart.renderTo.parentNode.appendChild(div);\n        };\n\n        viewSource = function () {\n            var pre = doc.createElement('pre');\n            pre.innerHTML = chart.getSVGForExport()\n                .replace(/</g, '\\n&lt;')\n                .replace(/>/g, '&gt;');\n            chart.renderTo.parentNode.appendChild(pre);\n        };\n\n        viewImage();\n\n        // View SVG Image\n        button = doc.createElement('button');\n        button.innerHTML = 'View SVG Image';\n        chart.renderTo.parentNode.appendChild(button);\n        button.onclick = viewImage;\n\n        // View SVG Source\n        button = doc.createElement('button');\n        button.innerHTML = 'View SVG Source';\n        chart.renderTo.parentNode.appendChild(button);\n        button.onclick = viewSource;\n    }\n    //*/\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/exporting.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/funnel.src.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/funnel.src.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * Highcharts funnel module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n/* eslint indent: 0 */\n\n\n\n\n\n\n// create shortcuts\nvar seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each;\n\n\nseriesType('funnel', 'pie',\n/**\n * Funnel charts are a type of chart often used to visualize stages in a sales\n * project, where the top are the initial stages with the most clients.\n * It requires that the modules/funnel.js file is loaded.\n *\n * @sample       highcharts/demo/funnel/ Funnel demo\n * @extends      {plotOptions.pie}\n * @excluding    size\n * @product      highcharts\n * @optionparent plotOptions.funnel\n */\n{\n\n    /**\n     * Initial animation is by default disabled for the funnel chart.\n     */\n    animation: false,\n\n    /**\n     * The center of the series. By default, it is centered in the middle\n     * of the plot area, so it fills the plot area height.\n     *\n     * @type    {Array<String|Number>}\n     * @default [\"50%\", \"50%\"]\n     * @since   3.0\n     * @product highcharts\n     */\n    center: ['50%', '50%'],\n\n    /**\n     * The width of the funnel compared to the width of the plot area,\n     * or the pixel width if it is a number.\n     *\n     * @type    {Number|String}\n     * @since   3.0\n     * @product highcharts\n     */\n    width: '90%',\n\n    /**\n     * The width of the neck, the lower part of the funnel. A number defines\n     * pixel width, a percentage string defines a percentage of the plot\n     * area width.\n     *\n     * @type    {Number|String}\n     * @sample  {highcharts} highcharts/demo/funnel/ Funnel demo\n     * @since   3.0\n     * @product highcharts\n     */\n    neckWidth: '30%',\n\n    /**\n     * The height of the funnel or pyramid. If it is a number it defines\n     * the pixel height, if it is a percentage string it is the percentage\n     * of the plot area height.\n     *\n     * @type    {Number|String}\n     * @sample  {highcharts} highcharts/demo/funnel/ Funnel demo\n     * @since   3.0\n     * @product highcharts\n     */\n    height: '100%',\n\n    /**\n     * The height of the neck, the lower part of the funnel. A number defines\n     * pixel width, a percentage string defines a percentage of the plot\n     * area height.\n     *\n     * @type    {Number|String}\n     * @product highcharts\n     */\n    neckHeight: '25%',\n\n    /**\n     * A reversed funnel has the widest area down. A reversed funnel with\n     * no neck width and neck height is a pyramid.\n     *\n     * @since   3.0.10\n     * @product highcharts\n     */\n    reversed: false,\n\n    /**\n     * @ignore\n     */\n    size: true, // to avoid adapting to data label size in Pie.drawDataLabels\n\n    \n},\n\n// Properties\n{\n    animate: noop,\n\n    /**\n     * Overrides the pie translate method\n     */\n    translate: function () {\n\n        var\n            // Get positions - either an integer or a percentage string\n            // must be given\n            getLength = function (length, relativeTo) {\n                return (/%$/).test(length) ?\n                    relativeTo * parseInt(length, 10) / 100 :\n                    parseInt(length, 10);\n            },\n\n            sum = 0,\n            series = this,\n            chart = series.chart,\n            options = series.options,\n            reversed = options.reversed,\n            ignoreHiddenPoint = options.ignoreHiddenPoint,\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            cumulative = 0, // start at top\n            center = options.center,\n            centerX = getLength(center[0], plotWidth),\n            centerY = getLength(center[1], plotHeight),\n            width = getLength(options.width, plotWidth),\n            tempWidth,\n            getWidthAt,\n            height = getLength(options.height, plotHeight),\n            neckWidth = getLength(options.neckWidth, plotWidth),\n            neckHeight = getLength(options.neckHeight, plotHeight),\n            neckY = (centerY - height / 2) + height - neckHeight,\n            data = series.data,\n            path,\n            fraction,\n            half = options.dataLabels.position === 'left' ? 1 : 0,\n\n            x1,\n            y1,\n            x2,\n            x3,\n            y3,\n            x4,\n            y5;\n\n        // Return the width at a specific y coordinate\n        series.getWidthAt = getWidthAt = function (y) {\n            var top = (centerY - height / 2);\n\n            return (y > neckY || height === neckHeight) ?\n                neckWidth :\n                neckWidth + (width - neckWidth) *\n                    (1 - (y - top) / (height - neckHeight));\n        };\n        series.getX = function (y, half, point) {\n            return centerX + (half ? -1 : 1) *\n                ((getWidthAt(reversed ? 2 * centerY - y : y) / 2) +\n                point.labelDistance);\n        };\n\n        // Expose\n        series.center = [centerX, centerY, height];\n        series.centerX = centerX;\n\n        /*\n         * Individual point coordinate naming:\n         *\n         * x1,y1 _________________ x2,y1\n         *  \\                         /\n         *   \\                       /\n         *    \\                     /\n         *     \\                   /\n         *      \\                 /\n         *     x3,y3 _________ x4,y3\n         *\n         * Additional for the base of the neck:\n         *\n         *       |               |\n         *       |               |\n         *       |               |\n         *     x3,y5 _________ x4,y5\n         */\n\n\n\n\n        // get the total sum\n        each(data, function (point) {\n            if (!ignoreHiddenPoint || point.visible !== false) {\n                sum += point.y;\n            }\n        });\n\n        each(data, function (point) {\n            // set start and end positions\n            y5 = null;\n            fraction = sum ? point.y / sum : 0;\n            y1 = centerY - height / 2 + cumulative * height;\n            y3 = y1 + fraction * height;\n            tempWidth = getWidthAt(y1);\n            x1 = centerX - tempWidth / 2;\n            x2 = x1 + tempWidth;\n            tempWidth = getWidthAt(y3);\n            x3 = centerX - tempWidth / 2;\n            x4 = x3 + tempWidth;\n\n            // the entire point is within the neck\n            if (y1 > neckY) {\n                x1 = x3 = centerX - neckWidth / 2;\n                x2 = x4 = centerX + neckWidth / 2;\n\n            // the base of the neck\n            } else if (y3 > neckY) {\n                y5 = y3;\n\n                tempWidth = getWidthAt(neckY);\n                x3 = centerX - tempWidth / 2;\n                x4 = x3 + tempWidth;\n\n                y3 = neckY;\n            }\n\n            if (reversed) {\n                y1 = 2 * centerY - y1;\n                y3 = 2 * centerY - y3;\n                if (y5 !== null) {\n                    y5 = 2 * centerY - y5;\n                }\n            }\n\n            // save the path\n            path = [\n                'M',\n                x1, y1,\n                'L',\n                x2, y1,\n                x4, y3\n            ];\n            if (y5 !== null) {\n                path.push(x4, y5, x3, y5);\n            }\n            path.push(x3, y3, 'Z');\n\n            // prepare for using shared dr\n            point.shapeType = 'path';\n            point.shapeArgs = { d: path };\n\n\n            // for tooltips and data labels\n            point.percentage = fraction * 100;\n            point.plotX = centerX;\n            point.plotY = (y1 + (y5 || y3)) / 2;\n\n            // Placement of tooltips and data labels\n            point.tooltipPos = [\n                centerX,\n                point.plotY\n            ];\n\n            // Slice is a noop on funnel points\n            point.slice = noop;\n\n            // Mimicking pie data label placement logic\n            point.half = half;\n\n            if (!ignoreHiddenPoint || point.visible !== false) {\n                cumulative += fraction;\n            }\n        });\n    },\n\n    /**\n     * Funnel items don't have angles (#2289)\n     */\n    sortByAngle: function (points) {\n        points.sort(function (a, b) {\n            return a.plotY - b.plotY;\n        });\n    },\n\n    /**\n     * Extend the pie data label method\n     */\n    drawDataLabels: function () {\n        var series = this,\n            data = series.data,\n            labelDistance = series.options.dataLabels.distance,\n            leftSide,\n            sign,\n            point,\n            i = data.length,\n            x,\n            y;\n\n        /**\n         * In the original pie label anticollision logic, the slots are\n         * distributed from one labelDistance above to one labelDistance\n         * below the pie. In funnels we don't want this.\n         */\n        series.center[2] -= 2 * labelDistance;\n\n        // Set the label position array for each point.\n        while (i--) {\n            point = data[i];\n            leftSide = point.half;\n            sign = leftSide ? 1 : -1;\n            y = point.plotY;\n            point.labelDistance = pick(\n                point.options.dataLabels && point.options.dataLabels.distance,\n                labelDistance\n            );\n\n            series.maxLabelDistance = Math.max(\n                point.labelDistance,\n                series.maxLabelDistance || 0\n            );\n            x = series.getX(y, leftSide, point);\n\n            // set the anchor point for data labels\n            point.labelPos = [\n                // first break of connector\n                0,\n                y,\n\n                // second break, right outside point shape\n                x + (point.labelDistance - 5) * sign,\n                y,\n\n                // landing point for connector\n                x + point.labelDistance * sign,\n                y,\n\n                // alignment\n                leftSide ? 'right' : 'left',\n                // center angle\n                0\n            ];\n        }\n\n        seriesTypes.pie.prototype.drawDataLabels.call(this);\n    }\n\n});\n\n\n/**\n * A `funnel` series. If the [type](#series.funnel.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.funnel\n * @excluding dataParser,dataURL,stack,xAxis,yAxis\n * @product   highcharts\n * @apioption series.funnel\n */\n\n/**\n * An array of data points for the series. For the `funnel` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.funnel.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         y: 3,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         y: 1,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Number>}\n * @extends   series.pie.data\n * @excluding sliced\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.funnel.data\n */\n\n/**\n * Pyramid series type.\n */\nseriesType('pyramid', 'funnel',\n/**\n * A pyramid series is a special type of funnel, without neck and reversed by\n * default.\n *\n * @sample       highcharts/demo/pyramid/\n *               Pyramid chart\n * @extends      plotOptions.funnel\n * @product      highcharts\n * @optionparent plotOptions.pyramid\n */\n{\n\n    /**\n     * The pyramid neck width is zero by default, as opposed to the funnel,\n     * which shares the same layout logic.\n     *\n     * @since 3.0.10\n     * @product highcharts\n     */\n    neckWidth: '0%',\n\n    /**\n     * The pyramid neck width is zero by default, as opposed to the funnel,\n     * which shares the same layout logic.\n     *\n     * @since 3.0.10\n     * @product highcharts\n     */\n    neckHeight: '0%',\n\n    /**\n     * The pyramid is reversed by default, as opposed to the funnel, which\n     * shares the layout engine, and is not reversed.\n     *\n     * @since 3.0.10\n     * @product highcharts\n     */\n    reversed: true\n});\n\n/**\n * A `pyramid` series. If the [type](#series.pyramid.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.pyramid\n * @excluding dataParser,dataURL,stack,xAxis,yAxis\n * @product   highcharts\n * @apioption series.pyramid\n */\n\n/**\n * An array of data points for the series. For the `pyramid` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.pyramid.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Number>}\n * @extends   series.pie.data\n * @excluding sliced\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.pyramid.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/funnel.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/keyboard-navigation.src.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/keyboard-navigation.src.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _parts_Tooltip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Tooltip.js */ \"./node_modules/highcharts/js/es-modules/parts/Tooltip.js\");\n/* harmony import */ var _parts_SvgRenderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts/SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * Accessibility module - Keyboard navigation\n *\n * (c) 2010-2017 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\nvar win = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    doc = win.document,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    fireEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    hasSVGFocusSupport;\n\n// Add focus border functionality to SVGElements.\n// Draws a new rect on top of element around its bounding box.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement.prototype, {\n    addFocusBorder: function (margin, style) {\n        // Allow updating by just adding new border\n        if (this.focusBorder) {\n            this.removeFocusBorder();\n        }\n        // Add the border rect\n        var bb = this.getBBox(),\n            pad = pick(margin, 3);\n        this.focusBorder = this.renderer.rect(\n            bb.x - pad,\n            bb.y - pad,\n            bb.width + 2 * pad,\n            bb.height + 2 * pad,\n            style && style.borderRadius\n        )\n        .addClass('highcharts-focus-border')\n        \n        .attr({\n            zIndex: 99\n        })\n        .add(this.parentGroup);\n    },\n\n    removeFocusBorder: function () {\n        if (this.focusBorder) {\n            this.focusBorder.destroy();\n            delete this.focusBorder;\n        }\n    }\n});\n\n\n// Set for which series types it makes sense to move to the closest point with\n// up/down arrows, and which series types should just move to next series.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.keyboardMoveVertical = true;\neach(['column', 'pie'], function (type) {\n    if (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes[type]) {\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes[type].prototype.keyboardMoveVertical = false;\n    }\n});\n\n\n/**\n * Strip HTML tags away from a string. Used for aria-label attributes, painting\n * on a canvas will fail if the text contains tags.\n * @param  {String} s The input string\n * @return {String}   The filtered string\n */\nfunction stripTags(s) {\n    return typeof s === 'string' ? s.replace(/<\\/?[^>]+(>|$)/g, '') : s;\n}\n\n\n/**\n * Get the index of a point in a series. This is needed when using e.g. data\n * grouping.\n *\n * @param {Point} point The point to find index of.\n * @return {number} The index in the series.points array of the point.\n */\nfunction getPointIndex(point) {\n    var index = point.index,\n        points = point.series.points,\n        i = points.length;\n    if (points[index] !== point) {\n        while (i--) {\n            if (points[i] === point) {\n                return i;\n            }\n        }\n    } else {\n        return index;\n    }\n}\n\n\n/**\n * Set default keyboard navigation options\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setOptions({\n    accessibility: {\n\n        /**\n         * Options for keyboard navigation.\n         *\n         * @type      {Object}\n         * @since     5.0.0\n         * @apioption accessibility.keyboardNavigation\n         */\n        keyboardNavigation: {\n\n            /**\n             * Enable keyboard navigation for the chart.\n             *\n             * @type      {Boolean}\n             * @default   true\n             * @since     5.0.0\n             * @apioption accessibility.keyboardNavigation.enabled\n             */\n            enabled: true,\n\n\n            /**\n             * Options for the focus border drawn around elements while\n             * navigating through them.\n             *\n             * @type      {Object}\n             * @sample    highcharts/accessibility/custom-focus\n             *            Custom focus ring\n             * @since     6.0.3\n             * @apioption accessibility.keyboardNavigation.focusBorder\n             */\n            focusBorder: {\n                /**\n                 * Enable/disable focus border for chart.\n                 *\n                 * @type      {Boolean}\n                 * @default   true\n                 * @since     6.0.3\n                 * @apioption accessibility.keyboardNavigation.focusBorder.enabled\n                 */\n                enabled: true,\n\n                /**\n                 * Hide the browser's default focus indicator.\n                 *\n                 * @type      {Boolean}\n                 * @default   true\n                 * @since     6.0.4\n                 * @apioption accessibility.keyboardNavigation.focusBorder.hideBrowserFocusOutline\n                 */\n                hideBrowserFocusOutline: true,\n\n                /**\n                 * Style options for the focus border drawn around elements\n                 * while navigating through them. Note that some browsers in\n                 * addition draw their own borders for focused elements. These\n                 * automatic borders can not be styled by Highcharts.\n                 *\n                 * In styled mode, the border is given the\n                 * `.highcharts-focus-border` class.\n                 *\n                 * @type      {Object}\n                 * @since     6.0.3\n                 * @apioption accessibility.keyboardNavigation.focusBorder.style\n                 */\n                style: {\n                    /**\n                     * Color of the focus border.\n                     *\n                     * @type      {Color}\n                     * @default   #000000\n                     * @since     6.0.3\n                     * @apioption accessibility.keyboardNavigation.focusBorder.style.color\n                    */\n                    color: '#335cad',\n                    /**\n                     * Line width of the focus border.\n                     *\n                     * @type      {Number}\n                     * @default   2\n                     * @since     6.0.3\n                     * @apioption accessibility.keyboardNavigation.focusBorder.style.lineWidth\n                    */\n                    lineWidth: 2,\n                    /**\n                     * Border radius of the focus border.\n                     *\n                     * @type      {Number}\n                     * @default   3\n                     * @since     6.0.3\n                     * @apioption accessibility.keyboardNavigation.focusBorder.style.borderRadius\n                    */\n                    borderRadius: 3\n                },\n\n                /**\n                 * Focus border margin around the elements.\n                 *\n                 * @type      {Number}\n                 * @default   2\n                 * @since     6.0.3\n                 * @apioption accessibility.keyboardNavigation.focusBorder.margin\n                 */\n                margin: 2\n            },\n\n            /**\n             * Set the keyboard navigation mode for the chart. Can be \"normal\"\n             * or \"serialize\". In normal mode, left/right arrow keys move\n             * between points in a series, while up/down arrow keys move between\n             * series. Up/down navigation acts intelligently to figure out which\n             * series makes sense to move to from any given point.\n             *\n             * In \"serialize\" mode, points are instead navigated as a single\n             * list. Left/right behaves as in \"normal\" mode. Up/down arrow keys\n             * will behave like left/right. This is useful for unifying\n             * navigation behavior with/without screen readers enabled.\n             *\n             * @type      {String}\n             * @validvalue [\"normal\", \"serialize\"]\n             * @default   normal\n             * @since     6.0.4\n             * @apioption accessibility.keyboardNavigation.mode\n             */\n\n            /**\n             * Skip null points when navigating through points with the\n             * keyboard.\n             *\n             * @type      {Boolean}\n             * @default   true\n             * @since     5.0.0\n             * @apioption accessibility.keyboardNavigation.skipNullPoints\n             */\n            skipNullPoints: true\n        }\n    }\n});\n\n/**\n * Keyboard navigation for the legend. Requires the Accessibility module.\n * @since 5.0.14\n * @apioption legend.keyboardNavigation\n */\n\n/**\n * Enable/disable keyboard navigation for the legend. Requires the Accessibility\n * module.\n *\n * @type {Boolean}\n * @see [accessibility.keyboardNavigation](\n *      #accessibility.keyboardNavigation.enabled)\n * @default true\n * @since 5.0.13\n * @apioption legend.keyboardNavigation.enabled\n */\n\n\n// Abstraction layer for keyboard navigation. Keep a map of keyCodes to\n// handler functions, and a next/prev move handler for tab order. The\n// module's keyCode handlers determine when to move to another module.\n// Validate holds a function to determine if there are prerequisites for\n// this module to run that are not met. Init holds a function to run once\n// before any keyCodes are interpreted. Terminate holds a function to run\n// once before moving to next/prev module.\n// The chart object keeps track of a list of KeyboardNavigationModules.\nfunction KeyboardNavigationModule(chart, options) {\n    this.chart = chart;\n    this.id = options.id;\n    this.keyCodeMap = options.keyCodeMap;\n    this.validate = options.validate;\n    this.init = options.init;\n    this.terminate = options.terminate;\n}\nKeyboardNavigationModule.prototype = {\n    // Find handler function(s) for key code in the keyCodeMap and run it.\n    run: function (e) {\n        var navModule = this,\n            keyCode = e.which || e.keyCode,\n            found = false,\n            handled = false;\n        each(this.keyCodeMap, function (codeSet) {\n            if (codeSet[0].indexOf(keyCode) > -1) {\n                found = true;\n                handled = codeSet[1].call(navModule, keyCode, e) === false ?\n                    // If explicitly returning false, we haven't handled it\n                    false :\n                    true;\n            }\n        });\n        // Default tab handler, move to next/prev module\n        if (!found && keyCode === 9) {\n            handled = this.move(e.shiftKey ? -1 : 1);\n        }\n        return handled;\n    },\n\n    // Move to next/prev valid module, or undefined if none, and init\n    // it. Returns true on success and false if there is no valid module\n    // to move to.\n    move: function (direction) {\n        var chart = this.chart;\n        if (this.terminate) {\n            this.terminate(direction);\n        }\n        chart.keyboardNavigationModuleIndex += direction;\n        var newModule = chart.keyboardNavigationModules[\n            chart.keyboardNavigationModuleIndex\n        ];\n\n        // Remove existing focus border if any\n        if (chart.focusElement) {\n            chart.focusElement.removeFocusBorder();\n        }\n\n        // Verify new module\n        if (newModule) {\n            if (newModule.validate && !newModule.validate()) {\n                return this.move(direction); // Invalid module, recurse\n            }\n            if (newModule.init) {\n                newModule.init(direction); // Valid module, init it\n                return true;\n            }\n        }\n        // No module\n        chart.keyboardNavigationModuleIndex = 0; // Reset counter\n\n        // Set focus to chart or exit anchor depending on direction\n        if (direction > 0) {\n            this.chart.exiting = true;\n            this.chart.tabExitAnchor.focus();\n        } else {\n            this.chart.renderTo.focus();\n        }\n\n        return false;\n    }\n};\n\n\n// Utility function to attempt to fake a click event on an element\nfunction fakeClickEvent(element) {\n    var fakeEvent;\n    if (element && element.onclick && doc.createEvent) {\n        fakeEvent = doc.createEvent('Events');\n        fakeEvent.initEvent('click', true, false);\n        element.onclick(fakeEvent);\n    }\n}\n\n\n// Determine if a series should be skipped\nfunction isSkipSeries(series) {\n    var a11yOptions = series.chart.options.accessibility;\n    return series.options.skipKeyboardNavigation ||\n        series.options.enableMouseTracking === false || // #8440\n        !series.visible ||\n        // Skip all points in a series where pointDescriptionThreshold is\n        // reached\n        (a11yOptions.pointDescriptionThreshold &&\n        a11yOptions.pointDescriptionThreshold <= series.points.length);\n}\n\n\n// Determine if a point should be skipped\nfunction isSkipPoint(point) {\n    var a11yOptions = point.series.chart.options.accessibility;\n    return point.isNull && a11yOptions.keyboardNavigation.skipNullPoints ||\n        point.visible === false ||\n        isSkipSeries(point.series);\n}\n\n\n// Get the point in a series that is closest (in distance) to a reference point\n// Optionally supply weight factors for x and y directions\nfunction getClosestPoint(point, series, xWeight, yWeight) {\n    var minDistance = Infinity,\n        dPoint,\n        minIx,\n        distance,\n        i = series.points.length;\n    if (point.plotX === undefined || point.plotY === undefined) {\n        return;\n    }\n    while (i--) {\n        dPoint = series.points[i];\n        if (dPoint.plotX === undefined || dPoint.plotY === undefined) {\n            continue;\n        }\n        distance = (point.plotX - dPoint.plotX) *\n                (point.plotX - dPoint.plotX) * (xWeight || 1) +\n                (point.plotY - dPoint.plotY) *\n                (point.plotY - dPoint.plotY) * (yWeight || 1);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minIx = i;\n        }\n    }\n    return minIx !== undefined && series.points[minIx];\n}\n\n\n// Pan along axis in a direction (1 or -1), optionally with a defined\n// granularity (number of steps it takes to walk across current view)\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.prototype.panStep = function (direction, granularity) {\n    var gran = granularity || 3,\n        extremes = this.getExtremes(),\n        step = (extremes.max - extremes.min) / gran * direction,\n        newMax = extremes.max + step,\n        newMin = extremes.min + step,\n        size = newMax - newMin;\n    if (direction < 0 && newMin < extremes.dataMin) {\n        newMin = extremes.dataMin;\n        newMax = newMin + size;\n    } else if (direction > 0 && newMax > extremes.dataMax) {\n        newMax = extremes.dataMax;\n        newMin = newMax - size;\n    }\n    this.setExtremes(newMin, newMax);\n};\n\n\n// Set chart's focus to an SVGElement. Calls focus() on it, and draws the focus\n// border. If the focusElement argument is supplied, it draws the border around\n// svgElement and sets the focus to focusElement.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.setFocusToElement = function (svgElement, focusElement) {\n    var focusBorderOptions = this.options.accessibility\n                .keyboardNavigation.focusBorder,\n        browserFocusElement = focusElement || svgElement;\n    // Set browser focus if possible\n    if (\n        browserFocusElement.element &&\n        browserFocusElement.element.focus\n    ) {\n        browserFocusElement.element.focus();\n        // Hide default focus ring\n        if (focusBorderOptions.hideBrowserFocusOutline) {\n            browserFocusElement.css({ outline: 'none' });\n        }\n    }\n    if (focusBorderOptions.enabled) {\n        // Remove old focus border\n        if (this.focusElement) {\n            this.focusElement.removeFocusBorder();\n        }\n        // Draw focus border (since some browsers don't do it automatically)\n        svgElement.addFocusBorder(focusBorderOptions.margin, {\n            stroke: focusBorderOptions.style.color,\n            strokeWidth: focusBorderOptions.style.lineWidth,\n            borderRadius: focusBorderOptions.style.borderRadius\n        });\n        this.focusElement = svgElement;\n    }\n};\n\n\n// Highlight a point (show tooltip and display hover state). Returns the\n// highlighted point.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.highlight = function () {\n    var chart = this.series.chart;\n    if (!this.isNull) {\n        this.onMouseOver(); // Show the hover marker and tooltip\n    } else {\n        if (chart.tooltip) {\n            chart.tooltip.hide(0);\n        }\n        // Don't call blur on the element, as it messes up the chart div's focus\n    }\n\n    // We focus only after calling onMouseOver because the state change can\n    // change z-index and mess up the element.\n    if (this.graphic) {\n        chart.setFocusToElement(this.graphic);\n    }\n\n    chart.highlightedPoint = this;\n    return this;\n};\n\n\n// Function to highlight next/previous point in chart\n// Returns highlighted point on success, false on failure (no adjacent point to\n// highlight in chosen direction)\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightAdjacentPoint = function (next) {\n    var chart = this,\n        series = chart.series,\n        curPoint = chart.highlightedPoint,\n        curPointIndex = curPoint && getPointIndex(curPoint) || 0,\n        curPoints = curPoint && curPoint.series.points,\n        lastSeries = chart.series && chart.series[chart.series.length - 1],\n        lastPoint = lastSeries && lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1],\n        newSeries,\n        newPoint;\n\n    // If no points, return false\n    if (!series[0] || !series[0].points) {\n        return false;\n    }\n\n    if (!curPoint) {\n        // No point is highlighted yet. Try first/last point depending on move\n        // direction\n        newPoint = next ? series[0].points[0] : lastPoint;\n    } else {\n        // We have a highlighted point.\n        // Grab next/prev point & series\n        newSeries = series[curPoint.series.index + (next ? 1 : -1)];\n        newPoint = curPoints[curPointIndex + (next ? 1 : -1)];\n        if (!newPoint && newSeries) {\n            // Done with this series, try next one\n            newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];\n        }\n\n        // If there is no adjacent point, we return false\n        if (!newPoint) {\n            return false;\n        }\n    }\n\n    // Recursively skip points\n    if (isSkipPoint(newPoint)) {\n        // If we skip this whole series, move to the end of the series before we\n        // recurse, just to optimize\n        newSeries = newPoint.series;\n        if (isSkipSeries(newSeries)) {\n            chart.highlightedPoint = next ?\n                newSeries.points[newSeries.points.length - 1] :\n                newSeries.points[0];\n        } else {\n            // Otherwise, just move one point\n            chart.highlightedPoint = newPoint;\n        }\n        // Retry\n        return chart.highlightAdjacentPoint(next);\n    }\n\n    // There is an adjacent point, highlight it\n    return newPoint.highlight();\n};\n\n\n// Highlight first valid point in a series. Returns the point if successfully\n// highlighted, otherwise false. If there is a highlighted point in the series,\n// use that as starting point.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.highlightFirstValidPoint = function () {\n    var curPoint = this.chart.highlightedPoint,\n        start = (curPoint && curPoint.series) === this ?\n            getPointIndex(curPoint) :\n            0,\n        points = this.points;\n\n    if (points) {\n        for (var i = start, len = points.length; i < len; ++i) {\n            if (!isSkipPoint(points[i])) {\n                return points[i].highlight();\n            }\n        }\n        for (var j = start; j >= 0; --j) {\n            if (!isSkipPoint(points[j])) {\n                return points[j].highlight();\n            }\n        }\n    }\n    return false;\n};\n\n\n// Highlight next/previous series in chart. Returns false if no adjacent series\n// in the direction, otherwise returns new highlighted point.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightAdjacentSeries = function (down) {\n    var chart = this,\n        newSeries,\n        newPoint,\n        adjacentNewPoint,\n        curPoint = chart.highlightedPoint,\n        lastSeries = chart.series && chart.series[chart.series.length - 1],\n        lastPoint = lastSeries && lastSeries.points &&\n                    lastSeries.points[lastSeries.points.length - 1];\n\n    // If no point is highlighted, highlight the first/last point\n    if (!chart.highlightedPoint) {\n        newSeries = down ? (chart.series && chart.series[0]) : lastSeries;\n        newPoint = down ?\n            (newSeries && newSeries.points && newSeries.points[0]) : lastPoint;\n        return newPoint ? newPoint.highlight() : false;\n    }\n\n    newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];\n\n    if (!newSeries) {\n        return false;\n    }\n\n    // We have a new series in this direction, find the right point\n    // Weigh xDistance as counting much higher than Y distance\n    newPoint = getClosestPoint(curPoint, newSeries, 4);\n\n    if (!newPoint) {\n        return false;\n    }\n\n    // New series and point exists, but we might want to skip it\n    if (isSkipSeries(newSeries)) {\n        // Skip the series\n        newPoint.highlight();\n        adjacentNewPoint = chart.highlightAdjacentSeries(down); // Try recurse\n        if (!adjacentNewPoint) {\n            // Recurse failed\n            curPoint.highlight();\n            return false;\n        }\n        // Recurse succeeded\n        return adjacentNewPoint;\n    }\n\n    // Highlight the new point or any first valid point back or forwards from it\n    newPoint.highlight();\n    return newPoint.series.highlightFirstValidPoint();\n};\n\n\n// Highlight the closest point vertically\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightAdjacentPointVertical = function (down) {\n    var curPoint = this.highlightedPoint,\n        minDistance = Infinity,\n        bestPoint;\n\n    if (curPoint.plotX === undefined || curPoint.plotY === undefined) {\n        return false;\n    }\n    each(this.series, function (series) {\n        if (isSkipSeries(series)) {\n            return;\n        }\n        each(series.points, function (point) {\n            if (point.plotY === undefined || point.plotX === undefined ||\n                point === curPoint) {\n                return;\n            }\n            var yDistance = point.plotY - curPoint.plotY,\n                width = Math.abs(point.plotX - curPoint.plotX),\n                distance = Math.abs(yDistance) * Math.abs(yDistance) +\n                    width * width * 4; // Weigh horizontal distance highly\n\n            // Reverse distance number if axis is reversed\n            if (series.yAxis.reversed) {\n                yDistance *= -1;\n            }\n\n            if (\n                yDistance < 0 && down || yDistance > 0 && !down || // Wrong dir\n                distance < 5 || // Points in same spot => infinite loop\n                isSkipPoint(point)\n            ) {\n                return;\n            }\n\n            if (distance < minDistance) {\n                minDistance = distance;\n                bestPoint = point;\n            }\n        });\n    });\n\n    return bestPoint ? bestPoint.highlight() : false;\n};\n\n\n// Show the export menu and focus the first item (if exists)\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.showExportMenu = function () {\n    if (this.exportSVGElements && this.exportSVGElements[0]) {\n        this.exportSVGElements[0].element.onclick();\n        this.highlightExportItem(0);\n    }\n};\n\n\n// Hide export menu\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.hideExportMenu = function () {\n    var chart = this,\n        exportList = chart.exportDivElements;\n    if (exportList && chart.exportContextMenu) {\n        // Reset hover states etc.\n        each(exportList, function (el) {\n            if (el.className === 'highcharts-menu-item' && el.onmouseout) {\n                el.onmouseout();\n            }\n        });\n        chart.highlightedExportItem = 0;\n        // Hide the menu div\n        chart.exportContextMenu.hideMenu();\n        // Make sure the chart has focus and can capture keyboard events\n        chart.container.focus();\n    }\n};\n\n\n// Highlight export menu item by index\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightExportItem = function (ix) {\n    var listItem = this.exportDivElements && this.exportDivElements[ix],\n        curHighlighted =\n            this.exportDivElements &&\n            this.exportDivElements[this.highlightedExportItem];\n\n    if (\n        listItem &&\n        listItem.tagName === 'DIV' &&\n        !(listItem.children && listItem.children.length)\n    ) {\n        if (listItem.focus && hasSVGFocusSupport) {\n            // Only focus if we can set focus back to the elements after\n            // destroying the menu (#7422)\n            listItem.focus();\n        }\n        if (curHighlighted && curHighlighted.onmouseout) {\n            curHighlighted.onmouseout();\n        }\n        if (listItem.onmouseover) {\n            listItem.onmouseover();\n        }\n        this.highlightedExportItem = ix;\n        return true;\n    }\n};\n\n\n// Try to highlight the last valid export menu item\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightLastExportItem = function () {\n    var chart = this,\n        i;\n    if (chart.exportDivElements) {\n        i = chart.exportDivElements.length;\n        while (i--) {\n            if (chart.highlightExportItem(i)) {\n                break;\n            }\n        }\n    }\n};\n\n\n// Highlight range selector button by index\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightRangeSelectorButton = function (ix) {\n    var buttons = this.rangeSelector.buttons;\n    // Deselect old\n    if (buttons[this.highlightedRangeSelectorItemIx]) {\n        buttons[this.highlightedRangeSelectorItemIx].setState(\n            this.oldRangeSelectorItemState || 0\n        );\n    }\n    // Select new\n    this.highlightedRangeSelectorItemIx = ix;\n    if (buttons[ix]) {\n        this.setFocusToElement(buttons[ix].box, buttons[ix]);\n        this.oldRangeSelectorItemState = buttons[ix].state;\n        buttons[ix].setState(2);\n        return true;\n    }\n    return false;\n};\n\n\n// Highlight legend item by index\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.highlightLegendItem = function (ix) {\n    var items = this.legend.allItems,\n        oldIx = this.highlightedLegendItemIx;\n    if (items[ix]) {\n        if (items[oldIx]) {\n            fireEvent(\n                items[oldIx].legendGroup.element,\n                'mouseout'\n            );\n        }\n        // Scroll if we have to\n        if (items[ix].pageIx !== undefined &&\n            items[ix].pageIx + 1 !== this.legend.currentPage) {\n            this.legend.scroll(1 + items[ix].pageIx - this.legend.currentPage);\n        }\n        // Focus\n        this.highlightedLegendItemIx = ix;\n        this.setFocusToElement(items[ix].legendItem, items[ix].legendGroup);\n        fireEvent(items[ix].legendGroup.element, 'mouseover');\n        return true;\n    }\n    return false;\n};\n\n\n// Add keyboard navigation handling modules to chart\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.addKeyboardNavigationModules = function () {\n    var chart = this;\n\n    function navModuleFactory(id, keyMap, options) {\n        return new KeyboardNavigationModule(chart, merge({\n            keyCodeMap: keyMap\n        }, { id: id }, options));\n    }\n\n    // List of the different keyboard handling modes we use depending on where\n    // we are in the chart. Each mode has a set of handling functions mapped to\n    // key codes. Each mode determines when to move to the next/prev mode.\n    chart.keyboardNavigationModules = [\n        // Entry point catching the first tab, allowing users to tab into points\n        // more intuitively.\n        navModuleFactory('entry', []),\n\n        // Points\n        navModuleFactory('points', [\n            // Left/Right\n            [[37, 39], function (keyCode) {\n                var right = keyCode === 39;\n                if (!chart.highlightAdjacentPoint(right)) {\n                    // Failed to highlight next, wrap to last/first\n                    return this.init(right ? 1 : -1);\n                }\n                return true;\n            }],\n            // Up/Down\n            [[38, 40], function (keyCode) {\n                var down = keyCode !== 38,\n                    navOptions = chart.options.accessibility.keyboardNavigation;\n                if (navOptions.mode && navOptions.mode === 'serialize') {\n                    // Act like left/right\n                    if (!chart.highlightAdjacentPoint(down)) {\n                        return this.init(down ? 1 : -1);\n                    }\n                    return true;\n                }\n                // Normal mode, move between series\n                var highlightMethod = chart.highlightedPoint &&\n                        chart.highlightedPoint.series.keyboardMoveVertical ?\n                        'highlightAdjacentPointVertical' :\n                        'highlightAdjacentSeries';\n                chart[highlightMethod](down);\n                return true;\n            }],\n            // Enter/Spacebar\n            [[13, 32], function () {\n                if (chart.highlightedPoint) {\n                    chart.highlightedPoint.firePointEvent('click');\n                }\n            }]\n        ], {\n            // Always start highlighting from scratch when entering this module\n            init: function (dir) {\n                var numSeries = chart.series.length,\n                    i = dir > 0 ? 0 : numSeries,\n                    res;\n                if (dir > 0) {\n                    delete chart.highlightedPoint;\n                    // Find first valid point to highlight\n                    while (i < numSeries) {\n                        res = chart.series[i].highlightFirstValidPoint();\n                        if (res) {\n                            return res;\n                        }\n                        ++i;\n                    }\n                } else {\n                    // Find last valid point to highlight\n                    while (i--) {\n                        chart.highlightedPoint = chart.series[i].points[\n                            chart.series[i].points.length - 1\n                        ];\n                        // Highlight first valid point in the series will also\n                        // look backwards. It always starts from currently\n                        // highlighted point.\n                        res = chart.series[i].highlightFirstValidPoint();\n                        if (res) {\n                            return res;\n                        }\n                    }\n                }\n            },\n            // If leaving points, don't show tooltip anymore\n            terminate: function () {\n                if (chart.tooltip) {\n                    chart.tooltip.hide(0);\n                }\n                delete chart.highlightedPoint;\n            }\n        }),\n\n        // Exporting\n        navModuleFactory('exporting', [\n            // Left/Up\n            [[37, 38], function () {\n                var i = chart.highlightedExportItem || 0,\n                    reachedEnd = true;\n                // Try to highlight prev item in list. Highlighting e.g.\n                // separators will fail.\n                while (i--) {\n                    if (chart.highlightExportItem(i)) {\n                        reachedEnd = false;\n                        break;\n                    }\n                }\n                if (reachedEnd) {\n                    chart.highlightLastExportItem();\n                    return true;\n                }\n            }],\n            // Right/Down\n            [[39, 40], function () {\n                var highlightedExportItem = chart.highlightedExportItem || 0,\n                    reachedEnd = true;\n                // Try to highlight next item in list. Highlighting e.g.\n                // separators will fail.\n                for (\n                    var i = highlightedExportItem + 1;\n                    i < chart.exportDivElements.length;\n                    ++i\n                ) {\n                    if (chart.highlightExportItem(i)) {\n                        reachedEnd = false;\n                        break;\n                    }\n                }\n                if (reachedEnd) {\n                    chart.highlightExportItem(0);\n                    return true;\n                }\n            }],\n            // Enter/Spacebar\n            [[13, 32], function () {\n                fakeClickEvent(\n                    chart.exportDivElements[chart.highlightedExportItem]\n                );\n            }]\n        ], {\n            // Only run exporting navigation if exporting support exists and is\n            // enabled on chart\n            validate: function () {\n                return (\n                    chart.exportChart &&\n                    !(\n                        chart.options.exporting &&\n                        chart.options.exporting.enabled === false\n                    )\n                );\n            },\n            // Show export menu\n            init: function (direction) {\n                chart.highlightedPoint = null;\n                chart.showExportMenu();\n                // If coming back to export menu from other module, try to\n                // highlight last item in menu\n                if (direction < 0) {\n                    chart.highlightLastExportItem();\n                }\n            },\n            // Hide the menu\n            terminate: function () {\n                chart.hideExportMenu();\n            }\n        }),\n\n        // Map zoom\n        navModuleFactory('mapZoom', [\n            // Up/down/left/right\n            [[38, 40, 37, 39], function (keyCode) {\n                chart[keyCode === 38 || keyCode === 40 ? 'yAxis' : 'xAxis'][0]\n                    .panStep(keyCode < 39 ? -1 : 1);\n            }],\n\n            // Tabs\n            [[9], function (keyCode, e) {\n                var button;\n                // Deselect old\n                chart.mapNavButtons[chart.focusedMapNavButtonIx].setState(0);\n                if (\n                    e.shiftKey && !chart.focusedMapNavButtonIx ||\n                    !e.shiftKey && chart.focusedMapNavButtonIx\n                ) { // trying to go somewhere we can't?\n                    chart.mapZoom(); // Reset zoom\n                    // Nowhere to go, go to prev/next module\n                    return this.move(e.shiftKey ? -1 : 1);\n                }\n                chart.focusedMapNavButtonIx += e.shiftKey ? -1 : 1;\n                button = chart.mapNavButtons[chart.focusedMapNavButtonIx];\n                chart.setFocusToElement(button.box, button);\n                button.setState(2);\n            }],\n\n            // Enter/Spacebar\n            [[13, 32], function () {\n                fakeClickEvent(\n                    chart.mapNavButtons[chart.focusedMapNavButtonIx].element\n                );\n            }]\n        ], {\n            // Only run this module if we have map zoom on the chart\n            validate: function () {\n                return (\n                    chart.mapZoom &&\n                    chart.mapNavButtons &&\n                    chart.mapNavButtons.length === 2\n                );\n            },\n\n            // Make zoom buttons do their magic\n            init: function (direction) {\n                var zoomIn = chart.mapNavButtons[0],\n                    zoomOut = chart.mapNavButtons[1],\n                    initialButton = direction > 0 ? zoomIn : zoomOut;\n\n                each(chart.mapNavButtons, function (button, i) {\n                    button.element.setAttribute('tabindex', -1);\n                    button.element.setAttribute('role', 'button');\n                    button.element.setAttribute(\n                        'aria-label',\n                        chart.langFormat(\n                            'accessibility.mapZoom' + (i ? 'Out' : 'In'),\n                            { chart: chart }\n                        )\n                    );\n                });\n\n                chart.setFocusToElement(initialButton.box, initialButton);\n                initialButton.setState(2);\n                chart.focusedMapNavButtonIx = direction > 0 ? 0 : 1;\n            }\n        }),\n\n        // Highstock range selector (minus input boxes)\n        navModuleFactory('rangeSelector', [\n            // Left/Right/Up/Down\n            [[37, 39, 38, 40], function (keyCode) {\n                var direction = (keyCode === 37 || keyCode === 38) ? -1 : 1;\n                // Try to highlight next/prev button\n                if (\n                    !chart.highlightRangeSelectorButton(\n                        chart.highlightedRangeSelectorItemIx + direction\n                    )\n                ) {\n                    return this.move(direction);\n                }\n            }],\n            // Enter/Spacebar\n            [[13, 32], function () {\n                // Don't allow click if button used to be disabled\n                if (chart.oldRangeSelectorItemState !== 3) {\n                    fakeClickEvent(\n                        chart.rangeSelector.buttons[\n                            chart.highlightedRangeSelectorItemIx\n                        ].element\n                    );\n                }\n            }]\n        ], {\n            // Only run this module if we have range selector\n            validate: function () {\n                return (\n                    chart.rangeSelector &&\n                    chart.rangeSelector.buttons &&\n                    chart.rangeSelector.buttons.length\n                );\n            },\n\n            // Make elements focusable and accessible\n            init: function (direction) {\n                each(chart.rangeSelector.buttons, function (button) {\n                    button.element.setAttribute('tabindex', '-1');\n                    button.element.setAttribute('role', 'button');\n                    button.element.setAttribute(\n                        'aria-label',\n                        chart.langFormat(\n                            'accessibility.rangeSelectorButton',\n                            {\n                                chart: chart,\n                                buttonText: button.text && button.text.textStr\n                            }\n                        )\n                    );\n                });\n                // Focus first/last button\n                chart.highlightRangeSelectorButton(\n                    direction > 0 ? 0 : chart.rangeSelector.buttons.length - 1\n                );\n            }\n        }),\n\n        // Highstock range selector, input boxes\n        navModuleFactory('rangeSelectorInput', [\n            // Tab/Up/Down\n            [[9, 38, 40], function (keyCode, e) {\n                var direction =\n                    (keyCode === 9 && e.shiftKey || keyCode === 38) ? -1 : 1,\n\n                    newIx = chart.highlightedInputRangeIx =\n                        chart.highlightedInputRangeIx + direction;\n\n                // Try to highlight next/prev item in list.\n                if (newIx > 1 || newIx < 0) { // Out of range\n                    return this.move(direction);\n                }\n                chart.rangeSelector[newIx ? 'maxInput' : 'minInput'].focus();\n            }]\n        ], {\n            // Only run if we have range selector with input boxes\n            validate: function () {\n                var inputVisible = (\n                    chart.rangeSelector &&\n                    chart.rangeSelector.inputGroup &&\n                    chart.rangeSelector.inputGroup.element\n                        .getAttribute('visibility') !== 'hidden'\n                );\n                return (\n                    inputVisible &&\n                    chart.options.rangeSelector.inputEnabled !== false &&\n                    chart.rangeSelector.minInput &&\n                    chart.rangeSelector.maxInput\n                );\n            },\n\n            // Highlight first/last input box\n            init: function (direction) {\n                chart.highlightedInputRangeIx = direction > 0 ? 0 : 1;\n                chart.rangeSelector[\n                    chart.highlightedInputRangeIx ? 'maxInput' : 'minInput'\n                ].focus();\n            }\n        }),\n\n        // Legend navigation\n        navModuleFactory('legend', [\n            // Left/Right/Up/Down\n            [[37, 39, 38, 40], function (keyCode) {\n                var direction = (keyCode === 37 || keyCode === 38) ? -1 : 1;\n                // Try to highlight next/prev legend item\n                if (!chart.highlightLegendItem(\n                    chart.highlightedLegendItemIx + direction\n                ) && chart.legend.allItems.length > 1) {\n                    // Wrap around if more than 1 item\n                    this.init(direction);\n                }\n            }],\n            // Enter/Spacebar\n            [[13, 32], function () {\n                var legendElement = chart.legend.allItems[\n                        chart.highlightedLegendItemIx\n                    ].legendItem.element;\n                fakeClickEvent(\n                     !chart.legend.options.useHTML ? // #8561\n                        legendElement.parentNode : legendElement\n                );\n            }]\n        ], {\n            // Only run this module if we have at least one legend - wait for\n            // it - item. Don't run if the legend is populated by a colorAxis.\n            // Don't run if legend navigation is disabled.\n            validate: function () {\n                return chart.legend && chart.legend.allItems &&\n                    chart.legend.display &&\n                    !(chart.colorAxis && chart.colorAxis.length) &&\n                    (chart.options.legend &&\n                    chart.options.legend.keyboardNavigation &&\n                    chart.options.legend.keyboardNavigation.enabled) !== false;\n            },\n\n            // Make elements focusable and accessible\n            init: function (direction) {\n                each(chart.legend.allItems, function (item) {\n                    item.legendGroup.element.setAttribute('tabindex', '-1');\n                    item.legendGroup.element.setAttribute('role', 'button');\n                    item.legendGroup.element.setAttribute(\n                        'aria-label',\n                        chart.langFormat(\n                            'accessibility.legendItem',\n                            {\n                                chart: chart,\n                                itemName: stripTags(item.name)\n                            }\n                        )\n                    );\n                });\n                // Focus first/last item\n                chart.highlightLegendItem(\n                    direction > 0 ? 0 : chart.legend.allItems.length - 1\n                );\n            }\n        })\n    ];\n};\n\n\n// Add exit anchor to the chart\n// We use this to move focus out of chart whenever we want, by setting focus\n// to this div and not preventing the default tab action.\n// We also use this when users come back into the chart by tabbing back, in\n// order to navigate from the end of the chart.\n// Function returns the unbind function for the exit anchor's event handler.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.addExitAnchor = function () {\n    var chart = this;\n    chart.tabExitAnchor = doc.createElement('div');\n    chart.tabExitAnchor.setAttribute('tabindex', '0');\n\n    // Hide exit anchor\n    merge(true, chart.tabExitAnchor.style, {\n        position: 'absolute',\n        left: '-9999px',\n        top: 'auto',\n        width: '1px',\n        height: '1px',\n        overflow: 'hidden'\n    });\n\n    chart.renderTo.appendChild(chart.tabExitAnchor);\n    return addEvent(chart.tabExitAnchor, 'focus',\n        function (ev) {\n            var e = ev || win.event,\n                curModule;\n\n            // If focusing and we are exiting, do nothing once.\n            if (!chart.exiting) {\n\n                // Not exiting, means we are coming in backwards\n                chart.renderTo.focus();\n                e.preventDefault();\n\n                // Move to last valid keyboard nav module\n                // Note the we don't run it, just set the index\n                chart.keyboardNavigationModuleIndex =\n                    chart.keyboardNavigationModules.length - 1;\n                curModule = chart.keyboardNavigationModules[\n                    chart.keyboardNavigationModuleIndex\n                ];\n\n                // Validate the module\n                if (curModule.validate && !curModule.validate()) {\n                    // Invalid.\n                    // Move inits next valid module in direction\n                    curModule.move(-1);\n                } else {\n                    // We have a valid module, init it\n                    curModule.init(-1);\n                }\n\n            } else {\n                // Don't skip the next focus, we only skip once.\n                chart.exiting = false;\n            }\n        }\n    );\n};\n\n\n// Clear the chart and reset the navigation state\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.resetKeyboardNavigation = function () {\n    var chart = this,\n        curMod = (\n            chart.keyboardNavigationModules &&\n            chart.keyboardNavigationModules[\n                chart.keyboardNavigationModuleIndex || 0\n            ]\n        );\n    if (curMod && curMod.terminate) {\n        curMod.terminate();\n    }\n    if (chart.focusElement) {\n        chart.focusElement.removeFocusBorder();\n    }\n    chart.keyboardNavigationModuleIndex = 0;\n    chart.keyboardReset = true;\n};\n\n\n/**\n * On destroy, we need to clean up the focus border and the state\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'destroy', function () {\n    var chart = this.chart;\n    if (chart.highlightedPoint && chart.highlightedPoint.series === this) {\n        delete chart.highlightedPoint;\n        if (chart.focusElement) {\n            chart.focusElement.removeFocusBorder();\n        }\n    }\n});\n\n\n// Add keyboard navigation events on chart load\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.callbacks.push(function (chart) {\n    var a11yOptions = chart.options.accessibility;\n    if (a11yOptions.enabled && a11yOptions.keyboardNavigation.enabled) {\n\n        // Test if we have focus support for SVG elements\n        hasSVGFocusSupport = !!chart.renderTo\n                                .getElementsByTagName('g')[0].focus;\n\n        // Init nav modules. We start at the first module, and as the user\n        // navigates through the chart the index will increase to use different\n        // handler modules.\n        chart.addKeyboardNavigationModules();\n        chart.keyboardNavigationModuleIndex = 0;\n\n        // Make chart container reachable by tab\n        if (\n            chart.container.hasAttribute &&\n            !chart.container.hasAttribute('tabIndex')\n        ) {\n            chart.container.setAttribute('tabindex', '0');\n        }\n\n        // Add tab exit anchor\n        if (!chart.tabExitAnchor) {\n            chart.unbindExitAnchorFocus = chart.addExitAnchor();\n        }\n\n        // Handle keyboard events by routing them to active keyboard nav module\n        chart.unbindKeydownHandler = addEvent(chart.renderTo, 'keydown',\n            function (ev) {\n                var e = ev || win.event,\n                    curNavModule = chart.keyboardNavigationModules[\n                        chart.keyboardNavigationModuleIndex\n                    ];\n                chart.keyboardReset = false;\n                // If there is a nav module for the current index, run it.\n                // Otherwise, we are outside of the chart in some direction.\n                if (curNavModule) {\n                    if (curNavModule.run(e)) {\n                        // Successfully handled this key event, stop default\n                        e.preventDefault();\n                    }\n                }\n            });\n\n        // Reset chart navigation state if we click outside the chart and it's\n        // not already reset\n        chart.unbindBlurHandler = addEvent(doc, 'mouseup', function () {\n            if (\n                !chart.keyboardReset &&\n                !(chart.pointer && chart.pointer.chartPosition)\n            ) {\n                chart.resetKeyboardNavigation();\n            }\n        });\n\n        // Add cleanup handlers\n        addEvent(chart, 'destroy', function () {\n            chart.resetKeyboardNavigation();\n            if (chart.unbindExitAnchorFocus && chart.tabExitAnchor) {\n                chart.unbindExitAnchorFocus();\n            }\n            if (chart.unbindKeydownHandler && chart.renderTo) {\n                chart.unbindKeydownHandler();\n            }\n            if (chart.unbindBlurHandler) {\n                chart.unbindBlurHandler();\n            }\n        });\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/keyboard-navigation.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/no-data-to-display.src.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/no-data-to-display.src.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * Plugin for displaying a message when there is no data visible in chart.\n *\n * (c) 2010-2017 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    chartPrototype = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype,\n    defaultOptions = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getOptions(),\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each;\n\n// Add language option\nextend(defaultOptions.lang, {\n    /**\n     * The text to display when the chart contains no data. Requires the\n     * no-data module, see [noData](#noData).\n     *\n     * @type {String}\n     * @default No data to display\n     * @since 3.0.8\n     * @product highcharts highstock\n     * @sample highcharts/no-data-to-display/no-data-line\n     *         No-data text\n     * @apioption lang.noData\n     */\n    noData: 'No data to display'\n});\n\n// Add default display options for message\n/**\n * Options for displaying a message like \"No data to display\".\n * This feature requires the file no-data-to-display.js to be loaded in the\n * page. The actual text to display is set in the lang.noData option.\n * @type {Object}\n *\n * @sample highcharts/no-data-to-display/no-data-line\n *         Line chart with no-data module\n * @sample highcharts/no-data-to-display/no-data-pie\n *         Pie chart with no-data module\n * @optionparent noData\n */\ndefaultOptions.noData = {\n\n    /**\n     * An object of additional SVG attributes for the no-data label.\n     *\n     * @type {Object}\n     * @since 3.0.8\n     * @product highcharts highstock\n     * @apioption noData.attr\n     */\n\n    /**\n     * Whether to insert the label as HTML, or as pseudo-HTML rendered with\n     * SVG.\n     *\n     * @type {Boolean}\n     * @default false\n     * @since 4.1.10\n     * @product highcharts highstock\n     * @apioption noData.useHTML\n     */\n\n    /**\n     * The position of the no-data label, relative to the plot area.\n     *\n     * @type {Object}\n     * @default { \"x\": 0, \"y\": 0, \"align\": \"center\", \"verticalAlign\": \"middle\" }\n     * @since 3.0.8\n     */\n    position: {\n\n        /**\n         * Horizontal offset of the label, in pixels.\n         *\n         * @type {Number}\n         * @default 0\n         * @product highcharts highstock\n         */\n        x: 0,\n\n        /**\n         * Vertical offset of the label, in pixels.\n         *\n         * @type {Number}\n         * @default 0\n         * @product highcharts highstock\n         */\n        y: 0,\n\n        /**\n         * Horizontal alignment of the label.\n         *\n         * @validvalue [\"left\", \"center\", \"right\"]\n         * @type {String}\n         * @default center\n         */\n        align: 'center',\n\n        /**\n         * Vertical alignment of the label.\n         *\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @type {String}\n         * @default middle\n         * @product highcharts highstock\n         */\n        verticalAlign: 'middle'\n    }\n};\n\n\n\n\n// Define hasData function for non-cartesian seris. Returns true if the series\n// has points at all.\neach([\n    'bubble',\n    'gauge',\n    'heatmap',\n    'pie',\n    'sankey',\n    'treemap',\n    'waterfall'\n], function (type) {\n    if (seriesTypes[type]) {\n        seriesTypes[type].prototype.hasData = function () {\n            return !!this.points.length; // != 0\n        };\n    }\n});\n\n/**\n * Define hasData functions for series. These return true if there are data\n * points on this series within the plot area.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.hasData = function () {\n    return (\n        this.visible &&\n        this.dataMax !== undefined &&\n        this.dataMin !== undefined // #3703\n    );\n};\n\n/**\n * Display a no-data message.\n *\n * @param {String} str An optional message to show in place of the default one\n */\nchartPrototype.showNoData = function (str) {\n    var chart = this,\n        options = chart.options,\n        text = str || (options && options.lang.noData),\n        noDataOptions = options && options.noData;\n\n    if (!chart.noDataLabel && chart.renderer) {\n        chart.noDataLabel = chart.renderer\n            .label(\n                text,\n                0,\n                0,\n                null,\n                null,\n                null,\n                noDataOptions.useHTML,\n                null,\n                'no-data'\n            );\n\n        \n\n        chart.noDataLabel.add();\n\n        chart.noDataLabel.align(\n            extend(chart.noDataLabel.getBBox(), noDataOptions.position),\n            false,\n            'plotBox'\n        );\n    }\n};\n\n/**\n * Hide no-data message\n */\nchartPrototype.hideNoData = function () {\n    var chart = this;\n    if (chart.noDataLabel) {\n        chart.noDataLabel = chart.noDataLabel.destroy();\n    }\n};\n\n/**\n * Returns true if there are data points within the plot area now\n */\nchartPrototype.hasData = function () {\n    var chart = this,\n        series = chart.series || [],\n        i = series.length;\n\n    while (i--) {\n        if (series[i].hasData() && !series[i].options.isInternal) {\n            return true;\n        }\n    }\n\n    return chart.loadingShown; // #4588\n};\n\n/**\n * Add event listener to handle automatic show or hide no-data message\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart, 'render', function handleNoData() {\n    if (this.hasData()) {\n        this.hideNoData();\n    } else {\n        this.showNoData();\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/no-data-to-display.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/overlapping-datalabels.src.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/overlapping-datalabels.src.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/**\n * (c) 2009-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n/**\n * Highcharts module to hide overlapping data labels. This module is included in\n * Highcharts.\n *\n * @ignore\n */\nvar Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    objectEach = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent;\n\n// Collect potensial overlapping data labels. Stack labels probably don't need\n// to be considered because they are usually accompanied by data labels that lie\n// inside the columns.\naddEvent(Chart, 'render', function collectAndHide() {\n    var labels = [];\n    // Consider external label collectors\n    each(this.labelCollectors || [], function (collector) {\n        labels = labels.concat(collector());\n    });\n\n    each(this.yAxis || [], function (yAxis) {\n        if (\n            yAxis.options.stackLabels &&\n            !yAxis.options.stackLabels.allowOverlap\n        ) {\n            objectEach(yAxis.stacks, function (stack) {\n                objectEach(stack, function (stackItem) {\n                    labels.push(stackItem.label);\n                });\n            });\n        }\n    });\n\n    each(this.series || [], function (series) {\n        var dlOptions = series.options.dataLabels,\n            // Range series have two collections\n            collections = series.dataLabelCollections || ['dataLabel'];\n\n        if (\n            (dlOptions.enabled || series._hasPointLabels) &&\n            !dlOptions.allowOverlap &&\n            series.visible\n        ) { // #3866\n            each(collections, function (coll) {\n                each(series.points, function (point) {\n                    if (point[coll] && point.visible) {  // #7815\n                        point[coll].labelrank = pick(\n                            point.labelrank,\n                            point.shapeArgs && point.shapeArgs.height\n                        ); // #4118\n                        labels.push(point[coll]);\n                    }\n                });\n            });\n        }\n    });\n\n    this.hideOverlappingLabels(labels);\n});\n\n/**\n * Hide overlapping labels. Labels are moved and faded in and out on zoom to\n * provide a smooth visual imression.\n */\nChart.prototype.hideOverlappingLabels = function (labels) {\n\n    var len = labels.length,\n        ren = this.renderer,\n        label,\n        i,\n        j,\n        label1,\n        label2,\n        isIntersecting,\n        box1,\n        box2,\n        intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n            return !(\n                x2 > x1 + w1 ||\n                x2 + w2 < x1 ||\n                y2 > y1 + h1 ||\n                y2 + h2 < y1\n            );\n        },\n\n        /**\n         * Get the box with its position inside the chart, as opposed to getBBox\n         * that only reports the position relative to the parent.\n         */\n        getAbsoluteBox = function (label) {\n            var pos,\n                parent,\n                bBox,\n                // Substract the padding if no background or border (#4333)\n                padding = 2 * (label.box ? 0 : (label.padding || 0)),\n                lineHeightCorrection = 0;\n\n            if (\n                label &&\n                (!label.alignAttr || label.placed)\n            ) {\n                pos = label.alignAttr || {\n                    x: label.attr('x'),\n                    y: label.attr('y')\n                };\n                parent = label.parentGroup;\n\n                // Get width and height if pure text nodes (stack labels)\n                if (!label.width) {\n                    bBox = label.getBBox();\n                    label.width = bBox.width;\n                    label.height = bBox.height;\n\n                    // Labels positions are computed from top left corner, so\n                    // we need to substract the text height from text nodes too.\n                    lineHeightCorrection = ren\n                        .fontMetrics(null, label.element).h;\n                }\n                return {\n                    x: pos.x + (parent.translateX || 0),\n                    y: pos.y + (parent.translateY || 0) - lineHeightCorrection,\n                    width: label.width - padding,\n                    height: label.height - padding\n                };\n\n            }\n        };\n\n    for (i = 0; i < len; i++) {\n        label = labels[i];\n        if (label) {\n\n            // Mark with initial opacity\n            label.oldOpacity = label.opacity;\n            label.newOpacity = 1;\n\n            label.absoluteBox = getAbsoluteBox(label);\n\n        }\n    }\n\n    // Prevent a situation in a gradually rising slope, that each label will\n    // hide the previous one because the previous one always has lower rank.\n    labels.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n    });\n\n    // Detect overlapping labels\n    for (i = 0; i < len; i++) {\n        label1 = labels[i];\n        box1 = label1 && label1.absoluteBox;\n\n        for (j = i + 1; j < len; ++j) {\n            label2 = labels[j];\n            box2 = label2 && label2.absoluteBox;\n\n            if (\n                box1 &&\n                box2 &&\n                label1 !== label2 && // #6465, polar chart with connectEnds\n                label1.newOpacity !== 0 &&\n                label2.newOpacity !== 0\n            ) {\n                isIntersecting = intersectRect(\n                    box1.x,\n                    box1.y,\n                    box1.width,\n                    box1.height,\n                    box2.x,\n                    box2.y,\n                    box2.width,\n                    box2.height\n                );\n\n\n                if (isIntersecting) {\n                    (label1.labelrank < label2.labelrank ? label1 : label2)\n                        .newOpacity = 0;\n                }\n            }\n        }\n    }\n\n    // Hide or show\n    each(labels, function (label) {\n        var complete,\n            newOpacity;\n\n        if (label) {\n            newOpacity = label.newOpacity;\n\n            if (label.oldOpacity !== newOpacity) {\n\n                // Make sure the label is completely hidden to avoid catching\n                // clicks (#4362)\n                if (label.alignAttr && label.placed) { // data labels\n                    if (newOpacity) {\n                        label.show(true);\n                    } else {\n                        complete = function () {\n                            label.hide();\n                        };\n                    }\n\n                    // Animate or set the opacity\n                    label.alignAttr.opacity = newOpacity;\n                    label[label.isOld ? 'animate' : 'attr'](\n                        label.alignAttr,\n                        null,\n                        complete\n                    );\n                } else { // other labels, tick labels\n                    label.attr({\n                        opacity: newOpacity\n                    });\n                }\n\n            }\n            label.isOld = true;\n        }\n    });\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/overlapping-datalabels.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/screen-reader.src.js":
/*!****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/screen-reader.src.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/**\n * Accessibility module - Screen Reader support\n *\n * (c) 2010-2017 Highsoft AS\n * Author: Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\nvar win = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    doc = win.document,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    map = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    erase = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    // CSS style to hide element from visual users while still exposing it to\n    // screen readers\n    hiddenStyle = {\n        position: 'absolute',\n        left: '-9999px',\n        top: 'auto',\n        width: '1px',\n        height: '1px',\n        overflow: 'hidden'\n    };\n\n// If a point has one of the special keys defined, we expose all keys to the\n// screen reader.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.commonKeys = ['name', 'id', 'category', 'x', 'value', 'y'];\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.specialKeys = [\n    'z', 'open', 'high', 'q3', 'median', 'q1', 'low', 'close'\n];\nif (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.pie) {\n    // A pie is always simple. Don't quote me on that.\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.pie.prototype.specialKeys = [];\n}\n\n\n/**\n * HTML encode some characters vulnerable for XSS.\n * @param  {string} html The input string\n * @return {string} The excaped string\n */\nfunction htmlencode(html) {\n    return html\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#x27;')\n        .replace(/\\//g, '&#x2F;');\n}\n\n\n/**\n * Strip HTML tags away from a string. Used for aria-label attributes, painting\n * on a canvas will fail if the text contains tags.\n * @param  {String} s The input string\n * @return {String}   The filtered string\n */\nfunction stripTags(s) {\n    return typeof s === 'string' ? s.replace(/<\\/?[^>]+(>|$)/g, '') : s;\n}\n\n\n/**\n * Accessibility options\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setOptions({\n\n    /**\n     * Options for configuring accessibility for the chart. Requires the\n     * [accessibility module](//code.highcharts.com/modules/accessibility.\n     * js) to be loaded. For a description of the module and information\n     * on its features, see [Highcharts Accessibility](http://www.highcharts.\n     * com/docs/chart-concepts/accessibility).\n     *\n     * @since 5.0.0\n     * @type {Object}\n     * @optionparent accessibility\n     */\n    accessibility: {\n\n        /**\n         * Whether or not to add series descriptions to charts with a single\n         * series.\n         *\n         * @type {Boolean}\n         * @default false\n         * @since 5.0.0\n         * @apioption accessibility.describeSingleSeries\n         */\n\n        /**\n         * Function to run upon clicking the \"View as Data Table\" link in the\n         * screen reader region.\n         *\n         * By default Highcharts will insert and set focus to a data table\n         * representation of the chart.\n         *\n         * @type {Function}\n         * @since 5.0.0\n         * @apioption accessibility.onTableAnchorClick\n         */\n\n        /**\n         * Date format to use for points on datetime axes when describing them\n         * to screen reader users.\n         *\n         * Defaults to the same format as in tooltip.\n         *\n         * For an overview of the replacement codes, see\n         * [dateFormat](/class-reference/Highcharts#dateFormat).\n         *\n         * @type {String}\n         * @see [pointDateFormatter](#accessibility.pointDateFormatter)\n         * @since 5.0.0\n         * @apioption accessibility.pointDateFormat\n         */\n\n        /**\n         * Formatter function to determine the date/time format used with\n         * points on datetime axes when describing them to screen reader users.\n         * Receives one argument, `point`, referring to the point to describe.\n         * Should return a date format string compatible with\n         * [dateFormat](/class-reference/Highcharts#dateFormat).\n         *\n         * @type {Function}\n         * @see [pointDateFormat](#accessibility.pointDateFormat)\n         * @since 5.0.0\n         * @apioption accessibility.pointDateFormatter\n         */\n\n        /**\n         * Formatter function to use instead of the default for point\n         * descriptions.\n         * Receives one argument, `point`, referring to the point to describe.\n         * Should return a String with the description of the point for a screen\n         * reader user.\n         *\n         * @type {Function}\n         * @see [point.description](#series.line.data.description)\n         * @since 5.0.0\n         * @apioption accessibility.pointDescriptionFormatter\n         */\n\n        /**\n         * Formatter function to use instead of the default for series\n         * descriptions. Receives one argument, `series`, referring to the\n         * series to describe. Should return a String with the description of\n         * the series for a screen reader user.\n         *\n         * @type {Function}\n         * @see [series.description](#plotOptions.series.description)\n         * @since 5.0.0\n         * @apioption accessibility.seriesDescriptionFormatter\n         */\n\n        /**\n         * Enable accessibility features for the chart.\n         *\n         * @type {Boolean}\n         * @default true\n         * @since 5.0.0\n         */\n        enabled: true,\n\n        /**\n         * When a series contains more points than this, we no longer expose\n         * information about individual points to screen readers.\n         *\n         * Set to `false` to disable.\n         *\n         * @type {Number|Boolean}\n         * @since 5.0.0\n         */\n        pointDescriptionThreshold: false, // set to false to disable\n\n        /**\n         * A formatter function to create the HTML contents of the hidden screen\n         * reader information region. Receives one argument, `chart`, referring\n         * to the chart object. Should return a String with the HTML content\n         * of the region.\n         *\n         * The link to view the chart as a data table will be added\n         * automatically after the custom HTML content.\n         *\n         * @type {Function}\n         * @default undefined\n         * @since 5.0.0\n         */\n        screenReaderSectionFormatter: function (chart) {\n            var options = chart.options,\n                chartTypes = chart.types || [],\n                formatContext = {\n                    chart: chart,\n                    numSeries: chart.series && chart.series.length\n                },\n                // Build axis info - but not for pies and maps. Consider not\n                // adding for certain other types as well (funnel, pyramid?)\n                axesDesc = (\n                    chartTypes.length === 1 && chartTypes[0] === 'pie' ||\n                    chartTypes[0] === 'map'\n                ) && {} || chart.getAxesDescription();\n\n            return '<div>' + chart.langFormat(\n                        'accessibility.navigationHint', formatContext\n                    ) + '</div><h3>' +\n                    (\n                        options.title.text ?\n                            htmlencode(options.title.text) :\n                            chart.langFormat(\n                                'accessibility.defaultChartTitle', formatContext\n                            )\n                    ) +\n                    (\n                        options.subtitle && options.subtitle.text ?\n                            '. ' + htmlencode(options.subtitle.text) :\n                            ''\n                    ) +\n                    '</h3><h4>' + chart.langFormat(\n                        'accessibility.longDescriptionHeading', formatContext\n                    ) + '</h4><div>' +\n                    (\n                        options.chart.description || chart.langFormat(\n                            'accessibility.noDescription', formatContext\n                        )\n                    ) +\n                    '</div><h4>' + chart.langFormat(\n                        'accessibility.structureHeading', formatContext\n                    ) + '</h4><div>' +\n                    (\n                        options.chart.typeDescription ||\n                        chart.getTypeDescription()\n                    ) + '</div>' +\n                    (axesDesc.xAxis ? (\n                        '<div>' + axesDesc.xAxis + '</div>'\n                    ) : '') +\n                    (axesDesc.yAxis ? (\n                        '<div>' + axesDesc.yAxis + '</div>'\n                    ) : '');\n        }\n    }\n});\n\n/**\n * A text description of the chart.\n *\n * If the Accessibility module is loaded, this is included by default\n * as a long description of the chart and its contents in the hidden\n * screen reader information region.\n *\n * @type {String}\n * @see [typeDescription](#chart.typeDescription)\n * @default undefined\n * @since 5.0.0\n * @apioption chart.description\n */\n\n /**\n * A text description of the chart type.\n *\n * If the Accessibility module is loaded, this will be included in the\n * description of the chart in the screen reader information region.\n *\n *\n * Highcharts will by default attempt to guess the chart type, but for\n * more complex charts it is recommended to specify this property for\n * clarity.\n *\n * @type {String}\n * @default undefined\n * @since 5.0.0\n * @apioption chart.typeDescription\n */\n\n\n// Utility function. Reverses child nodes of a DOM element\nfunction reverseChildNodes(node) {\n    var i = node.childNodes.length;\n    while (i--) {\n        node.appendChild(node.childNodes[i]);\n    }\n}\n\n\n// Whenever drawing series, put info on DOM elements\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'afterRender', function () {\n    if (this.chart.options.accessibility.enabled) {\n        this.setA11yDescription();\n    }\n});\n\n\n// Put accessible info on series and points of a series\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.setA11yDescription = function () {\n    var a11yOptions = this.chart.options.accessibility,\n        firstPointEl = (\n            this.points &&\n            this.points.length &&\n            this.points[0].graphic &&\n            this.points[0].graphic.element\n        ),\n        seriesEl = (\n            firstPointEl &&\n            firstPointEl.parentNode || this.graph &&\n            this.graph.element || this.group &&\n            this.group.element\n        ); // Could be tracker series depending on series type\n\n    if (seriesEl) {\n        // For some series types the order of elements do not match the order of\n        // points in series. In that case we have to reverse them in order for\n        // AT to read them out in an understandable order\n        if (seriesEl.lastChild === firstPointEl) {\n            reverseChildNodes(seriesEl);\n        }\n        // Make individual point elements accessible if possible. Note: If\n        // markers are disabled there might not be any elements there to make\n        // accessible.\n        if (\n            this.points && (\n                this.points.length < a11yOptions.pointDescriptionThreshold ||\n                a11yOptions.pointDescriptionThreshold === false\n            )\n        ) {\n            each(this.points, function (point) {\n                if (point.graphic) {\n                    point.graphic.element.setAttribute('role', 'img');\n                    point.graphic.element.setAttribute('tabindex', '-1');\n                    point.graphic.element.setAttribute('aria-label', stripTags(\n                        point.series.options.pointDescriptionFormatter &&\n                        point.series.options.pointDescriptionFormatter(point) ||\n                        a11yOptions.pointDescriptionFormatter &&\n                        a11yOptions.pointDescriptionFormatter(point) ||\n                        point.buildPointInfoString()\n                    ));\n                }\n            });\n        }\n        // Make series element accessible\n        if (this.chart.series.length > 1 || a11yOptions.describeSingleSeries) {\n            seriesEl.setAttribute(\n                'role',\n                this.options.exposeElementToA11y ? 'img' : 'region'\n            );\n            seriesEl.setAttribute('tabindex', '-1');\n            seriesEl.setAttribute(\n                'aria-label',\n                stripTags(\n                    a11yOptions.seriesDescriptionFormatter &&\n                    a11yOptions.seriesDescriptionFormatter(this) ||\n                    this.buildSeriesInfoString()\n                )\n            );\n        }\n    }\n};\n\n\n// Return string with information about series\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.buildSeriesInfoString = function () {\n    var chart = this.chart,\n        desc = this.description || this.options.description,\n        description = desc && chart.langFormat(\n            'accessibility.series.description', {\n                description: desc,\n                series: this\n            }\n        ),\n        xAxisInfo = chart.langFormat(\n            'accessibility.series.xAxisDescription',\n            {\n                name: this.xAxis && this.xAxis.getDescription(),\n                series: this\n            }\n        ),\n        yAxisInfo = chart.langFormat(\n            'accessibility.series.yAxisDescription',\n            {\n                name: this.yAxis && this.yAxis.getDescription(),\n                series: this\n            }\n        ),\n        summaryContext = {\n            name: this.name || '',\n            ix: this.index + 1,\n            numSeries: chart.series.length,\n            numPoints: this.points.length,\n            series: this\n        },\n        combination = chart.types.length === 1 ? '' : 'Combination',\n        summary = chart.langFormat(\n            'accessibility.series.summary.' + this.type + combination,\n            summaryContext\n        ) || chart.langFormat(\n            'accessibility.series.summary.default' + combination,\n            summaryContext\n        );\n\n    return summary + (description ? ' ' + description : '') + (\n            chart.yAxis.length > 1 && this.yAxis ?\n                ' ' + yAxisInfo : ''\n        ) + (\n            chart.xAxis.length > 1 && this.xAxis ?\n                ' ' + xAxisInfo : ''\n        );\n};\n\n\n// Return string with information about point\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.buildPointInfoString = function () {\n    var point = this,\n        series = point.series,\n        a11yOptions = series.chart.options.accessibility,\n        infoString = '',\n        dateTimePoint = series.xAxis && series.xAxis.isDatetimeAxis,\n        timeDesc =\n            dateTimePoint &&\n            series.chart.time.dateFormat(\n                a11yOptions.pointDateFormatter &&\n                a11yOptions.pointDateFormatter(point) ||\n                a11yOptions.pointDateFormat ||\n                _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tooltip.prototype.getXDateFormat.call(\n                    {\n                        getDateFormat: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tooltip.prototype.getDateFormat,\n                        chart: series.chart\n                    },\n                    point,\n                    series.chart.options.tooltip,\n                    series.xAxis\n                ),\n                point.x\n            ),\n        hasSpecialKey = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(series.specialKeys, function (key) {\n            return point[key] !== undefined;\n        });\n\n    // If the point has one of the less common properties defined, display all\n    // that are defined\n    if (hasSpecialKey) {\n        if (dateTimePoint) {\n            infoString = timeDesc;\n        }\n        each(series.commonKeys.concat(series.specialKeys), function (key) {\n            if (point[key] !== undefined && !(dateTimePoint && key === 'x')) {\n                infoString += (infoString ? '. ' : '') +\n                    key + ', ' +\n                    point[key];\n            }\n        });\n    } else {\n        // Pick and choose properties for a succint label\n        infoString =\n            (\n                this.name ||\n                timeDesc ||\n                this.category ||\n                this.id ||\n                'x, ' + this.x\n            ) + ', ' +\n            (this.value !== undefined ? this.value : this.y);\n    }\n\n    return (this.index + 1) + '. ' + infoString + '.' +\n        (this.description ? ' ' + this.description : '');\n};\n\n\n// Get descriptive label for axis\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.prototype.getDescription = function () {\n    return (\n        this.userOptions && this.userOptions.description ||\n        this.axisTitle && this.axisTitle.textStr ||\n        this.options.id ||\n        this.categories && 'categories' ||\n        this.isDatetimeAxis && 'Time' ||\n        'values'\n    );\n};\n\n\n// Whenever adding or removing series, keep track of types present in chart\naddEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'afterInit', function () {\n    var chart = this.chart;\n    if (chart.options.accessibility.enabled) {\n        chart.types = chart.types || [];\n\n        // Add type to list if does not exist\n        if (chart.types.indexOf(this.type) < 0) {\n            chart.types.push(this.type);\n        }\n    }\n});\naddEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'remove', function () {\n    var chart = this.chart,\n        removedSeries = this,\n        hasType = false;\n\n    // Check if any of the other series have the same type as this one.\n    // Otherwise remove it from the list.\n    each(chart.series, function (s) {\n        if (\n            s !== removedSeries &&\n            chart.types.indexOf(removedSeries.type) < 0\n        ) {\n            hasType = true;\n        }\n    });\n    if (!hasType) {\n        erase(chart.types, removedSeries.type);\n    }\n});\n\n\n// Return simplified description of chart type. Some types will not be familiar\n// to most screen reader users, but in those cases we try to add a description\n// of the type.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.getTypeDescription = function () {\n    var firstType = this.types && this.types[0],\n        firstSeries = this.series && this.series[0] || {},\n        mapTitle = firstSeries.mapTitle,\n        typeDesc = this.langFormat(\n            'accessibility.seriesTypeDescriptions.' + firstType,\n            { chart: this }\n        ),\n        formatContext = {\n            numSeries: this.series.length,\n            numPoints: firstSeries.points && firstSeries.points.length,\n            chart: this,\n            mapTitle: mapTitle\n        },\n        multi = this.series && this.series.length === 1 ? 'Single' : 'Multiple';\n\n    if (!firstType) {\n        return this.langFormat(\n            'accessibility.chartTypes.emptyChart', formatContext\n        );\n    } else if (firstType === 'map') {\n        return mapTitle ?\n            this.langFormat(\n                'accessibility.chartTypes.mapTypeDescription',\n                formatContext\n            ) :\n            this.langFormat(\n                'accessibility.chartTypes.unknownMap',\n                formatContext\n            );\n    } else if (this.types.length > 1) {\n        return this.langFormat(\n            'accessibility.chartTypes.combinationChart', formatContext\n        );\n    }\n\n    return (\n        this.langFormat(\n            'accessibility.chartTypes.' + firstType + multi,\n            formatContext\n        ) ||\n        this.langFormat(\n            'accessibility.chartTypes.default' + multi,\n            formatContext\n        )\n    ) +\n    (typeDesc ? ' ' + typeDesc : '');\n};\n\n\n// Return object with text description of each of the chart's axes\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.getAxesDescription = function () {\n    var numXAxes = this.xAxis.length,\n        numYAxes = this.yAxis.length,\n        desc = {};\n\n    if (numXAxes) {\n        desc.xAxis = this.langFormat(\n            'accessibility.axis.xAxisDescription' + (\n                numXAxes > 1 ? 'Plural' : 'Singular'\n            ),\n            {\n                chart: this,\n                names: map(this.xAxis, function (axis) {\n                    return axis.getDescription();\n                }),\n                numAxes: numXAxes\n            }\n        );\n    }\n\n    if (numYAxes) {\n        desc.yAxis = this.langFormat(\n            'accessibility.axis.yAxisDescription' + (\n                numYAxes > 1 ? 'Plural' : 'Singular'\n            ),\n            {\n                chart: this,\n                names: map(this.yAxis, function (axis) {\n                    return axis.getDescription();\n                }),\n                numAxes: numYAxes\n            }\n        );\n    }\n\n    return desc;\n};\n\n\n// Set a11y attribs on exporting menu\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.addAccessibleContextMenuAttribs = function () {\n    var exportList = this.exportDivElements;\n    if (exportList) {\n        // Set tabindex on the menu items to allow focusing by script\n        // Set role to give screen readers a chance to pick up the contents\n        each(exportList, function (item) {\n            if (item.tagName === 'DIV' &&\n                !(item.children && item.children.length)) {\n                item.setAttribute('role', 'menuitem');\n                item.setAttribute('tabindex', -1);\n            }\n        });\n        // Set accessibility properties on parent div\n        exportList[0].parentNode.setAttribute('role', 'menu');\n        exportList[0].parentNode.setAttribute('aria-label',\n            this.langFormat(\n                'accessibility.exporting.chartMenuLabel', { chart: this }\n            )\n        );\n    }\n};\n\n\n// Add screen reader region to chart.\n// tableId is the HTML id of the table to focus when clicking the table anchor\n// in the screen reader region.\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.addScreenReaderRegion = function (id, tableId) {\n    var chart = this,\n        hiddenSection = chart.screenReaderRegion = doc.createElement('div'),\n        tableShortcut = doc.createElement('h4'),\n        tableShortcutAnchor = doc.createElement('a'),\n        chartHeading = doc.createElement('h4');\n\n    hiddenSection.setAttribute('id', id);\n    hiddenSection.setAttribute('role', 'region');\n    hiddenSection.setAttribute(\n        'aria-label',\n        chart.langFormat(\n            'accessibility.screenReaderRegionLabel', { chart: this }\n        )\n    );\n\n    hiddenSection.innerHTML = chart.options.accessibility\n        .screenReaderSectionFormatter(chart);\n\n    // Add shortcut to data table if export-data is loaded\n    if (chart.getCSV) {\n        tableShortcutAnchor.innerHTML = chart.langFormat(\n            'accessibility.viewAsDataTable', { chart: chart }\n        );\n        tableShortcutAnchor.href = '#' + tableId;\n        // Make this unreachable by user tabbing\n        tableShortcutAnchor.setAttribute('tabindex', '-1');\n        tableShortcutAnchor.onclick =\n            chart.options.accessibility.onTableAnchorClick || function () {\n                chart.viewData();\n                doc.getElementById(tableId).focus();\n            };\n        tableShortcut.appendChild(tableShortcutAnchor);\n        hiddenSection.appendChild(tableShortcut);\n    }\n\n    // Note: JAWS seems to refuse to read aria-label on the container, so add an\n    // h4 element as title for the chart.\n    chartHeading.innerHTML = chart.langFormat(\n        'accessibility.chartHeading', { chart: chart }\n    );\n    chart.renderTo.insertBefore(chartHeading, chart.renderTo.firstChild);\n    chart.renderTo.insertBefore(hiddenSection, chart.renderTo.firstChild);\n\n    // Hide the section and the chart heading\n    merge(true, chartHeading.style, hiddenStyle);\n    merge(true, hiddenSection.style, hiddenStyle);\n};\n\n\n// Make chart container accessible, and wrap table functionality\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype.callbacks.push(function (chart) {\n    var options = chart.options,\n        a11yOptions = options.accessibility;\n\n    if (!a11yOptions.enabled) {\n        return;\n    }\n\n    var titleElement,\n        descElement = chart.container.getElementsByTagName('desc')[0],\n        textElements = chart.container.getElementsByTagName('text'),\n        titleId = 'highcharts-title-' + chart.index,\n        tableId = 'highcharts-data-table-' + chart.index,\n        hiddenSectionId = 'highcharts-information-region-' + chart.index,\n        chartTitle = options.title.text || chart.langFormat(\n            'accessibility.defaultChartTitle', { chart: chart }\n        ),\n        svgContainerTitle = stripTags(chart.langFormat(\n            'accessibility.svgContainerTitle', {\n                chartTitle: chartTitle\n            }\n        ));\n\n    // Add SVG title tag if it is set\n    if (svgContainerTitle.length) {\n        titleElement = doc.createElementNS(\n                'http://www.w3.org/2000/svg',\n                'title'\n            );\n        titleElement.textContent = svgContainerTitle;\n        titleElement.id = titleId;\n        descElement.parentNode.insertBefore(titleElement, descElement);\n    }\n\n    chart.renderTo.setAttribute('role', 'region');\n    chart.renderTo.setAttribute(\n        'aria-label',\n        chart.langFormat(\n            'accessibility.chartContainerLabel',\n            {\n                title: stripTags(chartTitle),\n                chart: chart\n            }\n        )\n    );\n\n    // Set screen reader properties on export menu\n    if (\n        chart.exportSVGElements &&\n        chart.exportSVGElements[0] &&\n        chart.exportSVGElements[0].element\n    ) {\n        // Set event handler on button\n        var button = chart.exportSVGElements[0].element,\n            oldExportCallback = button.onclick;\n        button.onclick = function () {\n            oldExportCallback.apply(\n                this,\n                Array.prototype.slice.call(arguments)\n            );\n            chart.addAccessibleContextMenuAttribs();\n            chart.highlightExportItem(0);\n        };\n\n        // Set props on button\n        button.setAttribute('role', 'button');\n        button.setAttribute(\n            'aria-label',\n            chart.langFormat(\n                'accessibility.exporting.menuButtonLabel', { chart: chart }\n            )\n        );\n\n        // Set props on group\n        chart.exportingGroup.element.setAttribute('role', 'region');\n        chart.exportingGroup.element.setAttribute('aria-label',\n            chart.langFormat(\n                'accessibility.exporting.exportRegionLabel', { chart: chart }\n            )\n        );\n    }\n\n    // Set screen reader properties on input boxes for range selector. We need\n    // to do this regardless of whether or not these are visible, as they are\n    // by default part of the page's tabindex unless we set them to -1.\n    if (chart.rangeSelector) {\n        each(['minInput', 'maxInput'], function (key, i) {\n            if (chart.rangeSelector[key]) {\n                chart.rangeSelector[key].setAttribute('tabindex', '-1');\n                chart.rangeSelector[key].setAttribute('role', 'textbox');\n                chart.rangeSelector[key].setAttribute(\n                    'aria-label',\n                    chart.langFormat(\n                        'accessibility.rangeSelector' +\n                            (i ? 'MaxInput' : 'MinInput'), { chart: chart }\n                    )\n                );\n            }\n        });\n    }\n\n    // Hide text elements from screen readers\n    each(textElements, function (el) {\n        el.setAttribute('aria-hidden', 'true');\n    });\n\n    // Add top-secret screen reader region\n    chart.addScreenReaderRegion(hiddenSectionId, tableId);\n\n    // Add ID and summary attr to table HTML\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap(chart, 'getTable', function (proceed) {\n        return proceed.apply(this, Array.prototype.slice.call(arguments, 1))\n            .replace(\n                '<table>',\n                '<table id=\"' + tableId + '\" summary=\"' + chart.langFormat(\n                    'accessibility.tableSummary', { chart: chart }\n                ) + '\">'\n            );\n    });\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/screen-reader.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/solid-gauge.src.js":
/*!**************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/solid-gauge.src.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_more_GaugeSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts-more/GaugeSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js\");\n/**\n * Solid angular gauge module\n *\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar pInt = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n    Renderer = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer,\n    colorAxisMethods;\n\n/**\n * Symbol definition of an arc with round edges.\n *\n * @param  {Number} x - The X coordinate for the top left position.\n * @param  {Number} y - The Y coordinate for the top left position.\n * @param  {Number} w - The pixel width.\n * @param  {Number} h - The pixel height.\n * @param  {Object} [options] - Additional options, depending on the actual\n *    symbol drawn.\n * @param {boolean} [options.rounded] - Whether to draw rounded edges.\n * @return {Array} Path of the created arc.\n */\nwrap(\n    Renderer.prototype.symbols,\n    'arc',\n    function (proceed, x, y, w, h, options) {\n        var arc = proceed,\n            path = arc(x, y, w, h, options);\n        if (options.rounded) {\n            var r = options.r || w,\n                smallR = (r - options.innerR) / 2,\n                x1 = path[1],\n                y1 = path[2],\n                x2 = path[12],\n                y2 = path[13],\n                roundStart = ['A', smallR, smallR, 0, 1, 1, x1, y1],\n                roundEnd = ['A', smallR, smallR, 0, 1, 1, x2, y2];\n            // Insert rounded edge on end, and remove line.\n            path.splice.apply(path, [path.length - 1, 0].concat(roundStart));\n            // Insert rounded edge on end, and remove line.\n            path.splice.apply(path, [11, 3].concat(roundEnd));\n        }\n\n        return path;\n    }\n);\n\n// These methods are defined in the ColorAxis object, and copied here.\n// If we implement an AMD system we should make ColorAxis a dependency.\ncolorAxisMethods = {\n\n\n    initDataClasses: function (userOptions) {\n        var chart = this.chart,\n            dataClasses,\n            colorCounter = 0,\n            options = this.options;\n        this.dataClasses = dataClasses = [];\n\n        each(userOptions.dataClasses, function (dataClass, i) {\n            var colors;\n\n            dataClass = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(dataClass);\n            dataClasses.push(dataClass);\n            if (!dataClass.color) {\n                if (options.dataClassColor === 'category') {\n                    colors = chart.options.colors;\n                    dataClass.color = colors[colorCounter++];\n                    // loop back to zero\n                    if (colorCounter === colors.length) {\n                        colorCounter = 0;\n                    }\n                } else {\n                    dataClass.color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(options.minColor).tweenTo(\n                        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(options.maxColor),\n                        i / (userOptions.dataClasses.length - 1)\n                    );\n                }\n            }\n        });\n    },\n\n    initStops: function (userOptions) {\n        this.stops = userOptions.stops || [\n            [0, this.options.minColor],\n            [1, this.options.maxColor]\n        ];\n        each(this.stops, function (stop) {\n            stop.color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(stop[1]);\n        });\n    },\n    /**\n     * Translate from a value to a color\n     */\n    toColor: function (value, point) {\n        var pos,\n            stops = this.stops,\n            from,\n            to,\n            color,\n            dataClasses = this.dataClasses,\n            dataClass,\n            i;\n\n        if (dataClasses) {\n            i = dataClasses.length;\n            while (i--) {\n                dataClass = dataClasses[i];\n                from = dataClass.from;\n                to = dataClass.to;\n                if (\n                    (from === undefined || value >= from) &&\n                    (to === undefined || value <= to)\n                ) {\n                    color = dataClass.color;\n                    if (point) {\n                        point.dataClass = i;\n                    }\n                    break;\n                }\n            }\n\n        } else {\n\n            if (this.isLog) {\n                value = this.val2lin(value);\n            }\n            pos = 1 - ((this.max - value) / (this.max - this.min));\n            i = stops.length;\n            while (i--) {\n                if (pos > stops[i][0]) {\n                    break;\n                }\n            }\n            from = stops[i] || stops[i + 1];\n            to = stops[i + 1] || from;\n\n            // The position within the gradient\n            pos = 1 - (to[0] - pos) / ((to[0] - from[0]) || 1);\n\n            color = from.color.tweenTo(\n                to.color,\n                pos\n            );\n        }\n        return color;\n    }\n};\n/**\n * A solid gauge is a circular gauge where the value is indicated by a filled\n * arc, and the color of the arc may variate with the value.\n *\n * @sample highcharts/demo/gauge-solid/ Solid gauges\n * @extends plotOptions.gauge\n * @excluding dial,pivot,wrap\n * @product highcharts\n * @optionparent plotOptions.solidgauge\n */\nvar solidGaugeOptions = {\n    /**\n     * Whether the strokes of the solid gauge should be `round` or `square`.\n     *\n     * @validvalue [\"square\", \"round\"]\n     * @type {String}\n     * @sample {highcharts} highcharts/demo/gauge-activity/ Rounded gauge\n     * @default round\n     * @since 4.2.2\n     * @product highcharts\n     * @apioption plotOptions.solidgauge.linecap\n     */\n\n    /**\n     * Allow the gauge to overshoot the end of the perimeter axis by this\n     * many degrees. Say if the gauge axis goes from 0 to 60, a value of\n     * 100, or 1000, will show 5 degrees beyond the end of the axis when this\n     * option is set to 5.\n     *\n     * @type      {Number}\n     * @default   0\n     * @since     3.0.10\n     * @product   highcharts\n     * @apioption plotOptions.solidgauge.overshoot\n     */\n\n    /**\n     * Wether to draw rounded edges on the gauge.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/demo/gauge-activity/ Activity Gauge\n     * @default false\n     * @since 5.0.8\n     * @product highcharts\n     * @apioption plotOptions.solidgauge.rounded\n     */\n\n    /**\n     * The threshold or base level for the gauge.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/plotoptions/solidgauge-threshold/\n     *         Zero threshold with negative and positive values\n     * @default null\n     * @since 5.0.3\n     * @product highcharts\n     * @apioption plotOptions.solidgauge.threshold\n     */\n\n    /**\n     * Whether to give each point an individual color.\n     */\n    colorByPoint: true\n\n};\n\n\n// The solidgauge series type\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType('solidgauge', 'gauge', solidGaugeOptions, {\n\n    /**\n     * Extend the translate function to extend the Y axis with the necessary\n     * decoration (#5895).\n     */\n    translate: function () {\n        var axis = this.yAxis;\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(axis, colorAxisMethods);\n\n        // Prepare data classes\n        if (!axis.dataClasses && axis.options.dataClasses) {\n            axis.initDataClasses(axis.options);\n        }\n        axis.initStops(axis.options);\n\n        // Generate points and inherit data label position\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.gauge.prototype.translate.call(this);\n    },\n\n    /**\n     * Draw the points where each point is one needle\n     */\n    drawPoints: function () {\n        var series = this,\n            yAxis = series.yAxis,\n            center = yAxis.center,\n            options = series.options,\n            renderer = series.chart.renderer,\n            overshoot = options.overshoot,\n            overshootVal = isNumber(overshoot) ? overshoot / 180 * Math.PI : 0,\n            thresholdAngleRad;\n\n        // Handle the threshold option\n        if (isNumber(options.threshold)) {\n            thresholdAngleRad = yAxis.startAngleRad + yAxis.translate(\n                options.threshold,\n                null,\n                null,\n                null,\n                true\n            );\n        }\n        this.thresholdAngleRad = pick(thresholdAngleRad, yAxis.startAngleRad);\n\n\n        each(series.points, function (point) {\n            var graphic = point.graphic,\n                rotation = yAxis.startAngleRad +\n                    yAxis.translate(point.y, null, null, null, true),\n                radius = (\n                    pInt(\n                        pick(point.options.radius, options.radius, 100)\n                    ) * center[2]\n                ) / 200,\n                innerRadius = (\n                    pInt(\n                        pick(point.options.innerRadius, options.innerRadius, 60)\n                    ) * center[2]\n                ) / 200,\n                shapeArgs,\n                d,\n                toColor = yAxis.toColor(point.y, point),\n                axisMinAngle = Math.min(yAxis.startAngleRad, yAxis.endAngleRad),\n                axisMaxAngle = Math.max(yAxis.startAngleRad, yAxis.endAngleRad),\n                minAngle,\n                maxAngle;\n\n            if (toColor === 'none') { // #3708\n                toColor = point.color || series.color || 'none';\n            }\n            if (toColor !== 'none') {\n                point.color = toColor;\n            }\n\n            // Handle overshoot and clipping to axis max/min\n            rotation = Math.max(\n                axisMinAngle - overshootVal,\n                Math.min(axisMaxAngle + overshootVal, rotation)\n            );\n\n            // Handle the wrap option\n            if (options.wrap === false) {\n                rotation = Math.max(\n                    axisMinAngle,\n                    Math.min(axisMaxAngle, rotation)\n                );\n            }\n\n            minAngle = Math.min(rotation, series.thresholdAngleRad);\n            maxAngle = Math.max(rotation, series.thresholdAngleRad);\n\n            if (maxAngle - minAngle > 2 * Math.PI) {\n                maxAngle = minAngle + 2 * Math.PI;\n            }\n\n            point.shapeArgs = shapeArgs = {\n                x: center[0],\n                y: center[1],\n                r: radius,\n                innerR: innerRadius,\n                start: minAngle,\n                end: maxAngle,\n                rounded: options.rounded\n            };\n            point.startR = radius; // For PieSeries.animate\n\n            if (graphic) {\n                d = shapeArgs.d;\n                graphic.animate(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({ fill: toColor }, shapeArgs));\n                if (d) {\n                    shapeArgs.d = d; // animate alters it\n                }\n            } else {\n                point.graphic = graphic = renderer.arc(shapeArgs)\n                    .attr({\n                        fill: toColor,\n                        'sweep-flag': 0\n                    })\n                    .add(series.group);\n\n                \n            }\n\n            if (graphic) {\n                graphic.addClass(point.getClassName(), true);\n            }\n        });\n    },\n\n    /**\n     * Extend the pie slice animation by animating from start angle and up\n     */\n    animate: function (init) {\n\n        if (!init) {\n            this.startAngleRad = this.thresholdAngleRad;\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.pie.prototype.animate.call(this, init);\n        }\n    }\n});\n\n/**\n * A `solidgauge` series. If the [type](#series.solidgauge.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n *\n * @type      {Object}\n * @extends   series,plotOptions.solidgauge\n * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,\n *            cropThreshold,dashStyle,dataParser,dataURL,dial,\n *            findNearestPointBy,getExtremesFromAll,marker,negativeColor,\n *            pointPlacement,pivot,shadow,softThreshold,stack,stacking,states,\n *            step,threshold,turboThreshold,wrap,zoneAxis,zones\n * @product   highcharts\n * @apioption series.solidgauge\n */\n\n/**\n * An array of data points for the series. For the `solidgauge` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](\n * #series.solidgauge.turboThreshold), this option is not available.\n *\n *  ```js\n *     data: [{\n *         y: 5,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         y: 7,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * The typical gauge only contains a single data value.\n *\n * @type {Array<Object|Number>}\n * @extends series.gauge.data\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts\n * @apioption series.solidgauge.data\n */\n\n/**\n * The inner radius of an individual point in a solid gauge. Can be\n * given as a number (pixels) or percentage string.\n *\n * @type {Number|String}\n * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/ Individual radius and innerRadius\n * @since 4.1.6\n * @product highcharts\n * @apioption series.solidgauge.data.innerRadius\n */\n\n/**\n * The outer radius of an individual point in a solid gauge. Can be\n * given as a number (pixels) or percentage string.\n *\n * @type {Number|String}\n * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/ Individual radius and innerRadius\n * @since 4.1.6\n * @product highcharts\n * @apioption series.solidgauge.data.radius\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/solid-gauge.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/modules/treemap.src.js":
/*!**********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/modules/treemap.src.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _mixins_tree_series_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mixins/tree-series.js */ \"./node_modules/highcharts/js/es-modules/mixins/tree-series.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/**\n * (c) 2014 Highsoft AS\n * Authors: Jon Arild Nygard / Oystein Moseng\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\nvar seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    map = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    getColor = _mixins_tree_series_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getColor,\n    getLevelOptions = _mixins_tree_series_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLevelOptions,\n    grep = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    isArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isBoolean = function (x) {\n        return typeof x === 'boolean';\n    },\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isObject = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isString = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    stableSort = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stableSort,\n    color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color,\n    eachObject = function (list, func, context) {\n        context = context || this;\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(list, function (val, key) {\n            func.call(context, val, key, list);\n        });\n    },\n    reduce = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reduce,\n    // @todo find correct name for this function.\n    // @todo Similar to reduce, this function is likely redundant\n    recursive = function (item, func, context) {\n        var next;\n        context = context || this;\n        next = func.call(context, item);\n        if (next !== false) {\n            recursive(next, func, context);\n        }\n    },\n    updateRootId = _mixins_tree_series_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].updateRootId;\n\n/**\n * A treemap displays hierarchical data using nested rectangles. The data can be\n * laid out in varying ways depending on options.\n *\n * @sample highcharts/demo/treemap-large-dataset/ Treemap\n *\n * @extends plotOptions.scatter\n * @excluding marker\n * @product highcharts\n * @optionparent plotOptions.treemap\n */\nseriesType('treemap', 'scatter', {\n\n    /**\n     * When enabled the user can click on a point which is a parent and\n     * zoom in on its children.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/plotoptions/treemap-allowdrilltonode/\n     *         Enabled\n     * @default false\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.allowDrillToNode\n     */\n\n    /**\n     * When the series contains less points than the crop threshold, all\n     * points are drawn, event if the points fall outside the visible plot\n     * area at the current zoom. The advantage of drawing all points (including\n     * markers and columns), is that animation is performed on updates.\n     * On the other hand, when the series contains more points than the\n     * crop threshold, the series data is cropped to only contain points\n     * that fall within the plot area. The advantage of cropping away invisible\n     * points is to increase performance on large series.\n     *\n     * @type {Number}\n     * @default 300\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.cropThreshold\n     */\n\n    /**\n     * This option decides if the user can interact with the parent nodes\n     * or just the leaf nodes. When this option is undefined, it will be\n     * true by default. However when allowDrillToNode is true, then it will\n     * be false by default.\n     *\n     * @type {Boolean}\n     * @sample {highcharts}\n     *         highcharts/plotoptions/treemap-interactbyleaf-false/\n     *         False\n     * @sample {highcharts}\n     *         highcharts/plotoptions/treemap-interactbyleaf-true-and-allowdrilltonode/\n     *         InteractByLeaf and allowDrillToNode is true\n     * @since 4.1.2\n     * @product highcharts\n     * @apioption plotOptions.treemap.interactByLeaf\n     */\n\n    /**\n     * The sort index of the point inside the treemap level.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/plotoptions/treemap-sortindex/\n     *         Sort by years\n     * @since 4.1.10\n     * @product highcharts\n     * @apioption plotOptions.treemap.sortIndex\n     */\n\n    /**\n     * When using automatic point colors pulled from the `options.colors`\n     * collection, this option determines whether the chart should receive\n     * one color per series or one color per point.\n     *\n     * @type {Boolean}\n     * @see [series colors](#plotOptions.treemap.colors)\n     * @default false\n     * @since 2.0\n     * @apioption plotOptions.treemap.colorByPoint\n     */\n\n    /**\n     * A series specific or series type specific color set to apply instead\n     * of the global [colors](#colors) when [colorByPoint](\n     * #plotOptions.treemap.colorByPoint) is true.\n     *\n     * @type {Array<Color>}\n     * @since 3.0\n     * @apioption plotOptions.treemap.colors\n     */\n\n    /**\n     * Whether to display this series type or specific series item in the\n     * legend.\n     *\n     * @type {Boolean}\n     * @default false\n     * @product highcharts\n     */\n    showInLegend: false,\n\n    /**\n     * @ignore\n     */\n    marker: false,\n    colorByPoint: false,\n    /**\n     * @extends plotOptions.heatmap.dataLabels\n     * @since 4.1.0\n     * @product highcharts\n     */\n    dataLabels: {\n        enabled: true,\n        defer: false,\n        verticalAlign: 'middle',\n        formatter: function () { // #2945\n            return this.point.name || this.point.id;\n        },\n        inside: true\n    },\n\n    tooltip: {\n        headerFormat: '',\n        pointFormat: '<b>{point.name}</b>: {point.value}<br/>'\n    },\n\n    /**\n     * Whether to ignore hidden points when the layout algorithm runs.\n     * If `false`, hidden points will leave open spaces.\n     *\n     * @type {Boolean}\n     * @default true\n     * @since 5.0.8\n     * @product highcharts\n     */\n    ignoreHiddenPoint: true,\n\n    /**\n     * This option decides which algorithm is used for setting position\n     * and dimensions of the points. Can be one of `sliceAndDice`, `stripes`,\n     *  `squarified` or `strip`.\n     *\n     * @validvalue [\"sliceAndDice\", \"stripes\", \"squarified\", \"strip\"]\n     * @type {String}\n     * @see [How to write your own algorithm](\n     * https://www.highcharts.com/docs/chart-and-series-types/treemap).\n     *\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/treemap-layoutalgorithm-sliceanddice/\n     *          SliceAndDice by default\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/treemap-layoutalgorithm-stripes/\n     *          Stripes\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/treemap-layoutalgorithm-squarified/\n     *          Squarified\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/treemap-layoutalgorithm-strip/\n     *          Strip\n     * @default sliceAndDice\n     * @since 4.1.0\n     * @product highcharts\n     */\n    layoutAlgorithm: 'sliceAndDice',\n\n    /**\n     * Defines which direction the layout algorithm will start drawing.\n     *  Possible values are \"vertical\" and \"horizontal\".\n     *\n     * @validvalue [\"vertical\", \"horizontal\"]\n     * @type {String}\n     * @default vertical\n     * @since 4.1.0\n     * @product highcharts\n     */\n    layoutStartingDirection: 'vertical',\n\n    /**\n     * Enabling this option will make the treemap alternate the drawing\n     * direction between vertical and horizontal. The next levels starting\n     * direction will always be the opposite of the previous.\n     *\n     * @type {Boolean}\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/treemap-alternatestartingdirection-true/\n     *          Enabled\n     * @default false\n     * @since 4.1.0\n     * @product highcharts\n     */\n    alternateStartingDirection: false,\n\n    /**\n     * Used together with the levels and allowDrillToNode options. When\n     * set to false the first level visible when drilling is considered\n     * to be level one. Otherwise the level will be the same as the tree\n     * structure.\n     *\n     * @type {Boolean}\n     * @default true\n     * @since 4.1.0\n     * @product highcharts\n     */\n    levelIsConstant: true,\n\n    /**\n     * Options for the button appearing when drilling down in a treemap.\n     */\n    drillUpButton: {\n\n        /**\n         * The position of the button.\n         */\n        position: {\n\n            /**\n             * Vertical alignment of the button.\n             *\n             * @default top\n             * @validvalue [\"top\", \"middle\", \"bottom\"]\n             * @apioption plotOptions.treemap.drillUpButton.position.verticalAlign\n             */\n\n            /**\n             * Horizontal alignment of the button.\n             * @validvalue [\"left\", \"center\", \"right\"]\n             */\n            align: 'right',\n\n            /**\n             * Horizontal offset of the button.\n             * @default -10\n             * @type {Number}\n             */\n            x: -10,\n\n            /**\n             * Vertical offset of the button.\n             */\n            y: 10\n        }\n    },\n\n\n    /**\n     * Set options on specific levels. Takes precedence over series options,\n     * but not point options.\n     *\n     * @type {Array<Object>}\n     * @sample {highcharts} highcharts/plotoptions/treemap-levels/\n     *         Styling dataLabels and borders\n     * @sample {highcharts} highcharts/demo/treemap-with-levels/\n     *         Different layoutAlgorithm\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels\n     */\n\n    /**\n     * Can set a `borderColor` on all points which lies on the same level.\n     *\n     * @type {Color}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.borderColor\n     */\n\n    /**\n     * Set the dash style of the border of all the point which lies on the\n     * level. See <a href\"#plotoptions.scatter.dashstyle\">\n     * plotOptions.scatter.dashStyle</a> for possible options.\n     *\n     * @type {String}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.borderDashStyle\n     */\n\n    /**\n     * Can set the borderWidth on all points which lies on the same level.\n     *\n     * @type {Number}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.borderWidth\n     */\n\n    /**\n     * Can set a color on all points which lies on the same level.\n     *\n     * @type {Color}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.color\n     */\n\n    /**\n     * A configuration object to define how the color of a child varies from the\n     * parent's color. The variation is distributed among the children of node.\n     * For example when setting brightness, the brightness change will range\n     * from the parent's original brightness on the first child, to the amount\n     * set in the `to` setting on the last node. This allows a gradient-like\n     * color scheme that sets children out from each other while highlighting\n     * the grouping on treemaps and sectors on sunburst charts.\n     *\n     * @type {Object}\n     * @sample highcharts/demo/sunburst/ Sunburst with color variation\n     * @since 6.0.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.colorVariation\n     */\n\n    /**\n     * The key of a color variation. Currently supports `brightness` only.\n     *\n     * @type {String}\n     * @validvalue [\"brightness\"]\n     * @since 6.0.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.colorVariation.key\n     */\n\n    /**\n     * The ending value of a color variation. The last sibling will receive this\n     * value.\n     *\n     * @type {Number}\n     * @since 6.0.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.colorVariation.to\n     */\n\n    /**\n     * Can set the options of dataLabels on each point which lies on the\n     * level. [plotOptions.treemap.dataLabels](#plotOptions.treemap.dataLabels)\n     * for possible values.\n     *\n     * @type {Object}\n     * @default undefined\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.dataLabels\n     */\n\n    /**\n     * Can set the layoutAlgorithm option on a specific level.\n     *\n     * @validvalue [\"sliceAndDice\", \"stripes\", \"squarified\", \"strip\"]\n     * @type {String}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.layoutAlgorithm\n     */\n\n    /**\n     * Can set the layoutStartingDirection option on a specific level.\n     *\n     * @validvalue [\"vertical\", \"horizontal\"]\n     * @type {String}\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.layoutStartingDirection\n     */\n\n    /**\n     * Decides which level takes effect from the options set in the levels\n     * object.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/plotoptions/treemap-levels/\n     *         Styling of both levels\n     * @since 4.1.0\n     * @product highcharts\n     * @apioption plotOptions.treemap.levels.level\n     */\n\n\n    \n\n\n\n// Prototype members\n}, {\n    pointArrayMap: ['value'],\n    directTouch: true,\n    optionalAxis: 'colorAxis',\n    getSymbol: noop,\n    parallelArrays: ['x', 'y', 'value', 'colorValue'],\n    colorKey: 'colorValue', // Point color option key\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    /**\n     * Creates an object map from parent id to childrens index.\n     * @param {Array} data List of points set in options.\n     * @param {string} data[].parent Parent id of point.\n     * @param {Array} existingIds List of all point ids.\n     * @return {Object} Map from parent id to children index in data.\n     */\n    getListOfParents: function (data, existingIds) {\n        var arr = isArray(data) ? data : [],\n            ids = isArray(existingIds) ? existingIds : [],\n            listOfParents = reduce(arr, function (prev, curr, i) {\n                var parent = pick(curr.parent, '');\n                if (prev[parent] === undefined) {\n                    prev[parent] = [];\n                }\n                prev[parent].push(i);\n                return prev;\n            }, {\n                '': [] // Root of tree\n            });\n\n        // If parent does not exist, hoist parent to root of tree.\n        eachObject(listOfParents, function (children, parent, list) {\n            if ((parent !== '') && (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray(parent, ids) === -1)) {\n                each(children, function (child) {\n                    list[''].push(child);\n                });\n                delete list[parent];\n            }\n        });\n        return listOfParents;\n    },\n    /**\n    * Creates a tree structured object from the series points\n    */\n    getTree: function () {\n        var series = this,\n            allIds = map(this.data, function (d) {\n                return d.id;\n            }),\n            parentList = series.getListOfParents(this.data, allIds);\n\n        series.nodeMap = [];\n        return series.buildNode('', -1, 0, parentList, null);\n    },\n    init: function (chart, options) {\n        var series = this,\n            colorSeriesMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorSeriesMixin;\n\n        // If color series logic is loaded, add some properties\n        if (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorSeriesMixin) {\n            this.translateColors = colorSeriesMixin.translateColors;\n            this.colorAttribs = colorSeriesMixin.colorAttribs;\n            this.axisTypes = colorSeriesMixin.axisTypes;\n        }\n\n        Series.prototype.init.call(series, chart, options);\n        if (series.options.allowDrillToNode) {\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(series, 'click', series.onClickDrillToNode);\n        }\n    },\n    buildNode: function (id, i, level, list, parent) {\n        var series = this,\n            children = [],\n            point = series.points[i],\n            height = 0,\n            node,\n            child;\n\n        // Actions\n        each((list[id] || []), function (i) {\n            child = series.buildNode(\n                series.points[i].id,\n                i,\n                (level + 1),\n                list,\n                id\n            );\n            height = Math.max(child.height + 1, height);\n            children.push(child);\n        });\n        node = {\n            id: id,\n            i: i,\n            children: children,\n            height: height,\n            level: level,\n            parent: parent,\n            visible: false // @todo move this to better location\n        };\n        series.nodeMap[node.id] = node;\n        if (point) {\n            point.node = node;\n        }\n        return node;\n    },\n    setTreeValues: function (tree) {\n        var series = this,\n            options = series.options,\n            idRoot = series.rootNode,\n            mapIdToNode = series.nodeMap,\n            nodeRoot = mapIdToNode[idRoot],\n            levelIsConstant = (\n                isBoolean(options.levelIsConstant) ?\n                options.levelIsConstant :\n                true\n            ),\n            childrenTotal = 0,\n            children = [],\n            val,\n            point = series.points[tree.i];\n\n        // First give the children some values\n        each(tree.children, function (child) {\n            child = series.setTreeValues(child);\n            children.push(child);\n            if (!child.ignore) {\n                childrenTotal += child.val;\n            }\n        });\n        // Sort the children\n        stableSort(children, function (a, b) {\n            return a.sortIndex - b.sortIndex;\n        });\n        // Set the values\n        val = pick(point && point.options.value, childrenTotal);\n        if (point) {\n            point.value = val;\n        }\n        extend(tree, {\n            children: children,\n            childrenTotal: childrenTotal,\n            // Ignore this node if point is not visible\n            ignore: !(pick(point && point.visible, true) && (val > 0)),\n            isLeaf: tree.visible && !childrenTotal,\n            levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),\n            name: pick(point && point.name, ''),\n            sortIndex: pick(point && point.sortIndex, -val),\n            val: val\n        });\n        return tree;\n    },\n    /**\n     * Recursive function which calculates the area for all children of a node.\n     * @param {Object} node The node which is parent to the children.\n     * @param {Object} area The rectangular area of the parent.\n     */\n    calculateChildrenAreas: function (parent, area) {\n        var series = this,\n            options = series.options,\n            mapOptionsToLevel = series.mapOptionsToLevel,\n            level = mapOptionsToLevel[parent.level + 1],\n            algorithm = pick(\n                (\n                    series[level &&\n                    level.layoutAlgorithm] &&\n                    level.layoutAlgorithm\n                ),\n                options.layoutAlgorithm\n            ),\n            alternate = options.alternateStartingDirection,\n            childrenValues = [],\n            children;\n\n        // Collect all children which should be included\n        children = grep(parent.children, function (n) {\n            return !n.ignore;\n        });\n\n        if (level && level.layoutStartingDirection) {\n            area.direction = level.layoutStartingDirection === 'vertical' ?\n                0 :\n                1;\n        }\n        childrenValues = series[algorithm](area, children);\n        each(children, function (child, index) {\n            var values = childrenValues[index];\n            child.values = merge(values, {\n                val: child.childrenTotal,\n                direction: (alternate ? 1 - area.direction : area.direction)\n            });\n            child.pointValues = merge(values, {\n                x: (values.x / series.axisRatio),\n                width: (values.width / series.axisRatio)\n            });\n            // If node has children, then call method recursively\n            if (child.children.length) {\n                series.calculateChildrenAreas(child, child.values);\n            }\n        });\n    },\n    setPointValues: function () {\n        var series = this,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis;\n        each(series.points, function (point) {\n            var node = point.node,\n                values = node.pointValues,\n                x1,\n                x2,\n                y1,\n                y2,\n                crispCorr = 0;\n\n            \n\n            // Points which is ignored, have no values.\n            if (values && node.visible) {\n                x1 = Math.round(\n                    xAxis.translate(values.x, 0, 0, 0, 1)\n                ) - crispCorr;\n                x2 = Math.round(\n                    xAxis.translate(values.x + values.width, 0, 0, 0, 1)\n                ) - crispCorr;\n                y1 = Math.round(\n                    yAxis.translate(values.y, 0, 0, 0, 1)\n                ) - crispCorr;\n                y2 = Math.round(\n                    yAxis.translate(values.y + values.height, 0, 0, 0, 1)\n                ) - crispCorr;\n                // Set point values\n                point.shapeType = 'rect';\n                point.shapeArgs = {\n                    x: Math.min(x1, x2),\n                    y: Math.min(y1, y2),\n                    width: Math.abs(x2 - x1),\n                    height: Math.abs(y2 - y1)\n                };\n                point.plotX = point.shapeArgs.x + (point.shapeArgs.width / 2);\n                point.plotY = point.shapeArgs.y + (point.shapeArgs.height / 2);\n            } else {\n                // Reset visibility\n                delete point.plotX;\n                delete point.plotY;\n            }\n        });\n    },\n\n    /**\n     * Set the node's color recursively, from the parent down.\n     */\n    setColorRecursive: function (\n        node,\n        parentColor,\n        colorIndex,\n        index,\n        siblings\n    ) {\n        var series = this,\n            chart = series && series.chart,\n            colors = chart && chart.options && chart.options.colors,\n            colorInfo,\n            point;\n\n        if (node) {\n            colorInfo = getColor(node, {\n                colors: colors,\n                index: index,\n                mapOptionsToLevel: series.mapOptionsToLevel,\n                parentColor: parentColor,\n                parentColorIndex: colorIndex,\n                series: series,\n                siblings: siblings\n            });\n\n            point = series.points[node.i];\n            if (point) {\n                point.color = colorInfo.color;\n                point.colorIndex = colorInfo.colorIndex;\n            }\n\n            // Do it all again with the children\n            each(node.children || [], function (child, i) {\n                series.setColorRecursive(\n                    child,\n                    colorInfo.color,\n                    colorInfo.colorIndex,\n                    i,\n                    node.children.length\n                );\n            });\n        }\n    },\n    algorithmGroup: function (h, w, d, p) {\n        this.height = h;\n        this.width = w;\n        this.plot = p;\n        this.direction = d;\n        this.startDirection = d;\n        this.total = 0;\n        this.nW = 0;\n        this.lW = 0;\n        this.nH = 0;\n        this.lH = 0;\n        this.elArr = [];\n        this.lP = {\n            total: 0,\n            lH: 0,\n            nH: 0,\n            lW: 0,\n            nW: 0,\n            nR: 0,\n            lR: 0,\n            aspectRatio: function (w, h) {\n                return Math.max((w / h), (h / w));\n            }\n        };\n        this.addElement = function (el) {\n            this.lP.total = this.elArr[this.elArr.length - 1];\n            this.total = this.total + el;\n            if (this.direction === 0) {\n                // Calculate last point old aspect ratio\n                this.lW = this.nW;\n                this.lP.lH = this.lP.total / this.lW;\n                this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH);\n                // Calculate last point new aspect ratio\n                this.nW = this.total / this.height;\n                this.lP.nH = this.lP.total / this.nW;\n                this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);\n            } else {\n                // Calculate last point old aspect ratio\n                this.lH = this.nH;\n                this.lP.lW = this.lP.total / this.lH;\n                this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH);\n                // Calculate last point new aspect ratio\n                this.nH = this.total / this.width;\n                this.lP.nW = this.lP.total / this.nH;\n                this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);\n            }\n            this.elArr.push(el);\n        };\n        this.reset = function () {\n            this.nW = 0;\n            this.lW = 0;\n            this.elArr = [];\n            this.total = 0;\n        };\n    },\n    algorithmCalcPoints: function (directionChange, last, group, childrenArea) {\n        var pX,\n            pY,\n            pW,\n            pH,\n            gW = group.lW,\n            gH = group.lH,\n            plot = group.plot,\n            keep,\n            i = 0,\n            end = group.elArr.length - 1;\n        if (last) {\n            gW = group.nW;\n            gH = group.nH;\n        } else {\n            keep = group.elArr[group.elArr.length - 1];\n        }\n        each(group.elArr, function (p) {\n            if (last || (i < end)) {\n                if (group.direction === 0) {\n                    pX = plot.x;\n                    pY = plot.y;\n                    pW = gW;\n                    pH = p / pW;\n                } else {\n                    pX = plot.x;\n                    pY = plot.y;\n                    pH = gH;\n                    pW = p / pH;\n                }\n                childrenArea.push({\n                    x: pX,\n                    y: pY,\n                    width: pW,\n                    height: pH\n                });\n                if (group.direction === 0) {\n                    plot.y = plot.y + pH;\n                } else {\n                    plot.x = plot.x + pW;\n                }\n            }\n            i = i + 1;\n        });\n        // Reset variables\n        group.reset();\n        if (group.direction === 0) {\n            group.width = group.width - gW;\n        } else {\n            group.height = group.height - gH;\n        }\n        plot.y = plot.parent.y + (plot.parent.height - group.height);\n        plot.x = plot.parent.x + (plot.parent.width - group.width);\n        if (directionChange) {\n            group.direction = 1 - group.direction;\n        }\n        // If not last, then add uncalculated element\n        if (!last) {\n            group.addElement(keep);\n        }\n    },\n    algorithmLowAspectRatio: function (directionChange, parent, children) {\n        var childrenArea = [],\n            series = this,\n            pTot,\n            plot = {\n                x: parent.x,\n                y: parent.y,\n                parent: parent\n            },\n            direction = parent.direction,\n            i = 0,\n            end = children.length - 1,\n            group = new this.algorithmGroup( // eslint-disable-line new-cap\n                parent.height,\n                parent.width,\n                direction,\n                plot\n            );\n        // Loop through and calculate all areas\n        each(children, function (child) {\n            pTot = (parent.width * parent.height) * (child.val / parent.val);\n            group.addElement(pTot);\n            if (group.lP.nR > group.lP.lR) {\n                series.algorithmCalcPoints(\n                    directionChange,\n                    false,\n                    group,\n                    childrenArea,\n                    plot\n                );\n            }\n            // If last child, then calculate all remaining areas\n            if (i === end) {\n                series.algorithmCalcPoints(\n                    directionChange,\n                    true,\n                    group,\n                    childrenArea,\n                    plot\n                );\n            }\n            i = i + 1;\n        });\n        return childrenArea;\n    },\n    algorithmFill: function (directionChange, parent, children) {\n        var childrenArea = [],\n            pTot,\n            direction = parent.direction,\n            x = parent.x,\n            y = parent.y,\n            width = parent.width,\n            height = parent.height,\n            pX,\n            pY,\n            pW,\n            pH;\n        each(children, function (child) {\n            pTot = (parent.width * parent.height) * (child.val / parent.val);\n            pX = x;\n            pY = y;\n            if (direction === 0) {\n                pH = height;\n                pW = pTot / pH;\n                width = width - pW;\n                x = x + pW;\n            } else {\n                pW = width;\n                pH = pTot / pW;\n                height = height - pH;\n                y = y + pH;\n            }\n            childrenArea.push({\n                x: pX,\n                y: pY,\n                width: pW,\n                height: pH\n            });\n            if (directionChange) {\n                direction = 1 - direction;\n            }\n        });\n        return childrenArea;\n    },\n    strip: function (parent, children) {\n        return this.algorithmLowAspectRatio(false, parent, children);\n    },\n    squarified: function (parent, children) {\n        return this.algorithmLowAspectRatio(true, parent, children);\n    },\n    sliceAndDice: function (parent, children) {\n        return this.algorithmFill(true, parent, children);\n    },\n    stripes: function (parent, children) {\n        return this.algorithmFill(false, parent, children);\n    },\n    translate: function () {\n        var series = this,\n            options = series.options,\n            // NOTE: updateRootId modifies series.\n            rootId = updateRootId(series),\n            rootNode,\n            pointValues,\n            seriesArea,\n            tree,\n            val;\n\n        // Call prototype function\n        Series.prototype.translate.call(series);\n\n        // @todo Only if series.isDirtyData is true\n        tree = series.tree = series.getTree();\n        rootNode = series.nodeMap[rootId];\n        series.mapOptionsToLevel = getLevelOptions({\n            from: rootNode.level + 1,\n            levels: options.levels,\n            to: tree.height,\n            defaults: {\n                levelIsConstant: series.options.levelIsConstant,\n                colorByPoint: options.colorByPoint\n            }\n        });\n        if (\n            rootId !== '' &&\n            (!rootNode || !rootNode.children.length)\n        ) {\n            series.drillToNode('', false);\n            rootId = series.rootNode;\n            rootNode = series.nodeMap[rootId];\n        }\n        // Parents of the root node is by default visible\n        recursive(series.nodeMap[series.rootNode], function (node) {\n            var next = false,\n                p = node.parent;\n            node.visible = true;\n            if (p || p === '') {\n                next = series.nodeMap[p];\n            }\n            return next;\n        });\n        // Children of the root node is by default visible\n        recursive(\n            series.nodeMap[series.rootNode].children,\n            function (children) {\n                var next = false;\n                each(children, function (child) {\n                    child.visible = true;\n                    if (child.children.length) {\n                        next = (next || []).concat(child.children);\n                    }\n                });\n                return next;\n            }\n        );\n        series.setTreeValues(tree);\n\n        // Calculate plotting values.\n        series.axisRatio = (series.xAxis.len / series.yAxis.len);\n        series.nodeMap[''].pointValues = pointValues =\n            { x: 0, y: 0, width: 100, height: 100 };\n        series.nodeMap[''].values = seriesArea = merge(pointValues, {\n            width: (pointValues.width * series.axisRatio),\n            direction: (options.layoutStartingDirection === 'vertical' ? 0 : 1),\n            val: tree.val\n        });\n        series.calculateChildrenAreas(tree, seriesArea);\n\n        // Logic for point colors\n        if (series.colorAxis) {\n            series.translateColors();\n        } else if (!options.colorByPoint) {\n            series.setColorRecursive(series.tree);\n        }\n\n        // Update axis extremes according to the root node.\n        if (options.allowDrillToNode) {\n            val = rootNode.pointValues;\n            series.xAxis.setExtremes(val.x, val.x + val.width, false);\n            series.yAxis.setExtremes(val.y, val.y + val.height, false);\n            series.xAxis.setScale();\n            series.yAxis.setScale();\n        }\n\n        // Assign values to points.\n        series.setPointValues();\n    },\n    /**\n     * Extend drawDataLabels with logic to handle custom options related to the\n     * treemap series:\n     * - Points which is not a leaf node, has dataLabels disabled by default.\n     * - Options set on series.levels is merged in.\n     * - Width of the dataLabel is set to match the width of the point shape.\n     */\n    drawDataLabels: function () {\n        var series = this,\n            mapOptionsToLevel = series.mapOptionsToLevel,\n            points = grep(series.points, function (n) {\n                return n.node.visible;\n            }),\n            options,\n            level;\n        each(points, function (point) {\n            level = mapOptionsToLevel[point.node.level];\n            // Set options to new object to avoid problems with scope\n            options = { style: {} };\n\n            // If not a leaf, then label should be disabled as default\n            if (!point.node.isLeaf) {\n                options.enabled = false;\n            }\n\n            // If options for level exists, include them as well\n            if (level && level.dataLabels) {\n                options = merge(options, level.dataLabels);\n                series._hasPointLabels = true;\n            }\n\n            // Set dataLabel width to the width of the point shape.\n            if (point.shapeArgs) {\n                options.style.width = point.shapeArgs.width;\n                if (point.dataLabel) {\n                    point.dataLabel.css({\n                        width: point.shapeArgs.width + 'px'\n                    });\n                }\n            }\n\n            // Merge custom options with point options\n            point.dlOptions = merge(options, point.options.dataLabels);\n        });\n        Series.prototype.drawDataLabels.call(this);\n    },\n\n    /**\n     * Over the alignment method by setting z index\n     */\n    alignDataLabel: function (point) {\n        seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);\n        if (point.dataLabel) {\n            // point.node.zIndex could be undefined (#6956)\n            point.dataLabel.attr({ zIndex: (point.node.zIndex || 0) + 1 });\n        }\n    },\n\n    \n\n    /**\n    * Extending ColumnSeries drawPoints\n    */\n    drawPoints: function () {\n        var series = this,\n            points = grep(series.points, function (n) {\n                return n.node.visible;\n            });\n\n        each(points, function (point) {\n            var groupKey = 'level-group-' + point.node.levelDynamic;\n            if (!series[groupKey]) {\n                series[groupKey] = series.chart.renderer.g(groupKey)\n                    .attr({\n                        // @todo Set the zIndex based upon the number of levels,\n                        // instead of using 1000\n                        zIndex: 1000 - point.node.levelDynamic\n                    })\n                    .add(series.group);\n            }\n            point.group = series[groupKey];\n\n        });\n        // Call standard drawPoints\n        seriesTypes.column.prototype.drawPoints.call(this);\n\n        \n        // In styled mode apply point.color. Use CSS, otherwise the fill\n        // used in the style sheet will take precedence over the fill\n        // attribute.\n        if (this.colorAttribs) { // Heatmap is loaded\n            each(this.points, function (point) {\n                if (point.graphic) {\n                    point.graphic.css(this.colorAttribs(point));\n                }\n            }, this);\n        }\n        \n\n        // If drillToNode is allowed, set a point cursor on clickables & add\n        // drillId to point\n        if (series.options.allowDrillToNode) {\n            each(points, function (point) {\n                if (point.graphic) {\n                    point.drillId = series.options.interactByLeaf ?\n                        series.drillToByLeaf(point) :\n                        series.drillToByGroup(point);\n                }\n            });\n        }\n    },\n    /**\n    * Add drilling on the suitable points\n    */\n    onClickDrillToNode: function (event) {\n        var series = this,\n            point = event.point,\n            drillId = point && point.drillId;\n        // If a drill id is returned, add click event and cursor.\n        if (isString(drillId)) {\n            point.setState(''); // Remove hover\n            series.drillToNode(drillId);\n        }\n    },\n    /**\n    * Finds the drill id for a parent node.\n    * Returns false if point should not have a click event\n    * @param {Object} point\n    * @return {String|Boolean} Drill to id or false when point should not have a\n    *         click event\n    */\n    drillToByGroup: function (point) {\n        var series = this,\n            drillId = false;\n        if (\n            (point.node.level - series.nodeMap[series.rootNode].level) === 1 &&\n            !point.node.isLeaf\n        ) {\n            drillId = point.id;\n        }\n        return drillId;\n    },\n    /**\n    * Finds the drill id for a leaf node.\n    * Returns false if point should not have a click event\n    * @param {Object} point\n    * @return {String|Boolean} Drill to id or false when point should not have a\n    *         click event\n    */\n    drillToByLeaf: function (point) {\n        var series = this,\n            drillId = false,\n            nodeParent;\n        if ((point.node.parent !== series.rootNode) && (point.node.isLeaf)) {\n            nodeParent = point.node;\n            while (!drillId) {\n                nodeParent = series.nodeMap[nodeParent.parent];\n                if (nodeParent.parent === series.rootNode) {\n                    drillId = nodeParent.id;\n                }\n            }\n        }\n        return drillId;\n    },\n    drillUp: function () {\n        var series = this,\n            node = series.nodeMap[series.rootNode];\n        if (node && isString(node.parent)) {\n            series.drillToNode(node.parent);\n        }\n    },\n    drillToNode: function (id, redraw) {\n        var series = this,\n            nodeMap = series.nodeMap,\n            node = nodeMap[id];\n        series.idPreviousRoot = series.rootNode;\n        series.rootNode = id;\n        if (id === '') {\n            series.drillUpButton = series.drillUpButton.destroy();\n        } else {\n            series.showDrillUpButton((node && node.name || id));\n        }\n        this.isDirty = true; // Force redraw\n        if (pick(redraw, true)) {\n            this.chart.redraw();\n        }\n    },\n    showDrillUpButton: function (name) {\n        var series = this,\n            backText = (name || '< Back'),\n            buttonOptions = series.options.drillUpButton,\n            attr,\n            states;\n\n        if (buttonOptions.text) {\n            backText = buttonOptions.text;\n        }\n        if (!this.drillUpButton) {\n            attr = buttonOptions.theme;\n            states = attr && attr.states;\n\n            this.drillUpButton = this.chart.renderer.button(\n                backText,\n                null,\n                null,\n                function () {\n                    series.drillUp();\n                },\n                attr,\n                states && states.hover,\n                states && states.select\n            )\n            .addClass('highcharts-drillup-button')\n            .attr({\n                align: buttonOptions.position.align,\n                zIndex: 7\n            })\n            .add()\n            .align(\n                buttonOptions.position,\n                false,\n                buttonOptions.relativeTo || 'plotBox'\n            );\n        } else {\n            this.drillUpButton.placed = false;\n            this.drillUpButton.attr({\n                text: backText\n            })\n            .align();\n        }\n    },\n    buildKDTree: noop,\n    drawLegendSymbol: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin.drawRectangle,\n    getExtremes: function () {\n        // Get the extremes from the value data\n        Series.prototype.getExtremes.call(this, this.colorValueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n\n        // Get the extremes from the y data\n        Series.prototype.getExtremes.call(this);\n    },\n    getExtremesFromAll: true,\n    bindAxes: function () {\n        var treeAxis = {\n            endOnTick: false,\n            gridLineWidth: 0,\n            lineWidth: 0,\n            min: 0,\n            dataMin: 0,\n            minPadding: 0,\n            max: 100,\n            dataMax: 100,\n            maxPadding: 0,\n            startOnTick: false,\n            title: null,\n            tickPositions: []\n        };\n        Series.prototype.bindAxes.call(this);\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(this.yAxis.options, treeAxis);\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(this.xAxis.options, treeAxis);\n    },\n    utils: {\n        recursive: recursive,\n        reduce: reduce\n    }\n\n// Point class\n}, {\n    getClassName: function () {\n        var className = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.getClassName.call(this),\n            series = this.series,\n            options = series.options;\n\n        // Above the current level\n        if (this.node.level <= series.nodeMap[series.rootNode].level) {\n            className += ' highcharts-above-level';\n\n        } else if (\n            !this.node.isLeaf &&\n            !pick(options.interactByLeaf, !options.allowDrillToNode)\n        ) {\n            className += ' highcharts-internal-node-interactive';\n\n        } else if (!this.node.isLeaf) {\n            className += ' highcharts-internal-node';\n        }\n        return className;\n    },\n\n    /**\n     * A tree point is valid if it has han id too, assume it may be a parent\n     * item.\n     */\n    isValid: function () {\n        return this.id || isNumber(this.value);\n    },\n    setState: function (state) {\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.setState.call(this, state);\n\n        // Graphic does not exist when point is not visible.\n        if (this.graphic) {\n            this.graphic.attr({\n                zIndex: state === 'hover' ? 1 : 0\n            });\n        }\n    },\n    setVisible: seriesTypes.pie.prototype.pointClass.prototype.setVisible\n});\n\n\n/**\n * A `treemap` series. If the [type](#series.treemap.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.treemap\n * @excluding dataParser,dataURL,stack\n * @product highcharts\n * @apioption series.treemap\n */\n\n/**\n * An array of data points for the series. For the `treemap` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `value` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.treemap.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         value: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         value: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Number>}\n * @extends series.heatmap.data\n * @excluding x,y\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts\n * @apioption series.treemap.data\n */\n\n/**\n * The value of the point, resulting in a relative area of the point\n * in the treemap.\n *\n * @type {Number}\n * @product highcharts\n * @apioption series.treemap.data.value\n */\n\n/**\n * Serves a purpose only if a `colorAxis` object is defined in the chart\n * options. This value will decide which color the point gets from the\n * scale of the colorAxis.\n *\n * @type {Number}\n * @default undefined\n * @since 4.1.0\n * @product highcharts\n * @apioption series.treemap.data.colorValue\n */\n\n/**\n * Only for treemap. Use this option to build a tree structure. The\n * value should be the id of the point which is the parent. If no points\n * has a matching id, or this option is undefined, then the parent will\n * be set to the root.\n *\n * @type {String}\n * @sample {highcharts} highcharts/point/parent/ Point parent\n * @sample {highcharts} highcharts/demo/treemap-with-levels/ Example where parent id is not matching\n * @default undefined\n * @since 4.1.0\n * @product highcharts\n * @apioption series.treemap.data.parent\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/modules/treemap.src.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Axis.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Axis.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_Tick_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Tick.js */ \"./node_modules/highcharts/js/es-modules/parts/Tick.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * Extenstion for 3d axes\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar ZAxis,\n\n    addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    deg2rad = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    perspective = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective,\n    perspective3D = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective3D,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    shapeArea = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea,\n    splat = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    Tick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n/**\n * @optionparent xAxis\n */\nvar extendedOptions = {\n    labels: {\n        /**\n         * Defines how the labels are be repositioned according to the 3D chart\n         * orientation.\n         * - `'offset'`: Maintain a fixed horizontal/vertical distance from the\n         *      tick marks, despite the chart orientation. This is the backwards\n         *      compatible behavior, and causes skewing of X and Z axes.\n         * - `'chart'`: Preserve 3D position relative to the chart.\n         *   This looks nice, but hard to read if the text isn't\n         *   forward-facing.\n         * - `'flap'`: Rotated text along the axis to compensate for the chart\n         *      orientation. This tries to maintain text as legible as possible\n         *      on all orientations.\n         * - `'ortho'`: Rotated text along the axis direction so that the labels\n         *      are orthogonal to the axis. This is very similar to `'flap'`,\n         *      but prevents skewing the labels (X and Y scaling are still\n         *      present).\n         *\n         * @validvalue ['offset', 'chart', 'flap', 'ortho']\n         * @sample highcharts/3d/skewed-labels/ Skewed labels\n         * @since 5.0.15\n         * @product highcharts\n         */\n        position3d: 'offset',\n\n        /**\n         * If enabled, the axis labels will skewed to follow the perspective.\n         *\n         * This will fix overlapping labels and titles, but texts become less\n         * legible due to the distortion.\n         *\n         * The final appearance depends heavily on `labels.position3d`.\n         *\n         * @since 5.0.15\n         * @sample highcharts/3d/skewed-labels/ Skewed labels\n         * @product highcharts\n         */\n        skew3d: false\n    },\n    title: {\n        /**\n         * Defines how the title is repositioned according to the 3D chart\n         * orientation.\n         * - `'offset'`: Maintain a fixed horizontal/vertical distance from the\n         *   tick marks, despite the chart orientation. This is the backwards\n         *   compatible behavior, and causes skewing of X and Z axes.\n         * - `'chart'`: Preserve 3D position relative to the chart.\n         *   This looks nice, but hard to read if the text isn't\n         *   forward-facing.\n         * - `'flap'`: Rotated text along the axis to compensate for the chart\n         *   orientation. This tries to maintain text as legible as possible on\n         *   all orientations.\n         * - `'ortho'`: Rotated text along the axis direction so that the labels\n         *   are orthogonal to the axis. This is very similar to `'flap'`, but\n         *   prevents skewing the labels (X and Y scaling are still present).\n         * - `null`: Will use the config from `labels.position3d`\n         *\n         * @validvalue ['offset', 'chart', 'flap', 'ortho', null]\n         * @type {String}\n         * @since 5.0.15\n         * @sample highcharts/3d/skewed-labels/ Skewed labels\n         * @product highcharts\n         */\n        position3d: null,\n\n        /**\n         * If enabled, the axis title will skewed to follow the perspective.\n         *\n          * This will fix overlapping labels and titles, but texts become less\n          * legible due to the distortion.\n         *\n         * The final appearance depends heavily on `title.position3d`.\n         *\n         * A `null` value will use the config from `labels.skew3d`.\n         *\n         * @validvalue [false, true, null]\n         * @type {Boolean}\n         * @sample highcharts/3d/skewed-labels/ Skewed labels\n         * @since 5.0.15\n         * @product highcharts\n         */\n        skew3d: null\n    }\n};\n\nmerge(true, Axis.prototype.defaultOptions, extendedOptions);\n\n\naddEvent(Axis, 'afterSetOptions', function () {\n    var options;\n    if (this.chart.is3d && this.chart.is3d() && this.coll !== 'colorAxis') {\n        options = this.options;\n        options.tickWidth = pick(options.tickWidth, 0);\n        options.gridLineWidth = pick(options.gridLineWidth, 1);\n    }\n});\n\nwrap(Axis.prototype, 'getPlotLinePath', function (proceed) {\n    var path = proceed.apply(this, [].slice.call(arguments, 1));\n\n    // Do not do this if the chart is not 3D\n    if (!this.chart.is3d() || this.coll === 'colorAxis') {\n        return path;\n    }\n\n    if (path === null) {\n        return path;\n    }\n\n    var chart = this.chart,\n        options3d = chart.options.chart.options3d,\n        d = this.isZAxis ? chart.plotWidth : options3d.depth,\n        frame = chart.frame3d;\n\n    var pArr = [\n        this.swapZ({ x: path[1], y: path[2], z: 0 }),\n        this.swapZ({ x: path[1], y: path[2], z: d }),\n        this.swapZ({ x: path[4], y: path[5], z: 0 }),\n        this.swapZ({ x: path[4], y: path[5], z: d })\n    ];\n\n    var pathSegments = [];\n    if (!this.horiz) {  // Y-Axis\n        if (frame.front.visible) {\n            pathSegments.push(pArr[0], pArr[2]);\n        }\n        if (frame.back.visible) {\n            pathSegments.push(pArr[1], pArr[3]);\n        }\n        if (frame.left.visible) {\n            pathSegments.push(pArr[0], pArr[1]);\n        }\n        if (frame.right.visible) {\n            pathSegments.push(pArr[2], pArr[3]);\n        }\n    } else if (this.isZAxis) {  // Z-Axis\n        if (frame.left.visible) {\n            pathSegments.push(pArr[0], pArr[2]);\n        }\n        if (frame.right.visible) {\n            pathSegments.push(pArr[1], pArr[3]);\n        }\n        if (frame.top.visible) {\n            pathSegments.push(pArr[0], pArr[1]);\n        }\n        if (frame.bottom.visible) {\n            pathSegments.push(pArr[2], pArr[3]);\n        }\n    } else {  // X-Axis\n        if (frame.front.visible) {\n            pathSegments.push(pArr[0], pArr[2]);\n        }\n        if (frame.back.visible) {\n            pathSegments.push(pArr[1], pArr[3]);\n        }\n        if (frame.top.visible) {\n            pathSegments.push(pArr[0], pArr[1]);\n        }\n        if (frame.bottom.visible) {\n            pathSegments.push(pArr[2], pArr[3]);\n        }\n    }\n\n    pathSegments = perspective(pathSegments, this.chart, false);\n\n    return this.chart.renderer.toLineSegments(pathSegments);\n});\n\n// Do not draw axislines in 3D\nwrap(Axis.prototype, 'getLinePath', function (proceed) {\n    // Do not do this if the chart is not 3D\n    if (!this.chart.is3d() || this.coll === 'colorAxis') {\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    }\n\n    return [];\n});\n\nwrap(Axis.prototype, 'getPlotBandPath', function (proceed) {\n    // Do not do this if the chart is not 3D\n    if (!this.chart.is3d() || this.coll === 'colorAxis') {\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    }\n\n    var args = arguments,\n        from = args[1],\n        to = args[2],\n        path = [],\n        fromPath = this.getPlotLinePath(from),\n        toPath = this.getPlotLinePath(to);\n\n    if (fromPath && toPath) {\n        for (var i = 0; i < fromPath.length; i += 6) {\n            path.push(\n                'M', fromPath[i + 1], fromPath[i + 2],\n                'L', fromPath[i + 4], fromPath[i + 5],\n                'L', toPath[i + 4], toPath[i + 5],\n                'L', toPath[i + 1], toPath[i + 2],\n                'Z');\n        }\n    }\n\n    return path;\n});\n\n\nfunction fix3dPosition(axis, pos, isTitle) {\n    // Do not do this if the chart is not 3D\n    if (!axis.chart.is3d() || axis.coll === 'colorAxis') {\n        return pos;\n    }\n\n    var chart = axis.chart,\n        alpha = deg2rad * chart.options.chart.options3d.alpha,\n        beta = deg2rad * chart.options.chart.options3d.beta,\n        positionMode = pick(\n            isTitle && axis.options.title.position3d,\n            axis.options.labels.position3d\n        ),\n        skew = pick(\n            isTitle && axis.options.title.skew3d,\n            axis.options.labels.skew3d\n        ),\n        frame = chart.frame3d,\n        plotLeft = chart.plotLeft,\n        plotRight = chart.plotWidth + plotLeft,\n        plotTop = chart.plotTop,\n        plotBottom = chart.plotHeight + plotTop,\n        // Indicates we are labelling an X or Z axis on the \"back\" of the chart\n        reverseFlap = false,\n        offsetX = 0,\n        offsetY = 0,\n        vecX,\n        vecY = { x: 0, y: 1, z: 0 };\n\n    pos = axis.swapZ({ x: pos.x, y: pos.y, z: 0 });\n\n\n    if (axis.isZAxis) {  // Z Axis\n        if (axis.opposite) {\n            if (frame.axes.z.top === null) {\n                return {};\n            }\n            offsetY = pos.y - plotTop;\n            pos.x = frame.axes.z.top.x;\n            pos.y = frame.axes.z.top.y;\n            vecX = frame.axes.z.top.xDir;\n            reverseFlap = !frame.top.frontFacing;\n        } else {\n            if (frame.axes.z.bottom === null) {\n                return {};\n            }\n            offsetY = pos.y - plotBottom;\n            pos.x = frame.axes.z.bottom.x;\n            pos.y = frame.axes.z.bottom.y;\n            vecX = frame.axes.z.bottom.xDir;\n            reverseFlap = !frame.bottom.frontFacing;\n        }\n    } else if (axis.horiz) {  // X Axis\n        if (axis.opposite) {\n            if (frame.axes.x.top === null) {\n                return {};\n            }\n            offsetY = pos.y - plotTop;\n            pos.y = frame.axes.x.top.y;\n            pos.z = frame.axes.x.top.z;\n            vecX = frame.axes.x.top.xDir;\n            reverseFlap = !frame.top.frontFacing;\n        } else {\n            if (frame.axes.x.bottom === null) {\n                return {};\n            }\n            offsetY = pos.y - plotBottom;\n            pos.y = frame.axes.x.bottom.y;\n            pos.z = frame.axes.x.bottom.z;\n            vecX = frame.axes.x.bottom.xDir;\n            reverseFlap = !frame.bottom.frontFacing;\n        }\n    } else {  // Y Axis\n        if (axis.opposite) {\n            if (frame.axes.y.right === null) {\n                return {};\n            }\n            offsetX = pos.x - plotRight;\n            pos.x = frame.axes.y.right.x;\n            pos.z = frame.axes.y.right.z;\n            vecX = frame.axes.y.right.xDir;\n            // Rotate 90 on opposite edge\n            vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };\n        } else {\n            if (frame.axes.y.left === null) {\n                return {};\n            }\n            offsetX = pos.x - plotLeft;\n            pos.x = frame.axes.y.left.x;\n            pos.z = frame.axes.y.left.z;\n            vecX = frame.axes.y.left.xDir;\n        }\n    }\n\n    if (positionMode === 'chart') {\n        // Labels preserve their direction relative to the chart\n        // nothing to do\n\n    } else if (positionMode === 'flap') {\n        // Labels are be rotated around the axis direction to face the screen\n        if (!axis.horiz) {  // Y Axis\n            vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n        } else {  // X and Z Axis\n            var sin = Math.sin(alpha);\n            var cos = Math.cos(alpha);\n            if (axis.opposite) {\n                sin = -sin;\n            }\n            if (reverseFlap) {\n                sin = -sin;\n            }\n            vecY = { x: vecX.z * sin, y: cos, z: -vecX.x * sin };\n        }\n    } else if (positionMode === 'ortho') {\n        // Labels will be rotated to be ortogonal to the axis\n        if (!axis.horiz) {  // Y Axis\n            vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n        } else {  // X and Z Axis\n            var sina = Math.sin(alpha);\n            var cosa = Math.cos(alpha);\n            var sinb = Math.sin(beta);\n            var cosb = Math.cos(beta);\n            var vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };\n            vecY = {\n                x: vecX.y * vecZ.z - vecX.z * vecZ.y,\n                y: vecX.z * vecZ.x - vecX.x * vecZ.z,\n                z: vecX.x * vecZ.y - vecX.y * vecZ.x\n            };\n            var scale = 1 / Math.sqrt(\n                vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z\n            );\n            if (reverseFlap) {\n                scale = -scale;\n            }\n            vecY = { x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z };\n        }\n    } else {  // positionMode  == 'offset'\n        // Labels will be skewd to maintain vertical / horizontal offsets from\n        // axis\n        if (!axis.horiz) {  // Y Axis\n            vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n        } else {  // X and Z Axis\n            vecY = {\n                x: Math.sin(beta) * Math.sin(alpha),\n                y: Math.cos(alpha),\n                z: -Math.cos(beta) * Math.sin(alpha)\n            };\n        }\n    }\n    pos.x += offsetX * vecX.x + offsetY * vecY.x;\n    pos.y += offsetX * vecX.y + offsetY * vecY.y;\n    pos.z += offsetX * vecX.z + offsetY * vecY.z;\n\n    var projected = perspective([pos], axis.chart)[0];\n\n    if (skew) {\n        // Check if the label text would be mirrored\n        var isMirrored = shapeArea(perspective([\n            pos,\n            { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },\n            { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }\n        ], axis.chart)) < 0;\n        if (isMirrored) {\n            vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };\n        }\n\n        var pointsProjected = perspective([\n            { x: pos.x, y: pos.y, z: pos.z },\n            { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },\n            { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }\n        ], axis.chart);\n\n        projected.matrix = [\n            pointsProjected[1].x - pointsProjected[0].x,\n            pointsProjected[1].y - pointsProjected[0].y,\n            pointsProjected[2].x - pointsProjected[0].x,\n            pointsProjected[2].y - pointsProjected[0].y,\n            projected.x,\n            projected.y\n        ];\n        projected.matrix[4] -= projected.x * projected.matrix[0] +\n            projected.y * projected.matrix[2];\n        projected.matrix[5] -= projected.x * projected.matrix[1] +\n            projected.y * projected.matrix[3];\n    }\n\n    return projected;\n}\n\n/*\nTick extensions\n */\nwrap(Tick.prototype, 'getMarkPath', function (proceed) {\n    var path = proceed.apply(this, [].slice.call(arguments, 1));\n\n    var pArr = [\n        fix3dPosition(this.axis, { x: path[1], y: path[2], z: 0 }),\n        fix3dPosition(this.axis, { x: path[4], y: path[5], z: 0 })\n    ];\n\n    return this.axis.chart.renderer.toLineSegments(pArr);\n});\n\naddEvent(Tick, 'afterGetLabelPosition', function (e) {\n    extend(e.pos, fix3dPosition(this.axis, e.pos));\n});\n\nwrap(Axis.prototype, 'getTitlePosition', function (proceed) {\n    var pos = proceed.apply(this, [].slice.call(arguments, 1));\n    return fix3dPosition(this, pos, true);\n});\n\naddEvent(Axis, 'drawCrosshair', function (e) {\n    if (this.chart.is3d() && this.coll !== 'colorAxis') {\n        if (e.point) {\n            e.point.crosshairPos = this.isXAxis ?\n                e.point.axisXpos :\n                this.len - (e.point.axisYpos);\n        }\n    }\n});\n\naddEvent(Axis, 'destroy', function () {\n    each(['backFrame', 'bottomFrame', 'sideFrame'], function (prop) {\n        if (this[prop]) {\n            this[prop] = this[prop].destroy();\n        }\n    }, this);\n});\n\n/*\nZ-AXIS\n*/\n\nAxis.prototype.swapZ = function (p, insidePlotArea) {\n    if (this.isZAxis) {\n        var plotLeft = insidePlotArea ? 0 : this.chart.plotLeft;\n        return {\n            x: plotLeft + p.z,\n            y: p.y,\n            z: p.x - plotLeft\n        };\n    }\n    return p;\n};\n\nZAxis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ZAxis = function () {\n    this.init.apply(this, arguments);\n};\nextend(ZAxis.prototype, Axis.prototype);\nextend(ZAxis.prototype, {\n    isZAxis: true,\n    setOptions: function (userOptions) {\n        userOptions = merge({\n            offset: 0,\n            lineWidth: 0\n        }, userOptions);\n        Axis.prototype.setOptions.call(this, userOptions);\n        this.coll = 'zAxis';\n    },\n    setAxisSize: function () {\n        Axis.prototype.setAxisSize.call(this);\n        this.width = this.len = this.chart.options.chart.options3d.depth;\n        this.right = this.chart.chartWidth - this.width - this.left;\n    },\n    getSeriesExtremes: function () {\n        var axis = this,\n            chart = axis.chart;\n\n        axis.hasVisibleSeries = false;\n\n        // Reset properties in case we're redrawing (#3353)\n        axis.dataMin =\n            axis.dataMax =\n            axis.ignoreMinPadding =\n            axis.ignoreMaxPadding = null;\n\n        if (axis.buildStacks) {\n            axis.buildStacks();\n        }\n\n        // loop through this axis' series\n        each(axis.series, function (series) {\n\n            if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                var seriesOptions = series.options,\n                    zData,\n                    threshold = seriesOptions.threshold;\n\n                axis.hasVisibleSeries = true;\n\n                // Validate threshold in logarithmic axes\n                if (axis.positiveValuesOnly && threshold <= 0) {\n                    threshold = null;\n                }\n\n                zData = series.zData;\n                if (zData.length) {\n                    axis.dataMin = Math.min(\n                        pick(axis.dataMin, zData[0]),\n                        Math.min.apply(null, zData)\n                    );\n                    axis.dataMax = Math.max(\n                        pick(axis.dataMax, zData[0]),\n                        Math.max.apply(null, zData)\n                    );\n                }\n            }\n        });\n    }\n});\n\n\n/**\n* Get the Z axis in addition to the default X and Y.\n*/\naddEvent(Chart, 'afterGetAxes', function () {\n    var chart = this,\n        options = this.options,\n        zAxisOptions = options.zAxis = splat(options.zAxis || {});\n\n    if (!chart.is3d()) {\n        return;\n    }\n    this.zAxis = [];\n    each(zAxisOptions, function (axisOptions, i) {\n        axisOptions.index = i;\n        // Z-Axis is shown horizontally, so it's kind of a X-Axis\n        axisOptions.isX = true;\n        var zAxis = new ZAxis(chart, axisOptions);\n        zAxis.setScale();\n    });\n});\n/**\n * Wrap getSlotWidth function to calculate individual width value\n * for each slot (#8042).\n */\nwrap(Axis.prototype, 'getSlotWidth', function (proceed, tick) {\n    if (this.chart.is3d() &&\n        tick &&\n        tick.label &&\n        this.categories &&\n        this.chart.frameShapes\n    ) {\n        var chart = this.chart,\n            ticks = this.ticks,\n            gridGroup = this.gridGroup.element.childNodes,\n            firstGridLine = gridGroup[0].getBBox(),\n            frame3DLeft = chart.frameShapes.left.getBBox(),\n            options3d = chart.options.chart.options3d,\n            origin = {\n                x: chart.plotWidth / 2,\n                y: chart.plotHeight / 2,\n                z: options3d.depth / 2,\n                vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n            },\n            labelPos,\n            prevLabelPos,\n            nextLabelPos,\n            slotWidth,\n            tickId = tick.pos,\n            prevTick = ticks[tickId - 1],\n            nextTick = ticks[tickId + 1];\n\n        // Check whether the tick is not the first one and previous tick exists,\n        // then calculate position of previous label.\n        if (tickId !== 0 && prevTick && prevTick.label.xy) { // #8621\n            prevLabelPos = perspective3D({\n                x: prevTick.label.xy.x,\n                y: prevTick.label.xy.y,\n                z: null\n            }, origin, origin.vd);\n        }\n        // If next label position is defined, then recalculate its position\n        // basing on the perspective.\n        if (nextTick && nextTick.label.xy) {\n            nextLabelPos = perspective3D({\n                x: nextTick.label.xy.x,\n                y: nextTick.label.xy.y,\n                z: null\n            }, origin, origin.vd);\n        }\n        labelPos = {\n            x: tick.label.xy.x,\n            y: tick.label.xy.y,\n            z: null\n        };\n\n        labelPos = perspective3D(labelPos, origin, origin.vd);\n\n        // If tick is first one, check whether next label position is already\n        // calculated, then return difference between the first and the second\n        // label. If there is no next label position calculated, return the\n        // difference between the first grid line and left 3d frame.\n        slotWidth = Math.abs(prevLabelPos ?\n            labelPos.x - prevLabelPos.x : nextLabelPos ?\n                nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x\n        );\n        return slotWidth;\n    }\n    return proceed.apply(this, [].slice.call(arguments, 1));\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Axis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Chart.js":
/*!*****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Chart.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * Extension for 3D charts\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    perspective = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n// Shorthand to check the is3d flag\nChart.prototype.is3d = function () {\n    return (\n        this.options.chart.options3d &&\n        this.options.chart.options3d.enabled\n    ); // #4280\n};\n\nChart.prototype.propsRequireDirtyBox.push('chart.options3d');\nChart.prototype.propsRequireUpdateSeries.push('chart.options3d');\n\n// Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to the\n// real 'scatter3d' series type.\naddEvent(Chart, 'afterInit', function () {\n    var options = this.options;\n\n    if (this.is3d()) {\n        each(options.series || [], function (s) {\n            var type = s.type ||\n                options.chart.type ||\n                options.chart.defaultSeriesType;\n            if (type === 'scatter') {\n                s.type = 'scatter3d';\n            }\n        });\n    }\n});\n// And do it on dynamic add (#8407)\naddEvent(Chart, 'addSeries', function (e) {\n    if (this.is3d()) {\n        if (e.options.type === 'scatter') {\n            e.options.type = 'scatter3d';\n        }\n    }\n});\n\n/**\n * Calculate scale of the 3D view. That is required to\n * fit chart's 3D projection into the actual plotting area. Reported as #4933.\n * @notice This function should ideally take the plot values instead of a chart\n *         object, but since the chart object is needed for perspective it is\n *         not practical. Possible to make both getScale and perspective more\n *         logical and also immutable.\n * @param  {Object} chart Chart object\n * @param  {Number} chart.plotLeft\n * @param  {Number} chart.plotWidth\n * @param  {Number} chart.plotTop\n * @param  {Number} chart.plotHeight\n * @param  {Number} depth The depth of the chart\n * @return {Number} The scale to fit the 3D chart into the plotting area.\n */\nfunction getScale(chart, depth) {\n    var plotLeft = chart.plotLeft,\n        plotRight = chart.plotWidth + plotLeft,\n        plotTop = chart.plotTop,\n        plotBottom = chart.plotHeight + plotTop,\n        originX = plotLeft + chart.plotWidth / 2,\n        originY = plotTop + chart.plotHeight / 2,\n        bbox3d = {\n            minX: Number.MAX_VALUE,\n            maxX: -Number.MAX_VALUE,\n            minY: Number.MAX_VALUE,\n            maxY: -Number.MAX_VALUE\n        },\n        corners,\n        scale = 1;\n\n    // Top left corners:\n    corners = [{\n        x: plotLeft,\n        y: plotTop,\n        z: 0\n    }, {\n        x: plotLeft,\n        y: plotTop,\n        z: depth\n    }];\n\n    // Top right corners:\n    each([0, 1], function (i) {\n        corners.push({\n            x: plotRight,\n            y: corners[i].y,\n            z: corners[i].z\n        });\n    });\n\n    // All bottom corners:\n    each([0, 1, 2, 3], function (i) {\n        corners.push({\n            x: corners[i].x,\n            y: plotBottom,\n            z: corners[i].z\n        });\n    });\n\n    // Calculate 3D corners:\n    corners = perspective(corners, chart, false);\n\n    // Get bounding box of 3D element:\n    each(corners, function (corner) {\n        bbox3d.minX = Math.min(bbox3d.minX, corner.x);\n        bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);\n        bbox3d.minY = Math.min(bbox3d.minY, corner.y);\n        bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);\n    });\n\n    // Left edge:\n    if (plotLeft > bbox3d.minX) {\n        scale = Math.min(\n            scale,\n            1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1\n        );\n    }\n\n    // Right edge:\n    if (plotRight < bbox3d.maxX) {\n        scale = Math.min(\n            scale,\n            (plotRight - originX) / (bbox3d.maxX - originX)\n        );\n    }\n\n    // Top edge:\n    if (plotTop > bbox3d.minY) {\n        if (bbox3d.minY < 0) {\n            scale = Math.min(\n                scale,\n                (plotTop + originY) / (-bbox3d.minY + plotTop + originY)\n            );\n        } else {\n            scale = Math.min(\n                scale,\n                1 - (plotTop + originY) / (bbox3d.minY + originY) % 1\n            );\n        }\n    }\n\n    // Bottom edge:\n    if (plotBottom < bbox3d.maxY) {\n        scale = Math.min(\n            scale,\n            Math.abs((plotBottom - originY) / (bbox3d.maxY - originY))\n        );\n    }\n\n    return scale;\n}\n\n\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype, 'isInsidePlot', function (proceed) {\n    return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));\n});\n\nvar defaultOptions = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getOptions();\n\n/**\n * @optionparent\n */\nvar extendedOptions = {\n\n    chart: {\n\n        /**\n         * Options to render charts in 3 dimensions. This feature requires\n         * `highcharts-3d.js`, found in the download package or online at\n         * [code.highcharts.com/highcharts-3d.js](http://code.highcharts.com/highcharts-\n         * 3d.js).\n         *\n         * @since 4.0\n         * @product highcharts\n         */\n        options3d: {\n\n            /**\n             * Wether to render the chart using the 3D functionality.\n             *\n             * @type {Boolean}\n             * @default false\n             * @since 4.0\n             * @product highcharts\n             */\n            enabled: false,\n\n            /**\n             * One of the two rotation angles for the chart.\n             *\n             * @type {Number}\n             * @default 0\n             * @since 4.0\n             * @product highcharts\n             */\n            alpha: 0,\n\n            /**\n             * One of the two rotation angles for the chart.\n             *\n             * @type {Number}\n             * @default 0\n             * @since 4.0\n             * @product highcharts\n             */\n            beta: 0,\n\n            /**\n             * The total depth of the chart.\n             *\n             * @type {Number}\n             * @default 100\n             * @since 4.0\n             * @product highcharts\n             */\n            depth: 100,\n\n            /**\n             * Whether the 3d box should automatically adjust to the chart plot\n             * area.\n             *\n             * @type {Boolean}\n             * @default true\n             * @since 4.2.4\n             * @product highcharts\n             */\n            fitToPlot: true,\n\n            /**\n             * Defines the distance the viewer is standing in front of the\n             * chart, this setting is important to calculate the perspective\n             * effect in column and scatter charts. It is not used for 3D pie\n             * charts.\n             *\n             * @type {Number}\n             * @default 100\n             * @since 4.0\n             * @product highcharts\n             */\n            viewDistance: 25,\n\n            /**\n             * Set it to `\"auto\"` to automatically move the labels to the best\n             * edge.\n             *\n             * @validvalue [null, \"auto\"]\n             * @type {String}\n             * @since 5.0.12\n             * @product highcharts\n             */\n            axisLabelPosition: null,\n\n            /**\n             * Provides the option to draw a frame around the charts by defining\n             * a bottom, front and back panel.\n             *\n             * @since 4.0\n             * @product highcharts\n             */\n            frame: {\n\n                /**\n                 * Whether the frames are visible.\n                 */\n                visible: 'default',\n\n                /**\n                 * General pixel thickness for the frame faces.\n                 */\n                size: 1,\n\n                /**\n                 * The bottom of the frame around a 3D chart.\n                 *\n                 * @since 4.0\n                 * @product highcharts\n                 */\n\n                /**\n                 * The color of the panel.\n                 *\n                 * @type {Color}\n                 * @default transparent\n                 * @since 4.0\n                 * @product highcharts\n                 * @apioption chart.options3d.frame.bottom.color\n                 */\n\n                /**\n                 * The thickness of the panel.\n                 *\n                 * @type {Number}\n                 * @default 1\n                 * @since 4.0\n                 * @product highcharts\n                 * @apioption chart.options3d.frame.bottom.size\n                 */\n\n                /**\n                 * Whether to display the frame. Possible values are `true`,\n                 * `false`, `\"auto\"` to display only the frames behind the data,\n                 * and `\"default\"` to display faces behind the data based on the\n                 * axis layout, ignoring the point of view.\n                 *\n                 * @validvalue [\"default\", \"auto\", true, false]\n                 * @type {Boolean|String}\n                 * @sample {highcharts} highcharts/3d/scatter-frame/ Auto frames\n                 * @default default\n                 * @since 5.0.12\n                 * @product highcharts\n                 * @apioption chart.options3d.frame.bottom.visible\n                 */\n\n                /**\n                 * The bottom of the frame around a 3D chart.\n                 */\n                bottom: {},\n\n                /**\n                 * The top of the frame around a 3D chart.\n                 *\n                 * @extends chart.options3d.frame.bottom\n                 */\n                top: {},\n\n                /**\n                 * The left side of the frame around a 3D chart.\n                 *\n                 * @extends chart.options3d.frame.bottom\n                 */\n                left: {},\n\n                /**\n                 * The right of the frame around a 3D chart.\n                 *\n                 * @extends chart.options3d.frame.bottom\n                 */\n                right: {},\n\n                /**\n                 * The back side of the frame around a 3D chart.\n                 *\n                 * @extends chart.options3d.frame.bottom\n                 */\n                back: {},\n\n                /**\n                 * The front of the frame around a 3D chart.\n                 *\n                 * @extends chart.options3d.frame.bottom\n                 */\n                front: {}\n            }\n        }\n    }\n};\n\nmerge(true, defaultOptions, extendedOptions);\n\n\n/**\n * Add the required CSS classes for column sides (#6018)\n */\naddEvent(Chart, 'afterGetContainer', function () {\n    this.renderer.definition({\n        tagName: 'style',\n        textContent:\n            '.highcharts-3d-top{' +\n                'filter: url(#highcharts-brighter)' +\n            '}\\n' +\n            '.highcharts-3d-side{' +\n                'filter: url(#highcharts-darker)' +\n            '}\\n'\n    });\n});\n\n\nwrap(Chart.prototype, 'setClassName', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    if (this.is3d()) {\n        this.container.className += ' highcharts-3d-chart';\n    }\n});\n\naddEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart, 'afterSetChartSize', function () {\n    var chart = this,\n        options3d = chart.options.chart.options3d;\n\n    if (chart.is3d()) {\n        var inverted = chart.inverted,\n            clipBox = chart.clipBox,\n            margin = chart.margin,\n            x = inverted ? 'y' : 'x',\n            y = inverted ? 'x' : 'y',\n            w = inverted ? 'height' : 'width',\n            h = inverted ? 'width' : 'height';\n\n        clipBox[x] = -(margin[3] || 0);\n        clipBox[y] = -(margin[0] || 0);\n        clipBox[w] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);\n        clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);\n\n        // Set scale, used later in perspective method():\n        // getScale uses perspective, so scale3d has to be reset.\n        chart.scale3d = 1;\n        if (options3d.fitToPlot === true) {\n            chart.scale3d = getScale(chart, options3d.depth);\n        }\n        // Recalculate the 3d frame with every call of setChartSize,\n        // instead of doing it after every redraw(). It avoids ticks\n        // and axis title outside of chart.\n        chart.frame3d = this.get3dFrame(); // #7942\n    }\n});\n\naddEvent(Chart, 'beforeRedraw', function () {\n    if (this.is3d()) {\n        // Set to force a redraw of all elements\n        this.isDirtyBox = true;\n    }\n});\n\naddEvent(Chart, 'beforeRender', function () {\n    if (this.is3d()) {\n        this.frame3d = this.get3dFrame();\n    }\n});\n\n// Draw the series in the reverse order (#3803, #3917)\nwrap(Chart.prototype, 'renderSeries', function (proceed) {\n    var series,\n        i = this.series.length;\n\n    if (this.is3d()) {\n        while (i--) {\n            series = this.series[i];\n            series.translate();\n            series.render();\n        }\n    } else {\n        proceed.call(this);\n    }\n});\n\naddEvent(Chart, 'afterDrawChartBox', function () {\n    if (this.is3d()) {\n        var chart = this,\n            renderer = chart.renderer,\n            options3d = this.options.chart.options3d,\n            frame = chart.get3dFrame(),\n            xm = this.plotLeft,\n            xp = this.plotLeft + this.plotWidth,\n            ym = this.plotTop,\n            yp = this.plotTop + this.plotHeight,\n            zm = 0,\n            zp = options3d.depth,\n            xmm = xm - (frame.left.visible ? frame.left.size : 0),\n            xpp = xp + (frame.right.visible ? frame.right.size : 0),\n            ymm = ym - (frame.top.visible ? frame.top.size : 0),\n            ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0),\n            zmm = zm - (frame.front.visible ? frame.front.size : 0),\n            zpp = zp + (frame.back.visible ? frame.back.size : 0),\n            verb = chart.hasRendered ? 'animate' : 'attr';\n\n        this.frame3d = frame;\n\n        if (!this.frameShapes) {\n            this.frameShapes = {\n                bottom: renderer.polyhedron().add(),\n                top: renderer.polyhedron().add(),\n                left: renderer.polyhedron().add(),\n                right: renderer.polyhedron().add(),\n                back: renderer.polyhedron().add(),\n                front: renderer.polyhedron().add()\n            };\n        }\n        this.frameShapes.bottom[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',\n            zIndex: frame.bottom.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }],\n                enabled: frame.bottom.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.bottom.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.bottom.visible && !frame.left.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.bottom.visible && !frame.right.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.bottom.visible && !frame.front.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.bottom.color).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.bottom.visible && !frame.back.visible\n            }]\n        });\n        this.frameShapes.top[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-top',\n            zIndex: frame.top.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }],\n                enabled: frame.top.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.top.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.top.visible && !frame.left.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.top.visible && !frame.right.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.top.visible && !frame.front.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.top.color).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.top.visible && !frame.back.visible\n            }]\n        });\n        this.frameShapes.left[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-left',\n            zIndex: frame.left.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }],\n                enabled: frame.left.visible && !frame.bottom.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }],\n                enabled: frame.left.visible && !frame.top.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }],\n                enabled: frame.left.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.left.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.left.visible && !frame.front.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.left.color).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.left.visible && !frame.back.visible\n            }]\n        });\n        this.frameShapes.right[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-right',\n            zIndex: frame.right.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }],\n                enabled: frame.right.visible && !frame.bottom.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }],\n                enabled: frame.right.visible && !frame.top.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.right.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }],\n                enabled: frame.right.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.right.visible && !frame.front.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.right.color).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.right.visible && !frame.back.visible\n            }]\n        });\n        this.frameShapes.back[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-back',\n            zIndex: frame.back.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.back.visible && !frame.bottom.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.back.visible && !frame.top.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.back.visible && !frame.left.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }],\n                enabled: frame.back.visible && !frame.right.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).get(),\n                vertexes: [{\n                    x: xm,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zp\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zp\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zp\n                }],\n                enabled: frame.back.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.back.color).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zpp\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zpp\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zpp\n                }],\n                enabled: frame.back.visible\n            }]\n        });\n        this.frameShapes.front[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-front',\n            zIndex: frame.front.frontFacing ? -1000 : 1000,\n            faces: [{ // bottom\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.front.visible && !frame.bottom.visible\n            },\n            { // top\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).brighten(0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.front.visible && !frame.top.visible\n            },\n            { // left\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }],\n                enabled: frame.front.visible && !frame.left.visible\n            },\n            { // right\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).brighten(-0.1).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.front.visible && !frame.right.visible\n            },\n            { // front\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).get(),\n                vertexes: [{\n                    x: xp,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: ym,\n                    z: zm\n                }, {\n                    x: xm,\n                    y: yp,\n                    z: zm\n                }, {\n                    x: xp,\n                    y: yp,\n                    z: zm\n                }],\n                enabled: frame.front.visible\n            },\n            { // back\n                fill: _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(frame.front.color).get(),\n                vertexes: [{\n                    x: xpp,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ypp,\n                    z: zmm\n                }, {\n                    x: xmm,\n                    y: ymm,\n                    z: zmm\n                }, {\n                    x: xpp,\n                    y: ymm,\n                    z: zmm\n                }],\n                enabled: frame.front.visible\n            }]\n        });\n    }\n});\n\nChart.prototype.retrieveStacks = function (stacking) {\n    var series = this.series,\n        stacks = {},\n        stackNumber,\n        i = 1;\n\n    each(this.series, function (s) {\n        stackNumber = pick(\n            s.options.stack,\n            (stacking ? 0 : series.length - 1 - s.index)\n        ); // #3841, #4532\n        if (!stacks[stackNumber]) {\n            stacks[stackNumber] = { series: [s], position: i };\n            i++;\n        } else {\n            stacks[stackNumber].series.push(s);\n        }\n    });\n\n    stacks.totalStacks = i + 1;\n    return stacks;\n};\n\nChart.prototype.get3dFrame = function () {\n    var chart = this,\n        options3d = chart.options.chart.options3d,\n        frameOptions = options3d.frame,\n        xm = chart.plotLeft,\n        xp = chart.plotLeft + chart.plotWidth,\n        ym = chart.plotTop,\n        yp = chart.plotTop + chart.plotHeight,\n        zm = 0,\n        zp = options3d.depth,\n        faceOrientation = function (vertexes) {\n            var area = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea3d(vertexes, chart);\n            // Give it 0.5 squared-pixel as a margin for rounding errors.\n            if (area > 0.5) {\n                return 1;\n            }\n            if (area < -0.5) {\n                return -1;\n            }\n            return 0;\n        },\n        bottomOrientation = faceOrientation([\n            { x: xm, y: yp, z: zp },\n            { x: xp, y: yp, z: zp },\n            { x: xp, y: yp, z: zm },\n            { x: xm, y: yp, z: zm }\n        ]),\n        topOrientation = faceOrientation([\n            { x: xm, y: ym, z: zm },\n            { x: xp, y: ym, z: zm },\n            { x: xp, y: ym, z: zp },\n            { x: xm, y: ym, z: zp }\n        ]),\n        leftOrientation = faceOrientation([\n            { x: xm, y: ym, z: zm },\n            { x: xm, y: ym, z: zp },\n            { x: xm, y: yp, z: zp },\n            { x: xm, y: yp, z: zm }\n        ]),\n        rightOrientation = faceOrientation([\n            { x: xp, y: ym, z: zp },\n            { x: xp, y: ym, z: zm },\n            { x: xp, y: yp, z: zm },\n            { x: xp, y: yp, z: zp }\n        ]),\n        frontOrientation = faceOrientation([\n            { x: xm, y: yp, z: zm },\n            { x: xp, y: yp, z: zm },\n            { x: xp, y: ym, z: zm },\n            { x: xm, y: ym, z: zm }\n        ]),\n        backOrientation = faceOrientation([\n            { x: xm, y: ym, z: zp },\n            { x: xp, y: ym, z: zp },\n            { x: xp, y: yp, z: zp },\n            { x: xm, y: yp, z: zp }\n        ]),\n        defaultShowBottom = false,\n        defaultShowTop = false,\n        defaultShowLeft = false,\n        defaultShowRight = false,\n        defaultShowFront = false,\n        defaultShowBack = true;\n\n    // The 'default' criteria to visible faces of the frame is looking up every\n    // axis to decide whenever the left/right//top/bottom sides of the frame\n    // will be shown\n    each([].concat(chart.xAxis, chart.yAxis, chart.zAxis), function (axis) {\n        if (axis) {\n            if (axis.horiz) {\n                if (axis.opposite) {\n                    defaultShowTop = true;\n                } else {\n                    defaultShowBottom = true;\n                }\n            } else {\n                if (axis.opposite) {\n                    defaultShowRight = true;\n                } else {\n                    defaultShowLeft = true;\n                }\n            }\n        }\n    });\n\n    var getFaceOptions = function (sources, faceOrientation, defaultVisible) {\n        var faceAttrs = ['size', 'color', 'visible'];\n        var options = {};\n        for (var i = 0; i < faceAttrs.length; i++) {\n            var attr = faceAttrs[i];\n            for (var j = 0; j < sources.length; j++) {\n                if (typeof sources[j] === 'object') {\n                    var val = sources[j][attr];\n                    if (val !== undefined && val !== null) {\n                        options[attr] = val;\n                        break;\n                    }\n                }\n            }\n        }\n        var isVisible = defaultVisible;\n        if (options.visible === true || options.visible === false) {\n            isVisible = options.visible;\n        } else if (options.visible === 'auto') {\n            isVisible = faceOrientation > 0;\n        }\n\n        return {\n            size: pick(options.size, 1),\n            color: pick(options.color, 'none'),\n            frontFacing: faceOrientation > 0,\n            visible: isVisible\n        };\n    };\n\n    // docs @TODO: Add all frame options (left, right, top, bottom, front, back)\n    // to apioptions JSDoc once the new system is up.\n    var ret = {\n        // FIXME: Previously, left/right, top/bottom and front/back pairs shared\n        // size and color.\n        // For compatibility and consistency sake, when one face have\n        // size/color/visibility set, the opposite face will default to the same\n        // values. Also, left/right used to be called 'side', so that's also\n        // added as a fallback\n        bottom: getFaceOptions(\n            [frameOptions.bottom, frameOptions.top, frameOptions],\n            bottomOrientation,\n            defaultShowBottom\n        ),\n        top: getFaceOptions(\n            [frameOptions.top, frameOptions.bottom, frameOptions],\n            topOrientation,\n            defaultShowTop\n        ),\n        left: getFaceOptions(\n            [\n                frameOptions.left,\n                frameOptions.right,\n                frameOptions.side,\n                frameOptions\n            ],\n            leftOrientation,\n            defaultShowLeft\n        ),\n        right: getFaceOptions(\n            [\n                frameOptions.right,\n                frameOptions.left,\n                frameOptions.side,\n                frameOptions\n            ],\n            rightOrientation,\n            defaultShowRight\n        ),\n        back: getFaceOptions(\n            [frameOptions.back, frameOptions.front, frameOptions],\n            backOrientation,\n            defaultShowBack\n        ),\n        front: getFaceOptions(\n            [frameOptions.front, frameOptions.back, frameOptions],\n            frontOrientation,\n            defaultShowFront\n        )\n    };\n\n\n    // Decide the bast place to put axis title/labels based on the visible\n    // faces. Ideally, The labels can only be on the edge between a visible face\n    // and an invisble one. Also, the Y label should be one the left-most edge\n    // (right-most if opposite),\n    if (options3d.axisLabelPosition === 'auto') {\n        var isValidEdge = function (face1, face2) {\n            return (\n                (face1.visible !== face2.visible) ||\n                (\n                    face1.visible &&\n                    face2.visible &&\n                    (face1.frontFacing !== face2.frontFacing)\n                )\n            );\n        };\n\n        var yEdges = [];\n        if (isValidEdge(ret.left, ret.front)) {\n            yEdges.push({\n                y: (ym + yp) / 2,\n                x: xm,\n                z: zm,\n                xDir: { x: 1, y: 0, z: 0 }\n            });\n        }\n        if (isValidEdge(ret.left, ret.back)) {\n            yEdges.push({\n                y: (ym + yp) / 2,\n                x: xm,\n                z: zp,\n                xDir: { x: 0, y: 0, z: -1 }\n            });\n        }\n        if (isValidEdge(ret.right, ret.front)) {\n            yEdges.push({\n                y: (ym + yp) / 2,\n                x: xp,\n                z: zm,\n                xDir: { x: 0, y: 0, z: 1 }\n            });\n        }\n        if (isValidEdge(ret.right, ret.back)) {\n            yEdges.push({\n                y: (ym + yp) / 2,\n                x: xp,\n                z: zp,\n                xDir: { x: -1, y: 0, z: 0 }\n            });\n        }\n\n        var xBottomEdges = [];\n        if (isValidEdge(ret.bottom, ret.front)) {\n            xBottomEdges.push({\n                x: (xm + xp) / 2,\n                y: yp,\n                z: zm,\n                xDir: { x: 1, y: 0, z: 0 }\n            });\n        }\n        if (isValidEdge(ret.bottom, ret.back)) {\n            xBottomEdges.push({\n                x: (xm + xp) / 2,\n                y: yp,\n                z: zp,\n                xDir: { x: -1, y: 0, z: 0 }\n            });\n        }\n\n        var xTopEdges = [];\n        if (isValidEdge(ret.top, ret.front)) {\n            xTopEdges.push({\n                x: (xm + xp) / 2,\n                y: ym,\n                z: zm,\n                xDir: { x: 1, y: 0, z: 0 }\n            });\n        }\n        if (isValidEdge(ret.top, ret.back)) {\n            xTopEdges.push({\n                x: (xm + xp) / 2,\n                y: ym,\n                z: zp,\n                xDir: { x: -1, y: 0, z: 0 }\n            });\n        }\n\n        var zBottomEdges = [];\n        if (isValidEdge(ret.bottom, ret.left)) {\n            zBottomEdges.push({\n                z: (zm + zp) / 2,\n                y: yp,\n                x: xm,\n                xDir: { x: 0, y: 0, z: -1 }\n            });\n        }\n        if (isValidEdge(ret.bottom, ret.right)) {\n            zBottomEdges.push({\n                z: (zm + zp) / 2,\n                y: yp,\n                x: xp,\n                xDir: { x: 0, y: 0, z: 1 }\n            });\n        }\n\n        var zTopEdges = [];\n        if (isValidEdge(ret.top, ret.left)) {\n            zTopEdges.push({\n                z: (zm + zp) / 2,\n                y: ym,\n                x: xm,\n                xDir: { x: 0, y: 0, z: -1 }\n            });\n        }\n        if (isValidEdge(ret.top, ret.right)) {\n            zTopEdges.push({\n                z: (zm + zp) / 2,\n                y: ym,\n                x: xp,\n                xDir: { x: 0, y: 0, z: 1 }\n            });\n        }\n\n        var pickEdge = function (edges, axis, mult) {\n            if (edges.length === 0) {\n                return null;\n            } else if (edges.length === 1) {\n                return edges[0];\n            }\n            var best = 0,\n                projections = perspective(edges, chart, false);\n            for (var i = 1; i < projections.length; i++) {\n                if (\n                    mult * projections[i][axis] >\n                    mult * projections[best][axis]\n                ) {\n                    best = i;\n                } else if (\n                    (\n                        mult * projections[i][axis] ===\n                        mult * projections[best][axis]\n                    ) &&\n                    (projections[i].z < projections[best].z)\n                ) {\n                    best = i;\n                }\n            }\n            return edges[best];\n        };\n        ret.axes = {\n            y: {\n                'left': pickEdge(yEdges, 'x', -1),\n                'right': pickEdge(yEdges, 'x', +1)\n            },\n            x: {\n                'top': pickEdge(xTopEdges, 'y', -1),\n                'bottom': pickEdge(xBottomEdges, 'y', +1)\n            },\n            z: {\n                'top': pickEdge(zTopEdges, 'y', -1),\n                'bottom': pickEdge(zBottomEdges, 'y', +1)\n            }\n        };\n    } else {\n        ret.axes = {\n            y: {\n                'left': { x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 } },\n                'right': { x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 } }\n            },\n            x: {\n                'top': { y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 } },\n                'bottom': { y: yp, z: zm, xDir: { x: 1, y: 0, z: 0 } }\n            },\n            z: {\n                'top': {\n                    x: defaultShowLeft ? xp : xm,\n                    y: ym,\n                    xDir: defaultShowLeft ?\n                        { x: 0, y: 0, z: 1 } :\n                        { x: 0, y: 0, z: -1 }\n                },\n                'bottom': {\n                    x: defaultShowLeft ? xp : xm,\n                    y: yp,\n                    xDir: defaultShowLeft ?\n                        { x: 0, y: 0, z: 1 } :\n                        { x: 0, y: 0, z: -1 }\n                }\n            }\n        };\n    }\n\n    return ret;\n};\n\n/**\n * Animation setter for matrix property.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx.prototype.matrixSetter = function () {\n    var interpolated;\n    if (this.pos < 1 &&\n            (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(this.start) || _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(this.end))) {\n        var start = this.start || [ 1, 0, 0, 1, 0, 0];\n        var end = this.end || [ 1, 0, 0, 1, 0, 0];\n        interpolated = [];\n        for (var i = 0; i < 6; i++) {\n            interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);\n        }\n    } else {\n        interpolated = this.end;\n    }\n\n    this.elem.attr(\n        this.prop,\n        interpolated,\n        null,\n        true\n    );\n};\n\n/**\n * Note: As of v5.0.12, `frame.left` or `frame.right` should be used\n * instead.\n *\n * The side for the frame around a 3D chart.\n *\n * @since 4.0\n * @product highcharts\n * @apioption chart.options3d.frame.side\n */\n\n/**\n * The color of the panel.\n *\n * @type {Color}\n * @default transparent\n * @since 4.0\n * @product highcharts\n * @apioption chart.options3d.frame.side.color\n */\n\n/**\n * The thickness of the panel.\n *\n * @type {Number}\n * @default 1\n * @since 4.0\n * @product highcharts\n * @apioption chart.options3d.frame.side.size\n */\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Chart.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Column.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Column.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    perspective = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    inArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    svg = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n\n\n/**\n * Depth of the columns in a 3D column chart. Requires `highcharts-3d.js`.\n *\n * @type {Number}\n * @default 25\n * @since 4.0\n * @product highcharts\n * @apioption plotOptions.column.depth\n */\n\n/**\n * 3D columns only. The color of the edges. Similar to `borderColor`,\n *  except it defaults to the same color as the column.\n *\n * @type {Color}\n * @product highcharts\n * @apioption plotOptions.column.edgeColor\n */\n\n/**\n * 3D columns only. The width of the colored edges.\n *\n * @type {Number}\n * @default 1\n * @product highcharts\n * @apioption plotOptions.column.edgeWidth\n */\n\n/**\n * The spacing between columns on the Z Axis in a 3D chart. Requires\n * `highcharts-3d.js`.\n *\n * @type {Number}\n * @default 1\n * @since 4.0\n * @product highcharts\n * @apioption plotOptions.column.groupZPadding\n */\n\nwrap(seriesTypes.column.prototype, 'translate', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    // Do not do this if the chart is not 3D\n    if (this.chart.is3d()) {\n        this.translate3dShapes();\n    }\n});\n\n// In 3D we need to pass point.outsidePlot option to the justifyDataLabel\n// method for disabling justifying dataLabels in columns outside plot\nwrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype, 'alignDataLabel', function (proceed) {\n    arguments[3].outside3dPlot = arguments[1].outside3dPlot;\n    proceed.apply(this, [].slice.call(arguments, 1));\n});\n\n// Don't use justifyDataLabel when point is outsidePlot\nwrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype, 'justifyDataLabel', function (proceed) {\n    return !(arguments[2].outside3dPlot) ?\n        proceed.apply(this, [].slice.call(arguments, 1)) :\n        false;\n});\n\nseriesTypes.column.prototype.translate3dPoints = function () {};\nseriesTypes.column.prototype.translate3dShapes = function () {\n\n    var series = this,\n        chart = series.chart,\n        seriesOptions = series.options,\n        depth = seriesOptions.depth || 25,\n        stack = seriesOptions.stacking ?\n            (seriesOptions.stack || 0) :\n            series.index, // #4743\n        z = stack * (depth + (seriesOptions.groupZPadding || 1)),\n        borderCrisp = series.borderWidth % 2 ? 0.5 : 0;\n\n    if (chart.inverted && !series.yAxis.reversed) {\n        borderCrisp *= -1;\n    }\n\n    if (seriesOptions.grouping !== false) {\n        z = 0;\n    }\n\n    z += (seriesOptions.groupZPadding || 1);\n    each(series.data, function (point) {\n        // #7103 Reset outside3dPlot flag\n        point.outside3dPlot = null;\n        if (point.y !== null) {\n            var shapeArgs = point.shapeArgs,\n                tooltipPos = point.tooltipPos,\n                // Array for final shapeArgs calculation.\n                // We are checking two dimensions (x and y).\n                dimensions = [['x', 'width'], ['y', 'height']],\n                borderlessBase; // Crisped rects can have +/- 0.5 pixels offset.\n\n            // #3131 We need to check if column is inside plotArea.\n            each(dimensions, function (d) {\n                borderlessBase = shapeArgs[d[0]] - borderCrisp;\n                if (borderlessBase < 0) {\n                    // If borderLessBase is smaller than 0, it is needed to set\n                    // its value to 0 or 0.5 depending on borderWidth\n                    // borderWidth may be even or odd.\n                    shapeArgs[d[1]] += shapeArgs[d[0]] + borderCrisp;\n                    shapeArgs[d[0]] = -borderCrisp;\n                    borderlessBase = 0;\n                }\n                if (\n                    (\n                        borderlessBase + shapeArgs[d[1]] >\n                        series[d[0] + 'Axis'].len\n                    ) &&\n                    // Do not change height/width of column if 0 (#6708)\n                    shapeArgs[d[1]] !== 0\n                ) {\n                    shapeArgs[d[1]] =\n                        series[d[0] + 'Axis'].len - shapeArgs[d[0]];\n                }\n                if (\n                    // Do not remove columns with zero height/width.\n                    (shapeArgs[d[1]] !== 0) &&\n                    (\n                        shapeArgs[d[0]] >= series[d[0] + 'Axis'].len ||\n                        shapeArgs[d[0]] + shapeArgs[d[1]] <= borderCrisp\n                    )\n                ) {\n                    // Set args to 0 if column is outside the chart.\n                    for (var key in shapeArgs) {\n                        shapeArgs[key] = 0;\n                    }\n                    // #7103 outside3dPlot flag is set on Points which are\n                    // currently outside of plot.\n                    point.outside3dPlot = true;\n                }\n            });\n\n            point.shapeType = 'cuboid';\n            shapeArgs.z = z;\n            shapeArgs.depth = depth;\n            shapeArgs.insidePlotArea = true;\n\n            // Translate the tooltip position in 3d space\n            tooltipPos = perspective(\n                [{ x: tooltipPos[0], y: tooltipPos[1], z: z }],\n                chart,\n                true\n            )[0];\n            point.tooltipPos = [tooltipPos.x, tooltipPos.y];\n        }\n    });\n    // store for later use #4067\n    series.z = z;\n};\n\nwrap(seriesTypes.column.prototype, 'animate', function (proceed) {\n    if (!this.chart.is3d()) {\n        proceed.apply(this, [].slice.call(arguments, 1));\n    } else {\n        var args = arguments,\n            init = args[1],\n            yAxis = this.yAxis,\n            series = this,\n            reversed = this.yAxis.reversed;\n\n        if (svg) { // VML is too slow anyway\n            if (init) {\n                each(series.data, function (point) {\n                    if (point.y !== null) {\n                        point.height = point.shapeArgs.height;\n                        point.shapey = point.shapeArgs.y;    // #2968\n                        point.shapeArgs.height = 1;\n                        if (!reversed) {\n                            if (point.stackY) {\n                                point.shapeArgs.y =\n                                    point.plotY + yAxis.translate(point.stackY);\n                            } else {\n                                point.shapeArgs.y =\n                                    point.plotY +\n                                    (\n                                        point.negative ?\n                                        -point.height :\n                                        point.height\n                                    );\n                            }\n                        }\n                    }\n                });\n\n            } else { // run the animation\n                each(series.data, function (point) {\n                    if (point.y !== null) {\n                        point.shapeArgs.height = point.height;\n                        point.shapeArgs.y = point.shapey;    // #2968\n                        // null value do not have a graphic\n                        if (point.graphic) {\n                            point.graphic.animate(\n                                point.shapeArgs,\n                                series.options.animation\n                            );\n                        }\n                    }\n                });\n\n                // redraw datalabels to the correct position\n                this.drawDataLabels();\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        }\n    }\n});\n\n/*\n * In case of 3d columns there is no sense to add this columns\n * to a specific series group - if series is added to a group\n * all columns will have the same zIndex in comparison with different series\n */\n\nwrap(\n    seriesTypes.column.prototype,\n    'plotGroup',\n    function (proceed, prop, name, visibility, zIndex, parent) {\n        if (this.chart.is3d() && parent && !this[prop]) {\n            if (!this.chart.columnGroup) {\n                this.chart.columnGroup =\n                    this.chart.renderer.g('columnGroup').add(parent);\n            }\n            this[prop] = this.chart.columnGroup;\n            this.chart.columnGroup.attr(this.getPlotBox());\n            this[prop].survive = true;\n        }\n        return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n);\n\n/*\n * When series is not added to group it is needed to change\n * setVisible method to allow correct Legend funcionality\n * This wrap is basing on pie chart series\n */\nwrap(\n    seriesTypes.column.prototype,\n    'setVisible',\n    function (proceed, vis) {\n        var series = this,\n            pointVis;\n        if (series.chart.is3d()) {\n            each(series.data, function (point) {\n                point.visible = point.options.visible = vis =\n                    vis === undefined ? !point.visible : vis;\n                pointVis = vis ? 'visible' : 'hidden';\n                series.options.data[inArray(point, series.data)] =\n                    point.options;\n                if (point.graphic) {\n                    point.graphic.attr({\n                        visibility: pointVis\n                    });\n                }\n            });\n        }\n        proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n);\n\nseriesTypes.column.prototype.handle3dGrouping = true;\naddEvent(Series, 'afterInit', function () {\n    if (this.chart.is3d() && this.handle3dGrouping) {\n        var seriesOptions = this.options,\n            grouping = seriesOptions.grouping,\n            stacking = seriesOptions.stacking,\n            reversedStacks = pick(this.yAxis.options.reversedStacks, true),\n            z = 0;\n\n        if (!(grouping !== undefined && !grouping)) {\n            var stacks = this.chart.retrieveStacks(stacking),\n                stack = seriesOptions.stack || 0,\n                i; // position within the stack\n            for (i = 0; i < stacks[stack].series.length; i++) {\n                if (stacks[stack].series[i] === this) {\n                    break;\n                }\n            }\n            z = (10 * (stacks.totalStacks - stacks[stack].position)) +\n                (reversedStacks ? i : -i); // #4369\n\n            // In case when axis is reversed, columns are also reversed inside\n            // the group (#3737)\n            if (!this.xAxis.reversed) {\n                z = (stacks.totalStacks * 10) - z;\n            }\n        }\n\n        seriesOptions.zIndex = z;\n    }\n});\n\n\n\nwrap(Series.prototype, 'alignDataLabel', function (proceed) {\n\n    // Only do this for 3D columns and columnranges\n    if (\n        this.chart.is3d() &&\n        (this.type === 'column' || this.type === 'columnrange')\n    ) {\n        var series = this,\n            chart = series.chart;\n\n        var args = arguments,\n            alignTo = args[4],\n            point = args[1];\n\n        var pos = ({ x: alignTo.x, y: alignTo.y, z: series.z });\n        pos = perspective([pos], chart, true)[0];\n        alignTo.x = pos.x;\n        // #7103 If point is outside of plotArea, hide data label.\n        alignTo.y = point.outside3dPlot ? -9e9 : pos.y;\n    }\n\n    proceed.apply(this, [].slice.call(arguments, 1));\n});\n\n// Added stackLabels position calculation for 3D charts.\nwrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StackItem.prototype, 'getStackBox', function (proceed, chart) { // #3946\n    var stackBox = proceed.apply(this, [].slice.call(arguments, 1));\n\n    // Only do this for 3D chart.\n    if (chart.is3d()) {\n        var pos = ({\n            x: stackBox.x,\n            y: stackBox.y,\n            z: 0\n        });\n        pos = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective([pos], chart, true)[0];\n        stackBox.x = pos.x;\n        stackBox.y = pos.y;\n    }\n\n    return stackBox;\n});\n\n/*\n    EXTENSION FOR 3D CYLINDRICAL COLUMNS\n    Not supported\n*/\n/*\nvar defaultOptions = H.getOptions();\ndefaultOptions.plotOptions.cylinder =\n    H.merge(defaultOptions.plotOptions.column);\nvar CylinderSeries = H.extendClass(seriesTypes.column, {\n    type: 'cylinder'\n});\nseriesTypes.cylinder = CylinderSeries;\n\nwrap(seriesTypes.cylinder.prototype, 'translate', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    // Do not do this if the chart is not 3D\n    if (!this.chart.is3d()) {\n        return;\n    }\n\n    var series = this,\n        chart = series.chart,\n        options = chart.options,\n        cylOptions = options.plotOptions.cylinder,\n        options3d = options.chart.options3d,\n        depth = cylOptions.depth || 0,\n        alpha = chart.alpha3d;\n\n    var z = cylOptions.stacking ?\n        (this.options.stack || 0) * depth :\n        series._i * depth;\n    z += depth / 2;\n\n    if (cylOptions.grouping !== false) { z = 0; }\n\n    each(series.data, function (point) {\n        var shapeArgs = point.shapeArgs,\n            deg2rad = H.deg2rad;\n        point.shapeType = 'arc3d';\n        shapeArgs.x += depth / 2;\n        shapeArgs.z = z;\n        shapeArgs.start = 0;\n        shapeArgs.end = 2 * PI;\n        shapeArgs.r = depth * 0.95;\n        shapeArgs.innerR = 0;\n        shapeArgs.depth =\n            shapeArgs.height * (1 / sin((90 - alpha) * deg2rad)) - z;\n        shapeArgs.alpha = 90 - alpha;\n        shapeArgs.beta = 0;\n    });\n});\n*/\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Column.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Math.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Math.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n/**\n *    Mathematical Functionility\n */\nvar deg2rad = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n\n/* eslint-disable max-len */\n/**\n * Apply 3-D rotation\n * Euler Angles (XYZ):\n *     cosA = cos(Alfa|Roll)\n *     cosB = cos(Beta|Pitch)\n *     cosG = cos(Gamma|Yaw)\n *\n * Composite rotation:\n * |          cosB * cosG             |           cosB * sinG            |    -sinB    |\n * | sinA * sinB * cosG - cosA * sinG | sinA * sinB * sinG + cosA * cosG | sinA * cosB |\n * | cosA * sinB * cosG + sinA * sinG | cosA * sinB * sinG - sinA * cosG | cosA * cosB |\n *\n * Now, Gamma/Yaw is not used (angle=0), so we assume cosG = 1 and sinG = 0, so\n * we get:\n * |     cosB    |   0    |   - sinB    |\n * | sinA * sinB |  cosA  | sinA * cosB |\n * | cosA * sinB | - sinA | cosA * cosB |\n *\n * But in browsers, y is reversed, so we get sinA => -sinA. The general result\n * is:\n * |      cosB     |   0    |    - sinB     |     | x |     | px |\n * | - sinA * sinB |  cosA  | - sinA * cosB |  x  | y |  =  | py |\n * |  cosA * sinB  |  sinA  |  cosA * cosB  |     | z |     | pz |\n */\n/* eslint-enable max-len */\nfunction rotate3D(x, y, z, angles) {\n    return {\n        x: angles.cosB * x - angles.sinB * z,\n        y: -angles.sinA * angles.sinB * x + angles.cosA * y -\n            angles.cosB * angles.sinA * z,\n        z: angles.cosA * angles.sinB * x + angles.sinA * y +\n            angles.cosA * angles.cosB * z\n    };\n}\n\n// Perspective3D function is available in global Highcharts scope because is\n// needed also outside of perspective() function (#8042).\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective3D = function (coordinate, origin, distance) {\n    var projection = ((distance > 0) && (distance < Number.POSITIVE_INFINITY)) ?\n    distance / (coordinate.z + origin.z + distance) :\n    1;\n    return {\n        x: coordinate.x * projection,\n        y: coordinate.y * projection\n    };\n};\n\n/**\n * Transforms a given array of points according to the angles in chart.options.\n * Parameters:\n *        - points: the array of points\n *        - chart: the chart\n *        - insidePlotArea: wether to verifiy the points are inside the plotArea\n * Returns:\n *        - an array of transformed points\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective = function (points, chart, insidePlotArea) {\n    var options3d = chart.options.chart.options3d,\n        inverted = insidePlotArea ? chart.inverted : false,\n        origin = {\n            x: chart.plotWidth / 2,\n            y: chart.plotHeight / 2,\n            z: options3d.depth / 2,\n            vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n        },\n        scale = chart.scale3d || 1,\n        beta = deg2rad * options3d.beta * (inverted ? -1 : 1),\n        alpha = deg2rad * options3d.alpha * (inverted ? -1 : 1),\n        angles = {\n            cosA: Math.cos(alpha),\n            cosB: Math.cos(-beta),\n            sinA: Math.sin(alpha),\n            sinB: Math.sin(-beta)\n        };\n\n    if (!insidePlotArea) {\n        origin.x += chart.plotLeft;\n        origin.y += chart.plotTop;\n    }\n\n    // Transform each point\n    return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map(points, function (point) {\n        var rotated = rotate3D(\n                (inverted ? point.y : point.x) - origin.x,\n                (inverted ? point.x : point.y) - origin.y,\n                (point.z || 0) - origin.z,\n                angles\n            ),\n            // Apply perspective\n            coordinate = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective3D(rotated, origin, origin.vd);\n\n        // Apply translation\n        coordinate.x = coordinate.x * scale + origin.x;\n        coordinate.y = coordinate.y * scale + origin.y;\n        coordinate.z = rotated.z * scale + origin.z;\n\n        return {\n            x: (inverted ? coordinate.y : coordinate.x),\n            y: (inverted ? coordinate.x : coordinate.y),\n            z: coordinate.z\n        };\n    });\n};\n\n/**\n * Calculate a distance from camera to points - made for calculating zIndex of\n * scatter points.\n * Parameters:\n *        - coordinates: The coordinates of the specific point\n *        - chart: the chart\n * Returns:\n *        - a distance from camera to point\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointCameraDistance = function (coordinates, chart) {\n    var options3d = chart.options.chart.options3d,\n        cameraPosition = {\n            x: chart.plotWidth / 2,\n            y: chart.plotHeight / 2,\n            z: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0) +\n                options3d.depth\n        },\n        distance = Math.sqrt(\n            Math.pow(cameraPosition.x - coordinates.plotX, 2) +\n            Math.pow(cameraPosition.y - coordinates.plotY, 2) +\n            Math.pow(cameraPosition.z - coordinates.plotZ, 2)\n        );\n    return distance;\n};\n\n/**\n * Calculate area of a 2D polygon using Shoelace algorithm\n * http://en.wikipedia.org/wiki/Shoelace_formula\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea = function (vertexes) {\n    var area = 0,\n        i,\n        j;\n    for (i = 0; i < vertexes.length; i++) {\n        j = (i + 1) % vertexes.length;\n        area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;\n    }\n    return area / 2;\n};\n\n/**\n * Calculate area of a 3D polygon after perspective projection\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea3d = function (vertexes, chart, insidePlotArea) {\n    return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective(vertexes, chart, insidePlotArea));\n};\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Math.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Pie.js":
/*!***************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Pie.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * 3D pie series\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar deg2rad = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    svg = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n\n/**\n * The thickness of a 3D pie. Requires `highcharts-3d.js`\n *\n * @type {Number}\n * @default 0\n * @since 4.0\n * @product highcharts\n * @apioption plotOptions.pie.depth\n */\n\nwrap(seriesTypes.pie.prototype, 'translate', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    // Do not do this if the chart is not 3D\n    if (!this.chart.is3d()) {\n        return;\n    }\n\n    var series = this,\n        seriesOptions = series.options,\n        depth = seriesOptions.depth || 0,\n        options3d = series.chart.options.chart.options3d,\n        alpha = options3d.alpha,\n        beta = options3d.beta,\n        z = seriesOptions.stacking ?\n            (seriesOptions.stack || 0) * depth :\n            series._i * depth;\n\n    z += depth / 2;\n\n    if (seriesOptions.grouping !== false) {\n        z = 0;\n    }\n\n    each(series.data, function (point) {\n\n        var shapeArgs = point.shapeArgs,\n            angle;\n\n        point.shapeType = 'arc3d';\n\n        shapeArgs.z = z;\n        shapeArgs.depth = depth * 0.75;\n        shapeArgs.alpha = alpha;\n        shapeArgs.beta = beta;\n        shapeArgs.center = series.center;\n\n        angle = (shapeArgs.end + shapeArgs.start) / 2;\n\n        point.slicedTranslation = {\n            translateX: Math.round(\n                Math.cos(angle) *\n                seriesOptions.slicedOffset *\n                Math.cos(alpha * deg2rad)\n            ),\n            translateY: Math.round(\n                Math.sin(angle) *\n                seriesOptions.slicedOffset *\n                Math.cos(alpha * deg2rad)\n            )\n        };\n    });\n});\n\nwrap(\n    seriesTypes.pie.prototype.pointClass.prototype,\n    'haloPath',\n    function (proceed) {\n        var args = arguments;\n        return this.series.chart.is3d() ? [] : proceed.call(this, args[1]);\n    }\n);\n\n\n\nwrap(seriesTypes.pie.prototype, 'drawPoints', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    if (this.chart.is3d()) {\n        each(this.points, function (point) {\n            var graphic = point.graphic;\n\n            // #4584 Check if has graphic - null points don't have it\n            if (graphic) {\n                // Hide null or 0 points (#3006, 3650)\n                graphic[point.y && point.visible ? 'show' : 'hide']();\n            }\n        });\n    }\n});\n\nwrap(seriesTypes.pie.prototype, 'drawDataLabels', function (proceed) {\n    if (this.chart.is3d()) {\n        var series = this,\n            chart = series.chart,\n            options3d = chart.options.chart.options3d;\n        each(series.data, function (point) {\n            var shapeArgs = point.shapeArgs,\n                r = shapeArgs.r,\n                // #3240 issue with datalabels for 0 and null values\n                a1 = (shapeArgs.alpha || options3d.alpha) * deg2rad,\n                b1 = (shapeArgs.beta || options3d.beta) * deg2rad,\n                a2 = (shapeArgs.start + shapeArgs.end) / 2,\n                labelPos = point.labelPos,\n                labelIndexes = [0, 2, 4], // [x1, y1, x2, y2, x3, y3]\n                yOffset = (-r * (1 - Math.cos(a1)) * Math.sin(a2)),\n                xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);\n\n            // Apply perspective on label positions\n            each(labelIndexes, function (index) {\n                labelPos[index] += xOffset;\n                labelPos[index + 1] += yOffset;\n            });\n        });\n    }\n\n    proceed.apply(this, [].slice.call(arguments, 1));\n});\n\nwrap(seriesTypes.pie.prototype, 'addPoint', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n    if (this.chart.is3d()) {\n        // destroy (and rebuild) everything!!!\n        this.update(this.userOptions, true); // #3845 pass the old options\n    }\n});\n\nwrap(seriesTypes.pie.prototype, 'animate', function (proceed) {\n    if (!this.chart.is3d()) {\n        proceed.apply(this, [].slice.call(arguments, 1));\n    } else {\n        var args = arguments,\n            init = args[1],\n            animation = this.options.animation,\n            attribs,\n            center = this.center,\n            group = this.group,\n            markerGroup = this.markerGroup;\n\n        if (svg) { // VML is too slow anyway\n\n            if (animation === true) {\n                animation = {};\n            }\n            // Initialize the animation\n            if (init) {\n\n                // Scale down the group and place it in the center\n                group.oldtranslateX = group.translateX;\n                group.oldtranslateY = group.translateY;\n                attribs = {\n                    translateX: center[0],\n                    translateY: center[1],\n                    scaleX: 0.001, // #1499\n                    scaleY: 0.001\n                };\n\n                group.attr(attribs);\n                if (markerGroup) {\n                    markerGroup.attrSetters = group.attrSetters;\n                    markerGroup.attr(attribs);\n                }\n\n            // Run the animation\n            } else {\n                attribs = {\n                    translateX: group.oldtranslateX,\n                    translateY: group.oldtranslateY,\n                    scaleX: 1,\n                    scaleY: 1\n                };\n                group.animate(attribs, animation);\n\n                if (markerGroup) {\n                    markerGroup.animate(attribs, animation);\n                }\n\n                // Delete this function to allow it only once\n                this.animate = null;\n            }\n\n        }\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Pie.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/SVGRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/SVGRenderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _parts_SvgRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar cos = Math.cos,\n    PI = Math.PI,\n    sin = Math.sin;\n\n\nvar animObject = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    charts = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    defined = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    deg2rad = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    inArray = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    map = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    perspective = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    SVGElement = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement,\n    SVGRenderer = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n/*\n    EXTENSION TO THE SVG-RENDERER TO ENABLE 3D SHAPES\n*/\n// HELPER METHODS //\n\nvar dFactor = (4 * (Math.sqrt(2) - 1) / 3) / (PI / 2);\n\n/** Method to construct a curved path\n  * Can 'wrap' around more then 180 degrees\n  */\nfunction curveTo(cx, cy, rx, ry, start, end, dx, dy) {\n    var result = [],\n        arcAngle = end - start;\n    if ((end > start) && (end - start > Math.PI / 2 + 0.0001)) {\n        result = result.concat(\n            curveTo(cx, cy, rx, ry, start, start + (Math.PI / 2), dx, dy)\n        );\n        result = result.concat(\n            curveTo(cx, cy, rx, ry, start + (Math.PI / 2), end, dx, dy)\n        );\n        return result;\n    }\n    if ((end < start) && (start - end > Math.PI / 2 + 0.0001)) {\n        result = result.concat(\n            curveTo(cx, cy, rx, ry, start, start - (Math.PI / 2), dx, dy)\n        );\n        result = result.concat(\n            curveTo(cx, cy, rx, ry, start - (Math.PI / 2), end, dx, dy)\n        );\n        return result;\n    }\n    return [\n        'C',\n        cx + (rx * Math.cos(start)) -\n            ((rx * dFactor * arcAngle) * Math.sin(start)) + dx,\n        cy + (ry * Math.sin(start)) +\n            ((ry * dFactor * arcAngle) * Math.cos(start)) + dy,\n        cx + (rx * Math.cos(end)) +\n            ((rx * dFactor * arcAngle) * Math.sin(end)) + dx,\n        cy + (ry * Math.sin(end)) -\n            ((ry * dFactor * arcAngle) * Math.cos(end)) + dy,\n\n        cx + (rx * Math.cos(end)) + dx,\n        cy + (ry * Math.sin(end)) + dy\n    ];\n}\n\n\n/**\n * Override the SVGRenderer initiator to add definitions used by brighter and\n * darker faces of the cuboids.\n */\nwrap(SVGRenderer.prototype, 'init', function (proceed) {\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    each([{\n        name: 'darker',\n        slope: 0.6\n    }, {\n        name: 'brighter',\n        slope: 1.4\n    }], function (cfg) {\n        this.definition({\n            tagName: 'filter',\n            id: 'highcharts-' + cfg.name,\n            children: [{\n                tagName: 'feComponentTransfer',\n                children: [{\n                    tagName: 'feFuncR',\n                    type: 'linear',\n                    slope: cfg.slope\n                }, {\n                    tagName: 'feFuncG',\n                    type: 'linear',\n                    slope: cfg.slope\n                }, {\n                    tagName: 'feFuncB',\n                    type: 'linear',\n                    slope: cfg.slope\n                }]\n            }]\n        });\n    }, this);\n});\n\n\nSVGRenderer.prototype.toLinePath = function (points, closed) {\n    var result = [];\n\n    // Put \"L x y\" for each point\n    each(points, function (point) {\n        result.push('L', point.x, point.y);\n    });\n\n    if (points.length) {\n        // Set the first element to M\n        result[0] = 'M';\n\n        // If it is a closed line, add Z\n        if (closed) {\n            result.push('Z');\n        }\n    }\n\n    return result;\n};\n\nSVGRenderer.prototype.toLineSegments = function (points) {\n    var result = [];\n\n    var m = true;\n    each(points, function (point) {\n        result.push(m ? 'M' : 'L', point.x, point.y);\n        m = !m;\n    });\n\n    return result;\n};\n\n/**\n * A 3-D Face is defined by it's 3D vertexes, and is only\n * visible if it's vertexes are counter-clockwise (Back-face culling).\n * It is used as a polyhedron Element\n */\nSVGRenderer.prototype.face3d = function (args) {\n    var renderer = this,\n        ret = this.createElement('path');\n    ret.vertexes = [];\n    ret.insidePlotArea = false;\n    ret.enabled = true;\n\n    wrap(ret, 'attr', function (proceed, hash) {\n        if (\n            typeof hash === 'object' &&\n            (\n                defined(hash.enabled) ||\n                defined(hash.vertexes) ||\n                defined(hash.insidePlotArea)\n            )\n        ) {\n            this.enabled = pick(hash.enabled, this.enabled);\n            this.vertexes = pick(hash.vertexes, this.vertexes);\n            this.insidePlotArea = pick(\n                hash.insidePlotArea,\n                this.insidePlotArea\n            );\n            delete hash.enabled;\n            delete hash.vertexes;\n            delete hash.insidePlotArea;\n\n            var chart = charts[renderer.chartIndex],\n                vertexes2d = perspective(\n                    this.vertexes,\n                    chart,\n                    this.insidePlotArea\n                ),\n                path = renderer.toLinePath(vertexes2d, true),\n                area = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea(vertexes2d),\n                visibility = (this.enabled && area > 0) ? 'visible' : 'hidden';\n\n            hash.d = path;\n            hash.visibility = visibility;\n        }\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    });\n\n    wrap(ret, 'animate', function (proceed, params) {\n        if (\n            typeof params === 'object' &&\n            (\n                defined(params.enabled) ||\n                defined(params.vertexes) ||\n                defined(params.insidePlotArea)\n            )\n        ) {\n            this.enabled = pick(params.enabled, this.enabled);\n            this.vertexes = pick(params.vertexes, this.vertexes);\n            this.insidePlotArea = pick(\n                params.insidePlotArea,\n                this.insidePlotArea\n            );\n            delete params.enabled;\n            delete params.vertexes;\n            delete params.insidePlotArea;\n\n            var chart = charts[renderer.chartIndex],\n                vertexes2d = perspective(\n                    this.vertexes,\n                    chart,\n                    this.insidePlotArea\n                ),\n                path = renderer.toLinePath(vertexes2d, true),\n                area = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea(vertexes2d),\n                visibility = (this.enabled && area > 0) ? 'visible' : 'hidden';\n\n            params.d = path;\n            this.attr('visibility', visibility);\n        }\n\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    });\n\n    return ret.attr(args);\n};\n\n/**\n * A Polyhedron is a handy way of defining a group of 3-D faces. It's only\n * attribute is `faces`, an array of attributes of each one of it's Face3D\n * instances.\n */\nSVGRenderer.prototype.polyhedron = function (args) {\n    var renderer = this,\n        result = this.g(),\n        destroy = result.destroy;\n\n    \n\n    result.faces = [];\n\n\n    // destroy all children\n    result.destroy = function () {\n        for (var i = 0; i < result.faces.length; i++) {\n            result.faces[i].destroy();\n        }\n        return destroy.call(this);\n    };\n\n    wrap(\n        result,\n        'attr',\n        function (proceed, hash, val, complete, continueAnimation) {\n            if (typeof hash === 'object' && defined(hash.faces)) {\n                while (result.faces.length > hash.faces.length) {\n                    result.faces.pop().destroy();\n                }\n                while (result.faces.length < hash.faces.length) {\n                    result.faces.push(renderer.face3d().add(result));\n                }\n                for (var i = 0; i < hash.faces.length; i++) {\n                    result.faces[i].attr(\n                        hash.faces[i],\n                        null,\n                        complete,\n                        continueAnimation\n                    );\n                }\n                delete hash.faces;\n            }\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        }\n\n    );\n\n    wrap(result, 'animate', function (proceed, params, duration, complete) {\n        if (params && params.faces) {\n            while (result.faces.length > params.faces.length) {\n                result.faces.pop().destroy();\n            }\n            while (result.faces.length < params.faces.length) {\n                result.faces.push(renderer.face3d().add(result));\n            }\n            for (var i = 0; i < params.faces.length; i++) {\n                result.faces[i].animate(params.faces[i], duration, complete);\n            }\n            delete params.faces;\n        }\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    });\n\n    return result.attr(args);\n};\n\n// CUBOIDS //\nSVGRenderer.prototype.cuboid = function (shapeArgs) {\n\n    var result = this.g(),\n        destroy = result.destroy,\n        paths = this.cuboidPath(shapeArgs);\n\n    \n\n    // Create the 3 sides. // Front, top and side are never overlapping in our\n    // case so it is redundant to set zIndex of every element.\n    result.front = this.path(paths[0]).attr({\n        'class': 'highcharts-3d-front'\n    }).add(result);\n    result.top = this.path(paths[1]).attr({\n        'class': 'highcharts-3d-top'\n    }).add(result);\n    result.side = this.path(paths[2]).attr({\n        'class': 'highcharts-3d-side'\n    }).add(result);\n\n    // apply the fill everywhere, the top a bit brighter, the side a bit darker\n    result.fillSetter = function (fill) {\n        this.front.attr({\n            fill: fill\n        });\n        this.top.attr({\n            fill: color(fill).brighten(0.1).get()\n        });\n        this.side.attr({\n            fill: color(fill).brighten(-0.1).get()\n        });\n        this.color = fill;\n\n        // for animation getter (#6776)\n        result.fill = fill;\n\n        return this;\n    };\n\n    // apply opacaity everywhere\n    result.opacitySetter = function (opacity) {\n        this.front.attr({ opacity: opacity });\n        this.top.attr({ opacity: opacity });\n        this.side.attr({ opacity: opacity });\n        return this;\n    };\n\n    result.attr = function (args, val, complete, continueAnimation) {\n\n        // Resolve setting attributes by string name\n        if (typeof args === 'string' && typeof val !== 'undefined') {\n            var key = args;\n            args = {};\n            args[key] = val;\n        }\n\n        if (args.shapeArgs || defined(args.x)) {\n            var shapeArgs = args.shapeArgs || args;\n            var paths = this.renderer.cuboidPath(shapeArgs);\n            this.front.attr({ d: paths[0] });\n            this.top.attr({ d: paths[1] });\n            this.side.attr({ d: paths[2] });\n        } else {\n            // getter returns value\n            return SVGElement.prototype.attr.call(\n                this, args, undefined, complete, continueAnimation\n            );\n        }\n\n        return this;\n    };\n\n    result.animate = function (args, duration, complete) {\n        if (defined(args.x) && defined(args.y)) {\n            var paths = this.renderer.cuboidPath(args);\n            this.front.animate({ d: paths[0] }, duration, complete);\n            this.top.animate({ d: paths[1] }, duration, complete);\n            this.side.animate({ d: paths[2] }, duration, complete);\n            this.attr({\n                zIndex: -paths[3] // #4774\n            });\n        } else if (args.opacity) {\n            this.front.animate(args, duration, complete);\n            this.top.animate(args, duration, complete);\n            this.side.animate(args, duration, complete);\n        } else {\n            SVGElement.prototype.animate.call(this, args, duration, complete);\n        }\n        return this;\n    };\n\n    // destroy all children\n    result.destroy = function () {\n        this.front.destroy();\n        this.top.destroy();\n        this.side.destroy();\n\n        return destroy.call(this);\n    };\n\n    // Apply the Z index to the cuboid group\n    result.attr({ zIndex: -paths[3] });\n\n    return result;\n};\n\n/**\n *    Generates a cuboid\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer.prototype.cuboidPath = function (shapeArgs) {\n    var x = shapeArgs.x,\n        y = shapeArgs.y,\n        z = shapeArgs.z,\n        h = shapeArgs.height,\n        w = shapeArgs.width,\n        d = shapeArgs.depth,\n        chart = charts[this.chartIndex],\n        front,\n        back,\n        top,\n        bottom,\n        left,\n        right,\n        shape,\n        path1,\n        path2,\n        path3,\n        isFront,\n        isTop,\n        isRight,\n        options3d = chart.options.chart.options3d,\n        alpha = options3d.alpha,\n        // Priority for x axis is the biggest,\n        // because of x direction has biggest influence on zIndex\n        incrementX = 10000,\n        // y axis has the smallest priority in case of our charts\n        // (needs to be set because of stacking)\n        incrementY = 10,\n        incrementZ = 100,\n        zIndex = 0;\n\n    // The 8 corners of the cube\n    var pArr = [{\n        x: x,\n        y: y,\n        z: z\n    }, {\n        x: x + w,\n        y: y,\n        z: z\n    }, {\n        x: x + w,\n        y: y + h,\n        z: z\n    }, {\n        x: x,\n        y: y + h,\n        z: z\n    }, {\n        x: x,\n        y: y + h,\n        z: z + d\n    }, {\n        x: x + w,\n        y: y + h,\n        z: z + d\n    }, {\n        x: x + w,\n        y: y,\n        z: z + d\n    }, {\n        x: x,\n        y: y,\n        z: z + d\n    }];\n\n    // apply perspective\n    pArr = perspective(pArr, chart, shapeArgs.insidePlotArea);\n\n    // helper method to decide which side is visible\n    function mapPath(i) {\n        return pArr[i];\n    }\n\n    /*\n     * First value - path with specific side\n     * Second  value - added information about side for later calculations.\n     * Possible second values are 0 for path1, 1 for path2 and -1 for no path\n     * chosen.\n     */\n    var pickShape = function (path1, path2) {\n        var ret = [\n                [], -1\n        ];\n        path1 = map(path1, mapPath);\n        path2 = map(path2, mapPath);\n        if (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea(path1) < 0) {\n            ret = [path1, 0];\n        } else if (_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shapeArea(path2) < 0) {\n            ret = [path2, 1];\n        }\n        return ret;\n    };\n\n    // front or back\n    front = [3, 2, 1, 0];\n    back = [7, 6, 5, 4];\n    shape = pickShape(front, back);\n    path1 = shape[0];\n    isFront = shape[1];\n\n\n    // top or bottom\n    top = [1, 6, 7, 0];\n    bottom = [4, 5, 2, 3];\n    shape = pickShape(top, bottom);\n    path2 = shape[0];\n    isTop = shape[1];\n\n    // side\n    right = [1, 2, 5, 6];\n    left = [0, 7, 4, 3];\n    shape = pickShape(right, left);\n    path3 = shape[0];\n    isRight = shape[1];\n\n    /*\n     * New block used for calculating zIndex. It is basing on X, Y and Z\n     * position of specific columns. All zIndexes (for X, Y and Z values) are\n     * added to the final zIndex, where every value has different priority. The\n     * biggest priority is in X and Z directions, the lowest index is for\n     * stacked columns (Y direction and the same X and Z positions). Big\n     * differences between priorities is made because we need to ensure that\n     * even for big changes in Y and Z parameters all columns will be drawn\n     * correctly.\n     */\n\n    if (isRight === 1) {\n        zIndex += incrementX * (1000 - x);\n    } else if (!isRight) {\n        zIndex += incrementX * x;\n    }\n\n    zIndex += incrementY * (\n        !isTop ||\n        // Numbers checked empirically\n        (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ?\n            chart.plotHeight - y : 10 + y\n    );\n\n    if (isFront === 1) {\n        zIndex += incrementZ * (z);\n    } else if (!isFront) {\n        zIndex += incrementZ * (1000 - z);\n    }\n\n    zIndex = -Math.round(zIndex);\n\n    return [\n        this.toLinePath(path1, true),\n        this.toLinePath(path2, true),\n        this.toLinePath(path3, true),\n        zIndex\n    ]; // #4774\n};\n\n// SECTORS //\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer.prototype.arc3d = function (attribs) {\n\n    var wrapper = this.g(),\n        renderer = wrapper.renderer,\n        customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end'];\n\n    /**\n     * Get custom attributes. Don't mutate the original object and return an\n     * object with only custom attr.\n     */\n    function suckOutCustom(params) {\n        var hasCA = false,\n            ca = {};\n\n        params = merge(params); // Don't mutate the original object\n\n        for (var key in params) {\n            if (inArray(key, customAttribs) !== -1) {\n                ca[key] = params[key];\n                delete params[key];\n                hasCA = true;\n            }\n        }\n        return hasCA ? ca : false;\n    }\n\n    attribs = merge(attribs);\n\n    attribs.alpha = (attribs.alpha || 0) * deg2rad;\n    attribs.beta = (attribs.beta || 0) * deg2rad;\n\n    // Create the different sub sections of the shape\n    wrapper.top = renderer.path();\n    wrapper.side1 = renderer.path();\n    wrapper.side2 = renderer.path();\n    wrapper.inn = renderer.path();\n    wrapper.out = renderer.path();\n\n    /**\n     * Add all faces\n     */\n    wrapper.onAdd = function () {\n        var parent = wrapper.parentGroup,\n            className = wrapper.attr('class');\n        wrapper.top.add(wrapper);\n\n        // These faces are added outside the wrapper group because the z index\n        // relates to neighbour elements as well\n        each(['out', 'inn', 'side1', 'side2'], function (face) {\n            wrapper[face]\n                .attr({\n                    'class': className + ' highcharts-3d-side'\n                })\n                .add(parent);\n        });\n    };\n\n    // Cascade to faces\n    each(['addClass', 'removeClass'], function (fn) {\n        wrapper[fn] = function () {\n            var args = arguments;\n            each(['top', 'out', 'inn', 'side1', 'side2'], function (face) {\n                wrapper[face][fn].apply(wrapper[face], args);\n            });\n        };\n    });\n\n    /**\n     * Compute the transformed paths and set them to the composite shapes\n     */\n    wrapper.setPaths = function (attribs) {\n\n        var paths = wrapper.renderer.arc3dPath(attribs),\n            zIndex = paths.zTop * 100;\n\n        wrapper.attribs = attribs;\n\n        wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });\n        wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });\n        wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });\n        wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });\n        wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });\n\n\n        // show all children\n        wrapper.zIndex = zIndex;\n        wrapper.attr({ zIndex: zIndex });\n\n        // Set the radial gradient center the first time\n        if (attribs.center) {\n            wrapper.top.setRadialReference(attribs.center);\n            delete attribs.center;\n        }\n    };\n    wrapper.setPaths(attribs);\n\n    // Apply the fill to the top and a darker shade to the sides\n    wrapper.fillSetter = function (value) {\n        var darker = color(value).brighten(-0.1).get();\n\n        this.fill = value;\n\n        this.side1.attr({ fill: darker });\n        this.side2.attr({ fill: darker });\n        this.inn.attr({ fill: darker });\n        this.out.attr({ fill: darker });\n        this.top.attr({ fill: value });\n        return this;\n    };\n\n    // Apply the same value to all. These properties cascade down to the\n    // children when set to the composite arc3d.\n    each(\n        ['opacity', 'translateX', 'translateY', 'visibility'],\n        function (setter) {\n            wrapper[setter + 'Setter'] = function (value, key) {\n                wrapper[key] = value;\n                each(['out', 'inn', 'side1', 'side2', 'top'], function (el) {\n                    wrapper[el].attr(key, value);\n                });\n            };\n        }\n    );\n\n    /**\n     * Override attr to remove shape attributes and use those to set child paths\n     */\n    wrap(wrapper, 'attr', function (proceed, params) {\n        var ca;\n        if (typeof params === 'object') {\n            ca = suckOutCustom(params);\n            if (ca) {\n                extend(wrapper.attribs, ca);\n                wrapper.setPaths(wrapper.attribs);\n            }\n        }\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    });\n\n    /**\n     * Override the animate function by sucking out custom parameters related to\n     * the shapes directly, and update the shapes from the animation step.\n     */\n    wrap(wrapper, 'animate', function (proceed, params, animation, complete) {\n        var ca,\n            from = this.attribs,\n            to,\n            anim,\n            randomProp = 'data-' + Math.random().toString(26).substring(2, 9);\n\n        // Attribute-line properties connected to 3D. These shouldn't have been\n        // in the attribs collection in the first place.\n        delete params.center;\n        delete params.z;\n        delete params.depth;\n        delete params.alpha;\n        delete params.beta;\n\n        anim = animObject(pick(animation, this.renderer.globalAnimation));\n\n        if (anim.duration) {\n            ca = suckOutCustom(params);\n            // Params need to have a property in order for the step to run\n            // (#5765, #7097, #7437)\n            wrapper[randomProp] = 0;\n            params[randomProp] = 1;\n            wrapper[randomProp + 'Setter'] = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop;\n\n            if (ca) {\n                to = ca;\n                anim.step = function (a, fx) {\n                    function interpolate(key) {\n                        return from[key] +\n                            (pick(to[key], from[key]) - from[key]) * fx.pos;\n                    }\n\n                    if (fx.prop === randomProp) {\n                        fx.elem.setPaths(merge(from, {\n                            x: interpolate('x'),\n                            y: interpolate('y'),\n                            r: interpolate('r'),\n                            innerR: interpolate('innerR'),\n                            start: interpolate('start'),\n                            end: interpolate('end')\n                        }));\n                    }\n                };\n            }\n            animation = anim; // Only when duration (#5572)\n        }\n        return proceed.call(this, params, animation, complete);\n    });\n\n    // destroy all children\n    wrapper.destroy = function () {\n        this.top.destroy();\n        this.out.destroy();\n        this.inn.destroy();\n        this.side1.destroy();\n        this.side2.destroy();\n\n        SVGElement.prototype.destroy.call(this);\n    };\n    // hide all children\n    wrapper.hide = function () {\n        this.top.hide();\n        this.out.hide();\n        this.inn.hide();\n        this.side1.hide();\n        this.side2.hide();\n    };\n    wrapper.show = function () {\n        this.top.show();\n        this.out.show();\n        this.inn.show();\n        this.side1.show();\n        this.side2.show();\n    };\n    return wrapper;\n};\n\n/**\n * Generate the paths required to draw a 3D arc\n */\nSVGRenderer.prototype.arc3dPath = function (shapeArgs) {\n    var cx = shapeArgs.x, // x coordinate of the center\n        cy = shapeArgs.y, // y coordinate of the center\n        start = shapeArgs.start, // start angle\n        end = shapeArgs.end - 0.00001, // end angle\n        r = shapeArgs.r, // radius\n        ir = shapeArgs.innerR || 0, // inner radius\n        d = shapeArgs.depth || 0, // depth\n        alpha = shapeArgs.alpha, // alpha rotation of the chart\n        beta = shapeArgs.beta; // beta rotation of the chart\n\n    // Derived Variables\n    var cs = Math.cos(start),        // cosinus of the start angle\n        ss = Math.sin(start),        // sinus of the start angle\n        ce = Math.cos(end),            // cosinus of the end angle\n        se = Math.sin(end),            // sinus of the end angle\n        rx = r * Math.cos(beta),        // x-radius\n        ry = r * Math.cos(alpha),    // y-radius\n        irx = ir * Math.cos(beta),    // x-radius (inner)\n        iry = ir * Math.cos(alpha),    // y-radius (inner)\n        dx = d * Math.sin(beta),        // distance between top and bottom in x\n        dy = d * Math.sin(alpha);    // distance between top and bottom in y\n\n    // TOP\n    var top = ['M', cx + (rx * cs), cy + (ry * ss)];\n    top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));\n    top = top.concat([\n        'L', cx + (irx * ce), cy + (iry * se)\n    ]);\n    top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));\n    top = top.concat(['Z']);\n\n    // OUTSIDE\n    var b = (beta > 0 ? Math.PI / 2 : 0),\n        a = (alpha > 0 ? 0 : Math.PI / 2);\n\n    var start2 = start > -b ? start : (end > -b ? -b : start),\n        end2 = end < PI - a ? end : (start < PI - a ? PI - a : end),\n        midEnd = 2 * PI - a;\n\n    // When slice goes over bottom middle, need to add both, left and right\n    // outer side. Additionally, when we cross right hand edge, create sharp\n    // edge. Outer shape/wall:\n    //\n    //            -------\n    //          /    ^    \\\n    //    4)   /   /   \\   \\  1)\n    //        /   /     \\   \\\n    //       /   /       \\   \\\n    // (c)=> ====         ==== <=(d)\n    //       \\   \\       /   /\n    //        \\   \\<=(a)/   /\n    //         \\   \\   /   / <=(b)\n    //    3)    \\    v    /  2)\n    //            -------\n    //\n    // (a) - inner side\n    // (b) - outer side\n    // (c) - left edge (sharp)\n    // (d) - right edge (sharp)\n    // 1..n - rendering order for startAngle = 0, when set to e.g 90, order\n    // changes clockwise (1->2, 2->3, n->1) and counterclockwise for negative\n    // startAngle\n\n    var out = ['M', cx + (rx * cos(start2)), cy + (ry * sin(start2))];\n    out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0));\n\n    // When shape is wide, it can cross both, (c) and (d) edges, when using\n    // startAngle\n    if (end > midEnd && start < midEnd) {\n        // Go to outer side\n        out = out.concat([\n            'L', cx + (rx * cos(end2)) + dx, cy + (ry * sin(end2)) + dy\n        ]);\n        // Curve to the right edge of the slice (d)\n        out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));\n        // Go to the inner side\n        out = out.concat([\n            'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n        ]);\n        // Curve to the true end of the slice\n        out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));\n        // Go to the outer side\n        out = out.concat([\n            'L', cx + (rx * cos(end)) + dx, cy + (ry * sin(end)) + dy\n        ]);\n        // Go back to middle (d)\n        out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));\n        out = out.concat([\n            'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n        ]);\n        // Go back to the left edge\n        out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));\n\n    // But shape can cross also only (c) edge:\n    } else if (end > PI - a && start < PI - a) {\n        // Go to outer side\n        out = out.concat([\n            'L',\n            cx + (rx * Math.cos(end2)) + dx,\n            cy + (ry * Math.sin(end2)) + dy\n        ]);\n        // Curve to the true end of the slice\n        out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy));\n        // Go to the inner side\n        out = out.concat([\n            'L', cx + (rx * Math.cos(end)), cy + (ry * Math.sin(end))\n        ]);\n        // Go back to the artifical end2\n        out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0));\n    }\n\n    out = out.concat([\n        'L', cx + (rx * Math.cos(end2)) + dx, cy + (ry * Math.sin(end2)) + dy\n    ]);\n    out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));\n    out = out.concat(['Z']);\n\n    // INSIDE\n    var inn = ['M', cx + (irx * cs), cy + (iry * ss)];\n    inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));\n    inn = inn.concat([\n        'L', cx + (irx * Math.cos(end)) + dx, cy + (iry * Math.sin(end)) + dy\n    ]);\n    inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));\n    inn = inn.concat(['Z']);\n\n    // SIDES\n    var side1 = [\n        'M', cx + (rx * cs), cy + (ry * ss),\n        'L', cx + (rx * cs) + dx, cy + (ry * ss) + dy,\n        'L', cx + (irx * cs) + dx, cy + (iry * ss) + dy,\n        'L', cx + (irx * cs), cy + (iry * ss),\n        'Z'\n    ];\n    var side2 = [\n        'M', cx + (rx * ce), cy + (ry * se),\n        'L', cx + (rx * ce) + dx, cy + (ry * se) + dy,\n        'L', cx + (irx * ce) + dx, cy + (iry * se) + dy,\n        'L', cx + (irx * ce), cy + (iry * se),\n        'Z'\n    ];\n\n    // correction for changed position of vanishing point caused by alpha and\n    // beta rotations\n    var angleCorr = Math.atan2(dy, -dx),\n        angleEnd = Math.abs(end + angleCorr),\n        angleStart = Math.abs(start + angleCorr),\n        angleMid = Math.abs((start + end) / 2 + angleCorr);\n\n    // set to 0-PI range\n    function toZeroPIRange(angle) {\n        angle = angle % (2 * Math.PI);\n        if (angle > Math.PI) {\n            angle = 2 * Math.PI - angle;\n        }\n        return angle;\n    }\n    angleEnd = toZeroPIRange(angleEnd);\n    angleStart = toZeroPIRange(angleStart);\n    angleMid = toZeroPIRange(angleMid);\n\n    // *1e5 is to compensate pInt in zIndexSetter\n    var incPrecision = 1e5,\n        a1 = angleMid * incPrecision,\n        a2 = angleStart * incPrecision,\n        a3 = angleEnd * incPrecision;\n\n    return {\n        top: top,\n        // max angle is PI, so this is always higher\n        zTop: Math.PI * incPrecision + 1,\n        out: out,\n        zOut: Math.max(a1, a2, a3),\n        inn: inn,\n        zInn: Math.max(a1, a2, a3),\n        side1: side1,\n        zSide1: a3 * 0.99, // to keep below zOut and zInn in case of same values\n        side2: side2,\n        zSide2: a2 * 0.99\n    };\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/SVGRenderer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Scatter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Scatter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * Scatter 3D series.\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar Point = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * A 3D scatter plot uses x, y and z coordinates to display values for three\n * variables for a set of data.\n *\n * @sample {highcharts} highcharts/3d/scatter/\n *         Simple 3D scatter\n * @sample {highcharts} highcharts/demo/3d-scatter-draggable\n *         Draggable 3d scatter\n *\n * @extends plotOptions.scatter\n * @product highcharts\n * @optionparent plotOptions.scatter3d\n */\nseriesType('scatter3d', 'scatter', {\n    tooltip: {\n        pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>'\n    }\n\n// Series class\n}, {\n    pointAttribs: function (point) {\n        var attribs = seriesTypes.scatter.prototype.pointAttribs\n            .apply(this, arguments);\n\n        if (this.chart.is3d() && point) {\n            attribs.zIndex = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointCameraDistance(point, this.chart);\n        }\n\n        return attribs;\n    },\n    axisTypes: ['xAxis', 'yAxis', 'zAxis'],\n    pointArrayMap: ['x', 'y', 'z'],\n    parallelArrays: ['x', 'y', 'z'],\n\n    // Require direct touch rather than using the k-d-tree, because the k-d-tree\n    // currently doesn't take the xyz coordinate system into account (#4552)\n    directTouch: true\n\n// Point class\n}, {\n    applyOptions: function () {\n        Point.prototype.applyOptions.apply(this, arguments);\n        if (this.z === undefined) {\n            this.z = 0;\n        }\n\n        return this;\n    }\n\n});\n\n\n/**\n * A `scatter3d` series. If the [type](#series.scatter3d.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * scatter3d](#plotOptions.scatter3d).\n *\n * @type {Object}\n * @extends series,plotOptions.scatter3d\n * @product highcharts\n * @apioption series.scatter3d\n */\n\n/**\n * An array of data points for the series. For the `scatter3d` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 values. In this case, the values correspond\n * to `x,y,z`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 0, 1],\n *         [1, 8, 7],\n *         [2, 9, 2]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series'\n * [turboThreshold](#series.scatter3d.turboThreshold), this option is not\n * available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 2,\n *         z: 24,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 4,\n *         z: 12,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Array>}\n * @extends series.scatter.data\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts\n * @apioption series.scatter3d.data\n */\n\n/**\n * The z value for each data point.\n *\n * @type {Number}\n * @product highcharts\n * @apioption series.scatter3d.data.z\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Scatter.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/Series.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/Series.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * Extension to the Series object in 3D charts.\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    perspective = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].perspective,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n\n// Wrap the translate method to post-translate points into 3D perspective\naddEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series, 'afterTranslate', function () {\n    if (this.chart.is3d()) {\n        this.translate3dPoints();\n    }\n});\n\n/**\n * Translate the plotX, plotY properties and add plotZ.\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series.prototype.translate3dPoints = function () {\n    var series = this,\n        chart = series.chart,\n        zAxis = pick(series.zAxis, chart.options.zAxis[0]),\n        rawPoints = [],\n        rawPoint,\n        projectedPoints,\n        projectedPoint,\n        zValue,\n        i;\n\n    for (i = 0; i < series.data.length; i++) {\n        rawPoint = series.data[i];\n\n        if (zAxis && zAxis.translate) {\n            zValue = zAxis.isLog && zAxis.val2lin ?\n                zAxis.val2lin(rawPoint.z) :\n                rawPoint.z; // #4562\n            rawPoint.plotZ = zAxis.translate(zValue);\n            rawPoint.isInside = rawPoint.isInside ?\n                (zValue >= zAxis.min && zValue <= zAxis.max) :\n                false;\n        } else {\n            rawPoint.plotZ = 0;\n        }\n\n        rawPoint.axisXpos = rawPoint.plotX;\n        rawPoint.axisYpos = rawPoint.plotY;\n        rawPoint.axisZpos = rawPoint.plotZ;\n\n        rawPoints.push({\n            x: rawPoint.plotX,\n            y: rawPoint.plotY,\n            z: rawPoint.plotZ\n        });\n    }\n\n    projectedPoints = perspective(rawPoints, chart, true);\n\n    for (i = 0; i < series.data.length; i++) {\n        rawPoint = series.data[i];\n        projectedPoint = projectedPoints[i];\n\n        rawPoint.plotX = projectedPoint.x;\n        rawPoint.plotY = projectedPoint.y;\n        rawPoint.plotZ = projectedPoint.z;\n    }\n};\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/Series.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-3d/VMLRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-3d/VMLRenderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_SvgRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-3d/VMLRenderer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-map/ColorAxis.js":
/*!**********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-map/ColorAxis.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _parts_Color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _parts_Legend_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    ColorAxis,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    Legend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend,\n    LegendSymbolMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n\n// If ColorAxis already exists, we may be loading the heatmap module on top of\n// Highmaps.\nif (!_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ColorAxis) {\n\n    /**\n     * The ColorAxis object for inclusion in gradient legends\n     */\n    ColorAxis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ColorAxis = function () {\n        this.init.apply(this, arguments);\n    };\n    extend(ColorAxis.prototype, Axis.prototype);\n    extend(ColorAxis.prototype, {\n        /**\n         * A color axis for choropleth maps and heat maps. Visually, the color\n         * axis will appear as a gradient or as separate items inside the\n         * legend, depending on whether the axis is scalar or based on data\n         * classes.\n         *\n         * For supported color formats, see the\n         * [docs article about colors](https://www.highcharts.com/docs/chart-design-and-style/colors).\n         *\n         * A scalar color axis is represented by a gradient. The colors either\n         * range between the [minColor](#colorAxis.minColor) and the\n         * [maxColor](#colorAxis.maxColor), or for more fine grained control the\n         * colors can be defined in [stops](#colorAxis.stops). Often times, the\n         * color axis needs to be adjusted to get the right color spread for the\n         * data. In addition to stops, consider using a logarithmic\n         * [axis type](#colorAxis.type), or setting [min](#colorAxis.min) and\n         * [max](#colorAxis.max) to avoid the colors being determined by\n         * outliers.\n         *\n         * When [dataClasses](#colorAxis.dataClasses) are used, the ranges are\n         * subdivided into separate classes like categories based on their\n         * values. This can be used for ranges between two values, but also for\n         * a true category. However, when your data is categorized, it may be as\n         * convenient to add each category to a separate series.\n         *\n         * See [the Axis object](/class-reference/Highcharts.Axis) for\n         * programmatic access to the axis.\n         *\n         * @extends xAxis\n         * @excluding allowDecimals,alternateGridColor,breaks,categories,\n         *            crosshair,dateTimeLabelFormats,lineWidth,linkedTo,maxZoom,\n         *            minRange,minTickInterval,offset,opposite,plotBands,\n         *            plotLines,showEmpty,title\n         * @product highcharts highmaps\n         * @optionparent colorAxis\n         */\n        defaultColorAxisOptions: {\n\n            /**\n             * Whether to allow decimals on the color axis.\n             * @type {Boolean}\n             * @default true\n             * @product highcharts highmaps\n             * @apioption colorAxis.allowDecimals\n             */\n\n            /**\n             * Determines how to set each data class' color if no individual\n             * color is set. The default value, `tween`, computes intermediate\n             * colors between `minColor` and `maxColor`. The other possible\n             * value, `category`, pulls colors from the global or chart specific\n             * [colors](#colors) array.\n             *\n             * @validvalue [\"tween\", \"category\"]\n             * @type {String}\n             * @sample {highmaps} maps/coloraxis/dataclasscolor/ Category colors\n             * @default tween\n             * @product highcharts highmaps\n             * @apioption colorAxis.dataClassColor\n             */\n\n            /**\n             * An array of data classes or ranges for the choropleth map. If\n             * none given, the color axis is scalar and values are distributed\n             * as a gradient between the minimum and maximum colors.\n             *\n             * @type {Array<Object>}\n             * @sample {highmaps} maps/demo/data-class-ranges/ Multiple ranges\n             * @sample {highmaps} maps/demo/data-class-two-ranges/ Two ranges\n             * @product highcharts highmaps\n             * @apioption colorAxis.dataClasses\n             */\n\n            /**\n             * The color of each data class. If not set, the color is pulled\n             * from the global or chart-specific [colors](#colors) array. In\n             * styled mode, this option is ignored. Instead, use colors defined\n             * in CSS.\n             *\n             * @type {Color}\n             * @sample {highmaps} maps/demo/data-class-two-ranges/\n             *         Explicit colors\n             * @product highcharts highmaps\n             * @apioption colorAxis.dataClasses.color\n             */\n\n            /**\n             * The start of the value range that the data class represents,\n             * relating to the point value.\n             *\n             * The range of each `dataClass` is closed in both ends, but can be\n             * overridden by the next `dataClass`.\n             *\n             * @type      {Number}\n             * @product   highcharts highmaps\n             * @apioption colorAxis.dataClasses.from\n             */\n\n            /**\n             * The name of the data class as it appears in the legend.\n             * If no name is given, it is automatically created based on the\n             * `from` and `to` values. For full programmatic control,\n             * [legend.labelFormatter](#legend.labelFormatter) can be used.\n             * In the formatter, `this.from` and `this.to` can be accessed.\n             *\n             * @type      {String}\n             * @sample    {highmaps} maps/coloraxis/dataclasses-name/\n             *            Named data classes\n             * @sample    {highmaps} maps/coloraxis/dataclasses-labelformatter/\n             *            Formatted data classes\n             * @product   highcharts highmaps\n             * @apioption colorAxis.dataClasses.name\n             */\n\n            /**\n             * The end of the value range that the data class represents,\n             * relating to the point value.\n             *\n             * The range of each `dataClass` is closed in both ends, but can be\n             * overridden by the next `dataClass`.\n             *\n             * @type      {Number}\n             * @product   highcharts highmaps\n             * @apioption colorAxis.dataClasses.to\n             */\n\n            /**\n              * @ignore-option\n              */\n            lineWidth: 0,\n\n            /**\n             * Padding of the min value relative to the length of the axis. A\n             * padding of 0.05 will make a 100px axis 5px longer.\n             *\n             * @type {Number}\n             * @product highcharts highmaps\n             */\n            minPadding: 0,\n\n            /**\n             * The maximum value of the axis in terms of map point values. If\n             * `null`, the max value is automatically calculated. If the\n             * `endOnTick` option is true, the max value might be rounded up.\n             *\n             * @type {Number}\n             * @sample {highmaps} maps/coloraxis/gridlines/\n             *         Explicit min and max to reduce the effect of outliers\n             * @product highcharts highmaps\n             * @apioption colorAxis.max\n             */\n\n            /**\n             * The minimum value of the axis in terms of map point values. If\n             * `null`, the min value is automatically calculated. If the\n             * `startOnTick` option is true, the min value might be rounded\n             * down.\n             *\n             * @type {Number}\n             * @sample {highmaps} maps/coloraxis/gridlines/\n             *         Explicit min and max to reduce the effect of outliers\n             * @product highcharts highmaps\n             * @apioption colorAxis.min\n             */\n\n            /**\n             * Padding of the max value relative to the length of the axis. A\n             * padding of 0.05 will make a 100px axis 5px longer.\n             *\n             * @type {Number}\n             * @product highcharts highmaps\n             */\n            maxPadding: 0,\n\n            /**\n             * Color of the grid lines extending from the axis across the\n             * gradient.\n             *\n             * @type {Color}\n             * @sample {highmaps} maps/coloraxis/gridlines/\n             *         Grid lines demonstrated\n             * @default #e6e6e6\n             * @product highcharts highmaps\n             * @apioption colorAxis.gridLineColor\n             */\n\n            /**\n             * The width of the grid lines extending from the axis across the\n             * gradient of a scalar color axis.\n             *\n             * @type {Number}\n             * @sample {highmaps} maps/coloraxis/gridlines/\n             *         Grid lines demonstrated\n             * @default 1\n             * @product highcharts highmaps\n             */\n            gridLineWidth: 1,\n\n            /**\n             * The interval of the tick marks in axis units. When `null`, the\n             * tick interval is computed to approximately follow the\n             * `tickPixelInterval`.\n             *\n             * @type {Number}\n             * @product highcharts highmaps\n             * @apioption colorAxis.tickInterval\n             */\n\n            /**\n             * If [tickInterval](#colorAxis.tickInterval) is `null` this option\n             * sets the approximate pixel interval of the tick marks.\n             *\n             * @type {Number}\n             * @default 72\n             * @product highcharts highmaps\n             */\n            tickPixelInterval: 72,\n\n            /**\n             * Whether to force the axis to start on a tick. Use this option\n             * with the `maxPadding` option to control the axis start.\n             *\n             * @type {Boolean}\n             * @default true\n             * @product highcharts highmaps\n             */\n            startOnTick: true,\n\n            /**\n             * Whether to force the axis to end on a tick. Use this option with\n             * the [maxPadding](#colorAxis.maxPadding) option to control the\n             * axis end.\n             *\n             * @type {Boolean}\n             * @default true\n             * @product highcharts highmaps\n             */\n            endOnTick: true,\n\n            /**    @ignore */\n            offset: 0,\n\n            /**\n             * The triangular marker on a scalar color axis that points to the\n             * value of the hovered area. To disable the marker, set\n             * `marker: null`.\n             *\n             * @type {Object}\n             * @sample {highmaps} maps/coloraxis/marker/ Black marker\n             * @product highcharts highmaps\n             */\n            marker: {\n\n                /**\n                 * Animation for the marker as it moves between values. Set to\n                 * `false` to disable animation. Defaults to `{ duration: 50 }`.\n                 *\n                 * @type {AnimationOptions|Boolean}\n                 * @product highcharts highmaps\n                 */\n                animation: {\n                    duration: 50\n                },\n\n                /**\n                 * @ignore\n                 */\n                width: 0.01\n                \n            },\n\n            /**\n             * The axis labels show the number for each tick.\n             *\n             * For more live examples on label options, see [xAxis.labels in the\n             * Highcharts API.](/highcharts#xAxis.labels)\n             *\n             * @type {Object}\n             * @extends xAxis.labels\n             * @product highcharts highmaps\n             */\n            labels: {\n\n                /**\n                 * How to handle overflowing labels on horizontal color axis.\n                 * Can be undefined or \"justify\". If \"justify\", labels will not\n                 * render outside the legend area. If there is room to move it,\n                 * it will be aligned to the edge, else it will be removed.\n                 *\n                 * @validvalue [null, \"justify\"]\n                 * @type {String}\n                 * @default justify\n                 * @product highcharts highmaps\n                 */\n                overflow: 'justify',\n\n                rotation: 0\n            },\n\n            /**\n             * The color to represent the minimum of the color axis. Unless\n             * [dataClasses](#colorAxis.dataClasses) or\n             * [stops](#colorAxis.stops) are set, the gradient starts at this\n             * value.\n             *\n             * If dataClasses are set, the color is based on minColor and\n             * maxColor unless a color is set for each data class, or the\n             * [dataClassColor](#colorAxis.dataClassColor) is set.\n             *\n             * @type {Color}\n             * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/\n             *         Min and max colors on scalar (gradient) axis\n             * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/\n             *         On data classes\n             * @default #e6ebf5\n             * @product highcharts highmaps\n             */\n            minColor: '#e6ebf5',\n\n            /**\n             * The color to represent the maximum of the color axis. Unless\n             * [dataClasses](#colorAxis.dataClasses) or\n             * [stops](#colorAxis.stops) are set, the gradient ends at this\n             * value.\n             *\n             * If dataClasses are set, the color is based on minColor and\n             * maxColor unless a color is set for each data class, or the\n             * [dataClassColor](#colorAxis.dataClassColor) is set.\n             *\n             * @type {Color}\n             * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/\n             *         Min and max colors on scalar (gradient) axis\n             * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/\n             *         On data classes\n             * @default #003399\n             * @product highcharts highmaps\n             */\n            maxColor: '#003399',\n\n            /**\n             * Color stops for the gradient of a scalar color axis. Use this in\n             * cases where a linear gradient between a `minColor` and `maxColor`\n             * is not sufficient. The stops is an array of tuples, where the\n             * first item is a float between 0 and 1 assigning the relative\n             * position in the gradient, and the second item is the color.\n             *\n             * @type {Array<Array>}\n             * @sample {highmaps} maps/demo/heatmap/\n             *         Heatmap with three color stops\n             * @product highcharts highmaps\n             * @apioption colorAxis.stops\n             */\n\n            /**\n             * The pixel length of the main tick marks on the color axis.\n             */\n            tickLength: 5,\n\n            /**\n             * The type of interpolation to use for the color axis. Can be\n             * `linear` or `logarithmic`.\n             *\n             * @validvalue [\"linear\", \"logarithmic\"]\n             * @type {String}\n             * @default linear\n             * @product highcharts highmaps\n             * @apioption colorAxis.type\n             */\n\n            /**\n             * Whether to reverse the axis so that the highest number is closest\n             * to the origin. Defaults to `false` in a horizontal legend and\n             * `true` in a vertical legend, where the smallest value starts on\n             * top.\n             *\n             * @type {Boolean}\n             * @product highcharts highmaps\n             * @apioption colorAxis.reversed\n             */\n\n            /**\n             * Fires when the legend item belonging to the colorAxis is clicked.\n             * One parameter, `event`, is passed to the function.\n             *\n             * @type      {Function}\n             * @product   highcharts highmaps\n             * @apioption colorAxis.events.legendItemClick\n             */\n\n            /**\n             * Whether to display the colorAxis in the legend.\n             *\n             * @type {Boolean}\n             * @see [heatmap.showInLegend](#series.heatmap.showInLegend)\n             * @default true\n             * @since 4.2.7\n             * @product highcharts highmaps\n             */\n            showInLegend: true\n        },\n\n        // Properties to preserve after destroy, for Axis.update (#5881, #6025)\n        keepProps: [\n            'legendGroup',\n            'legendItemHeight',\n            'legendItemWidth',\n            'legendItem',\n            'legendSymbol'\n        ].concat(Axis.prototype.keepProps),\n\n        /**\n         * Initialize the color axis\n         */\n        init: function (chart, userOptions) {\n            var horiz = chart.options.legend.layout !== 'vertical',\n                options;\n\n            this.coll = 'colorAxis';\n\n            // Build the options\n            options = merge(this.defaultColorAxisOptions, {\n                side: horiz ? 2 : 1,\n                reversed: !horiz\n            }, userOptions, {\n                opposite: !horiz,\n                showEmpty: false,\n                title: null,\n                visible: chart.options.legend.enabled\n            });\n\n            Axis.prototype.init.call(this, chart, options);\n\n            // Base init() pushes it to the xAxis array, now pop it again\n            // chart[this.isXAxis ? 'xAxis' : 'yAxis'].pop();\n\n            // Prepare data classes\n            if (userOptions.dataClasses) {\n                this.initDataClasses(userOptions);\n            }\n            this.initStops();\n\n            // Override original axis properties\n            this.horiz = horiz;\n            this.zoomEnabled = false;\n\n            // Add default values\n            this.defaultLegendLength = 200;\n        },\n\n        initDataClasses: function (userOptions) {\n            var chart = this.chart,\n                dataClasses,\n                colorCounter = 0,\n                colorCount = chart.options.chart.colorCount,\n                options = this.options,\n                len = userOptions.dataClasses.length;\n            this.dataClasses = dataClasses = [];\n            this.legendItems = [];\n\n            each(userOptions.dataClasses, function (dataClass, i) {\n                var colors;\n\n                dataClass = merge(dataClass);\n                dataClasses.push(dataClass);\n\n                \n                if (options.dataClassColor === 'category') {\n                    \n                    dataClass.colorIndex = colorCounter;\n\n                    // increase and loop back to zero\n                    colorCounter++;\n                    if (colorCounter === colorCount) {\n                        colorCounter = 0;\n                    }\n                } else {\n                    dataClass.color = color(options.minColor).tweenTo(\n                        color(options.maxColor),\n                        len < 2 ? 0.5 : i / (len - 1) // #3219\n                    );\n                }\n            });\n        },\n\n        /**\n         * Override so that ticks are not added in data class axes (#6914)\n         */\n        setTickPositions: function () {\n            if (!this.dataClasses) {\n                return Axis.prototype.setTickPositions.call(this);\n            }\n        },\n\n\n        initStops: function () {\n            this.stops = this.options.stops || [\n                [0, this.options.minColor],\n                [1, this.options.maxColor]\n            ];\n            each(this.stops, function (stop) {\n                stop.color = color(stop[1]);\n            });\n        },\n\n        /**\n         * Extend the setOptions method to process extreme colors and color\n         * stops.\n         */\n        setOptions: function (userOptions) {\n            Axis.prototype.setOptions.call(this, userOptions);\n\n            this.options.crosshair = this.options.marker;\n        },\n\n        setAxisSize: function () {\n            var symbol = this.legendSymbol,\n                chart = this.chart,\n                legendOptions = chart.options.legend || {},\n                x,\n                y,\n                width,\n                height;\n\n            if (symbol) {\n                this.left = x = symbol.attr('x');\n                this.top = y = symbol.attr('y');\n                this.width = width = symbol.attr('width');\n                this.height = height = symbol.attr('height');\n                this.right = chart.chartWidth - x - width;\n                this.bottom = chart.chartHeight - y - height;\n\n                this.len = this.horiz ? width : height;\n                this.pos = this.horiz ? x : y;\n            } else {\n                // Fake length for disabled legend to avoid tick issues\n                // and such (#5205)\n                this.len = (\n                        this.horiz ?\n                            legendOptions.symbolWidth :\n                            legendOptions.symbolHeight\n                    ) || this.defaultLegendLength;\n            }\n        },\n\n        normalizedValue: function (value) {\n            if (this.isLog) {\n                value = this.val2lin(value);\n            }\n            return 1 - ((this.max - value) / ((this.max - this.min) || 1));\n        },\n\n        /**\n         * Translate from a value to a color\n         */\n        toColor: function (value, point) {\n            var pos,\n                stops = this.stops,\n                from,\n                to,\n                color,\n                dataClasses = this.dataClasses,\n                dataClass,\n                i;\n\n            if (dataClasses) {\n                i = dataClasses.length;\n                while (i--) {\n                    dataClass = dataClasses[i];\n                    from = dataClass.from;\n                    to = dataClass.to;\n                    if (\n                        (from === undefined || value >= from) &&\n                        (to === undefined || value <= to)\n                    ) {\n                        \n                        if (point) {\n                            point.dataClass = i;\n                            point.colorIndex = dataClass.colorIndex;\n                        }\n                        break;\n                    }\n                }\n\n            } else {\n\n                pos = this.normalizedValue(value);\n                i = stops.length;\n                while (i--) {\n                    if (pos > stops[i][0]) {\n                        break;\n                    }\n                }\n                from = stops[i] || stops[i + 1];\n                to = stops[i + 1] || from;\n\n                // The position within the gradient\n                pos = 1 - (to[0] - pos) / ((to[0] - from[0]) || 1);\n\n                color = from.color.tweenTo(\n                    to.color,\n                    pos\n                );\n            }\n            return color;\n        },\n\n        /**\n         * Override the getOffset method to add the whole axis groups inside\n         * the legend.\n         */\n        getOffset: function () {\n            var group = this.legendGroup,\n                sideOffset = this.chart.axisOffset[this.side];\n\n            if (group) {\n\n                // Hook for the getOffset method to add groups to this parent\n                // group\n                this.axisParent = group;\n\n                // Call the base\n                Axis.prototype.getOffset.call(this);\n\n                // First time only\n                if (!this.added) {\n\n                    this.added = true;\n\n                    this.labelLeft = 0;\n                    this.labelRight = this.width;\n                }\n                // Reset it to avoid color axis reserving space\n                this.chart.axisOffset[this.side] = sideOffset;\n            }\n        },\n\n        /**\n         * Create the color gradient\n         */\n        setLegendColor: function () {\n            var grad,\n                horiz = this.horiz,\n                reversed = this.reversed,\n                one = reversed ? 1 : 0,\n                zero = reversed ? 0 : 1;\n\n            grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one]; // #3190\n            this.legendColor = {\n                linearGradient: {\n                    x1: grad[0], y1: grad[1],\n                    x2: grad[2], y2: grad[3]\n                },\n                stops: this.stops\n            };\n        },\n\n        /**\n         * The color axis appears inside the legend and has its own legend\n         * symbol\n         */\n        drawLegendSymbol: function (legend, item) {\n            var padding = legend.padding,\n                legendOptions = legend.options,\n                horiz = this.horiz,\n                width = pick(\n                    legendOptions.symbolWidth,\n                    horiz ? this.defaultLegendLength : 12\n                ),\n                height = pick(\n                    legendOptions.symbolHeight,\n                    horiz ? 12 : this.defaultLegendLength\n                ),\n                labelPadding = pick(\n                    legendOptions.labelPadding,\n                    horiz ? 16 : 30\n                ),\n                itemDistance = pick(legendOptions.itemDistance, 10);\n\n            this.setLegendColor();\n\n            // Create the gradient\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - 11,\n                width,\n                height\n            ).attr({\n                zIndex: 1\n            }).add(item.legendGroup);\n\n            // Set how much space this legend item takes up\n            this.legendItemWidth = width + padding +\n                (horiz ? itemDistance : labelPadding);\n            this.legendItemHeight = height + padding +\n                (horiz ? labelPadding : 0);\n        },\n        /**\n         * Fool the legend\n         */\n        setState: function (state) {\n            each(this.series, function (series) {\n                series.setState(state);\n            });\n        },\n        visible: true,\n        setVisible: noop,\n        getSeriesExtremes: function () {\n            var series = this.series,\n                i = series.length;\n            this.dataMin = Infinity;\n            this.dataMax = -Infinity;\n            while (i--) {\n                series[i].getExtremes();\n                if (series[i].valueMin !== undefined) {\n                    this.dataMin = Math.min(this.dataMin, series[i].valueMin);\n                    this.dataMax = Math.max(this.dataMax, series[i].valueMax);\n                }\n            }\n        },\n        drawCrosshair: function (e, point) {\n            var plotX = point && point.plotX,\n                plotY = point && point.plotY,\n                crossPos,\n                axisPos = this.pos,\n                axisLen = this.len;\n\n            if (point) {\n                crossPos = this.toPixels(point[point.series.colorKey]);\n                if (crossPos < axisPos) {\n                    crossPos = axisPos - 2;\n                } else if (crossPos > axisPos + axisLen) {\n                    crossPos = axisPos + axisLen + 2;\n                }\n\n                point.plotX = crossPos;\n                point.plotY = this.len - crossPos;\n                Axis.prototype.drawCrosshair.call(this, e, point);\n                point.plotX = plotX;\n                point.plotY = plotY;\n\n                if (\n                    this.cross &&\n                    !this.cross.addedToColorAxis &&\n                    this.legendGroup\n                ) {\n                    this.cross\n                        .addClass('highcharts-coloraxis-marker')\n                        .add(this.legendGroup);\n\n                    this.cross.addedToColorAxis = true;\n\n                    \n\n                }\n            }\n        },\n        getPlotLinePath: function (a, b, c, d, pos) {\n            // crosshairs only\n            return isNumber(pos) ? // pos can be 0 (#3969)\n                (\n                    this.horiz ? [\n                        'M',\n                        pos - 4, this.top - 6,\n                        'L',\n                        pos + 4, this.top - 6,\n                        pos, this.top,\n                        'Z'\n                    ] : [\n                        'M',\n                        this.left, pos,\n                        'L',\n                        this.left - 6, pos + 6,\n                        this.left - 6, pos - 6,\n                        'Z'\n                    ]\n                ) :\n                Axis.prototype.getPlotLinePath.call(this, a, b, c, d);\n        },\n\n        update: function (newOptions, redraw) {\n            var chart = this.chart,\n                legend = chart.legend;\n\n            each(this.series, function (series) {\n                // Needed for Axis.update when choropleth colors change\n                series.isDirtyData = true;\n            });\n\n            // When updating data classes, destroy old items and make sure new\n            // ones are created (#3207)\n            if (newOptions.dataClasses && legend.allItems) {\n                each(legend.allItems, function (item) {\n                    if (item.isDataClass && item.legendGroup) {\n                        item.legendGroup.destroy();\n                    }\n                });\n                chart.isDirtyLegend = true;\n            }\n\n            // Keep the options structure updated for export. Unlike xAxis and\n            // yAxis, the colorAxis is not an array. (#3207)\n            chart.options[this.coll] = merge(this.userOptions, newOptions);\n\n            Axis.prototype.update.call(this, newOptions, redraw);\n            if (this.legendItem) {\n                this.setLegendColor();\n                legend.colorizeItem(this, true);\n            }\n        },\n\n        /**\n         * Extend basic axis remove by also removing the legend item.\n         */\n        remove: function () {\n            if (this.legendItem) {\n                this.chart.legend.destroyItem(this);\n            }\n            Axis.prototype.remove.call(this);\n        },\n\n        /**\n         * Get the legend item symbols for data classes\n         */\n        getDataClassLegendSymbols: function () {\n            var axis = this,\n                chart = this.chart,\n                legendItems = this.legendItems,\n                legendOptions = chart.options.legend,\n                valueDecimals = legendOptions.valueDecimals,\n                valueSuffix = legendOptions.valueSuffix || '',\n                name;\n\n            if (!legendItems.length) {\n                each(this.dataClasses, function (dataClass, i) {\n                    var vis = true,\n                        from = dataClass.from,\n                        to = dataClass.to;\n\n                    // Assemble the default name. This can be overridden\n                    // by legend.options.labelFormatter\n                    name = '';\n                    if (from === undefined) {\n                        name = '< ';\n                    } else if (to === undefined) {\n                        name = '> ';\n                    }\n                    if (from !== undefined) {\n                        name += _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(from, valueDecimals) +\n                            valueSuffix;\n                    }\n                    if (from !== undefined && to !== undefined) {\n                        name += ' - ';\n                    }\n                    if (to !== undefined) {\n                        name += _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(to, valueDecimals) + valueSuffix;\n                    }\n                    // Add a mock object to the legend items\n                    legendItems.push(extend({\n                        chart: chart,\n                        name: name,\n                        options: {},\n                        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n                        visible: true,\n                        setState: noop,\n                        isDataClass: true,\n                        setVisible: function () {\n                            vis = this.visible = !vis;\n                            each(axis.series, function (series) {\n                                each(series.points, function (point) {\n                                    if (point.dataClass === i) {\n                                        point.setVisible(vis);\n                                    }\n                                });\n                            });\n                            chart.legend.colorizeItem(this, vis);\n                        }\n                    }, dataClass));\n                });\n            }\n            return legendItems;\n        },\n        name: '' // Prevents 'undefined' in legend in IE8\n    });\n\n    /**\n     * Handle animation of the color attributes directly\n     */\n    each(['fill', 'stroke'], function (prop) {\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx.prototype[prop + 'Setter'] = function () {\n            this.elem.attr(\n                prop,\n                color(this.start).tweenTo(\n                    color(this.end),\n                    this.pos\n                ),\n                null,\n                true\n            );\n        };\n    });\n\n    /**\n     * Extend the chart getAxes method to also get the color axis\n     */\n    addEvent(Chart, 'afterGetAxes', function () {\n\n        var options = this.options,\n            colorAxisOptions = options.colorAxis;\n\n        this.colorAxis = [];\n        if (colorAxisOptions) {\n            new ColorAxis(this, colorAxisOptions); // eslint-disable-line no-new\n        }\n    });\n\n\n    /**\n     * Add the color axis. This also removes the axis' own series to prevent\n     * them from showing up individually.\n     */\n    addEvent(Legend, 'afterGetAllItems', function (e) {\n        var colorAxisItems = [],\n            colorAxis = this.chart.colorAxis[0],\n            i;\n\n        if (colorAxis && colorAxis.options) {\n            if (colorAxis.options.showInLegend) {\n                // Data classes\n                if (colorAxis.options.dataClasses) {\n                    colorAxisItems = colorAxis.getDataClassLegendSymbols();\n                // Gradient legend\n                } else {\n                    // Add this axis on top\n                    colorAxisItems.push(colorAxis);\n                }\n\n                // Don't add the color axis' series\n                each(colorAxis.series, function (series) {\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase(e.allItems, series);\n                });\n            }\n        }\n\n        i = colorAxisItems.length;\n        while (i--) {\n            e.allItems.unshift(colorAxisItems[i]);\n        }\n    });\n\n    addEvent(Legend, 'afterColorizeItem', function (e) {\n        if (e.visible && e.item.legendColor) {\n            e.item.legendSymbol.attr({\n                fill: e.item.legendColor\n            });\n        }\n    });\n\n    // Updates in the legend need to be reflected in the color axis (6888)\n    addEvent(Legend, 'afterUpdate', function () {\n        if (this.chart.colorAxis[0]) {\n            this.chart.colorAxis[0].update({}, arguments[2]);\n        }\n    });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-map/ColorAxis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-map/ColorSeriesMixin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-map/ColorSeriesMixin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar defined = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * Mixin for maps and heatmaps\n */\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorPointMixin = {\n    /**\n     * Color points have a value option that determines whether or not it is\n     * a null point\n     */\n    isValid: function () {\n        // undefined is allowed\n        return (\n            this.value !== null &&\n            this.value !== Infinity &&\n            this.value !== -Infinity\n        );\n    },\n\n    /**\n     * Set the visibility of a single point\n     */\n    setVisible: function (vis) {\n        var point = this,\n            method = vis ? 'show' : 'hide';\n\n        point.visible = Boolean(vis);\n\n        // Show and hide associated elements\n        each(['graphic', 'dataLabel'], function (key) {\n            if (point[key]) {\n                point[key][method]();\n            }\n        });\n    },\n    setState: function (state) {\n        _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype.setState.call(this, state);\n        if (this.graphic) {\n            this.graphic.attr({\n                zIndex: state === 'hover' ? 1 : 0\n            });\n        }\n    }\n};\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorSeriesMixin = {\n    pointArrayMap: ['value'],\n    axisTypes: ['xAxis', 'yAxis', 'colorAxis'],\n    optionalAxis: 'colorAxis',\n    trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n    getSymbol: noop,\n    parallelArrays: ['x', 'y', 'value'],\n    colorKey: 'value',\n\n    \n\n    /**\n     * In choropleth maps, the color is a result of the value, so this needs\n     * translation too\n     */\n    translateColors: function () {\n        var series = this,\n            nullColor = this.options.nullColor,\n            colorAxis = this.colorAxis,\n            colorKey = this.colorKey;\n\n        each(this.data, function (point) {\n            var value = point[colorKey],\n                color;\n\n            color = point.options.color ||\n                (\n                    point.isNull ?\n                        nullColor :\n                        (colorAxis && value !== undefined) ?\n                            colorAxis.toColor(value, point) :\n                            point.color || series.color\n                );\n\n            if (color) {\n                point.color = color;\n            }\n        });\n    },\n\n    /**\n     * Get the color attibutes to apply on the graphic\n     */\n    colorAttribs: function (point) {\n        var ret = {};\n        if (defined(point.color)) {\n            ret[this.colorProp || 'fill'] = point.color;\n        }\n        return ret;\n    }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-map/ColorSeriesMixin.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-map/HeatmapSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-map/HeatmapSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Legend_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _ColorSeriesMixin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ColorSeriesMixin.js */ \"./node_modules/highcharts/js/es-modules/parts-map/ColorSeriesMixin.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\nvar colorPointMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorPointMixin,\n    colorSeriesMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].colorSeriesMixin,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    LegendSymbolMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n\n/**\n * A heatmap is a graphical representation of data where the individual values\n * contained in a matrix are represented as colors.\n *\n * @sample       highcharts/demo/heatmap/\n *               Simple heatmap\n * @sample       highcharts/demo/heatmap-canvas/\n *               Heavy heatmap\n * @extends      {plotOptions.scatter}\n * @excluding    animationLimit,connectEnds,connectNulls,dashStyle,\n *               findNearestPointBy,getExtremesFromAll,linecap,lineWidth,marker,\n *               pointInterval,pointIntervalUnit,pointRange,pointStart,shadow,\n *               softThreshold,stacking,step,threshold\n * @product      highcharts highmaps\n * @optionparent plotOptions.heatmap\n */\nseriesType('heatmap', 'scatter', {\n\n    /**\n     * Animation is disabled by default on the heatmap series.\n     *\n     * @type {Boolean|Object}\n     */\n    animation: false,\n\n    /**\n     * The border width for each heat map item.\n     */\n    borderWidth: 0,\n\n    /**\n     * Padding between the points in the heatmap.\n     *\n     * @type {Number}\n     * @default 0\n     * @since 6.0\n     * @apioption plotOptions.heatmap.pointPadding\n     */\n\n    /**\n     * The main color of the series. In heat maps this color is rarely used,\n     * as we mostly use the color to denote the value of each point. Unless\n     * options are set in the [colorAxis](#colorAxis), the default value\n     * is pulled from the [options.colors](#colors) array.\n     *\n     * @type {Color}\n     * @default null\n     * @since 4.0\n     * @product highcharts\n     * @apioption plotOptions.heatmap.color\n     */\n\n    /**\n     * The column size - how many X axis units each column in the heatmap\n     * should span.\n     *\n     * @type {Number}\n     * @sample {highcharts} maps/demo/heatmap/ One day\n     * @sample {highmaps} maps/demo/heatmap/ One day\n     * @default 1\n     * @since 4.0\n     * @product highcharts highmaps\n     * @apioption plotOptions.heatmap.colsize\n     */\n\n    /**\n     * The row size - how many Y axis units each heatmap row should span.\n     *\n     * @type {Number}\n     * @sample {highcharts} maps/demo/heatmap/ 1 by default\n     * @sample {highmaps} maps/demo/heatmap/ 1 by default\n     * @default 1\n     * @since 4.0\n     * @product highcharts highmaps\n     * @apioption plotOptions.heatmap.rowsize\n     */\n\n    \n\n    dataLabels: {\n\n        formatter: function () { // #2945\n            return this.point.value;\n        },\n        inside: true,\n        verticalAlign: 'middle',\n        crop: false,\n        overflow: false,\n        padding: 0 // #3837\n    },\n\n    /**\n     * @ignore\n     */\n    marker: null,\n\n    /**    @ignore */\n    pointRange: null, // dynamically set to colsize by default\n\n    tooltip: {\n        pointFormat: '{point.x}, {point.y}: {point.value}<br/>'\n    },\n\n    states: {\n\n        hover: {\n            /**\n             * @ignore\n             */\n            halo: false,  // #3406, halo is disabled on heatmaps by default\n\n            /**\n             * How much to brighten the point on interaction. Requires the main\n             * color to be defined in hex or rgb(a) format.\n             *\n             * In styled mode, the hover brightening is by default replaced\n             * with a fill-opacity set in the `.highcharts-point:hover` rule.\n             *\n             * @type {Number}\n             * @product highcharts highmaps\n             */\n            brightness: 0.2\n        }\n    }\n\n}, merge(colorSeriesMixin, {\n    pointArrayMap: ['y', 'value'],\n    hasPointSpecificOptions: true,\n    getExtremesFromAll: true,\n    directTouch: true,\n\n    /**\n     * Override the init method to add point ranges on both axes.\n     */\n    init: function () {\n        var options;\n        seriesTypes.scatter.prototype.init.apply(this, arguments);\n\n        options = this.options;\n        // #3758, prevent resetting in setData\n        options.pointRange = pick(options.pointRange, options.colsize || 1);\n        this.yAxis.axisPointRange = options.rowsize || 1; // general point range\n    },\n    translate: function () {\n        var series = this,\n            options = series.options,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            seriesPointPadding = options.pointPadding || 0,\n            between = function (x, a, b) {\n                return Math.min(Math.max(a, x), b);\n            };\n\n        series.generatePoints();\n\n        each(series.points, function (point) {\n            var xPad = (options.colsize || 1) / 2,\n                yPad = (options.rowsize || 1) / 2,\n                x1 = between(\n                    Math.round(\n                        xAxis.len -\n                        xAxis.translate(point.x - xPad, 0, 1, 0, 1)\n                    ),\n                    -xAxis.len, 2 * xAxis.len\n                ),\n                x2 = between(\n                    Math.round(\n                        xAxis.len -\n                        xAxis.translate(point.x + xPad, 0, 1, 0, 1)\n                    ),\n                    -xAxis.len, 2 * xAxis.len\n                ),\n                y1 = between(\n                    Math.round(yAxis.translate(point.y - yPad, 0, 1, 0, 1)),\n                    -yAxis.len, 2 * yAxis.len\n                ),\n                y2 = between(\n                    Math.round(yAxis.translate(point.y + yPad, 0, 1, 0, 1)),\n                    -yAxis.len, 2 * yAxis.len\n                ),\n                pointPadding = pick(point.pointPadding, seriesPointPadding);\n\n            // Set plotX and plotY for use in K-D-Tree and more\n            point.plotX = point.clientX = (x1 + x2) / 2;\n            point.plotY = (y1 + y2) / 2;\n\n            point.shapeType = 'rect';\n            point.shapeArgs = {\n                x: Math.min(x1, x2) + pointPadding,\n                y: Math.min(y1, y2) + pointPadding,\n                width: Math.abs(x2 - x1) - pointPadding * 2,\n                height: Math.abs(y2 - y1) - pointPadding * 2\n            };\n        });\n\n        series.translateColors();\n    },\n    drawPoints: function () {\n        seriesTypes.column.prototype.drawPoints.call(this);\n\n        each(this.points, function (point) {\n            \n            // In styled mode, use CSS, otherwise the fill used in the style\n            // sheet will take precedence over the fill attribute.\n            point.graphic.css(this.colorAttribs(point));\n            \n        }, this);\n    },\n    animate: noop,\n    getBox: noop,\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n    alignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n    getExtremes: function () {\n        // Get the extremes from the value data\n        Series.prototype.getExtremes.call(this, this.valueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n\n        // Get the extremes from the y data\n        Series.prototype.getExtremes.call(this);\n    }\n\n}), _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\n    haloPath: function (size) {\n        if (!size) {\n            return [];\n        }\n        var rect = this.shapeArgs;\n        return [\n            'M', rect.x - size, rect.y - size,\n            'L', rect.x - size, rect.y + rect.height + size,\n            rect.x + rect.width + size, rect.y + rect.height + size,\n            rect.x + rect.width + size, rect.y - size,\n            'Z'\n        ];\n    }\n}, colorPointMixin));\n/**\n * A `heatmap` series. If the [type](#series.heatmap.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.heatmap\n * @excluding dataParser,dataURL,marker,pointRange,stack\n * @product highcharts highmaps\n * @apioption series.heatmap\n */\n\n/**\n * An array of data points for the series. For the `heatmap` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,y,value`. If the first value is a string, it is\n * applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 9, 7],\n *         [1, 10, 4],\n *         [2, 6, 3]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.heatmap.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 3,\n *         value: 10,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 7,\n *         value: 10,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Array>}\n * @extends series.line.data\n * @excluding marker\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts highmaps\n * @apioption series.heatmap.data\n */\n\n/**\n * The color of the point. In heat maps the point color is rarely set\n * explicitly, as we use the color to denote the `value`. Options for\n * this are set in the [colorAxis](#colorAxis) configuration.\n *\n * @type {Color}\n * @product highcharts highmaps\n * @apioption series.heatmap.data.color\n */\n\n/**\n * The value of the point, resulting in a color controled by options\n * as set in the [colorAxis](#colorAxis) configuration.\n *\n * @type {Number}\n * @product highcharts highmaps\n * @apioption series.heatmap.data.value\n */\n\n/**\n * The x value of the point. For datetime axes,\n * the X value is the timestamp in milliseconds since 1970.\n *\n * @type {Number}\n * @product highcharts highmaps\n * @apioption series.heatmap.data.x\n */\n\n/**\n * The y value of the point.\n *\n * @type {Number}\n * @product highcharts highmaps\n * @apioption series.heatmap.data.y\n */\n\n/**\n * Point padding for a single point.\n *\n * @type {Number}\n * @sample maps/plotoptions/tilemap-pointpadding Point padding on tiles\n * @apioption series.heatmap.data.pointPadding\n */\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-map/HeatmapSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/AreaRangeSeries.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/AreaRangeSeries.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    defined = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    seriesProto = Series.prototype,\n    pointProto = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype;\n\n/**\n * The area range series is a carteseian series with higher and lower values\n * for each point along an X axis, where the area between the values is shaded.\n * Requires `highcharts-more.js`.\n *\n * @extends      plotOptions.area\n * @product      highcharts highstock\n * @sample       {highcharts} highcharts/demo/arearange/\n *               Area range chart\n * @sample       {highstock} stock/demo/arearange/\n *               Area range chart\n * @excluding    stack,stacking\n * @optionparent plotOptions.arearange\n */\nseriesType('arearange', 'area', {\n    \n\n    threshold: null,\n\n    tooltip: {\n        \n        pointFormat: '<span class=\"highcharts-color-{series.colorIndex}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        \n    },\n\n    /**\n     * Whether the whole area or just the line should respond to mouseover\n     * tooltips and other mouse or touch events.\n     *\n     * @since   2.3.0\n     * @product highcharts highstock\n     */\n    trackByArea: true,\n\n    /**\n     * Extended data labels for range series types. Range series data labels\n     * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,\n     * `yLow` and `yHigh` options to allow the higher and lower data label\n     * sets individually.\n     *\n     * @type      {Object}\n     * @extends   plotOptions.series.dataLabels\n     * @excluding x,y\n     * @since     2.3.0\n     * @product   highcharts highstock\n     */\n    dataLabels: {\n\n        align: null,\n        verticalAlign: null,\n\n        /**\n         * X offset of the lower data labels relative to the point value.\n         *\n         * @sample  {highcharts} highcharts/plotoptions/arearange-datalabels/\n         *          Data labels on range series\n         * @sample  {highstock} highcharts/plotoptions/arearange-datalabels/\n         *          Data labels on range series\n         * @since   2.3.0\n         * @product highcharts highstock\n         */\n        xLow: 0,\n\n        /**\n         * X offset of the higher data labels relative to the point value.\n         *\n         * @sample  {highcharts|highstock}\n         *          highcharts/plotoptions/arearange-datalabels/\n         *          Data labels on range series\n         * @since   2.3.0\n         * @product highcharts highstock\n         */\n        xHigh: 0,\n\n        /**\n         * Y offset of the lower data labels relative to the point value.\n         *\n         * @sample  {highcharts|highstock}\n         *          highcharts/plotoptions/arearange-datalabels/\n         *          Data labels on range series\n         * @default 16\n         * @since   2.3.0\n         * @product highcharts highstock\n         */\n        yLow: 0,\n\n        /**\n         * Y offset of the higher data labels relative to the point value.\n         *\n         * @sample  {highcharts|highstock}\n         *          highcharts/plotoptions/arearange-datalabels/\n         *          Data labels on range series\n         * @default -6\n         * @since   2.3.0\n         * @product highcharts highstock\n         */\n        yHigh: 0\n    }\n\n// Prototype members\n}, {\n    pointArrayMap: ['low', 'high'],\n    dataLabelCollections: ['dataLabel', 'dataLabelUpper'],\n    toYData: function (point) {\n        return [point.low, point.high];\n    },\n    pointValKey: 'low',\n    deferTranslatePolar: true,\n\n    /**\n     * Translate a point's plotHigh from the internal angle and radius\n     * measures to true plotHigh coordinates. This is an addition of the\n     * toXY method found in Polar.js, because it runs too early for\n     * arearanges to be considered (#3419).\n     */\n    highToXY: function (point) {\n        // Find the polar plotX and plotY\n        var chart = this.chart,\n            xy = this.xAxis.postTranslate(\n                point.rectPlotX,\n                this.yAxis.len - point.plotHigh\n            );\n        point.plotHighX = xy.x - chart.plotLeft;\n        point.plotHigh = xy.y - chart.plotTop;\n        point.plotLowX = point.plotX;\n    },\n\n    /**\n     * Translate data points from raw values x and y to plotX and plotY\n     */\n    translate: function () {\n        var series = this,\n            yAxis = series.yAxis,\n            hasModifyValue = !!series.modifyValue;\n\n        seriesTypes.area.prototype.translate.apply(series);\n\n        // Set plotLow and plotHigh\n        each(series.points, function (point) {\n\n            var low = point.low,\n                high = point.high,\n                plotY = point.plotY;\n\n            if (high === null || low === null) {\n                point.isNull = true;\n                point.plotY = null;\n            } else {\n                point.plotLow = plotY;\n                point.plotHigh = yAxis.translate(\n                    hasModifyValue ? series.modifyValue(high, point) : high,\n                    0,\n                    1,\n                    0,\n                    1\n                );\n                if (hasModifyValue) {\n                    point.yBottom = point.plotHigh;\n                }\n            }\n        });\n\n        // Postprocess plotHigh\n        if (this.chart.polar) {\n            each(this.points, function (point) {\n                series.highToXY(point);\n                point.tooltipPos = [\n                    (point.plotHighX + point.plotLowX) / 2,\n                    (point.plotHigh + point.plotLow) / 2\n                ];\n            });\n        }\n    },\n\n    /**\n     * Extend the line series' getSegmentPath method by applying the segment\n     * path to both lower and higher values of the range\n     */\n    getGraphPath: function (points) {\n\n        var highPoints = [],\n            highAreaPoints = [],\n            i,\n            getGraphPath = seriesTypes.area.prototype.getGraphPath,\n            point,\n            pointShim,\n            linePath,\n            lowerPath,\n            options = this.options,\n            connectEnds = this.chart.polar && options.connectEnds !== false,\n            connectNulls = options.connectNulls,\n            step = options.step,\n            higherPath,\n            higherAreaPath;\n\n        points = points || this.points;\n        i = points.length;\n\n        /**\n         * Create the top line and the top part of the area fill. The area\n         * fill compensates for null points by drawing down to the lower graph,\n         * moving across the null gap and starting again at the lower graph.\n         */\n        i = points.length;\n        while (i--) {\n            point = points[i];\n\n            if (\n                !point.isNull &&\n                !connectEnds &&\n                !connectNulls &&\n                (!points[i + 1] || points[i + 1].isNull)\n            ) {\n                highAreaPoints.push({\n                    plotX: point.plotX,\n                    plotY: point.plotY,\n                    doCurve: false // #5186, gaps in areasplinerange fill\n                });\n            }\n\n            pointShim = {\n                polarPlotY: point.polarPlotY,\n                rectPlotX: point.rectPlotX,\n                yBottom: point.yBottom,\n                // plotHighX is for polar charts\n                plotX: pick(point.plotHighX, point.plotX),\n                plotY: point.plotHigh,\n                isNull: point.isNull\n            };\n\n            highAreaPoints.push(pointShim);\n\n            highPoints.push(pointShim);\n\n            if (\n                !point.isNull &&\n                !connectEnds &&\n                !connectNulls &&\n                (!points[i - 1] || points[i - 1].isNull)\n            ) {\n                highAreaPoints.push({\n                    plotX: point.plotX,\n                    plotY: point.plotY,\n                    doCurve: false // #5186, gaps in areasplinerange fill\n                });\n            }\n        }\n\n        // Get the paths\n        lowerPath = getGraphPath.call(this, points);\n        if (step) {\n            if (step === true) {\n                step = 'left';\n            }\n            options.step = {\n                left: 'right',\n                center: 'center',\n                right: 'left'\n            }[step]; // swap for reading in getGraphPath\n        }\n        higherPath = getGraphPath.call(this, highPoints);\n        higherAreaPath = getGraphPath.call(this, highAreaPoints);\n        options.step = step;\n\n        // Create a line on both top and bottom of the range\n        linePath = [].concat(lowerPath, higherPath);\n\n        // For the area path, we need to change the 'move' statement\n        // into 'lineTo' or 'curveTo'\n        if (!this.chart.polar && higherAreaPath[0] === 'M') {\n            higherAreaPath[0] = 'L'; // this probably doesn't work for spline\n        }\n\n        this.graphPath = linePath;\n        this.areaPath = lowerPath.concat(higherAreaPath);\n\n        // Prepare for sideways animation\n        linePath.isArea = true;\n        linePath.xMap = lowerPath.xMap;\n        this.areaPath.xMap = lowerPath.xMap;\n\n        return linePath;\n    },\n\n    /**\n     * Extend the basic drawDataLabels method by running it for both lower\n     * and higher values.\n     */\n    drawDataLabels: function () {\n\n        var data = this.data,\n            length = data.length,\n            i,\n            originalDataLabels = [],\n            dataLabelOptions = this.options.dataLabels,\n            align = dataLabelOptions.align,\n            verticalAlign = dataLabelOptions.verticalAlign,\n            inside = dataLabelOptions.inside,\n            point,\n            up,\n            inverted = this.chart.inverted;\n\n        if (dataLabelOptions.enabled || this._hasPointLabels) {\n\n            // Step 1: set preliminary values for plotY and dataLabel\n            // and draw the upper labels\n            i = length;\n            while (i--) {\n                point = data[i];\n                if (point) {\n                    up = inside ?\n                        point.plotHigh < point.plotLow :\n                        point.plotHigh > point.plotLow;\n\n                    // Set preliminary values\n                    point.y = point.high;\n                    point._plotY = point.plotY;\n                    point.plotY = point.plotHigh;\n\n                    // Store original data labels and set preliminary label\n                    // objects to be picked up in the uber method\n                    originalDataLabels[i] = point.dataLabel;\n                    point.dataLabel = point.dataLabelUpper;\n\n                    // Set the default offset\n                    point.below = up;\n                    if (inverted) {\n                        if (!align) {\n                            dataLabelOptions.align = up ? 'right' : 'left';\n                        }\n                    } else {\n                        if (!verticalAlign) {\n                            dataLabelOptions.verticalAlign = up ?\n                                'top' :\n                                'bottom';\n                        }\n                    }\n\n                    dataLabelOptions.x = dataLabelOptions.xHigh;\n                    dataLabelOptions.y = dataLabelOptions.yHigh;\n                }\n            }\n\n            if (seriesProto.drawDataLabels) {\n                seriesProto.drawDataLabels.apply(this, arguments); // #1209\n            }\n\n            // Step 2: reorganize and handle data labels for the lower values\n            i = length;\n            while (i--) {\n                point = data[i];\n                if (point) {\n                    up = inside ?\n                        point.plotHigh < point.plotLow :\n                        point.plotHigh > point.plotLow;\n\n                    // Move the generated labels from step 1, and reassign\n                    // the original data labels\n                    point.dataLabelUpper = point.dataLabel;\n                    point.dataLabel = originalDataLabels[i];\n\n                    // Reset values\n                    point.y = point.low;\n                    point.plotY = point._plotY;\n\n                    // Set the default offset\n                    point.below = !up;\n                    if (inverted) {\n                        if (!align) {\n                            dataLabelOptions.align = up ? 'left' : 'right';\n                        }\n                    } else {\n                        if (!verticalAlign) {\n                            dataLabelOptions.verticalAlign = up ?\n                                'bottom' :\n                                'top';\n                        }\n\n                    }\n\n                    dataLabelOptions.x = dataLabelOptions.xLow;\n                    dataLabelOptions.y = dataLabelOptions.yLow;\n                }\n            }\n            if (seriesProto.drawDataLabels) {\n                seriesProto.drawDataLabels.apply(this, arguments);\n            }\n        }\n\n        dataLabelOptions.align = align;\n        dataLabelOptions.verticalAlign = verticalAlign;\n    },\n\n    alignDataLabel: function () {\n        seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);\n    },\n\n    drawPoints: function () {\n        var series = this,\n            pointLength = series.points.length,\n            point,\n            i;\n\n        // Draw bottom points\n        seriesProto.drawPoints.apply(series, arguments);\n\n        // Prepare drawing top points\n        i = 0;\n        while (i < pointLength) {\n            point = series.points[i];\n\n            // Save original props to be overridden by temporary props for top\n            // points\n            point.origProps = {\n                plotY: point.plotY,\n                plotX: point.plotX,\n                isInside: point.isInside,\n                negative: point.negative,\n                zone: point.zone,\n                y: point.y\n            };\n\n            point.lowerGraphic = point.graphic;\n            point.graphic = point.upperGraphic;\n            point.plotY = point.plotHigh;\n            if (defined(point.plotHighX)) {\n                point.plotX = point.plotHighX;\n            }\n            point.y = point.high;\n            point.negative = point.high < (series.options.threshold || 0);\n            point.zone = series.zones.length && point.getZone();\n\n            if (!series.chart.polar) {\n                point.isInside = point.isTopInside = (\n                    point.plotY !== undefined &&\n                    point.plotY >= 0 &&\n                    point.plotY <= series.yAxis.len && // #3519\n                    point.plotX >= 0 &&\n                    point.plotX <= series.xAxis.len\n                );\n            }\n            i++;\n        }\n\n        // Draw top points\n        seriesProto.drawPoints.apply(series, arguments);\n\n        // Reset top points preliminary modifications\n        i = 0;\n        while (i < pointLength) {\n            point = series.points[i];\n            point.upperGraphic = point.graphic;\n            point.graphic = point.lowerGraphic;\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(point, point.origProps);\n            delete point.origProps;\n            i++;\n        }\n    },\n\n    setStackedPoints: noop\n}, {\n    setState: function () {\n        var prevState = this.state,\n            series = this.series,\n            isPolar = series.chart.polar;\n\n\n        if (!defined(this.plotHigh)) {\n            // Boost doesn't calculate plotHigh\n            this.plotHigh = series.yAxis.toPixels(this.high, true);\n        }\n\n        if (!defined(this.plotLow)) {\n            // Boost doesn't calculate plotLow\n            this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);\n        }\n\n        if (series.stateMarkerGraphic) {\n            series.lowerStateMarkerGraphic = series.stateMarkerGraphic;\n            series.stateMarkerGraphic = series.upperStateMarkerGraphic;\n        }\n\n        // Change state also for the top marker\n        this.graphic = this.upperGraphic;\n        this.plotY = this.plotHigh;\n\n        if (isPolar) {\n            this.plotX = this.plotHighX;\n        }\n\n        // Top state:\n        pointProto.setState.apply(this, arguments);\n\n        this.state = prevState;\n\n        // Now restore defaults\n        this.plotY = this.plotLow;\n        this.graphic = this.lowerGraphic;\n\n        if (isPolar) {\n            this.plotX = this.plotLowX;\n        }\n\n        if (series.stateMarkerGraphic) {\n            series.upperStateMarkerGraphic = series.stateMarkerGraphic;\n            series.stateMarkerGraphic = series.lowerStateMarkerGraphic;\n            // Lower marker is stored at stateMarkerGraphic\n            // to avoid reference duplication (#7021)\n            series.lowerStateMarkerGraphic = undefined;\n        }\n\n        pointProto.setState.apply(this, arguments);\n\n    },\n    haloPath: function () {\n        var isPolar = this.series.chart.polar,\n            path = [];\n\n        // Bottom halo\n        this.plotY = this.plotLow;\n        if (isPolar) {\n            this.plotX = this.plotLowX;\n        }\n\n        if (this.isInside) {\n            path = pointProto.haloPath.apply(this, arguments);\n        }\n\n        // Top halo\n        this.plotY = this.plotHigh;\n        if (isPolar) {\n            this.plotX = this.plotHighX;\n        }\n        if (this.isTopInside) {\n            path = path.concat(\n                pointProto.haloPath.apply(this, arguments)\n            );\n        }\n\n        return path;\n    },\n    destroyElements: function () {\n        var graphics = ['lowerGraphic', 'upperGraphic'];\n\n        each(graphics, function (graphicName) {\n            if (this[graphicName]) {\n                this[graphicName] = this[graphicName].destroy();\n            }\n        }, this);\n\n        // Clear graphic for states, removed in the above each:\n        this.graphic = null;\n\n        return pointProto.destroyElements.apply(this, arguments);\n    }\n});\n\n\n/**\n * A `arearange` series. If the [type](#series.arearange.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n *\n * @type      {Object}\n * @extends   series,plotOptions.arearange\n * @excluding dataParser,dataURL,stack,stacking\n * @product   highcharts highstock\n * @apioption series.arearange\n */\n\n/**\n * An array of data points for the series. For the `arearange` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,low,high`. If the first value is a string, it is\n * applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 8, 3],\n *         [1, 1, 1],\n *         [2, 6, 8]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series'\n * [turboThreshold](#series.arearange.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         low: 9,\n *         high: 0,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         low: 3,\n *         high: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.line.data\n * @excluding marker,y\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.arearange.data\n */\n\n/**\n * The high or maximum value for each data point.\n *\n * @type      {Number}\n * @product   highcharts highstock\n * @apioption series.arearange.data.high\n */\n\n/**\n * The low or minimum value for each data point.\n *\n * @type      {Number}\n * @product   highcharts highstock\n * @apioption series.arearange.data.low\n */\n\n /**\n * @excluding x,y\n * @product   highcharts highstock\n * @apioption series.arearange.dataLabels\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/AreaRangeSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/AreaSplineRangeSeries.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/AreaSplineRangeSeries.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * The area spline range is a cartesian series type with higher and\n * lower Y values along an X axis. The area inside the range is colored, and\n * the graph outlining the area is a smoothed spline. Requires\n * `highcharts-more.js`.\n *\n * @extends   plotOptions.arearange\n * @excluding step\n * @since     2.3.0\n * @sample    {highstock|highstock} stock/demo/areasplinerange/\n *            Area spline range\n * @product   highcharts highstock\n * @apioption plotOptions.areasplinerange\n */\nseriesType('areasplinerange', 'arearange', null, {\n    getPointSpline: seriesTypes.spline.prototype.getPointSpline\n});\n\n/**\n * A `areasplinerange` series. If the [type](#series.areasplinerange.type)\n * option is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.areasplinerange\n * @excluding dataParser,dataURL,stack\n * @product   highcharts highstock\n * @apioption series.areasplinerange\n */\n\n/**\n * An array of data points for the series. For the `areasplinerange`\n * series type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,low,high`. If the first value is a string, it is\n * applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 0, 5],\n *         [1, 9, 1],\n *         [2, 5, 2]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](\n * #series.areasplinerange.turboThreshold), this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         low: 5,\n *         high: 0,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         low: 4,\n *         high: 1,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.arearange.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.areasplinerange.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/AreaSplineRangeSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/BoxPlotSeries.js":
/*!***************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/BoxPlotSeries.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * The boxplot series type.\n *\n * @constructor seriesTypes.boxplot\n * @augments    seriesTypes.column\n */\n\n/**\n * A box plot is a convenient way of depicting groups of data through their\n * five-number summaries: the smallest observation (sample minimum), lower\n * quartile (Q1), median (Q2), upper quartile (Q3), and largest observation\n * (sample maximum).\n *\n * @sample       highcharts/demo/box-plot/ Box plot\n * @extends      {plotOptions.column}\n * @product      highcharts\n * @excluding    borderColor,borderRadius,borderWidth,groupZPadding,states\n * @optionparent plotOptions.boxplot\n */\nseriesType('boxplot', 'column', {\n\n    threshold: null,\n\n    tooltip: {\n        \n        pointFormat: '<span class=\"highcharts-color-{point.colorIndex}\">' +\n            '\\u25CF</span> <b> {series.name}</b><br/>' +\n            'Maximum: {point.high}<br/>' +\n            'Upper quartile: {point.q3}<br/>' +\n            'Median: {point.median}<br/>' +\n            'Lower quartile: {point.q1}<br/>' +\n            'Minimum: {point.low}<br/>'\n        \n    },\n\n    /**\n     * The length of the whiskers, the horizontal lines marking low and\n     * high values. It can be a numerical pixel value, or a percentage\n     * value of the box width. Set `0` to disable whiskers.\n     *\n     * @type    {Number|String}\n     * @sample  {highcharts} highcharts/plotoptions/box-plot-styling/\n     *          True by default\n     * @since   3.0\n     * @product highcharts\n     */\n    whiskerLength: '50%'\n    \n\n}, /** @lends seriesTypes.boxplot */ {\n\n    // array point configs are mapped to this\n    pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],\n    toYData: function (point) { // return a plain array for speedy calculation\n        return [point.low, point.q1, point.median, point.q3, point.high];\n    },\n\n    // defines the top of the tracker\n    pointValKey: 'high',\n\n    \n\n    /**\n     * Disable data labels for box plot\n     */\n    drawDataLabels: noop,\n\n    /**\n     * Translate data points from raw values x and y to plotX and plotY\n     */\n    translate: function () {\n        var series = this,\n            yAxis = series.yAxis,\n            pointArrayMap = series.pointArrayMap;\n\n        seriesTypes.column.prototype.translate.apply(series);\n\n        // do the translation on each point dimension\n        each(series.points, function (point) {\n            each(pointArrayMap, function (key) {\n                if (point[key] !== null) {\n                    point[key + 'Plot'] = yAxis.translate(\n                        point[key], 0, 1, 0, 1\n                    );\n                }\n            });\n        });\n    },\n\n    /**\n     * Draw the data points\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            options = series.options,\n            chart = series.chart,\n            renderer = chart.renderer,\n            q1Plot,\n            q3Plot,\n            highPlot,\n            lowPlot,\n            medianPlot,\n            medianPath,\n            crispCorr,\n            crispX = 0,\n            boxPath,\n            width,\n            left,\n            right,\n            halfWidth,\n            // error bar inherits this series type but doesn't do quartiles\n            doQuartiles = series.doQuartiles !== false,\n            pointWiskerLength,\n            whiskerLength = series.options.whiskerLength;\n\n\n        each(points, function (point) {\n\n            var graphic = point.graphic,\n                verb = graphic ? 'animate' : 'attr',\n                shapeArgs = point.shapeArgs; // the box\n\n            \n\n            if (point.plotY !== undefined) {\n\n                // crisp vector coordinates\n                width = shapeArgs.width;\n                left = Math.floor(shapeArgs.x);\n                right = left + width;\n                halfWidth = Math.round(width / 2);\n                q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);\n                q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);\n                highPlot = Math.floor(point.highPlot);\n                lowPlot = Math.floor(point.lowPlot);\n\n                if (!graphic) {\n                    point.graphic = graphic = renderer.g('point')\n                        .add(series.group);\n\n                    point.stem = renderer.path()\n                        .addClass('highcharts-boxplot-stem')\n                        .add(graphic);\n\n                    if (whiskerLength) {\n                        point.whiskers = renderer.path()\n                            .addClass('highcharts-boxplot-whisker')\n                            .add(graphic);\n                    }\n                    if (doQuartiles) {\n                        point.box = renderer.path(boxPath)\n                            .addClass('highcharts-boxplot-box')\n                            .add(graphic);\n                    }\n                    point.medianShape = renderer.path(medianPath)\n                        .addClass('highcharts-boxplot-median')\n                        .add(graphic);\n                }\n\n                \n\n\n                // The stem\n                crispCorr = (point.stem.strokeWidth() % 2) / 2;\n                crispX = left + halfWidth + crispCorr;\n                point.stem[verb]({ d: [\n                    // stem up\n                    'M',\n                    crispX, q3Plot,\n                    'L',\n                    crispX, highPlot,\n\n                    // stem down\n                    'M',\n                    crispX, q1Plot,\n                    'L',\n                    crispX, lowPlot\n                ] });\n\n                // The box\n                if (doQuartiles) {\n                    crispCorr = (point.box.strokeWidth() % 2) / 2;\n                    q1Plot = Math.floor(q1Plot) + crispCorr;\n                    q3Plot = Math.floor(q3Plot) + crispCorr;\n                    left += crispCorr;\n                    right += crispCorr;\n                    point.box[verb]({ d: [\n                        'M',\n                        left, q3Plot,\n                        'L',\n                        left, q1Plot,\n                        'L',\n                        right, q1Plot,\n                        'L',\n                        right, q3Plot,\n                        'L',\n                        left, q3Plot,\n                        'z'\n                    ] });\n                }\n\n                // The whiskers\n                if (whiskerLength) {\n                    crispCorr = (point.whiskers.strokeWidth() % 2) / 2;\n                    highPlot = highPlot + crispCorr;\n                    lowPlot = lowPlot + crispCorr;\n                    pointWiskerLength = (/%$/).test(whiskerLength) ?\n                        halfWidth * parseFloat(whiskerLength) / 100 :\n                        whiskerLength / 2;\n                    point.whiskers[verb]({ d: [\n                        // High whisker\n                        'M',\n                        crispX - pointWiskerLength,\n                        highPlot,\n                        'L',\n                        crispX + pointWiskerLength,\n                        highPlot,\n\n                        // Low whisker\n                        'M',\n                        crispX - pointWiskerLength,\n                        lowPlot,\n                        'L',\n                        crispX + pointWiskerLength,\n                        lowPlot\n                    ] });\n                }\n\n                // The median\n                medianPlot = Math.round(point.medianPlot);\n                crispCorr = (point.medianShape.strokeWidth() % 2) / 2;\n                medianPlot = medianPlot + crispCorr;\n\n                point.medianShape[verb]({ d: [\n                    'M',\n                    left,\n                    medianPlot,\n                    'L',\n                    right,\n                    medianPlot\n                ] });\n            }\n        });\n\n    },\n    setStackedPoints: noop // #3890\n\n});\n\n/**\n * A `boxplot` series. If the [type](#series.boxplot.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.boxplot\n * @excluding dataParser,dataURL,marker,stack,stacking,states\n * @product   highcharts\n * @apioption series.boxplot\n */\n\n/**\n * An array of data points for the series. For the `boxplot` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 6 or 5 values. In this case, the values\n * correspond to `x,low,q1,median,q3,high`. If the first value is a\n * string, it is applied as the name of the point, and the `x` value\n * is inferred. The `x` value can also be omitted, in which case the\n * inner arrays should be of length 5\\. Then the `x` value is automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 3, 0, 10, 3, 5],\n *         [1, 7, 8, 7, 2, 9],\n *         [2, 6, 9, 5, 1, 3]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.boxplot.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         low: 4,\n *         q1: 9,\n *         median: 9,\n *         q3: 1,\n *         high: 10,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         low: 5,\n *         q1: 7,\n *         median: 3,\n *         q3: 6,\n *         high: 2,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.boxplot.data\n */\n\n/**\n * The `high` value for each data point, signifying the highest value\n * in the sample set. The top whisker is drawn here.\n *\n * @type      {Number}\n * @product   highcharts\n * @apioption series.boxplot.data.high\n */\n\n/**\n * The `low` value for each data point, signifying the lowest value\n * in the sample set. The bottom whisker is drawn here.\n *\n * @type      {Number}\n * @product   highcharts\n * @apioption series.boxplot.data.low\n */\n\n/**\n * The median for each data point. This is drawn as a line through the\n * middle area of the box.\n *\n * @type      {Number}\n * @product   highcharts\n * @apioption series.boxplot.data.median\n */\n\n/**\n * The lower quartile for each data point. This is the bottom of the\n * box.\n *\n * @type      {Number}\n * @product   highcharts\n * @apioption series.boxplot.data.q1\n */\n\n/**\n * The higher quartile for each data point. This is the top of the box.\n *\n * @type      {Number}\n * @product   highcharts\n * @apioption series.boxplot.data.q3\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/BoxPlotSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/BubbleSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/BubbleSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_ScatterSeries_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts/ScatterSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\nvar arrayMax = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    Axis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    color = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    Point = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n\n/**\n * A bubble series is a three dimensional series type where each point renders\n * an X, Y and Z value. Each points is drawn as a bubble where the position\n * along the X and Y axes mark the X and Y values, and the size of the bubble\n * relates to the Z value. Requires `highcharts-more.js`.\n *\n * @sample       {highcharts} highcharts/demo/bubble/ Bubble chart\n * @extends      plotOptions.scatter\n * @product      highcharts highstock\n * @optionparent plotOptions.bubble\n */\nseriesType('bubble', 'scatter', {\n\n    dataLabels: {\n        formatter: function () { // #2945\n            return this.point.z;\n        },\n        inside: true,\n        verticalAlign: 'middle'\n    },\n\n    /**\n     * If there are more points in the series than the `animationLimit`, the\n     * animation won't run. Animation affects overall performance and doesn't\n     * work well with heavy data series.\n     * @since 6.1.0\n     */\n    animationLimit: 250,\n\n    /**\n     * Whether to display negative sized bubbles. The threshold is given\n     * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative\n     * bubbles can be visualized by setting\n     * [negativeColor](#plotOptions.bubble.negativeColor).\n     *\n     * @type      {Boolean}\n     * @sample    {highcharts} highcharts/plotoptions/bubble-negative/\n     *            Negative bubbles\n     * @default   true\n     * @since     3.0\n     * @apioption plotOptions.bubble.displayNegative\n     */\n\n    /**\n     * @extends   plotOptions.series.marker\n     * @excluding enabled,enabledThreshold,height,radius,width\n     */\n    marker: {\n        \n        /**\n         * In bubble charts, the radius is overridden and determined based on\n         * the point's data value.\n         */\n        /**\n         * @ignore-option\n         */\n        radius: null,\n\n        states: {\n            hover: {\n                radiusPlus: 0\n            }\n        },\n\n        /**\n         * A predefined shape or symbol for the marker. Possible values are\n         * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n         *\n         * Additionally, the URL to a graphic can be given on the form\n         * `url(graphic.png)`. Note that for the image to be applied to exported\n         * charts, its URL needs to be accessible by the export server.\n         *\n         * Custom callbacks for symbol path generation can also be added to\n         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n         * used by its method name, as shown in the demo.\n         *\n         * @validvalue [\"circle\", \"square\", \"diamond\", \"triangle\",\n         *              \"triangle-down\"]\n         * @sample     {highcharts} highcharts/plotoptions/bubble-symbol/\n         *             Bubble chart with various symbols\n         * @sample     {highcharts} highcharts/plotoptions/series-marker-symbol/\n         *             General chart with predefined, graphic and custom markers\n         * @since      5.0.11\n         */\n        symbol: 'circle'\n    },\n\n    /**\n     * Minimum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height.\n     *\n     * @type    {Number|String}\n     * @sample  {highcharts} highcharts/plotoptions/bubble-size/ Bubble size\n     * @since   3.0\n     * @product highcharts highstock\n     */\n    minSize: 8,\n\n    /**\n     * Maximum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height.\n     *\n     * @type    {Number|String}\n     * @sample  {highcharts} highcharts/plotoptions/bubble-size/\n     *          Bubble size\n     * @since   3.0\n     * @product highcharts highstock\n     */\n    maxSize: '20%',\n\n    /**\n     * When a point's Z value is below the\n     * [zThreshold](#plotOptions.bubble.zThreshold) setting, this color is used.\n     *\n     * @type      {Color}\n     * @sample    {highcharts} highcharts/plotoptions/bubble-negative/\n     *            Negative bubbles\n     * @default   null\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.bubble.negativeColor\n     */\n\n    /**\n     * Whether the bubble's value should be represented by the area or the\n     * width of the bubble. The default, `area`, corresponds best to the\n     * human perception of the size of each bubble.\n     *\n     * @validvalue [\"area\", \"width\"]\n     * @type       {String}\n     * @sample     {highcharts} highcharts/plotoptions/bubble-sizeby/\n     *             Comparison of area and size\n     * @default    area\n     * @since      3.0.7\n     * @apioption  plotOptions.bubble.sizeBy\n     */\n\n    /**\n     * When this is true, the absolute value of z determines the size of\n     * the bubble. This means that with the default `zThreshold` of 0, a\n     * bubble of value -1 will have the same size as a bubble of value 1,\n     * while a bubble of value 0 will have a smaller size according to\n     * `minSize`.\n     *\n     * @type      {Boolean}\n     * @sample    {highcharts}\n     *            highcharts/plotoptions/bubble-sizebyabsolutevalue/\n     *            Size by absolute value, various thresholds\n     * @default   false\n     * @since     4.1.9\n     * @product   highcharts\n     * @apioption plotOptions.bubble.sizeByAbsoluteValue\n     */\n\n    /**\n     * When this is true, the series will not cause the Y axis to cross\n     * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n     * unless the data actually crosses the plane.\n     *\n     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n     * 3 will make the Y axis show negative values according to the `minPadding`\n     * option. If `softThreshold` is `true`, the Y axis starts at 0.\n     *\n     * @since   4.1.9\n     * @product highcharts\n     */\n    softThreshold: false,\n\n    states: {\n        hover: {\n            halo: {\n                size: 5\n            }\n        }\n    },\n\n    tooltip: {\n        pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n    },\n\n    turboThreshold: 0,\n\n    /**\n     * The minimum for the Z value range. Defaults to the highest Z value\n     * in the data.\n     *\n     * @type      {Number}\n     * @see       [zMin](#plotOptions.bubble.zMin)\n     * @sample    {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n     *            Z has a possible range of 0-100\n     * @default   null\n     * @since     4.0.3\n     * @product   highcharts\n     * @apioption plotOptions.bubble.zMax\n     */\n\n    /**\n     * The minimum for the Z value range. Defaults to the lowest Z value\n     * in the data.\n     *\n     * @type      {Number}\n     * @see       [zMax](#plotOptions.bubble.zMax)\n     * @sample    {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n     *            Z has a possible range of 0-100\n     * @default   null\n     * @since     4.0.3\n     * @product   highcharts\n     * @apioption plotOptions.bubble.zMin\n     */\n\n    /**\n     * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,\n     * bubbles with lower Z values are skipped. When `displayNegative`\n     * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)\n     * is given, points with lower Z is colored.\n     *\n     * @type    {Number}\n     * @sample  {highcharts} highcharts/plotoptions/bubble-negative/\n     *          Negative bubbles\n     * @default 0\n     * @since   3.0\n     * @product highcharts\n     */\n    zThreshold: 0,\n\n    zoneAxis: 'z'\n\n// Prototype members\n}, {\n    pointArrayMap: ['y', 'z'],\n    parallelArrays: ['x', 'y', 'z'],\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    specialGroup: 'group', // To allow clipping (#6296)\n    bubblePadding: true,\n    zoneAxis: 'z',\n    directTouch: true,\n\n    \n\n    /**\n     * Get the radius for each point based on the minSize, maxSize and each\n     * point's Z value. This must be done prior to Series.translate because\n     * the axis needs to add padding in accordance with the point sizes.\n     */\n    getRadii: function (zMin, zMax, minSize, maxSize) {\n        var len,\n            i,\n            pos,\n            zData = this.zData,\n            radii = [],\n            options = this.options,\n            sizeByArea = options.sizeBy !== 'width',\n            zThreshold = options.zThreshold,\n            zRange = zMax - zMin,\n            value,\n            radius;\n\n        // Set the shape type and arguments to be picked up in drawPoints\n        for (i = 0, len = zData.length; i < len; i++) {\n\n            value = zData[i];\n\n            // When sizing by threshold, the absolute value of z determines\n            // the size of the bubble.\n            if (options.sizeByAbsoluteValue && value !== null) {\n                value = Math.abs(value - zThreshold);\n                zMax = zRange = Math.max(\n                    zMax - zThreshold,\n                    Math.abs(zMin - zThreshold)\n                );\n                zMin = 0;\n            }\n\n            if (!isNumber(value)) {\n                radius = null;\n            // Issue #4419 - if value is less than zMin, push a radius that's\n            // always smaller than the minimum size\n            } else if (value < zMin) {\n                radius = minSize / 2 - 1;\n            } else {\n                // Relative size, a number between 0 and 1\n                pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n\n                if (sizeByArea && pos >= 0) {\n                    pos = Math.sqrt(pos);\n                }\n                radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n            }\n            radii.push(radius);\n        }\n        this.radii = radii;\n    },\n\n    /**\n     * Perform animation on the bubbles\n     */\n    animate: function (init) {\n        if (\n            !init &&\n            this.points.length < this.options.animationLimit // #8099\n        ) {\n            each(this.points, function (point) {\n                var graphic = point.graphic,\n                    animationTarget;\n\n                if (graphic && graphic.width) { // URL symbols don't have width\n                    animationTarget = {\n                        x: graphic.x,\n                        y: graphic.y,\n                        width: graphic.width,\n                        height: graphic.height\n                    };\n\n                    // Start values\n                    graphic.attr({\n                        x: point.plotX,\n                        y: point.plotY,\n                        width: 1,\n                        height: 1\n                    });\n\n                    // Run animation\n                    graphic.animate(animationTarget, this.options.animation);\n                }\n            }, this);\n\n            // delete this function to allow it only once\n            this.animate = null;\n        }\n    },\n\n    /**\n     * Extend the base translate method to handle bubble size\n     */\n    translate: function () {\n\n        var i,\n            data = this.data,\n            point,\n            radius,\n            radii = this.radii;\n\n        // Run the parent method\n        seriesTypes.scatter.prototype.translate.call(this);\n\n        // Set the shape type and arguments to be picked up in drawPoints\n        i = data.length;\n\n        while (i--) {\n            point = data[i];\n            radius = radii ? radii[i] : 0; // #1737\n\n            if (isNumber(radius) && radius >= this.minPxSize / 2) {\n                // Shape arguments\n                point.marker = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(point.marker, {\n                    radius: radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                });\n\n                // Alignment box for the data label\n                point.dlBox = {\n                    x: point.plotX - radius,\n                    y: point.plotY - radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                };\n            } else { // below zThreshold\n                // #1691\n                point.shapeArgs = point.plotY = point.dlBox = undefined;\n            }\n        }\n    },\n\n    alignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n    buildKDTree: noop,\n    applyZones: noop\n\n// Point class\n}, {\n    haloPath: function (size) {\n        return Point.prototype.haloPath.call(\n            this,\n            // #6067\n            size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size\n        );\n    },\n    ttBelow: false\n});\n\n/**\n * Add logic to pad each axis with the amount of pixels\n * necessary to avoid the bubbles to overflow.\n */\nAxis.prototype.beforePadding = function () {\n    var axis = this,\n        axisLength = this.len,\n        chart = this.chart,\n        pxMin = 0,\n        pxMax = axisLength,\n        isXAxis = this.isXAxis,\n        dataKey = isXAxis ? 'xData' : 'yData',\n        min = this.min,\n        extremes = {},\n        smallestSize = Math.min(chart.plotWidth, chart.plotHeight),\n        zMin = Number.MAX_VALUE,\n        zMax = -Number.MAX_VALUE,\n        range = this.max - min,\n        transA = axisLength / range,\n        activeSeries = [];\n\n    // Handle padding on the second pass, or on redraw\n    each(this.series, function (series) {\n\n        var seriesOptions = series.options,\n            zData;\n\n        if (\n            series.bubblePadding &&\n            (series.visible || !chart.options.chart.ignoreHiddenSeries)\n        ) {\n\n            // Correction for #1673\n            axis.allowZoomOutside = true;\n\n            // Cache it\n            activeSeries.push(series);\n\n            if (isXAxis) { // because X axis is evaluated first\n\n                // For each series, translate the size extremes to pixel values\n                each(['minSize', 'maxSize'], function (prop) {\n                    var length = seriesOptions[prop],\n                        isPercent = /%$/.test(length);\n\n                    length = pInt(length);\n                    extremes[prop] = isPercent ?\n                        smallestSize * length / 100 :\n                        length;\n\n                });\n                series.minPxSize = extremes.minSize;\n                // Prioritize min size if conflict to make sure bubbles are\n                // always visible. #5873\n                series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);\n\n                // Find the min and max Z\n                zData = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep(series.zData, _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber);\n                if (zData.length) { // #1735\n                    zMin = pick(seriesOptions.zMin, Math.min(\n                        zMin,\n                        Math.max(\n                            arrayMin(zData),\n                            seriesOptions.displayNegative === false ?\n                                seriesOptions.zThreshold :\n                                -Number.MAX_VALUE\n                        )\n                    ));\n                    zMax = pick(\n                        seriesOptions.zMax,\n                        Math.max(zMax, arrayMax(zData))\n                    );\n                }\n            }\n        }\n    });\n\n    each(activeSeries, function (series) {\n\n        var data = series[dataKey],\n            i = data.length,\n            radius;\n\n        if (isXAxis) {\n            series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n        }\n\n        if (range > 0) {\n            while (i--) {\n                if (\n                    isNumber(data[i]) &&\n                    axis.dataMin <= data[i] &&\n                    data[i] <= axis.dataMax\n                ) {\n                    radius = series.radii[i];\n                    pxMin = Math.min(\n                        ((data[i] - min) * transA) - radius,\n                        pxMin\n                    );\n                    pxMax = Math.max(\n                        ((data[i] - min) * transA) + radius,\n                        pxMax\n                    );\n                }\n            }\n        }\n    });\n\n    // Apply the padding to the min and max properties\n    if (activeSeries.length && range > 0 && !this.isLog) {\n        pxMax -= axisLength;\n        transA *= (\n            axisLength +\n            Math.max(0, pxMin) - // #8901\n            Math.min(pxMax, axisLength)\n        ) / axisLength;\n        each(\n            [['min', 'userMin', pxMin], ['max', 'userMax', pxMax]],\n            function (keys) {\n                if (pick(axis.options[keys[0]], axis[keys[1]]) === undefined) {\n                    axis[keys[0]] += keys[2] / transA;\n                }\n            }\n        );\n    }\n};\n\n\n/**\n * A `bubble` series. If the [type](#series.bubble.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.bubble\n * @excluding dataParser,dataURL,stack\n * @product   highcharts highstock\n * @apioption series.bubble\n */\n\n/**\n * An array of data points for the series. For the `bubble` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,y,z`. If the first value is a string, it is applied\n * as the name of the point, and the `x` value is inferred. The `x`\n * value can also be omitted, in which case the inner arrays should\n * be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart` and\n * `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 1, 2],\n *         [1, 5, 5],\n *         [2, 0, 2]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.bubble.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 1,\n *         z: 1,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 5,\n *         z: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.bubble.data\n */\n\n/**\n * The size value for each bubble. The bubbles' diameters are computed\n * based on the `z`, and controlled by series options like `minSize`,\n * `maxSize`, `sizeBy`, `zMin` and `zMax`.\n *\n * @type {Number}\n * @product highcharts\n * @apioption series.bubble.data.z\n */\n\n/**\n * @excluding enabled,enabledThreshold,height,radius,width\n * @apioption series.bubble.marker\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/BubbleSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/ColumnRangeSeries.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/ColumnRangeSeries.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar defaultPlotOptions = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\nvar colProto = seriesTypes.column.prototype;\n/**\n * The column range is a cartesian series type with higher and lower\n * Y values along an X axis. Requires `highcharts-more.js`. To display\n * horizontal bars, set [chart.inverted](#chart.inverted) to `true`.\n *\n * @type         {Object}\n * @extends      plotOptions.column\n * @excluding    negativeColor,stacking,softThreshold,threshold\n * @sample       {highcharts|highstock} highcharts/demo/columnrange/\n *               Inverted column range\n * @since        2.3.0\n * @product      highcharts highstock\n * @optionparent plotOptions.columnrange\n */\nvar columnRangeOptions = {\n\n    /**\n     * Extended data labels for range series types. Range series data labels\n     * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,\n     * `yLow` and `yHigh` options to allow the higher and lower data label\n     * sets individually.\n     *\n     * @type      {Object}\n     * @extends   plotOptions.arearange.dataLabels\n     * @excluding x,y\n     * @since     2.3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.columnrange.dataLabels\n     */\n\n    pointRange: null,\n\n    /** @ignore-option */\n    marker: null,\n\n    states: {\n        hover: {\n            /** @ignore-option */\n            halo: false\n        }\n    }\n};\n/**\n * The ColumnRangeSeries class\n */\nseriesType('columnrange', 'arearange', merge(\n    defaultPlotOptions.column,\n    defaultPlotOptions.arearange,\n    columnRangeOptions\n\n), {\n    /**\n     * Translate data points from raw values x and y to plotX and plotY\n     */\n    translate: function () {\n        var series = this,\n            yAxis = series.yAxis,\n            xAxis = series.xAxis,\n            startAngleRad = xAxis.startAngleRad,\n            start,\n            chart = series.chart,\n            isRadial = series.xAxis.isRadial,\n            safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999,\n            plotHigh;\n\n        // Don't draw too far outside plot area (#6835)\n        function safeBounds(pixelPos) {\n            return Math.min(Math.max(\n                -safeDistance,\n                pixelPos\n            ), safeDistance);\n        }\n\n\n        colProto.translate.apply(series);\n\n        // Set plotLow and plotHigh\n        each(series.points, function (point) {\n            var shapeArgs = point.shapeArgs,\n                minPointLength = series.options.minPointLength,\n                heightDifference,\n                height,\n                y;\n\n            point.plotHigh = plotHigh = safeBounds(\n                yAxis.translate(point.high, 0, 1, 0, 1)\n            );\n            point.plotLow = safeBounds(point.plotY);\n\n            // adjust shape\n            y = plotHigh;\n            height = pick(point.rectPlotY, point.plotY) - plotHigh;\n\n            // Adjust for minPointLength\n            if (Math.abs(height) < minPointLength) {\n                heightDifference = (minPointLength - height);\n                height += heightDifference;\n                y -= heightDifference / 2;\n\n            // Adjust for negative ranges or reversed Y axis (#1457)\n            } else if (height < 0) {\n                height *= -1;\n                y -= height;\n            }\n\n            if (isRadial) {\n\n                start = point.barX + startAngleRad;\n                point.shapeType = 'path';\n                point.shapeArgs = {\n                    d: series.polarArc(\n                        y + height,\n                        y,\n                        start,\n                        start + point.pointWidth\n                    )\n                };\n            } else {\n\n                shapeArgs.height = height;\n                shapeArgs.y = y;\n\n                point.tooltipPos = chart.inverted ?\n                [\n                    yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,\n                    xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x -\n                        shapeArgs.width / 2,\n                    height\n                ] : [\n                    xAxis.left - chart.plotLeft + shapeArgs.x +\n                        shapeArgs.width / 2,\n                    yAxis.pos - chart.plotTop + y + height / 2,\n                    height\n                ]; // don't inherit from column tooltip position - #3372\n            }\n        });\n    },\n    directTouch: true,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    drawGraph: noop,\n    getSymbol: noop,\n    crispCol: colProto.crispCol,\n    drawPoints: colProto.drawPoints,\n    drawTracker: colProto.drawTracker,\n    getColumnMetrics: colProto.getColumnMetrics,\n    pointAttribs: colProto.pointAttribs,\n\n    // Overrides from modules that may be loaded after this module\n    animate: function () {\n        return colProto.animate.apply(this, arguments);\n    },\n    polarArc: function () {\n        return colProto.polarArc.apply(this, arguments);\n    },\n    translate3dPoints: function () {\n        return colProto.translate3dPoints.apply(this, arguments);\n    },\n    translate3dShapes: function () {\n        return colProto.translate3dShapes.apply(this, arguments);\n    }\n}, {\n    setState: colProto.pointClass.prototype.setState\n});\n\n\n/**\n * A `columnrange` series. If the [type](#series.columnrange.type)\n * option is not specified, it is inherited from\n * [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.columnrange\n * @excluding dataParser,dataURL,stack,stacking\n * @product   highcharts highstock\n * @apioption series.columnrange\n */\n\n/**\n * An array of data points for the series. For the `columnrange` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,low,high`. If the first value is a string, it is\n * applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 4, 2],\n *         [1, 2, 1],\n *         [2, 9, 10]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](\n * #series.columnrange.turboThreshold), this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         low: 0,\n *         high: 4,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         low: 5,\n *         high: 3,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.arearange.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.columnrange.data\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.columnrange.states.hover\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.columnrange.states.select\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/ColumnRangeSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/ErrorBarSeries.js":
/*!****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/ErrorBarSeries.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _BoxPlotSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoxPlotSeries.js */ \"./node_modules/highcharts/js/es-modules/parts-more/BoxPlotSeries.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * Error bars are a graphical representation of the variability of data and are\n * used on graphs to indicate the error, or uncertainty in a reported\n * measurement.\n *\n * @sample       highcharts/demo/error-bar/\n *               Error bars on a column series\n * @sample       highcharts/series-errorbar/on-scatter/\n *               Error bars on a scatter series\n * @extends      {plotOptions.boxplot}\n * @product      highcharts highstock\n * @optionparent plotOptions.errorbar\n */\nseriesType('errorbar', 'boxplot', {\n    \n\n    grouping: false,\n\n    /**\n     * The parent series of the error bar. The default value links it to\n     * the previous series. Otherwise, use the id of the parent series.\n     *\n     * @since   3.0\n     * @product highcharts\n     */\n    linkedTo: ':previous',\n\n    tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n    },\n\n    /**\n     * The line width of the whiskers, the horizontal lines marking low\n     * and high values. When `null`, the general\n     * [lineWidth](#plotOptions.errorbar.lineWidth) applies.\n     *\n     * @type    {Number}\n     * @sample  {highcharts} highcharts/plotoptions/error-bar-styling/\n     *          Error bar styling\n     * @since   3.0\n     * @product highcharts\n     */\n    whiskerWidth: null\n\n// Prototype members\n}, {\n    type: 'errorbar',\n    pointArrayMap: ['low', 'high'], // array point configs are mapped to this\n    toYData: function (point) { // return a plain array for speedy calculation\n        return [point.low, point.high];\n    },\n    pointValKey: 'high', // defines the top of the tracker\n    doQuartiles: false,\n    drawDataLabels: seriesTypes.arearange ?\n        function () {\n            var valKey = this.pointValKey;\n            seriesTypes.arearange.prototype.drawDataLabels.call(this);\n            // Arearange drawDataLabels does not reset point.y to high,\n            // but to low after drawing (#4133)\n            each(this.data, function (point) {\n                point.y = point[valKey];\n            });\n        } :\n        noop,\n\n    /**\n     * Get the width and X offset, either on top of the linked series column\n     * or standalone\n     */\n    getColumnMetrics: function () {\n        return (this.linkedParent && this.linkedParent.columnMetrics) ||\n            seriesTypes.column.prototype.getColumnMetrics.call(this);\n    }\n});\n\n/**\n * A `errorbar` series. If the [type](#series.errorbar.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.errorbar\n * @excluding dataParser,dataURL,stack,stacking\n * @product   highcharts\n * @apioption series.errorbar\n */\n\n/**\n * An array of data points for the series. For the `errorbar` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 3 or 2 values. In this case, the values\n * correspond to `x,low,high`. If the first value is a string, it is\n * applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 2\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 10, 2],\n *         [1, 1, 8],\n *         [2, 4, 5]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.errorbar.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         low: 0,\n *         high: 0,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         low: 5,\n *         high: 5,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.arearange.data\n * @excluding dataLabels,drilldown,marker,states\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.errorbar.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/ErrorBarSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Interaction.js */ \"./node_modules/highcharts/js/es-modules/parts/Interaction.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    TrackerMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TrackerMixin;\n\n\n/**\n * Gauges are circular plots displaying one or more values with a dial pointing\n * to values along the perimeter.\n *\n * @sample       highcharts/demo/gauge-speedometer/ Gauge chart\n * @extends      {plotOptions.line}\n * @excluding    animationLimit,boostThreshold,connectEnds,connectNulls,\n *               cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,\n *               marker,negativeColor,pointPlacement,shadow,softThreshold,\n *               stacking,states,step,threshold,turboThreshold,xAxis,zoneAxis,\n *               zones\n * @product      highcharts\n * @optionparent plotOptions.gauge\n */\nseriesType('gauge', 'line', {\n\n    /**\n     * When this option is `true`, the dial will wrap around the axes. For\n     * instance, in a full-range gauge going from 0 to 360, a value of 400\n     * will point to 40\\. When `wrap` is `false`, the dial stops at 360.\n     *\n     * @type      {Boolean}\n     * @see       [overshoot](#plotOptions.gauge.overshoot)\n     * @default   true\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.wrap\n     */\n\n    /**\n     * Data labels for the gauge. For gauges, the data labels are enabled\n     * by default and shown in a bordered box below the point.\n     *\n     * @type    {Object}\n     * @extends plotOptions.series.dataLabels\n     * @since   2.3.0\n     * @product highcharts\n     */\n    dataLabels: {\n\n        /**\n         * Enable or disable the data labels.\n         *\n         * @since   2.3.0\n         * @product highcharts highmaps\n         */\n        enabled: true,\n\n        defer: false,\n\n        /**\n         * The y position offset of the label relative to the center of the\n         * gauge.\n         *\n         * @since   2.3.0\n         * @product highcharts highmaps\n         */\n        y: 15,\n\n        /**\n         * The border radius in pixels for the gauge's data label.\n         *\n         * @since   2.3.0\n         * @product highcharts highmaps\n         */\n        borderRadius: 3,\n\n        crop: false,\n\n        /**\n         * The vertical alignment of the data label.\n         *\n         * @product highcharts highmaps\n         */\n        verticalAlign: 'top',\n\n        /**\n         * The Z index of the data labels. A value of 2 display them behind\n         * the dial.\n         *\n         * @since   2.1.5\n         * @product highcharts highmaps\n         */\n        zIndex: 2\n        \n    },\n\n    /**\n     * Options for the dial or arrow pointer of the gauge.\n     *\n     * In styled mode, the dial is styled with the\n     * `.highcharts-gauge-series .highcharts-dial` rule.\n     *\n     * @type    {Object}\n     * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n     * @since   2.3.0\n     * @product highcharts\n     */\n    dial: {},\n\n    /**\n     * The length of the dial's base part, relative to the total radius\n     * or length of the dial.\n     *\n     * @type      {String}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n     *            Dial options demonstrated\n     * @default   70%\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.dial.baseLength\n     */\n\n    /**\n     * The pixel width of the base of the gauge dial. The base is the part\n     * closest to the pivot, defined by baseLength.\n     *\n     * @type      {Number}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n     *            Dial options demonstrated\n     * @default   3\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.dial.baseWidth\n     */\n\n    /**\n     * The radius or length of the dial, in percentages relative to the\n     * radius of the gauge itself.\n     *\n     * @type      {String}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n     *            Dial options demonstrated\n     * @default   80%\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.dial.radius\n     */\n\n    /**\n     * The length of the dial's rear end, the part that extends out on the\n     * other side of the pivot. Relative to the dial's length.\n     *\n     * @type      {String}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n     *            Dial options demonstrated\n     * @default   10%\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.dial.rearLength\n     */\n\n    /**\n     * The width of the top of the dial, closest to the perimeter. The pivot\n     * narrows in from the base to the top.\n     *\n     * @type      {Number}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-dial/\n     *            Dial options demonstrated\n     * @default   1\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.dial.topWidth\n     */\n\n    \n\n    /**\n     * Allow the dial to overshoot the end of the perimeter axis by this\n     * many degrees. Say if the gauge axis goes from 0 to 60, a value of\n     * 100, or 1000, will show 5 degrees beyond the end of the axis when this\n     * option is set to 5.\n     *\n     * @type      {Number}\n     * @see       [wrap](#plotOptions.gauge.wrap)\n     * @sample    {highcharts} highcharts/plotoptions/gauge-overshoot/\n     *            Allow 5 degrees overshoot\n     * @default   0\n     * @since     3.0.10\n     * @product   highcharts\n     * @apioption plotOptions.gauge.overshoot\n     */\n\n    /**\n     * Options for the pivot or the center point of the gauge.\n     *\n     * In styled mode, the pivot is styled with the\n     * `.highcharts-gauge-series .highcharts-pivot` rule.\n     *\n     * @type    {Object}\n     * @sample  {highcharts} highcharts/css/gauge/ Styled mode\n     * @since   2.3.0\n     * @product highcharts\n     */\n    pivot: {},\n\n    /**\n     * The pixel radius of the pivot.\n     *\n     * @type      {Number}\n     * @sample    {highcharts} highcharts/plotoptions/gauge-pivot/\n     *            Pivot options demonstrated\n     * @default   5\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.pivot.radius\n     */\n\n    \n\n\n    tooltip: {\n        headerFormat: ''\n    },\n\n    /**\n     * Whether to display this particular series or series type in the\n     * legend. Defaults to false for gauge series.\n     *\n     * @since   2.3.0\n     * @product highcharts\n     */\n    showInLegend: false\n\n\n\n// Prototype members\n}, {\n    // chart.angular will be set to true when a gauge series is present,\n    // and this will be used on the axes\n    angular: true,\n    directTouch: true, // #5063\n    drawGraph: noop,\n    fixedBox: true,\n    forceDL: true,\n    noSharedTooltip: true,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n\n    /**\n     * Calculate paths etc\n     */\n    translate: function () {\n\n        var series = this,\n            yAxis = series.yAxis,\n            options = series.options,\n            center = yAxis.center;\n\n        series.generatePoints();\n\n        each(series.points, function (point) {\n\n            var dialOptions = merge(options.dial, point.dial),\n                radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) /\n                    200,\n                baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) /\n                    100,\n                rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) /\n                    100,\n                baseWidth = dialOptions.baseWidth || 3,\n                topWidth = dialOptions.topWidth || 1,\n                overshoot = options.overshoot,\n                rotation = yAxis.startAngleRad +\n                    yAxis.translate(point.y, null, null, null, true);\n\n            // Handle the wrap and overshoot options\n            if (isNumber(overshoot)) {\n                overshoot = overshoot / 180 * Math.PI;\n                rotation = Math.max(\n                    yAxis.startAngleRad - overshoot,\n                    Math.min(yAxis.endAngleRad + overshoot, rotation)\n                );\n\n            } else if (options.wrap === false) {\n                rotation = Math.max(\n                    yAxis.startAngleRad,\n                    Math.min(yAxis.endAngleRad, rotation)\n                );\n            }\n\n            rotation = rotation * 180 / Math.PI;\n\n            point.shapeType = 'path';\n            point.shapeArgs = {\n                d: dialOptions.path || [\n                    'M',\n                    -rearLength, -baseWidth / 2,\n                    'L',\n                    baseLength, -baseWidth / 2,\n                    radius, -topWidth / 2,\n                    radius, topWidth / 2,\n                    baseLength, baseWidth / 2,\n                    -rearLength, baseWidth / 2,\n                    'z'\n                ],\n                translateX: center[0],\n                translateY: center[1],\n                rotation: rotation\n            };\n\n            // Positions for data label\n            point.plotX = center[0];\n            point.plotY = center[1];\n        });\n    },\n\n    /**\n     * Draw the points where each point is one needle\n     */\n    drawPoints: function () {\n\n        var series = this,\n            center = series.yAxis.center,\n            pivot = series.pivot,\n            options = series.options,\n            pivotOptions = options.pivot,\n            renderer = series.chart.renderer;\n\n        each(series.points, function (point) {\n\n            var graphic = point.graphic,\n                shapeArgs = point.shapeArgs,\n                d = shapeArgs.d,\n                dialOptions = merge(options.dial, point.dial); // #1233\n\n            if (graphic) {\n                graphic.animate(shapeArgs);\n                shapeArgs.d = d; // animate alters it\n            } else {\n                point.graphic = renderer[point.shapeType](shapeArgs)\n                    .attr({\n                        // required by VML when animation is false\n                        rotation: shapeArgs.rotation,\n                        zIndex: 1\n                    })\n                    .addClass('highcharts-dial')\n                    .add(series.group);\n\n                \n            }\n        });\n\n        // Add or move the pivot\n        if (pivot) {\n            pivot.animate({ // #1235\n                translateX: center[0],\n                translateY: center[1]\n            });\n        } else {\n            series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))\n                .attr({\n                    zIndex: 2\n                })\n                .addClass('highcharts-pivot')\n                .translate(center[0], center[1])\n                .add(series.group);\n\n            \n        }\n    },\n\n    /**\n     * Animate the arrow up from startAngle\n     */\n    animate: function (init) {\n        var series = this;\n\n        if (!init) {\n            each(series.points, function (point) {\n                var graphic = point.graphic;\n\n                if (graphic) {\n                    // start value\n                    graphic.attr({\n                        rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                    });\n\n                    // animate\n                    graphic.animate({\n                        rotation: point.shapeArgs.rotation\n                    }, series.options.animation);\n                }\n            });\n\n            // delete this function to allow it only once\n            series.animate = null;\n        }\n    },\n\n    render: function () {\n        this.group = this.plotGroup(\n            'group',\n            'series',\n            this.visible ? 'visible' : 'hidden',\n            this.options.zIndex,\n            this.chart.seriesGroup\n        );\n        Series.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n    },\n\n    /**\n     * Extend the basic setData method by running processData and generatePoints\n     * immediately, in order to access the points from the legend.\n     */\n    setData: function (data, redraw) {\n        Series.prototype.setData.call(this, data, false);\n        this.processData();\n        this.generatePoints();\n        if (pick(redraw, true)) {\n            this.chart.redraw();\n        }\n    },\n\n    /**\n     * If the tracking module is loaded, add the point tracker\n     */\n    drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint\n\n// Point members\n}, {\n    /**\n     * Don't do any hover colors or anything\n     */\n    setState: function (state) {\n        this.state = state;\n    }\n});\n\n/**\n * A `gauge` series. If the [type](#series.gauge.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.gauge\n * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,\n *            cropThreshold,dashStyle,dataParser,dataURL,findNearestPointBy,\n *            getExtremesFromAll,marker,negativeColor,pointPlacement,shadow,\n *            softThreshold,stack,stacking,states,step,threshold,\n *            turboThreshold,zoneAxis,zones\n * @product   highcharts\n * @apioption series.gauge\n */\n\n/**\n * An array of data points for the series. For the `gauge` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.gauge.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *     y: 6,\n *     name: \"Point2\",\n *     color: \"#00FF00\"\n * }, {\n *     y: 8,\n *     name: \"Point1\",\n *     color: \"#FF00FF\"\n * }]</pre>\n *\n * The typical gauge only contains a single data value.\n *\n * @type      {Array<Object|Number>}\n * @extends   series.line.data\n * @excluding drilldown,marker,x\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.gauge.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/GaugeSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/Pane.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/Pane.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _mixins_centered_series_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mixins/centered-series.js */ \"./node_modules/highcharts/js/es-modules/mixins/centered-series.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar CenteredSeriesMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CenteredSeriesMixin,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    splat = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat;\n/**\n * The Pane object allows options that are common to a set of X and Y axes.\n *\n * In the future, this can be extended to basic Highcharts and Highstock.\n *\n */\nfunction Pane(options, chart) {\n    this.init(options, chart);\n}\n\n// Extend the Pane prototype\nextend(Pane.prototype, {\n\n    coll: 'pane', // Member of chart.pane\n\n    /**\n     * Initiate the Pane object\n     */\n    init: function (options, chart) {\n        this.chart = chart;\n        this.background = [];\n\n        chart.pane.push(this);\n\n        this.setOptions(options);\n    },\n\n    setOptions: function (options) {\n\n        // Set options. Angular charts have a default background (#3318)\n        this.options = options = merge(\n            this.defaultOptions,\n            this.chart.angular ? { background: {} } : undefined,\n            options\n        );\n    },\n\n    /**\n     * Render the pane with its backgrounds.\n     */\n    render: function () {\n\n        var options = this.options,\n            backgroundOption = this.options.background,\n            renderer = this.chart.renderer,\n            len,\n            i;\n\n        if (!this.group) {\n            this.group = renderer.g('pane-group')\n                .attr({ zIndex: options.zIndex || 0 })\n                .add();\n        }\n\n        this.updateCenter();\n\n        // Render the backgrounds\n        if (backgroundOption) {\n            backgroundOption = splat(backgroundOption);\n\n            len = Math.max(\n                backgroundOption.length,\n                this.background.length || 0\n            );\n\n            for (i = 0; i < len; i++) {\n                // #6641 - if axis exists, chart is circular and apply\n                // background\n                if (backgroundOption[i] && this.axis) {\n                    this.renderBackground(\n                        merge(\n                            this.defaultBackgroundOptions,\n                            backgroundOption[i]\n                        ),\n                        i\n                    );\n                } else if (this.background[i]) {\n                    this.background[i] = this.background[i].destroy();\n                    this.background.splice(i, 1);\n                }\n            }\n        }\n    },\n\n    /**\n     * Render an individual pane background.\n     * @param  {Object} backgroundOptions Background options\n     * @param  {number} i The index of the background in this.backgrounds\n     */\n    renderBackground: function (backgroundOptions, i) {\n        var method = 'animate';\n\n        if (!this.background[i]) {\n            this.background[i] = this.chart.renderer.path()\n                .add(this.group);\n            method = 'attr';\n        }\n\n        this.background[i][method]({\n            'd': this.axis.getPlotBandPath(\n                backgroundOptions.from,\n                backgroundOptions.to,\n                backgroundOptions\n            )\n        }).attr({\n            \n            'class': 'highcharts-pane ' + (backgroundOptions.className || '')\n        });\n\n    },\n\n    /**\n     * The pane serves as a container for axes and backgrounds for circular\n     * gauges and polar charts.\n     * @since 2.3.0\n     * @optionparent pane\n     */\n    defaultOptions: {\n\n        /**\n         * The end angle of the polar X axis or gauge value axis, given in\n         * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)\n         * + 360.\n         *\n         * @type {Number}\n         * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n         *         VU-meter with custom start and end angle\n         * @since 2.3.0\n         * @product highcharts\n         * @apioption pane.endAngle\n         */\n\n        /**\n         * The center of a polar chart or angular gauge, given as an array\n         * of [x, y] positions. Positions can be given as integers that\n         * transform to pixels, or as percentages of the plot area size.\n         *\n         * @type {Array<String|Number>}\n         * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n         *         Two gauges with different center\n         * @default [\"50%\", \"50%\"]\n         * @since 2.3.0\n         * @product highcharts\n         */\n        center: ['50%', '50%'],\n\n        /**\n         * The size of the pane, either as a number defining pixels, or a\n         * percentage defining a percentage of the plot are.\n         *\n         * @type {Number|String}\n         * @sample {highcharts} highcharts/demo/gauge-vu-meter/ Smaller size\n         * @default 85%\n         * @product highcharts\n         */\n        size: '85%',\n\n        /**\n         * The start angle of the polar X axis or gauge axis, given in degrees\n         * where 0 is north. Defaults to 0.\n         *\n         * @type {Number}\n         * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n         *         VU-meter with custom start and end angle\n         * @since 2.3.0\n         * @product highcharts\n         */\n        startAngle: 0\n    },\n\n    /**\n     * An array of background items for the pane.\n     * @type {Array<Object>}\n     * @sample {highcharts} highcharts/demo/gauge-speedometer/\n     *         Speedometer gauge with multiple backgrounds\n     * @optionparent pane.background\n     */\n    defaultBackgroundOptions: {\n        /**\n         * The class name for this background.\n         *\n         * @type {String}\n         * @sample {highcharts} highcharts/css/pane/ Panes styled by CSS\n         * @sample {highstock} highcharts/css/pane/ Panes styled by CSS\n         * @sample {highmaps} highcharts/css/pane/ Panes styled by CSS\n         * @default highcharts-pane\n         * @since 5.0.0\n         * @apioption pane.background.className\n         */\n\n        /**\n         * The shape of the pane background. When `solid`, the background\n         * is circular. When `arc`, the background extends only from the min\n         * to the max of the value axis.\n         *\n         * @validvalue [\"solid\", \"arc\"]\n         * @type {String}\n         * @default solid\n         * @since 2.3.0\n         * @product highcharts\n         */\n        shape: 'circle',\n        \n\n        /** @ignore-option */\n        from: -Number.MAX_VALUE, // corrected to axis min\n\n        /**\n         * The inner radius of the pane background. Can be either numeric\n         * (pixels) or a percentage string.\n         *\n         * @type {Number|String}\n         * @default 0\n         * @since 2.3.0\n         * @product highcharts\n         */\n        innerRadius: 0,\n\n        /** @ignore-option */\n        to: Number.MAX_VALUE, // corrected to axis max\n\n        /**\n         * The outer radius of the circular pane background. Can be either\n         * numeric (pixels) or a percentage string.\n         *\n         * @type {Number|String}\n         * @default 105%\n         * @since 2.3.0\n         * @product highcharts\n         */\n        outerRadius: '105%'\n    },\n\n    /**\n     * Gets the center for the pane and its axis.\n     */\n    updateCenter: function (axis) {\n        this.center = (axis || this.axis || {}).center =\n            CenteredSeriesMixin.getCenter.call(this);\n    },\n\n    /**\n     * Destroy the pane item\n     * /\n    destroy: function () {\n        H.erase(this.chart.pane, this);\n        each(this.background, function (background) {\n            background.destroy();\n        });\n        this.background.length = 0;\n        this.group = this.group.destroy();\n    },\n    */\n\n    /**\n     * Update the pane item with new options\n     * @param  {Object} options New pane options\n     */\n    update: function (options, redraw) {\n\n        merge(true, this.options, options);\n        this.setOptions(this.options);\n        this.render();\n        each(this.chart.axes, function (axis) {\n            if (axis.pane === this) {\n                axis.pane = null;\n                axis.update({}, redraw);\n            }\n        }, this);\n    }\n\n});\n\n_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pane = Pane;\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/Pane.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/Polar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/Polar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Pointer.js */ \"./node_modules/highcharts/js/es-modules/parts/Pointer.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n/**\n * Extensions for polar charts. Additionally, much of the geometry required for\n * polar charts is gathered in RadialAxes.js.\n */\n\nvar each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Pointer = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n\n    seriesProto = Series.prototype,\n    pointerProto = Pointer.prototype,\n    colProto;\n\nif (!_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].polarExtended) {\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].polarExtended = true;\n\n\n    /**\n     * Search a k-d tree by the point angle, used for shared tooltips in polar\n     * charts\n     */\n    seriesProto.searchPointByAngle = function (e) {\n        var series = this,\n            chart = series.chart,\n            xAxis = series.xAxis,\n            center = xAxis.pane.center,\n            plotX = e.chartX - center[0] - chart.plotLeft,\n            plotY = e.chartY - center[1] - chart.plotTop;\n\n        return this.searchKDTree({\n            clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n        });\n\n    };\n\n    /**\n     * #6212 Calculate connectors for spline series in polar chart.\n     * @param {Boolean} calculateNeighbours\n     *        Check if connectors should be calculated for neighbour points as\n     *        well allows short recurence\n     */\n    seriesProto.getConnectors = function (\n        segment,\n        index,\n        calculateNeighbours,\n        connectEnds\n    ) {\n\n        var i,\n            prevPointInd,\n            nextPointInd,\n            previousPoint,\n            nextPoint,\n            previousX,\n            previousY,\n            nextX,\n            nextY,\n            plotX,\n            plotY,\n            ret,\n            // 1 means control points midway between points, 2 means 1/3 from\n            // the point, 3 is 1/4 etc;\n            smoothing = 1.5,\n            denom = smoothing + 1,\n            leftContX,\n            leftContY,\n            rightContX,\n            rightContY,\n            dLControlPoint, // distance left control point\n            dRControlPoint,\n            leftContAngle,\n            rightContAngle,\n            jointAngle,\n            addedNumber = connectEnds ? 1 : 0;\n\n        // Calculate final index of points depending on the initial index value.\n        // Because of calculating neighbours, index may be outisde segment\n        // array.\n        if (index >= 0 && index <= segment.length - 1) {\n            i = index;\n        } else if (index < 0) {\n            i = segment.length - 1 + index;\n        } else {\n            i = 0;\n        }\n\n        prevPointInd = (i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1;\n        nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1;\n        previousPoint = segment[prevPointInd];\n        nextPoint = segment[nextPointInd];\n        previousX = previousPoint.plotX;\n        previousY = previousPoint.plotY;\n        nextX = nextPoint.plotX;\n        nextY = nextPoint.plotY;\n        plotX = segment[i].plotX; // actual point\n        plotY = segment[i].plotY;\n        leftContX = (smoothing * plotX + previousX) / denom;\n        leftContY = (smoothing * plotY + previousY) / denom;\n        rightContX = (smoothing * plotX + nextX) / denom;\n        rightContY = (smoothing * plotY + nextY) / denom;\n        dLControlPoint = Math.sqrt(\n            Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)\n        );\n        dRControlPoint = Math.sqrt(\n            Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)\n        );\n        leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);\n        rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);\n        jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n        // Ensure the right direction, jointAngle should be in the same quadrant\n        // as leftContAngle\n        if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n            jointAngle -= Math.PI;\n        }\n        // Find the corrected control points for a spline straight through the\n        // point\n        leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;\n        leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;\n        rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;\n        rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;\n\n        // push current point's connectors into returned object\n\n        ret = {\n            rightContX: rightContX,\n            rightContY: rightContY,\n            leftContX: leftContX,\n            leftContY: leftContY,\n            plotX: plotX,\n            plotY: plotY\n        };\n\n        // calculate connectors for previous and next point and push them inside\n        // returned object\n        if (calculateNeighbours) {\n            ret.prevPointCont = this.getConnectors(\n                segment,\n                prevPointInd,\n                false,\n                connectEnds\n            );\n        }\n        return ret;\n    };\n\n    /**\n     * Wrap the buildKDTree function so that it searches by angle (clientX) in\n     * case of shared tooltip, and by two dimensional distance in case of\n     * non-shared.\n     */\n    wrap(seriesProto, 'buildKDTree', function (proceed) {\n        if (this.chart.polar) {\n            if (this.kdByAngle) {\n                this.searchPoint = this.searchPointByAngle;\n            } else {\n                this.options.findNearestPointBy = 'xy';\n            }\n        }\n        proceed.apply(this);\n    });\n\n    /**\n     * Translate a point's plotX and plotY from the internal angle and radius\n     * measures to true plotX, plotY coordinates\n     */\n    seriesProto.toXY = function (point) {\n        var xy,\n            chart = this.chart,\n            plotX = point.plotX,\n            plotY = point.plotY,\n            clientX;\n\n        // Save rectangular plotX, plotY for later computation\n        point.rectPlotX = plotX;\n        point.rectPlotY = plotY;\n\n        // Find the polar plotX and plotY\n        xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);\n        point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n        point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n\n        // If shared tooltip, record the angle in degrees in order to align X\n        // points. Otherwise, use a standard k-d tree to get the nearest point\n        // in two dimensions.\n        if (this.kdByAngle) {\n            clientX = (\n                (plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle\n            ) % 360;\n            if (clientX < 0) { // #2665\n                clientX += 360;\n            }\n            point.clientX = clientX;\n        } else {\n            point.clientX = point.plotX;\n        }\n    };\n\n    if (seriesTypes.spline) {\n        /**\n         * Overridden method for calculating a spline from one point to the next\n         */\n        wrap(\n            seriesTypes.spline.prototype,\n            'getPointSpline',\n            function (proceed, segment, point, i) {\n                var ret,\n                    connectors;\n\n                if (this.chart.polar) {\n                    // moveTo or lineTo\n                    if (!i) {\n                        ret = ['M', point.plotX, point.plotY];\n                    } else { // curve from last point to this\n                        connectors = this.getConnectors(\n                            segment,\n                            i,\n                            true,\n                            this.connectEnds\n                        );\n                        ret = [\n                            'C',\n                            connectors.prevPointCont.rightContX,\n                            connectors.prevPointCont.rightContY,\n                            connectors.leftContX,\n                            connectors.leftContY,\n                            connectors.plotX,\n                            connectors.plotY\n                        ];\n                    }\n                } else {\n                    ret = proceed.call(this, segment, point, i);\n                }\n                return ret;\n            }\n        );\n\n        // #6430 Areasplinerange series use unwrapped getPointSpline method, so\n        // we need to set this method again.\n        if (seriesTypes.areasplinerange) {\n            seriesTypes.areasplinerange.prototype.getPointSpline =\n                seriesTypes.spline.prototype.getPointSpline;\n        }\n    }\n\n    /**\n     * Extend translate. The plotX and plotY values are computed as if the polar\n     * chart were a cartesian plane, where plotX denotes the angle in radians\n     * and (yAxis.len - plotY) is the pixel distance from center.\n     */\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(Series, 'afterTranslate', function () {\n        var chart = this.chart,\n            points,\n            i;\n\n        if (chart.polar) {\n            // Postprocess plot coordinates\n            this.kdByAngle = chart.tooltip && chart.tooltip.shared;\n\n            if (!this.preventPostTranslate) {\n                points = this.points;\n                i = points.length;\n\n                while (i--) {\n                    // Translate plotX, plotY from angle and radius to true plot\n                    // coordinates\n                    this.toXY(points[i]);\n                }\n            }\n\n            // Perform clip after render\n            if (!this.hasClipCircleSetter) {\n                this.hasClipCircleSetter = Boolean(\n                    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(this, 'afterRender', function () {\n                        var circ;\n                        if (chart.polar) {\n                            circ = this.yAxis.center;\n                            this.group.clip(\n                                chart.renderer.clipCircle(\n                                    circ[0],\n                                    circ[1],\n                                    circ[2] / 2\n                                )\n                            );\n                            this.setClip = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop;\n                        }\n                    })\n                );\n            }\n        }\n    }, { order: 2 }); // Run after translation of ||-coords\n\n    /**\n     * Extend getSegmentPath to allow connecting ends across 0 to provide a\n     * closed circle in line-like series.\n     */\n    wrap(seriesProto, 'getGraphPath', function (proceed, points) {\n        var series = this,\n            i,\n            firstValid,\n            popLastPoint;\n\n        // Connect the path\n        if (this.chart.polar) {\n            points = points || this.points;\n\n            // Append first valid point in order to connect the ends\n            for (i = 0; i < points.length; i++) {\n                if (!points[i].isNull) {\n                    firstValid = i;\n                    break;\n                }\n            }\n\n\n            /**\n             * Polar charts only. Whether to connect the ends of a line series\n             * plot across the extremes.\n             *\n             * @type {Boolean}\n             * @sample {highcharts} highcharts/plotoptions/line-connectends-false/\n             *         Do not connect\n             * @since 2.3.0\n             * @product highcharts\n             * @apioption plotOptions.series.connectEnds\n             */\n            if (\n                this.options.connectEnds !== false &&\n                firstValid !== undefined\n            ) {\n                this.connectEnds = true; // re-used in splines\n                points.splice(points.length, 0, points[firstValid]);\n                popLastPoint = true;\n            }\n\n            // For area charts, pseudo points are added to the graph, now we\n            // need to translate these\n            each(points, function (point) {\n                if (point.polarPlotY === undefined) {\n                    series.toXY(point);\n                }\n            });\n        }\n\n        // Run uber method\n        var ret = proceed.apply(this, [].slice.call(arguments, 1));\n\n        // #6212 points.splice method is adding points to an array. In case of\n        // areaspline getGraphPath method is used two times and in both times\n        // points are added to an array. That is why points.pop is used, to get\n        // unmodified points.\n        if (popLastPoint) {\n            points.pop();\n        }\n        return ret;\n    });\n\n\n    var polarAnimate = function (proceed, init) {\n        var chart = this.chart,\n            animation = this.options.animation,\n            group = this.group,\n            markerGroup = this.markerGroup,\n            center = this.xAxis.center,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop,\n            attribs;\n\n        // Specific animation for polar charts\n        if (chart.polar) {\n\n            // Enable animation on polar charts only in SVG. In VML, the scaling\n            // is different, plus animation would be so slow it would't matter.\n            if (chart.renderer.isSVG) {\n\n                if (animation === true) {\n                    animation = {};\n                }\n\n                // Initialize the animation\n                if (init) {\n\n                    // Scale down the group and place it in the center\n                    attribs = {\n                        translateX: center[0] + plotLeft,\n                        translateY: center[1] + plotTop,\n                        scaleX: 0.001, // #1499\n                        scaleY: 0.001\n                    };\n\n                    group.attr(attribs);\n                    if (markerGroup) {\n                        markerGroup.attr(attribs);\n                    }\n\n                // Run the animation\n                } else {\n                    attribs = {\n                        translateX: plotLeft,\n                        translateY: plotTop,\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                    group.animate(attribs, animation);\n                    if (markerGroup) {\n                        markerGroup.animate(attribs, animation);\n                    }\n\n                    // Delete this function to allow it only once\n                    this.animate = null;\n                }\n            }\n\n        // For non-polar charts, revert to the basic animation\n        } else {\n            proceed.call(this, init);\n        }\n    };\n\n    // Define the animate method for regular series\n    wrap(seriesProto, 'animate', polarAnimate);\n\n\n    if (seriesTypes.column) {\n\n        colProto = seriesTypes.column.prototype;\n\n        colProto.polarArc = function (low, high, start, end) {\n            var center = this.xAxis.center,\n                len = this.yAxis.len;\n\n            return this.chart.renderer.symbols.arc(\n                center[0],\n                center[1],\n                len - high,\n                null,\n                {\n                    start: start,\n                    end: end,\n                    innerR: len - pick(low, len)\n                }\n            );\n        };\n\n        /**\n        * Define the animate method for columnseries\n        */\n        wrap(colProto, 'animate', polarAnimate);\n\n\n        /**\n         * Extend the column prototype's translate method\n         */\n        wrap(colProto, 'translate', function (proceed) {\n\n            var xAxis = this.xAxis,\n                startAngleRad = xAxis.startAngleRad,\n                start,\n                points,\n                point,\n                i;\n\n            this.preventPostTranslate = true;\n\n            // Run uber method\n            proceed.call(this);\n\n            // Postprocess plot coordinates\n            if (xAxis.isRadial) {\n                points = this.points;\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    start = point.barX + startAngleRad;\n                    point.shapeType = 'path';\n                    point.shapeArgs = {\n                        d: this.polarArc(\n                            point.yBottom,\n                            point.plotY,\n                            start,\n                            start + point.pointWidth\n                        )\n                    };\n                    // Provide correct plotX, plotY for tooltip\n                    this.toXY(point);\n                    point.tooltipPos = [point.plotX, point.plotY];\n                    point.ttBelow = point.plotY > xAxis.center[1];\n                }\n            }\n        });\n\n\n        /**\n         * Align column data labels outside the columns. #1199.\n         */\n        wrap(colProto, 'alignDataLabel', function (\n            proceed,\n            point,\n            dataLabel,\n            options,\n            alignTo,\n            isNew\n        ) {\n\n            if (this.chart.polar) {\n                var angle = point.rectPlotX / Math.PI * 180,\n                    align,\n                    verticalAlign;\n\n                // Align nicely outside the perimeter of the columns\n                if (options.align === null) {\n                    if (angle > 20 && angle < 160) {\n                        align = 'left'; // right hemisphere\n                    } else if (angle > 200 && angle < 340) {\n                        align = 'right'; // left hemisphere\n                    } else {\n                        align = 'center'; // top or bottom\n                    }\n                    options.align = align;\n                }\n                if (options.verticalAlign === null) {\n                    if (angle < 45 || angle > 315) {\n                        verticalAlign = 'bottom'; // top part\n                    } else if (angle > 135 && angle < 225) {\n                        verticalAlign = 'top'; // bottom part\n                    } else {\n                        verticalAlign = 'middle'; // left or right\n                    }\n                    options.verticalAlign = verticalAlign;\n                }\n\n                seriesProto.alignDataLabel.call(\n                    this,\n                    point,\n                    dataLabel,\n                    options,\n                    alignTo,\n                    isNew\n                );\n            } else {\n                proceed.call(this, point, dataLabel, options, alignTo, isNew);\n            }\n\n        });\n    }\n\n    /**\n     * Extend getCoordinates to prepare for polar axis values\n     */\n    wrap(pointerProto, 'getCoordinates', function (proceed, e) {\n        var chart = this.chart,\n            ret = {\n                xAxis: [],\n                yAxis: []\n            };\n\n        if (chart.polar) {\n\n            each(chart.axes, function (axis) {\n                var isXAxis = axis.isXAxis,\n                    center = axis.center,\n                    x = e.chartX - center[0] - chart.plotLeft,\n                    y = e.chartY - center[1] - chart.plotTop;\n\n                ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                    axis: axis,\n                    value: axis.translate(\n                        isXAxis ?\n                            Math.PI - Math.atan2(x, y) : // angle\n                            // distance from center\n                            Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)),\n                        true\n                    )\n                });\n            });\n\n        } else {\n            ret = proceed.call(this, e);\n        }\n\n        return ret;\n    });\n\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer.prototype.clipCircle = function (x, y, r) {\n        var wrapper,\n            id = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey(),\n\n            clipPath = this.createElement('clipPath').attr({\n                id: id\n            }).add(this.defs);\n\n        wrapper = this.circle(x, y, r).add(clipPath);\n        wrapper.id = id;\n        wrapper.clipPath = clipPath;\n\n        return wrapper;\n    };\n\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart, 'getAxes', function () {\n\n        if (!this.pane) {\n            this.pane = [];\n        }\n        each(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat(this.options.pane), function (paneOptions) {\n            new _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pane( // eslint-disable-line no-new\n                paneOptions,\n                this\n            );\n        }, this);\n    });\n\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart, 'afterDrawChartBox', function () {\n        each(this.pane, function (pane) {\n            pane.render();\n        });\n    });\n\n    /**\n     * Extend chart.get to also search in panes. Used internally in\n     * responsiveness and chart.update.\n     */\n    wrap(_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart.prototype, 'get', function (proceed, id) {\n        return _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(this.pane, function (pane) {\n            return pane.options.id === id;\n        }) || proceed.call(this, id);\n    });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/Polar.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/PolygonSeries.js":
/*!***************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/PolygonSeries.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Legend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _parts_ScatterSeries_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/ScatterSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar LegendSymbolMixin = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * A polygon series can be used to draw any freeform shape in the cartesian\n * coordinate system. A fill is applied with the `color` option, and\n * stroke is applied through `lineWidth` and `lineColor` options. Requires\n * the `highcharts-more.js` file.\n *\n * @type {Object}\n * @extends plotOptions.scatter\n * @excluding softThreshold,threshold\n * @sample {highcharts} highcharts/demo/polygon/ Polygon\n * @sample {highstock} highcharts/demo/polygon/ Polygon\n * @since 4.1.0\n * @product highcharts highstock\n * @optionparent plotOptions.polygon\n */\nseriesType('polygon', 'scatter', {\n    marker: {\n        enabled: false,\n        states: {\n            hover: {\n                enabled: false\n            }\n        }\n    },\n    stickyTracking: false,\n    tooltip: {\n        followPointer: true,\n        pointFormat: ''\n    },\n    trackByArea: true\n\n// Prototype members\n}, {\n    type: 'polygon',\n    getGraphPath: function () {\n\n        var graphPath = Series.prototype.getGraphPath.call(this),\n            i = graphPath.length + 1;\n\n        // Close all segments\n        while (i--) {\n            if ((i === graphPath.length || graphPath[i] === 'M') && i > 0) {\n                graphPath.splice(i, 0, 'z');\n            }\n        }\n        this.areaPath = graphPath;\n        return graphPath;\n    },\n    drawGraph: function () {\n        \n        seriesTypes.area.prototype.drawGraph.call(this);\n    },\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n    drawTracker: Series.prototype.drawTracker,\n    setStackedPoints: noop // No stacking points on polygons (#5310)\n});\n\n\n\n/**\n * A `polygon` series. If the [type](#series.polygon.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.polygon\n * @excluding dataParser,dataURL,stack\n * @product highcharts highstock\n * @apioption series.polygon\n */\n\n/**\n * An array of data points for the series. For the `polygon` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 10],\n *         [1, 3],\n *         [2, 1]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.polygon.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 1,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 8,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Array>}\n * @extends series.line.data\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts highstock\n * @apioption series.polygon.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/PolygonSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/RadialAxis.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/RadialAxis.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _parts_Tick_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Tick.js */ \"./node_modules/highcharts/js/es-modules/parts/Tick.js\");\n/* harmony import */ var _Pane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pane.js */ \"./node_modules/highcharts/js/es-modules/parts-more/Pane.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar addEvent = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    each = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    map = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    Tick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick,\n    wrap = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n    correctFloat = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n\n\n    hiddenAxisMixin, // @todo Extract this to a new file\n    radialAxisMixin, // @todo Extract this to a new file\n    axisProto = Axis.prototype,\n    tickProto = Tick.prototype;\n\nif (!_parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radialAxisExtended) {\n    _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radialAxisExtended = true;\n\n    /**\n     * Augmented methods for the x axis in order to hide it completely, used for\n     * the X axis in gauges\n     */\n    hiddenAxisMixin = {\n        getOffset: noop,\n        redraw: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        render: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        setScale: noop,\n        setCategories: noop,\n        setTitle: noop\n    };\n\n    /**\n     * Augmented methods for the value axis\n     */\n    radialAxisMixin = {\n\n        /**\n         * The default options extend defaultYAxisOptions\n         */\n        defaultRadialGaugeOptions: {\n            labels: {\n                align: 'center',\n                x: 0,\n                y: null // auto\n            },\n            minorGridLineWidth: 0,\n            minorTickInterval: 'auto',\n            minorTickLength: 10,\n            minorTickPosition: 'inside',\n            minorTickWidth: 1,\n            tickLength: 10,\n            tickPosition: 'inside',\n            tickWidth: 2,\n            title: {\n                rotation: 0\n            },\n            zIndex: 2 // behind dials, points in the series group\n        },\n\n        // Circular axis around the perimeter of a polar chart\n        defaultRadialXOptions: {\n            gridLineWidth: 1, // spokes\n            labels: {\n                align: null, // auto\n                distance: 15,\n                x: 0,\n                y: null, // auto\n                style: {\n                    textOverflow: 'none' // wrap lines by default (#7248)\n                }\n            },\n            maxPadding: 0,\n            minPadding: 0,\n            showLastLabel: false,\n            tickLength: 0\n        },\n\n        // Radial axis, like a spoke in a polar chart\n        defaultRadialYOptions: {\n            gridLineInterpolation: 'circle',\n            labels: {\n                align: 'right',\n                x: -3,\n                y: -2\n            },\n            showLastLabel: false,\n            title: {\n                x: 4,\n                text: null,\n                rotation: 90\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n\n            var options = this.options = merge(\n                this.defaultOptions,\n                this.defaultRadialOptions,\n                userOptions\n            );\n\n            // Make sure the plotBands array is instanciated for each Axis\n            // (#2649)\n            if (!options.plotBands) {\n                options.plotBands = [];\n            }\n\n            _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent(this, 'afterSetOptions');\n\n        },\n\n        /**\n         * Wrap the getOffset method to return zero offset for title or labels\n         * in a radial axis\n         */\n        getOffset: function () {\n            // Call the Axis prototype method (the method we're in now is on the\n            // instance)\n            axisProto.getOffset.call(this);\n\n            // Title or label offsets are not counted\n            this.chart.axisOffset[this.side] = 0;\n\n        },\n\n\n        /**\n         * Get the path for the axis line. This method is also referenced in the\n         * getPlotLinePath method.\n         */\n        getLinePath: function (lineWidth, radius) {\n            var center = this.center,\n                end,\n                chart = this.chart,\n                r = pick(radius, center[2] / 2 - this.offset),\n                path;\n\n            if (this.isCircular || radius !== undefined) {\n                path = this.chart.renderer.symbols.arc(\n                    this.left + center[0],\n                    this.top + center[1],\n                    r,\n                    r,\n                    {\n                        start: this.startAngleRad,\n                        end: this.endAngleRad,\n                        open: true,\n                        innerR: 0\n                    }\n                );\n\n                // Bounds used to position the plotLine label next to the line\n                // (#7117)\n                path.xBounds = [this.left + center[0]];\n                path.yBounds = [this.top + center[1] - r];\n\n            } else {\n                end = this.postTranslate(this.angleRad, r);\n                path = [\n                    'M',\n                    center[0] + chart.plotLeft,\n                    center[1] + chart.plotTop,\n                    'L',\n                    end.x,\n                    end.y\n                ];\n            }\n            return path;\n        },\n\n        /**\n         * Override setAxisTranslation by setting the translation to the\n         * difference in rotation. This allows the translate method to return\n         * angle for any given value.\n         */\n        setAxisTranslation: function () {\n\n            // Call uber method\n            axisProto.setAxisTranslation.call(this);\n\n            // Set transA and minPixelPadding\n            if (this.center) { // it's not defined the first time\n                if (this.isCircular) {\n\n                    this.transA = (this.endAngleRad - this.startAngleRad) /\n                        ((this.max - this.min) || 1);\n\n\n                } else {\n                    this.transA = (\n                        (this.center[2] / 2) /\n                        ((this.max - this.min) || 1)\n                    );\n                }\n\n                if (this.isXAxis) {\n                    this.minPixelPadding = this.transA * this.minPointOffset;\n                } else {\n                    // This is a workaround for regression #2593, but categories\n                    // still don't position correctly.\n                    this.minPixelPadding = 0;\n                }\n            }\n        },\n\n        /**\n         * In case of auto connect, add one closestPointRange to the max value\n         * right before tickPositions are computed, so that ticks will extend\n         * passed the real max.\n         */\n        beforeSetTickPositions: function () {\n            // If autoConnect is true, polygonal grid lines are connected, and\n            // one closestPointRange is added to the X axis to prevent the last\n            // point from overlapping the first.\n            this.autoConnect = (\n                this.isCircular &&\n                pick(this.userMax, this.options.max) === undefined &&\n                correctFloat(this.endAngleRad - this.startAngleRad) ===\n                correctFloat(2 * Math.PI)\n            );\n\n            if (this.autoConnect) {\n                this.max += (\n                    (this.categories && 1) ||\n                    this.pointRange ||\n                    this.closestPointRange ||\n                    0\n                ); // #1197, #2260\n            }\n        },\n\n        /**\n         * Override the setAxisSize method to use the arc's circumference as\n         * length. This allows tickPixelInterval to apply to pixel lengths along\n         * the perimeter\n         */\n        setAxisSize: function () {\n\n            axisProto.setAxisSize.call(this);\n\n            if (this.isRadial) {\n\n                // Set the center array\n                this.pane.updateCenter(this);\n\n                // The sector is used in Axis.translate to compute the\n                // translation of reversed axis points (#2570)\n                if (this.isCircular) {\n                    this.sector = this.endAngleRad - this.startAngleRad;\n                }\n\n                // Axis len is used to lay out the ticks\n                this.len = this.width = this.height =\n                    this.center[2] * pick(this.sector, 1) / 2;\n\n            }\n        },\n\n        /**\n         * Returns the x, y coordinate of a point given by a value and a pixel\n         * distance from center\n         */\n        getPosition: function (value, length) {\n            return this.postTranslate(\n                this.isCircular ?\n                    this.translate(value) :\n                    this.angleRad, // #2848\n                pick(\n                    this.isCircular ? length : this.translate(value),\n                    this.center[2] / 2\n                ) - this.offset\n            );\n        },\n\n        /**\n         * Translate from intermediate plotX (angle), plotY (axis.len - radius)\n         * to final chart coordinates.\n         */\n        postTranslate: function (angle, radius) {\n\n            var chart = this.chart,\n                center = this.center;\n\n            angle = this.startAngleRad + angle;\n\n            return {\n                x: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n                y: chart.plotTop + center[1] + Math.sin(angle) * radius\n            };\n\n        },\n\n        /**\n         * Find the path for plot bands along the radial axis\n         */\n        getPlotBandPath: function (from, to, options) {\n            var center = this.center,\n                startAngleRad = this.startAngleRad,\n                fullRadius = center[2] / 2,\n                radii = [\n                    pick(options.outerRadius, '100%'),\n                    options.innerRadius,\n                    pick(options.thickness, 10)\n                ],\n                offset = Math.min(this.offset, 0),\n                percentRegex = /%$/,\n                start,\n                end,\n                open,\n                isCircular = this.isCircular, // X axis in a polar chart\n                ret;\n\n            // Polygonal plot bands\n            if (this.options.gridLineInterpolation === 'polygon') {\n                ret = this.getPlotLinePath(from).concat(\n                    this.getPlotLinePath(to, true)\n                );\n\n            // Circular grid bands\n            } else {\n\n                // Keep within bounds\n                from = Math.max(from, this.min);\n                to = Math.min(to, this.max);\n\n                // Plot bands on Y axis (radial axis) - inner and outer radius\n                // depend on to and from\n                if (!isCircular) {\n                    radii[0] = this.translate(from);\n                    radii[1] = this.translate(to);\n                }\n\n                // Convert percentages to pixel values\n                radii = map(radii, function (radius) {\n                    if (percentRegex.test(radius)) {\n                        radius = (pInt(radius, 10) * fullRadius) / 100;\n                    }\n                    return radius;\n                });\n\n                // Handle full circle\n                if (options.shape === 'circle' || !isCircular) {\n                    start = -Math.PI / 2;\n                    end = Math.PI * 1.5;\n                    open = true;\n                } else {\n                    start = startAngleRad + this.translate(from);\n                    end = startAngleRad + this.translate(to);\n                }\n\n                radii[0] -= offset; // #5283\n                radii[2] -= offset; // #5283\n\n                ret = this.chart.renderer.symbols.arc(\n                    this.left + center[0],\n                    this.top + center[1],\n                    radii[0],\n                    radii[0],\n                    {\n                        // Math is for reversed yAxis (#3606)\n                        start: Math.min(start, end),\n                        end: Math.max(start, end),\n                        innerR: pick(radii[1], radii[0] - radii[2]),\n                        open: open\n                    }\n                );\n            }\n\n            return ret;\n        },\n\n        /**\n         * Find the path for plot lines perpendicular to the radial axis.\n         */\n        getPlotLinePath: function (value, reverse) {\n            var axis = this,\n                center = axis.center,\n                chart = axis.chart,\n                end = axis.getPosition(value),\n                xAxis,\n                xy,\n                tickPositions,\n                ret;\n\n            // Spokes\n            if (axis.isCircular) {\n                ret = [\n                    'M',\n                    center[0] + chart.plotLeft,\n                    center[1] + chart.plotTop,\n                    'L',\n                    end.x,\n                    end.y\n                ];\n\n            // Concentric circles\n            } else if (axis.options.gridLineInterpolation === 'circle') {\n                value = axis.translate(value);\n                if (value) { // a value of 0 is in the center\n                    ret = axis.getLinePath(0, value);\n                }\n            // Concentric polygons\n            } else {\n                // Find the X axis in the same pane\n                each(chart.xAxis, function (a) {\n                    if (a.pane === axis.pane) {\n                        xAxis = a;\n                    }\n                });\n                ret = [];\n                value = axis.translate(value);\n                tickPositions = xAxis.tickPositions;\n                if (xAxis.autoConnect) {\n                    tickPositions = tickPositions.concat([tickPositions[0]]);\n                }\n                // Reverse the positions for concatenation of polygonal plot\n                // bands\n                if (reverse) {\n                    tickPositions = [].concat(tickPositions).reverse();\n                }\n\n                each(tickPositions, function (pos, i) {\n                    xy = xAxis.getPosition(pos, value);\n                    ret.push(i ? 'L' : 'M', xy.x, xy.y);\n                });\n\n            }\n            return ret;\n        },\n\n        /**\n         * Find the position for the axis title, by default inside the gauge\n         */\n        getTitlePosition: function () {\n            var center = this.center,\n                chart = this.chart,\n                titleOptions = this.options.title;\n\n            return {\n                x: chart.plotLeft + center[0] + (titleOptions.x || 0),\n                y: (\n                    chart.plotTop +\n                    center[1] -\n                    (\n                        {\n                            high: 0.5,\n                            middle: 0.25,\n                            low: 0\n                        }[titleOptions.align] * center[2]\n                    ) +\n                    (titleOptions.y || 0)\n                )\n            };\n        }\n\n    };\n\n    /**\n     * Actions before axis init.\n     */\n    addEvent(Axis, 'init', function (e) {\n        var chart = this.chart,\n            angular = chart.angular,\n            polar = chart.polar,\n            isX = this.isXAxis,\n            isHidden = angular && isX,\n            isCircular,\n            chartOptions = chart.options,\n            paneIndex = e.userOptions.pane || 0,\n            pane = this.pane = chart.pane && chart.pane[paneIndex];\n\n        // Before prototype.init\n        if (angular) {\n            extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);\n            isCircular = !isX;\n            if (isCircular) {\n                this.defaultRadialOptions = this.defaultRadialGaugeOptions;\n            }\n\n        } else if (polar) {\n            extend(this, radialAxisMixin);\n            isCircular = isX;\n            this.defaultRadialOptions = isX ?\n                this.defaultRadialXOptions :\n                merge(this.defaultYAxisOptions, this.defaultRadialYOptions);\n\n        }\n\n        // Disable certain features on angular and polar axes\n        if (angular || polar) {\n            this.isRadial = true;\n            chart.inverted = false;\n            chartOptions.chart.zoomType = null;\n        } else {\n            this.isRadial = false;\n        }\n\n        // A pointer back to this axis to borrow geometry\n        if (pane && isCircular) {\n            pane.axis = this;\n        }\n\n        this.isCircular = isCircular;\n\n    });\n\n    addEvent(Axis, 'afterInit', function () {\n\n        var chart = this.chart,\n            options = this.options,\n            isHidden = chart.angular && this.isXAxis,\n            pane = this.pane,\n            paneOptions = pane && pane.options;\n\n        if (!isHidden && pane && (chart.angular || chart.polar)) {\n\n            // Start and end angle options are\n            // given in degrees relative to top, while internal computations are\n            // in radians relative to right (like SVG).\n\n            // Y axis in polar charts\n            this.angleRad = (options.angle || 0) * Math.PI / 180;\n            // Gauges\n            this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;\n            this.endAngleRad = (\n                pick(paneOptions.endAngle, paneOptions.startAngle + 360) - 90\n            ) * Math.PI / 180; // Gauges\n            this.offset = options.offset || 0;\n\n        }\n\n    });\n\n    /**\n     * Wrap auto label align to avoid setting axis-wide rotation on radial axes\n     * (#4920)\n     * @param   {Function} proceed\n     * @returns {String} Alignment\n     */\n    wrap(axisProto, 'autoLabelAlign', function (proceed) {\n        if (!this.isRadial) {\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        } // else return undefined\n    });\n\n    /**\n     * Add special cases within the Tick class' methods for radial axes.\n     */\n    addEvent(Tick, 'afterGetPosition', function (e) {\n        if (this.axis.getPosition) {\n            extend(e.pos, this.axis.getPosition(this.pos));\n        }\n    });\n\n    /**\n     * Find the center position of the label based on the distance option.\n     */\n    addEvent(Tick, 'afterGetLabelPosition', function (e) {\n        var axis = this.axis,\n            label = this.label,\n            labelOptions = axis.options.labels,\n            optionsY = labelOptions.y,\n            ret,\n            centerSlot = 20, // 20 degrees to each side at the top and bottom\n            align = labelOptions.align,\n            angle = (\n                (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) /\n                Math.PI * 180\n            ) % 360;\n\n        if (axis.isRadial) { // Both X and Y axes in a polar chart\n            ret = axis.getPosition(this.pos, (axis.center[2] / 2) +\n                pick(labelOptions.distance, -25));\n\n            // Automatically rotated\n            if (labelOptions.rotation === 'auto') {\n                label.attr({\n                    rotation: angle\n                });\n\n            // Vertically centered\n            } else if (optionsY === null) {\n                optionsY = (\n                    axis.chart.renderer\n                        .fontMetrics(label.styles && label.styles.fontSize).b -\n                    label.getBBox().height / 2\n                );\n            }\n\n            // Automatic alignment\n            if (align === null) {\n                if (axis.isCircular) { // Y axis\n                    if (\n                        this.label.getBBox().width >\n                        axis.len * axis.tickInterval / (axis.max - axis.min)\n                    ) { // #3506\n                        centerSlot = 0;\n                    }\n                    if (angle > centerSlot && angle < 180 - centerSlot) {\n                        align = 'left'; // right hemisphere\n                    } else if (\n                        angle > 180 + centerSlot &&\n                        angle < 360 - centerSlot\n                    ) {\n                        align = 'right'; // left hemisphere\n                    } else {\n                        align = 'center'; // top or bottom\n                    }\n                } else {\n                    align = 'center';\n                }\n                label.attr({\n                    align: align\n                });\n            }\n\n            e.pos.x = ret.x + labelOptions.x;\n            e.pos.y = ret.y + optionsY;\n\n        }\n    });\n\n    /**\n     * Wrap the getMarkPath function to return the path of the radial marker\n     */\n    wrap(tickProto, 'getMarkPath', function (\n        proceed,\n        x,\n        y,\n        tickLength,\n        tickWidth,\n        horiz,\n        renderer\n    ) {\n        var axis = this.axis,\n            endPoint,\n            ret;\n\n        if (axis.isRadial) {\n            endPoint = axis.getPosition(\n                this.pos,\n                axis.center[2] / 2 + tickLength\n            );\n            ret = [\n                'M',\n                x,\n                y,\n                'L',\n                endPoint.x,\n                endPoint.y\n            ];\n        } else {\n            ret = proceed.call(\n                this,\n                x,\n                y,\n                tickLength,\n                tickWidth,\n                horiz,\n                renderer\n            );\n        }\n        return ret;\n    });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/RadialAxis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts-more/WaterfallSeries.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts-more/WaterfallSeries.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _parts_Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _parts_Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _parts_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _parts_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar correctFloat = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    isNumber = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    pick = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _parts_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * A waterfall chart displays sequentially introduced positive or negative\n * values in cumulative columns.\n *\n * @sample       highcharts/demo/waterfall/\n *               Waterfall chart\n * @sample       highcharts/plotoptions/waterfall-inverted/\n *               Horizontal (inverted) waterfall\n * @sample       highcharts/plotoptions/waterfall-stacked/\n *               Stacked waterfall chart\n * @extends      {plotOptions.column}\n * @product      highcharts\n * @optionparent plotOptions.waterfall\n */\nseriesType('waterfall', 'column', {\n\n    /**\n     * The color used specifically for positive point columns. When not\n     * specified, the general series color is used.\n     *\n     * In styled mode, the waterfall colors can be set with the\n     * `.highcharts-point-negative`, `.highcharts-sum` and\n     * `.highcharts-intermediate-sum` classes.\n     *\n     * @type      {Color}\n     * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall\n     * @product   highcharts\n     * @apioption plotOptions.waterfall.upColor\n     */\n\n    dataLabels: {\n        inside: true\n    },\n    \n\n// Prototype members\n}, {\n    pointValKey: 'y',\n\n    /**\n     * Property needed to prevent lines between the columns from disappearing\n     * when negativeColor is used.\n     */\n    showLine: true,\n\n    /**\n     * After generating points, set y-values for all sums.\n     */\n    generatePoints: function () {\n        var previousIntermediate = this.options.threshold,\n            point,\n            len,\n            i,\n            y;\n        // Parent call:\n        seriesTypes.column.prototype.generatePoints.apply(this);\n\n        for (i = 0, len = this.points.length; i < len; i++) {\n            point = this.points[i];\n            y = this.processedYData[i];\n            // override point value for sums\n            // #3710 Update point does not propagate to sum\n            if (point.isSum) {\n                point.y = correctFloat(y);\n            } else if (point.isIntermediateSum) {\n                point.y = correctFloat(y - previousIntermediate); // #3840\n                previousIntermediate = y;\n            }\n        }\n    },\n\n    /**\n     * Translate data points from raw values\n     */\n    translate: function () {\n        var series = this,\n            options = series.options,\n            yAxis = series.yAxis,\n            len,\n            i,\n            points,\n            point,\n            shapeArgs,\n            stack,\n            y,\n            yValue,\n            previousY,\n            previousIntermediate,\n            range,\n            minPointLength = pick(options.minPointLength, 5),\n            halfMinPointLength = minPointLength / 2,\n            threshold = options.threshold,\n            stacking = options.stacking,\n            stackIndicator,\n            tooltipY;\n\n        // run column series translate\n        seriesTypes.column.prototype.translate.apply(series);\n\n        previousY = previousIntermediate = threshold;\n        points = series.points;\n\n        for (i = 0, len = points.length; i < len; i++) {\n            // cache current point object\n            point = points[i];\n            yValue = series.processedYData[i];\n            shapeArgs = point.shapeArgs;\n\n            // get current stack\n            stack = stacking &&\n                yAxis.stacks[\n                    (series.negStacks && yValue < threshold ? '-' : '') +\n                        series.stackKey\n                ];\n            stackIndicator = series.getStackIndicator(\n                stackIndicator,\n                point.x,\n                series.index\n            );\n            range = pick(\n                stack && stack[point.x].points[stackIndicator.key],\n                [0, yValue]\n            );\n\n            // up points\n            y = Math.max(previousY, previousY + point.y) + range[0];\n            shapeArgs.y = yAxis.translate(y, 0, 1, 0, 1);\n\n            // sum points\n            if (point.isSum) {\n                shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);\n                shapeArgs.height = Math.min(\n                        yAxis.translate(range[0], 0, 1, 0, 1),\n                        yAxis.len\n                    ) - shapeArgs.y; // #4256\n\n            } else if (point.isIntermediateSum) {\n                shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);\n                shapeArgs.height = Math.min(\n                        yAxis.translate(previousIntermediate, 0, 1, 0, 1),\n                        yAxis.len\n                    ) - shapeArgs.y;\n                previousIntermediate = range[1];\n\n            // If it's not the sum point, update previous stack end position\n            // and get shape height (#3886)\n            } else {\n                shapeArgs.height = yValue > 0 ?\n                    yAxis.translate(previousY, 0, 1, 0, 1) - shapeArgs.y :\n                    yAxis.translate(previousY, 0, 1, 0, 1) -\n                        yAxis.translate(previousY - yValue, 0, 1, 0, 1);\n\n                previousY += stack && stack[point.x] ?\n                    stack[point.x].total :\n                    yValue;\n\n                point.below = previousY < pick(threshold, 0);\n            }\n\n            // #3952 Negative sum or intermediate sum not rendered correctly\n            if (shapeArgs.height < 0) {\n                shapeArgs.y += shapeArgs.height;\n                shapeArgs.height *= -1;\n            }\n\n            point.plotY = shapeArgs.y = Math.round(shapeArgs.y) -\n                (series.borderWidth % 2) / 2;\n            // #3151\n            shapeArgs.height = Math.max(Math.round(shapeArgs.height), 0.001);\n            point.yBottom = shapeArgs.y + shapeArgs.height;\n\n            if (shapeArgs.height <= minPointLength && !point.isNull) {\n                shapeArgs.height = minPointLength;\n                shapeArgs.y -= halfMinPointLength;\n                point.plotY = shapeArgs.y;\n                if (point.y < 0) {\n                    point.minPointLengthOffset = -halfMinPointLength;\n                } else {\n                    point.minPointLengthOffset = halfMinPointLength;\n                }\n            } else {\n                if (point.isNull) {\n                    shapeArgs.width = 0;\n                }\n                point.minPointLengthOffset = 0;\n            }\n\n            // Correct tooltip placement (#3014)\n            tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);\n\n            if (series.chart.inverted) {\n                point.tooltipPos[0] = yAxis.len - tooltipY;\n            } else {\n                point.tooltipPos[1] = tooltipY;\n            }\n        }\n    },\n\n    /**\n     * Call default processData then override yData to reflect\n     * waterfall's extremes on yAxis\n     */\n    processData: function (force) {\n        var series = this,\n            options = series.options,\n            yData = series.yData,\n            // #3710 Update point does not propagate to sum\n            points = series.options.data,\n            point,\n            dataLength = yData.length,\n            threshold = options.threshold || 0,\n            subSum,\n            sum,\n            dataMin,\n            dataMax,\n            y,\n            i;\n\n        sum = subSum = dataMin = dataMax = threshold;\n\n        for (i = 0; i < dataLength; i++) {\n            y = yData[i];\n            point = points && points[i] ? points[i] : {};\n\n            if (y === 'sum' || point.isSum) {\n                yData[i] = correctFloat(sum);\n            } else if (y === 'intermediateSum' || point.isIntermediateSum) {\n                yData[i] = correctFloat(subSum);\n            } else {\n                sum += y;\n                subSum += y;\n            }\n            dataMin = Math.min(sum, dataMin);\n            dataMax = Math.max(sum, dataMax);\n        }\n\n        Series.prototype.processData.call(this, force);\n\n        // Record extremes only if stacking was not set:\n        if (!series.options.stacking) {\n            series.dataMin = dataMin;\n            series.dataMax = dataMax;\n        }\n    },\n\n    /**\n     * Return y value or string if point is sum\n     */\n    toYData: function (pt) {\n        if (pt.isSum) {\n            // #3245 Error when first element is Sum or Intermediate Sum\n            return (pt.x === 0 ? null : 'sum');\n        }\n        if (pt.isIntermediateSum) {\n            return (pt.x === 0 ? null : 'intermediateSum'); // #3245\n        }\n        return pt.y;\n    },\n\n    \n\n    /**\n     * Return an empty path initially, because we need to know the\n     * stroke-width in order to set the final path.\n     */\n    getGraphPath: function () {\n        return ['M', 0, 0];\n    },\n\n    /**\n     * Draw columns' connector lines\n     */\n    getCrispPath: function () {\n\n        var data = this.data,\n            length = data.length,\n            lineWidth = this.graph.strokeWidth() + this.borderWidth,\n            normalizer = Math.round(lineWidth) % 2 / 2,\n            reversedXAxis = this.xAxis.reversed,\n            reversedYAxis = this.yAxis.reversed,\n            path = [],\n            prevArgs,\n            pointArgs,\n            i,\n            d;\n\n        for (i = 1; i < length; i++) {\n            pointArgs = data[i].shapeArgs;\n            prevArgs = data[i - 1].shapeArgs;\n\n            d = [\n                'M',\n                prevArgs.x + (reversedXAxis ? 0 : prevArgs.width),\n                prevArgs.y + data[i - 1].minPointLengthOffset + normalizer,\n                'L',\n                pointArgs.x + (reversedXAxis ? prevArgs.width : 0),\n                prevArgs.y + data[i - 1].minPointLengthOffset + normalizer\n            ];\n\n            if (\n                (data[i - 1].y < 0 && !reversedYAxis) ||\n                (data[i - 1].y > 0 && reversedYAxis)\n            ) {\n                d[2] += prevArgs.height;\n                d[5] += prevArgs.height;\n            }\n\n            path = path.concat(d);\n        }\n\n        return path;\n    },\n\n    /**\n     * The graph is initially drawn with an empty definition, then updated with\n     * crisp rendering.\n     */\n    drawGraph: function () {\n        Series.prototype.drawGraph.call(this);\n        this.graph.attr({\n            d: this.getCrispPath()\n        });\n    },\n\n    /**\n     * Waterfall has stacking along the x-values too.\n     */\n    setStackedPoints: function () {\n        var series = this,\n            options = series.options,\n            stackedYLength,\n            i;\n\n        Series.prototype.setStackedPoints.apply(series, arguments);\n\n        stackedYLength = series.stackedYData ? series.stackedYData.length : 0;\n\n        // Start from the second point:\n        for (i = 1; i < stackedYLength; i++) {\n            if (\n                !options.data[i].isSum &&\n                !options.data[i].isIntermediateSum\n            ) {\n                // Sum previous stacked data as waterfall can grow up/down:\n                series.stackedYData[i] += series.stackedYData[i - 1];\n            }\n        }\n    },\n\n    /**\n     * Extremes for a non-stacked series are recorded in processData.\n     * In case of stacking, use Series.stackedYData to calculate extremes.\n     */\n    getExtremes: function () {\n        if (this.options.stacking) {\n            return Series.prototype.getExtremes.apply(this, arguments);\n        }\n    }\n\n\n// Point members\n}, {\n    getClassName: function () {\n        var className = Point.prototype.getClassName.call(this);\n\n        if (this.isSum) {\n            className += ' highcharts-sum';\n        } else if (this.isIntermediateSum) {\n            className += ' highcharts-intermediate-sum';\n        }\n        return className;\n    },\n    /**\n     * Pass the null test in ColumnSeries.translate.\n     */\n    isValid: function () {\n        return isNumber(this.y, true) || this.isSum || this.isIntermediateSum;\n    }\n\n});\n\n/**\n * A `waterfall` series. If the [type](#series.waterfall.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.waterfall\n * @excluding dataParser,dataURL\n * @product   highcharts\n * @apioption series.waterfall\n */\n\n/**\n * An array of data points for the series. For the `waterfall` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 7],\n *         [1, 8],\n *         [2, 3]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series'\n * [turboThreshold](#series.waterfall.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 8,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 8,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.waterfall.data\n */\n\n\n/**\n * When this property is true, the points acts as a summary column for\n * the values added or substracted since the last intermediate sum,\n * or since the start of the series. The `y` value is ignored.\n *\n * @type      {Boolean}\n * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall\n * @default   false\n * @product   highcharts\n * @apioption series.waterfall.data.isIntermediateSum\n */\n\n/**\n * When this property is true, the point display the total sum across\n * the entire series. The `y` value is ignored.\n *\n * @type      {Boolean}\n * @sample    {highcharts} highcharts/demo/waterfall/ Waterfall\n * @default   false\n * @product   highcharts\n * @apioption series.waterfall.data.isSum\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts-more/WaterfallSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/AreaSeries.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/AreaSeries.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    LegendSymbolMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType;\n\n/**\n * Area series type.\n *\n * @ignore\n * @constructor Highcharts.seriesTypes.area\n * @implements  {Highcharts.Series}\n */\nseriesType('area', 'line', {\n\n    /**\n     * The area series type.\n     *\n     * @sample {highcharts} highcharts/demo/area-basic/\n     *         Area chart\n     * @sample {highstock} stock/demo/area/\n     *         Area chart\n     *\n     * @type          {*}\n     * @extends       plotOptions.line\n     * @product       highcharts highstock\n     * @optionparent  plotOptions.area\n     */\n\n    /**\n     * Fill color or gradient for the area. When `null`, the series' `color`\n     * is used with the series' `fillOpacity`.\n     *\n     * In styled mode, the fill color can be set with the `.highcharts-area`\n     * class name.\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/\n     *         Null by default\n     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/\n     *         Gradient\n     *\n     * @type       {Highcharts.ColorString}\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.fillColor\n     */\n\n    /**\n     * Fill opacity for the area. When you set an explicit `fillColor`,\n     * the `fillOpacity` is not applied. Instead, you should define the\n     * opacity in the `fillColor` with an rgba color definition. The\n     * `fillOpacity` setting, also the default setting, overrides the alpha\n     * component of the `color` setting.\n     *\n     * In styled mode, the fill opacity can be set with the `.highcharts-area`\n     * class name.\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-fillopacity/\n     *         Automatic fill color and fill opacity of 0.1\n     *\n     * @type       {number}\n     * @default    {highcharts} 0.75\n     * @default    {highstock} .75\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.fillOpacity\n     */\n\n    /**\n     * A separate color for the graph line. By default the line takes the\n     * `color` of the series, but the lineColor setting allows setting a\n     * separate color for the line without altering the `fillColor`.\n     *\n     * In styled mode, the line stroke can be set with the `.highcharts-graph`\n     * class name.\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-linecolor/\n     *         Dark gray line\n     *\n     * @type       {Highcharts.ColorString}\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.lineColor\n     */\n\n    /**\n     * A separate color for the negative part of the area.\n     *\n     * In styled mode, a negative color is set with the `.highcharts-negative`\n     * class name.\n     *\n     * @see [negativeColor](#plotOptions.area.negativeColor)\n     *\n     * @sample {highcharts} highcharts/css/series-negative-color/\n     *         Negative color in styled mode\n     *\n     * @type       {Highcharts.ColorString}\n     * @since      3.0\n     * @product    highcharts\n     * @apioption  plotOptions.area.negativeFillColor\n     */\n\n    /**\n     * Whether the whole area or just the line should respond to mouseover\n     * tooltips and other mouse or touch events.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/\n     *         Display the tooltip when the area is hovered\n     *\n     * @type       {boolean}\n     * @default    false\n     * @since      1.1.6\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.trackByArea\n     */\n\n    /**\n     * When this is true, the series will not cause the Y axis to cross\n     * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n     * unless the data actually crosses the plane.\n     *\n     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n     * 3 will make the Y axis show negative values according to the `minPadding`\n     * option. If `softThreshold` is `true`, the Y axis starts at 0.\n     *\n     * @type       {boolean}\n     * @since      4.1.9\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.softThreshold\n     */\n    softThreshold: false,\n\n    /**\n     * The Y axis value to serve as the base for the area, for distinguishing\n     * between values above and below a threshold. The area between the graph\n     * and the threshold is filled.\n     *\n     * * If a number is given, the Y axis will scale to the threshold.\n     * * If `null`, the scaling behaves like a line series with fill between the\n     *   graph and the Y axis minimum.\n     * * If `Infinity` or `-Infinity`, the area between the graph and the\n     *   corresponing Y axis extreme is filled (since v6.1.0).\n     *\n     * @sample  {highcharts} highcharts/plotoptions/area-threshold/\n     *          A threshold of 100\n     * @sample  {highcharts} highcharts/plotoptions/area-threshold-infinity/\n     *          A threshold of Infinity\n     *\n     * @type       {number}\n     * @since      2.0\n     * @product    highcharts highstock\n     * @apioption  plotOptions.area.threshold\n     */\n    threshold: 0\n\n\n}, /** @lends seriesTypes.area.prototype */ {\n    singleStacks: false,\n    /**\n     * Return an array of stacked points, where null and missing points are\n     * replaced by dummy points in order for gaps to be drawn correctly\n     * in stacks.\n     *\n     * @ignore\n     * @function Highcharts.seriesTypes.area#getStackPoints\n     *\n     * @param  {Array<Highcharts.Point>} points\n     *\n     * @return {Array<*>}\n     */\n    getStackPoints: function (points) {\n        var series = this,\n            segment = [],\n            keys = [],\n            xAxis = this.xAxis,\n            yAxis = this.yAxis,\n            stack = yAxis.stacks[this.stackKey],\n            pointMap = {},\n            seriesIndex = series.index,\n            yAxisSeries = yAxis.series,\n            seriesLength = yAxisSeries.length,\n            visibleSeries,\n            upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n            i;\n\n\n        points = points || this.points;\n\n        if (this.options.stacking) {\n\n            for (i = 0; i < points.length; i++) {\n                // Reset after point update (#7326)\n                points[i].leftNull = points[i].rightNull = null;\n\n                // Create a map where we can quickly look up the points by their\n                // X values.\n                pointMap[points[i].x] = points[i];\n            }\n\n            // Sort the keys (#1651)\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(stack, function (stackX, x) {\n                // nulled after switching between\n                // grouping and not (#1651, #2336)\n                if (stackX.total !== null) {\n                    keys.push(x);\n                }\n            });\n            keys.sort(function (a, b) {\n                return a - b;\n            });\n\n            visibleSeries = map(yAxisSeries, function () {\n                return this.visible;\n            });\n\n            each(keys, function (x, idx) {\n                var y = 0,\n                    stackPoint,\n                    stackedValues;\n\n                if (pointMap[x] && !pointMap[x].isNull) {\n                    segment.push(pointMap[x]);\n\n                    // Find left and right cliff. -1 goes left, 1 goes right.\n                    each([-1, 1], function (direction) {\n                        var nullName = direction === 1 ?\n                                'rightNull' :\n                                'leftNull',\n                            cliffName = direction === 1 ?\n                                'rightCliff' :\n                                'leftCliff',\n                            cliff = 0,\n                            otherStack = stack[keys[idx + direction]];\n\n                        // If there is a stack next to this one,\n                        // to the left or to the right...\n                        if (otherStack) {\n                            i = seriesIndex;\n                            // Can go either up or down,\n                            // depending on reversedStacks\n                            while (i >= 0 && i < seriesLength) {\n                                stackPoint = otherStack.points[i];\n                                if (!stackPoint) {\n                                    // If the next point in this series\n                                    // is missing, mark the point\n                                    // with point.leftNull or\n                                    // point.rightNull = true.\n                                    if (i === seriesIndex) {\n                                        pointMap[x][nullName] = true;\n\n                                    // If there are missing points in\n                                    // the next stack in any of the\n                                    // series below this one, we need\n                                    // to substract the missing values\n                                    // and add a hiatus to the left or right.\n                                    } else if (visibleSeries[i]) {\n                                        stackedValues = stack[x].points[i];\n                                        if (stackedValues) {\n                                            cliff -= stackedValues[1] -\n                                                stackedValues[0];\n                                        }\n                                    }\n                                }\n                                // When reversedStacks is true, loop up,\n                                // else loop down\n                                i += upOrDown;\n                            }\n                        }\n                        pointMap[x][cliffName] = cliff;\n                    });\n\n\n                // There is no point for this X value in this series, so we\n                // insert a dummy point in order for the areas to be drawn\n                // correctly.\n                } else {\n\n                    // Loop down the stack to find the series below this\n                    // one that has a value (#1991)\n                    i = seriesIndex;\n                    while (i >= 0 && i < seriesLength) {\n                        stackPoint = stack[x].points[i];\n                        if (stackPoint) {\n                            y = stackPoint[1];\n                            break;\n                        }\n                        // When reversedStacks is true, loop up, else loop down\n                        i += upOrDown;\n                    }\n                    y = yAxis.translate(y, 0, 1, 0, 1); // #6272\n                    segment.push({\n                        isNull: true,\n                        plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272\n                        x: x,\n                        plotY: y,\n                        yBottom: y\n                    });\n                }\n            });\n\n        }\n\n        return segment;\n    },\n\n    /**\n     * @ignore\n     * @function Highcharts.seriesTypes.area#getGraphPath\n     *\n     * @param  {Array<Highcharts.Points>} points\n     *\n     * @return {Array<number|string>}\n     */\n    getGraphPath: function (points) {\n        var getGraphPath = Series.prototype.getGraphPath,\n            graphPath,\n            options = this.options,\n            stacking = options.stacking,\n            yAxis = this.yAxis,\n            topPath,\n            bottomPath,\n            bottomPoints = [],\n            graphPoints = [],\n            seriesIndex = this.index,\n            i,\n            areaPath,\n            plotX,\n            stacks = yAxis.stacks[this.stackKey],\n            threshold = options.threshold,\n            translatedThreshold = yAxis.getThreshold(options.threshold),\n            isNull,\n            yBottom,\n            connectNulls = options.connectNulls || stacking === 'percent',\n            /**\n             * To display null points in underlying stacked series, this\n             * series graph must be broken, and the area also fall down\n             * to fill the gap left by the null point. #2069\n             */\n            addDummyPoints = function (i, otherI, side) {\n                var point = points[i],\n                    stackedValues = stacking &&\n                        stacks[point.x].points[seriesIndex],\n                    nullVal = point[side + 'Null'] || 0,\n                    cliffVal = point[side + 'Cliff'] || 0,\n                    top,\n                    bottom,\n                    isNull = true;\n\n                if (cliffVal || nullVal) {\n\n                    top = (nullVal ? stackedValues[0] : stackedValues[1]) +\n                        cliffVal;\n                    bottom = stackedValues[0] + cliffVal;\n                    isNull = !!nullVal;\n\n                } else if (\n                    !stacking &&\n                    points[otherI] &&\n                    points[otherI].isNull\n                ) {\n                    top = bottom = threshold;\n                }\n\n                // Add to the top and bottom line of the area\n                if (top !== undefined) {\n                    graphPoints.push({\n                        plotX: plotX,\n                        plotY: top === null ?\n                            translatedThreshold :\n                            yAxis.getThreshold(top),\n                        isNull: isNull,\n                        isCliff: true\n                    });\n                    bottomPoints.push({\n                        plotX: plotX,\n                        plotY: bottom === null ?\n                            translatedThreshold :\n                            yAxis.getThreshold(bottom),\n                        doCurve: false // #1041, gaps in areaspline areas\n                    });\n                }\n            };\n\n        // Find what points to use\n        points = points || this.points;\n\n        // Fill in missing points\n        if (stacking) {\n            points = this.getStackPoints(points);\n        }\n\n        for (i = 0; i < points.length; i++) {\n            isNull = points[i].isNull;\n            plotX = pick(points[i].rectPlotX, points[i].plotX);\n            yBottom = pick(points[i].yBottom, translatedThreshold);\n\n            if (!isNull || connectNulls) {\n\n                if (!connectNulls) {\n                    addDummyPoints(i, i - 1, 'left');\n                }\n                // Skip null point when stacking is false and connectNulls true\n                if (!(isNull && !stacking && connectNulls)) {\n                    graphPoints.push(points[i]);\n                    bottomPoints.push({\n                        x: i,\n                        plotX: plotX,\n                        plotY: yBottom\n                    });\n                }\n\n                if (!connectNulls) {\n                    addDummyPoints(i, i + 1, 'right');\n                }\n            }\n        }\n\n        topPath = getGraphPath.call(this, graphPoints, true, true);\n\n        bottomPoints.reversed = true;\n        bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n        if (bottomPath.length) {\n            bottomPath[0] = 'L';\n        }\n\n        areaPath = topPath.concat(bottomPath);\n        // TODO: don't set leftCliff and rightCliff when connectNulls?\n        graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);\n        areaPath.xMap = topPath.xMap;\n        this.areaPath = areaPath;\n\n        return graphPath;\n    },\n\n    /**\n     * Draw the graph and the underlying area. This method calls the Series base\n     * function and adds the area. The areaPath is calculated in the\n     * getSegmentPath method called from Series.prototype.drawGraph.\n     *\n     * @ignore\n     * @function Highcharts.seriesTypes.area#drawGraph\n     *\n     * @return {void}\n     */\n    drawGraph: function () {\n\n        // Define or reset areaPath\n        this.areaPath = [];\n\n        // Call the base method\n        Series.prototype.drawGraph.apply(this);\n\n        // Define local variables\n        var series = this,\n            areaPath = this.areaPath,\n            options = this.options,\n            zones = this.zones,\n            props = [[\n                'area',\n                'highcharts-area'\n                \n            ]]; // area name, main color, fill color\n\n        each(zones, function (zone, i) {\n            props.push([\n                'zone-area-' + i,\n                'highcharts-area highcharts-zone-area-' + i + ' ' +\n                    zone.className\n                \n            ]);\n        });\n\n        each(props, function (prop) {\n            var areaKey = prop[0],\n                area = series[areaKey];\n\n            // Create or update the area\n            if (area) { // update\n                area.endX = series.preventGraphAnimation ? null : areaPath.xMap;\n                area.animate({ d: areaPath });\n\n            } else { // create\n                area = series[areaKey] = series.chart.renderer.path(areaPath)\n                    .addClass(prop[1])\n                    .attr({\n                        \n                        zIndex: 0 // #1069\n                    }).add(series.group);\n                area.isArea = true;\n            }\n            area.startX = areaPath.xMap;\n            area.shiftUnit = options.step ? 2 : 1;\n        });\n    },\n\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle\n});\n\n/**\n * A `area` series. If the [type](#series.area.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type       {*}\n * @extends    series,plotOptions.area\n * @excluding  dataParser,dataURL\n * @product    highcharts highstock\n * @apioption  series.area\n */\n\n/**\n * An array of data points for the series. For the `area` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 9],\n *         [1, 7],\n *         [2, 6]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.area.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n *\n * @type       {Array<number|Array<number>|*>}\n * @extends    series.line.data\n * @product    highcharts highstock\n * @apioption  series.area.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/AreaSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/AreaSplineSeries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/AreaSplineSeries.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _AreaSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AreaSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/AreaSeries.js\");\n/* harmony import */ var _SplineSeries_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SplineSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/SplineSeries.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar areaProto = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes.area.prototype,\n    defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    LegendSymbolMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType;\n/**\n * AreaSplineSeries object\n */\n/**\n * The area spline series is an area series where the graph between the points\n * is smoothed into a spline.\n *\n * @extends   plotOptions.area\n * @excluding step\n * @sample    {highcharts} highcharts/demo/areaspline/ Area spline chart\n * @sample    {highstock} stock/demo/areaspline/ Area spline chart\n * @product   highcharts highstock\n * @apioption plotOptions.areaspline\n */\nseriesType('areaspline', 'spline', defaultPlotOptions.area, {\n    getStackPoints: areaProto.getStackPoints,\n    getGraphPath: areaProto.getGraphPath,\n    drawGraph: areaProto.drawGraph,\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle\n});\n/**\n * A `areaspline` series. If the [type](#series.areaspline.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n *\n * @type      {Object}\n * @extends   series,plotOptions.areaspline\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.areaspline\n */\n\n\n/**\n * An array of data points for the series. For the `areaspline` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 10],\n *         [1, 9],\n *         [2, 3]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series'\n * [turboThreshold](#series.areaspline.turboThreshold), this option is not\n * available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 4,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.areaspline.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/AreaSplineSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Axis.js":
/*!*************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Axis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Tick_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tick.js */ \"./node_modules/highcharts/js/es-modules/parts/Tick.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options for crosshairs on axes.\n *\n * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions\n */\n\n/**\n * Options for axes.\n *\n * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions\n */\n\n/**\n * Position of the axis title.\n *\n * @typedef Highcharts.AxisTitlePositionObject\n *\n * @property {number} x\n *           X position.\n *\n * @property {number} y\n *           Y position.\n */\n\n/**\n * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n * function.\n *\n * @typedef Highcharts.ExtremesObject\n *\n * @property {number} dataMax\n *           The maximum value of the axis' associated series.\n *\n * @property {number} dataMin\n *           The minimum value of the axis' associated series.\n *\n * @property {number} max\n *           The maximum axis value, either automatic or set manually. If\n *           the `max` option is not set, `maxPadding` is 0 and `endOnTick`\n *           is false, this value will be the same as `dataMax`.\n *\n * @property {number} min\n *           The minimum axis value, either automatic or set manually. If\n *           the `min` option is not set, `minPadding` is 0 and\n *           `startOnTick` is false, this value will be the same\n *           as `dataMin`.\n *\n * @property {number} userMax\n *           The user defined maximum, either from the `max` option or from\n *           a zoom or `setExtremes` action.\n *\n * @property {number} userMin\n *           The user defined minimum, either from the `min` option or from\n *           a zoom or `setExtremes` action.\n */\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    animObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    correctFloat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    deg2rad = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    getMagnitude = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMagnitude,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isString = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    normalizeTickInterval = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeTickInterval,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    syncTimeout = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout,\n    Tick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick;\n\n/**\n * Create a new axis object. Called internally when instanciating a new chart or\n * adding axes by {@link Highcharts.Chart#addAxis}.\n *\n * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n * series cartesian chart, there is one X axis and one Y axis.\n *\n * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n * an array of Axis objects. If there is only one axis, it can be referenced\n * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n * pattern goes for Y axes.\n *\n * If you need to get the axes from a series object, use the `series.xAxis` and\n * `series.yAxis` properties. These are not arrays, as one series can only be\n * associated to one X and one Y axis.\n *\n * A third way to reference the axis programmatically is by `id`. Add an `id` in\n * the axis configuration options, and get the axis by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the axes are given in options.xAxis and\n * options.yAxis.\n *\n * @class\n * @name Highcharts.Axis\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance to apply the axis on.\n *\n * @param {Highcharts.AxisOptions} options\n *        Axis options.\n */\nvar Axis = function () {\n    this.init.apply(this, arguments);\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */{\n\n    /**\n     * The X axis or category axis. Normally this is the horizontal axis,\n     * though if the chart is inverted this is the vertical axis. In case of\n     * multiple axes, the xAxis node is an array of configuration objects.\n     *\n     * See [the Axis object](/class-reference/Highcharts.Axis) for\n     * programmatic access to the axis.\n     *\n     * @productdesc {highmaps}\n     * In Highmaps, the axis is hidden, but it is used behind the scenes to\n     * control features like zooming and panning. Zooming is in effect the same\n     * as setting the extremes of one of the exes.\n     *\n     * @optionparent xAxis\n     */\n    defaultOptions: {\n\n        /**\n         * When using multiple axis, the ticks of two or more opposite axes\n         * will automatically be aligned by adding ticks to the axis or axes\n         * with the least ticks, as if `tickAmount` were specified.\n         *\n         * This can be prevented by setting `alignTicks` to false. If the grid\n         * lines look messy, it's a good idea to hide them for the secondary\n         * axis by setting `gridLineWidth` to 0.\n         *\n         * If `startOnTick` or `endOnTick` in an Axis options are set to false,\n         * then the `alignTicks ` will be disabled for the Axis.\n         *\n         * Disabled for logarithmic axes.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @product   highcharts highstock\n         * @apioption xAxis.alignTicks\n         */\n\n        /**\n         * Whether to allow decimals in this axis' ticks. When counting\n         * integers, like persons or hits on a web page, decimals should\n         * be avoided in the labels.\n         *\n         * @see [minTickInterval](#xAxis.minTickInterval)\n         *\n         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/\n         *         True by default\n         * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/\n         *         False\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     2.0\n         * @apioption xAxis.allowDecimals\n         */\n\n        /**\n         * When using an alternate grid color, a band is painted across the\n         * plot area between every other grid line.\n         *\n         * @sample {highcharts} highcharts/yaxis/alternategridcolor/\n         *         Alternate grid color on the Y axis\n         * @sample {highstock} stock/xaxis/alternategridcolor/\n         *         Alternate grid color on the Y axis\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption xAxis.alternateGridColor\n         */\n\n        /**\n         * An array defining breaks in the axis, the sections defined will be\n         * left out and all the points shifted closer to each other.\n         *\n         * @productdesc {highcharts}\n         * Requires that the broken-axis.js module is loaded.\n         *\n         * @sample {highcharts} highcharts/axisbreak/break-simple/\n         *         Simple break\n         * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/\n         *         Advanced with callback\n         * @sample {highstock} stock/demo/intraday-breaks/\n         *         Break on nights and weekends\n         *\n         * @type      {Array<*>}\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.breaks\n         */\n\n        /**\n         * A number indicating how much space should be left between the start\n         * and the end of the break. The break size is given in axis units,\n         * so for instance on a `datetime` axis, a break size of 3600000 would\n         * indicate the equivalent of an hour.\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.breaks.breakSize\n         */\n\n        /**\n         * The point where the break starts.\n         *\n         * @type      {number}\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.breaks.from\n         */\n\n        /**\n         * Defines an interval after which the break appears again. By default\n         * the breaks do not repeat.\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.breaks.repeat\n         */\n\n        /**\n         * The point where the break ends.\n         *\n         * @type      {number}\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.breaks.to\n         */\n\n        /**\n         * If categories are present for the xAxis, names are used instead of\n         * numbers for that axis. Since Highcharts 3.0, categories can also\n         * be extracted by giving each point a [name](#series.data) and setting\n         * axis [type](#xAxis.type) to `category`. However, if you have multiple\n         * series, best practice remains defining the `categories` array.\n         *\n         * Example:\n         *\n         * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>\n         *\n         * @sample {highcharts} highcharts/demo/line-labels/\n         *         With\n         * @sample {highcharts} highcharts/xaxis/categories/\n         *         Without\n         *\n         * @type      {Array<string>}\n         * @product   highcharts\n         * @apioption xAxis.categories\n         */\n\n        /**\n         * The highest allowed value for automatically computed axis extremes.\n         *\n         * @see [floor](#xAxis.floor)\n         *\n         * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/\n         *         Floor and ceiling\n         *\n         * @type       {number}\n         * @since      4.0\n         * @product    highcharts highstock\n         * @apioption  xAxis.ceiling\n         */\n\n        /**\n         * A class name that opens for styling the axis by CSS, especially in\n         * Highcharts styled mode. The class name is applied to group elements\n         * for the grid, axis elements and labels.\n         *\n         * @sample {highcharts|highstock|highmaps} highcharts/css/axis/\n         *         Multiple axes with separate styling\n         *\n         * @type      {string}\n         * @since     5.0.0\n         * @apioption xAxis.className\n         */\n\n        /**\n         * Configure a crosshair that follows either the mouse pointer or the\n         * hovered point.\n         *\n         * In styled mode, the crosshairs are styled in the\n         * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or\n         * `.highcharts-xaxis-category` classes.\n         *\n         * @productdesc {highstock}\n         * In Highstock, by default, the crosshair is enabled on the X axis and\n         * disabled on the Y axis.\n         *\n         * @sample {highcharts} highcharts/xaxis/crosshair-both/\n         *         Crosshair on both axes\n         * @sample {highstock} stock/xaxis/crosshairs-xy/\n         *         Crosshair on both axes\n         * @sample {highmaps} highcharts/xaxis/crosshair-both/\n         *         Crosshair on both axes\n         *\n         * @type      {boolean|*}\n         * @default   false\n         * @since     4.1\n         * @apioption xAxis.crosshair\n         */\n\n        /**\n         * A class name for the crosshair, especially as a hook for styling.\n         *\n         * @type      {string}\n         * @since     5.0.0\n         * @apioption xAxis.crosshair.className\n         */\n\n        /**\n         * The color of the crosshair. Defaults to `#cccccc` for numeric and\n         * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where\n         * the crosshair by default highlights the whole category.\n         *\n         * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/\n         *         Customized crosshairs\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #cccccc\n         * @since     4.1\n         * @apioption xAxis.crosshair.color\n         */\n\n        /**\n         * The dash style for the crosshair. See\n         * [series.dashStyle](#plotOptions.series.dashStyle)\n         * for possible values.\n         *\n         * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/\n         *         Dotted crosshair\n         * @sample {highstock} stock/xaxis/crosshair-dashed/\n         *         Dashed X axis crosshair\n         *\n         * @type       {string}\n         * @default    Solid\n         * @since      4.1\n         * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n         *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n         *             \"LongDashDot\", \"LongDashDotDot\"]\n         * @apioption  xAxis.crosshair.dashStyle\n         */\n\n        /**\n         * A label on the axis next to the crosshair.\n         *\n         * In styled mode, the label is styled with the\n         * `.highcharts-crosshair-label` class.\n         *\n         * @sample {highstock} stock/xaxis/crosshair-label/\n         *         Crosshair labels\n         * @sample {highstock} highcharts/css/crosshair-label/\n         *         Style mode\n         *\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label\n         */\n\n        /**\n         * Alignment of the label compared to the axis. Defaults to `left` for\n         * right-side axes, `right` for left-side axes and `center` for\n         * horizontal axes.\n         *\n         * @type      {string}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.align\n         */\n\n        /**\n         * The background color for the label. Defaults to the related series\n         * color, or `#666666` if that is not available.\n         *\n         * @type      {Highcharts.ColorString}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.backgroundColor\n         */\n\n        /**\n         * The border color for the crosshair label\n         *\n         * @type      {Highcharts.ColorString}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.borderColor\n         */\n\n        /**\n         * The border corner radius of the crosshair label.\n         *\n         * @type      {number}\n         * @default   3\n         * @since     2.1.10\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.borderRadius\n         */\n\n        /**\n         * The border width for the crosshair label.\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.borderWidth\n         */\n\n        /**\n         * A format string for the crosshair label. Defaults to `{value}` for\n         * numeric axes and `{value:%b %d, %Y}` for datetime axes.\n         *\n         * @type      {string}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.format\n         */\n\n        /**\n         * Formatter function for the label text.\n         *\n         * @type      {Highcharts.FormatterCallbackFunction}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.formatter\n         */\n\n        /**\n         * Padding inside the crosshair label.\n         *\n         * @type      {number}\n         * @default   8\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.padding\n         */\n\n        /**\n         * The shape to use for the label box.\n         *\n         * @type      {string}\n         * @default   callout\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.shape\n         */\n\n        /**\n         * Text styles for the crosshair label.\n         *\n         * @type      {Highcharts.CSSObject}\n         * @default   {\"color\": \"white\", \"fontWeight\": \"normal\", \"fontSize\": \"11px\", \"textAlign\": \"center\"}\n         * @since     2.1\n         * @product   highstock\n         * @apioption xAxis.crosshair.label.style\n         */\n\n        /**\n         * Whether the crosshair should snap to the point or follow the pointer\n         * independent of points.\n         *\n         * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/\n         *         True by default\n         * @sample {highmaps} maps/demo/latlon-advanced/\n         *         Snap is false\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.1\n         * @apioption xAxis.crosshair.snap\n         */\n\n        /**\n         * The pixel width of the crosshair. Defaults to 1 for numeric or\n         * datetime axes, and for one category width for category axes.\n         *\n         * @sample {highcharts} highcharts/xaxis/crosshair-customized/\n         *         Customized crosshairs\n         * @sample {highstock} highcharts/xaxis/crosshair-customized/\n         *         Customized crosshairs\n         * @sample {highmaps} highcharts/xaxis/crosshair-customized/\n         *         Customized crosshairs\n         *\n         * @type      {number}\n         * @default   1\n         * @since     4.1\n         * @apioption xAxis.crosshair.width\n         */\n\n        /**\n         * The Z index of the crosshair. Higher Z indices allow drawing the\n         * crosshair on top of the series or behind the grid lines.\n         *\n         * @type      {number}\n         * @default   2\n         * @since     4.1\n         * @apioption xAxis.crosshair.zIndex\n         */\n\n        /**\n         * For a datetime axis, the scale will automatically adjust to the\n         * appropriate unit. This member gives the default string\n         * representations used for each unit. For intermediate values,\n         * different units may be used, for example the `day` unit can be used\n         * on midnight and `hour` unit be used for intermediate values on the\n         * same axis. For an overview of the replacement codes, see\n         * [dateFormat](/class-reference/Highcharts#dateFormat). Defaults to:\n         *\n         * <pre>{\n         *     millisecond: '%H:%M:%S.%L',\n         *     second: '%H:%M:%S',\n         *     minute: '%H:%M',\n         *     hour: '%H:%M',\n         *     day: '%e. %b',\n         *     week: '%e. %b',\n         *     month: '%b \\'%y',\n         *     year: '%Y'\n         * }</pre>\n         *\n         * @sample {highcharts} highcharts/xaxis/datetimelabelformats/\n         *         Different day format on X axis\n         * @sample {highstock} stock/xaxis/datetimelabelformats/\n         *         More information in x axis labels\n         *\n         * @product highcharts highstock\n         */\n        dateTimeLabelFormats: {\n            millisecond: '%H:%M:%S.%L',\n            second: '%H:%M:%S',\n            minute: '%H:%M',\n            hour: '%H:%M',\n            day: '%e. %b',\n            week: '%e. %b',\n            month: '%b \\'%y',\n            year: '%Y'\n        },\n\n        /**\n         * _Requires Accessibility module_\n         *\n         * Description of the axis to screen reader users.\n         *\n         * @type      {string}\n         * @since     5.0.0\n         * @apioption xAxis.description\n         */\n\n        /**\n         * Whether to force the axis to end on a tick. Use this option with\n         * the `maxPadding` option to control the axis end.\n         *\n         * @productdesc {highstock}\n         * In Highstock, `endOnTick` is always false when the navigator is\n         * enabled, to prevent jumpy scrolling.\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         True by default\n         * @sample {highcharts} highcharts/yaxis/endontick/\n         *         False\n         * @sample {highstock} stock/demo/basic-line/\n         *         True by default\n         * @sample {highstock} stock/xaxis/endontick/\n         *         False\n         *\n         * @since 1.2.0\n         */\n        endOnTick: false,\n\n        /**\n         * Event handlers for the axis.\n         *\n         * @type      {*}\n         * @apioption xAxis.events\n         */\n\n        /**\n         * An event fired after the breaks have rendered.\n         *\n         * @see [breaks](#xAxis.breaks)\n         *\n         * @sample {highcharts} highcharts/axisbreak/break-event/\n         *         AfterBreak Event\n         *\n         * @type      {Function}\n         * @since     4.1.0\n         * @product   highcharts\n         * @apioption xAxis.events.afterBreaks\n         */\n\n        /**\n         * As opposed to the `setExtremes` event, this event fires after the\n         * final min and max values are computed and corrected for `minRange`.\n         *\n         *\n         * Fires when the minimum and maximum is set for the axis, either by\n         * calling the `.setExtremes()` method or by selecting an area in the\n         * chart. One parameter, `event`, is passed to the function, containing\n         * common event information.\n         *\n         * The new user set minimum and maximum values can be found by\n         * `event.min` and `event.max`. These reflect the axis minimum and\n         * maximum in axis values. The actual data extremes are found in\n         * `event.dataMin` and `event.dataMax`.\n         *\n         * @type      {Function}\n         * @since     2.3\n         * @context   Axis\n         * @apioption xAxis.events.afterSetExtremes\n         */\n\n        /**\n         * An event fired when a break from this axis occurs on a point.\n         *\n         * @see [breaks](#xAxis.breaks)\n         *\n         * @sample {highcharts} highcharts/axisbreak/break-visualized/\n         *         Visualization of a Break\n         *\n         * @type      {Function}\n         * @since     4.1.0\n         * @product   highcharts\n         * @context   Axis\n         * @apioption xAxis.events.pointBreak\n         */\n\n        /**\n         * An event fired when a point falls inside a break from this axis.\n         *\n         * @type      {Function}\n         * @product   highcharts highstock\n         * @context   Axis\n         * @apioption xAxis.events.pointInBreak\n         */\n\n        /**\n         * Fires when the minimum and maximum is set for the axis, either by\n         * calling the `.setExtremes()` method or by selecting an area in the\n         * chart. One parameter, `event`, is passed to the function,\n         * containing common event information.\n         *\n         * The new user set minimum and maximum values can be found by\n         * `event.min` and `event.max`. These reflect the axis minimum and\n         * maximum in data values. When an axis is zoomed all the way out from\n         * the \"Reset zoom\" button, `event.min` and `event.max` are null, and\n         * the new extremes are set based on `this.dataMin` and `this.dataMax`.\n         *\n         * @sample {highstock} stock/xaxis/events-setextremes/\n         *         Log new extremes on x axis\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Axis\n         * @apioption xAxis.events.setExtremes\n         */\n\n        /**\n         * The lowest allowed value for automatically computed axis extremes.\n         *\n         * @see [ceiling](#yAxis.ceiling)\n         *\n         * @sample {highcharts} highcharts/yaxis/floor-ceiling/\n         *         Floor and ceiling\n         * @sample {highstock} stock/demo/lazy-loading/\n         *         Prevent negative stock price on Y axis\n         *\n         * @type      {number}\n         * @since     4.0\n         * @product   highcharts highstock\n         * @apioption xAxis.floor\n         */\n\n        /**\n         * The dash or dot style of the grid lines. For possible values, see\n         * [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n         * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n         * series-dashstyle-all/).\n         *\n         * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/\n         *         Long dashes\n         * @sample {highstock} stock/xaxis/gridlinedashstyle/\n         *         Long dashes\n         *\n         * @type       {string}\n         * @default    Solid\n         * @since      1.2\n         * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n         *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n         *             \"LongDashDot\", \"LongDashDotDot\"]\n         * @apioption  xAxis.gridLineDashStyle\n         */\n\n        /**\n         * The Z index of the grid lines.\n         *\n         * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/\n         *         A Z index of 4 renders the grid above the graph\n         *\n         * @type      {number}\n         * @default   1\n         * @product   highcharts highstock\n         * @apioption xAxis.gridZIndex\n         */\n\n        /**\n         * An id for the axis. This can be used after render time to get\n         * a pointer to the axis object through `chart.get()`.\n         *\n         * @sample {highcharts} highcharts/xaxis/id/\n         *         Get the object\n         * @sample {highstock} stock/xaxis/id/\n         *         Get the object\n         *\n         * @type      {string}\n         * @since     1.2.0\n         * @apioption xAxis.id\n         */\n\n        /**\n         * The axis labels show the number or category for each tick.\n         *\n         * @productdesc {highmaps}\n         * X and Y axis labels are by default disabled in Highmaps, but the\n         * functionality is inherited from Highcharts and used on `colorAxis`,\n         * and can be enabled on X and Y axes too.\n         */\n        labels: {\n\n            /**\n             * What part of the string the given position is anchored to.\n             * If `left`, the left side of the string is at the axis position.\n             * Can be one of `\"left\"`, `\"center\"` or `\"right\"`. Defaults to\n             * an intelligent guess based on which side of the chart the axis\n             * is on and the rotation of the label.\n             *\n             * @see [reserveSpace](#xAxis.labels.reserveSpace)\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-align-left/\n             *         Left\n             * @sample {highcharts} highcharts/xaxis/labels-align-right/\n             *         Right\n             * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n             *         Left-aligned labels on a vertical category axis\n             *\n             * @type       {string}\n             * @validvalue [\"left\", \"center\", \"right\"]\n             * @apioption  xAxis.labels.align\n             */\n\n            /**\n             * For horizontal axes, the allowed degrees of label rotation\n             * to prevent overlapping labels. If there is enough space,\n             * labels are not rotated. As the chart gets narrower, it\n             * will start rotating the labels -45 degrees, then remove\n             * every second label and try again with rotations 0 and -45 etc.\n             * Set it to `false` to disable rotation, which will\n             * cause the labels to word-wrap if possible.\n             *\n             * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/\n             *         Default auto rotation of 0 or -45\n             * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/\n             *         Custom graded auto rotation\n             *\n             * @type      {Array<number>}\n             * @default   [-45]\n             * @since     4.1.0\n             * @product   highcharts highstock\n             * @apioption xAxis.labels.autoRotation\n             */\n\n            /**\n             * When each category width is more than this many pixels, we don't\n             * apply auto rotation. Instead, we lay out the axis label with word\n             * wrap. A lower limit makes sense when the label contains multiple\n             * short words that don't extend the available horizontal space for\n             * each label.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/\n             *         Lower limit\n             *\n             * @type      {number}\n             * @default   80\n             * @since     4.1.5\n             * @product   highcharts\n             * @apioption xAxis.labels.autoRotationLimit\n             */\n\n            /**\n             * Polar charts only. The label's pixel distance from the perimeter\n             * of the plot area.\n             *\n             * @type      {number}\n             * @default   15\n             * @product   highcharts\n             * @apioption xAxis.labels.distance\n             */\n\n            /**\n             * Enable or disable the axis labels.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-enabled/\n             *         X axis labels disabled\n             * @sample {highstock} stock/xaxis/labels-enabled/\n             *         X axis labels disabled\n             *\n             * @default {highcharts|highstock} true\n             * @default {highmaps} false\n             */\n            enabled: true,\n\n            /**\n             * A [format string](https://www.highcharts.com/docs/chart-\n             * concepts/labels-and-string-formatting) for the axis label.\n             *\n             * @sample {highcharts|highstock} highcharts/yaxis/labels-format/\n             *         Add units to Y axis label\n             *\n             * @type      {string}\n             * @default   {value}\n             * @since     3.0\n             * @apioption xAxis.labels.format\n             */\n\n            /**\n             * Callback JavaScript function to format the label. The value\n             * is given by `this.value`. Additional properties for `this` are\n             * `axis`, `chart`, `isFirst` and `isLast`. The value of the default\n             * label formatter can be retrieved by calling\n             * `this.axis.defaultLabelFormatter.call(this)` within the function.\n             *\n             * Defaults to:\n             *\n             * <pre>function() {\n             *     return this.value;\n             * }</pre>\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/\n             *         Linked category names\n             * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/\n             *         Modified numeric labels\n             * @sample {highstock} stock/xaxis/labels-formatter/\n             *         Added units on Y axis\n             *\n             * @type      {Function}\n             * @apioption xAxis.labels.formatter\n             */\n\n            /**\n             * Horizontal axis only. When `staggerLines` is not set,\n             * `maxStaggerLines` defines how many lines the axis is allowed to\n             * add to automatically avoid overlapping X labels. Set to `1` to\n             * disable overlap detection.\n             *\n             * @deprecated\n             * @type      {number}\n             * @default   5\n             * @since     1.3.3\n             * @product   highstock highmaps\n             * @apioption xAxis.labels.maxStaggerLines\n             */\n\n            /**\n             * How to handle overflowing labels on horizontal axis. If set to\n             * `\"allow\"`, it will not be aligned at all. By default it\n             * `\"justify\"` labels inside the chart area. If there is room to\n             * move it, it will be aligned to the edge, else it will be removed.\n             *\n             * @type       {boolean|string}\n             * @default    justify\n             * @since      2.2.5\n             * @validvalue [\"allow\", \"justify\"]\n             * @apioption  xAxis.labels.overflow\n             */\n\n            /**\n             * The pixel padding for axis labels, to ensure white space between\n             * them.\n             *\n             * @type      {number}\n             * @default   5\n             * @product   highcharts\n             * @apioption xAxis.labels.padding\n             */\n\n            /**\n             * Whether to reserve space for the labels. By default, space is\n             * reserved for the labels in these cases:\n             *\n             * * On all horizontal axes.\n             * * On vertical axes if `label.align` is `right` on a left-side\n             * axis or `left` on a right-side axis.\n             * * On vertical axes if `label.align` is `center`.\n             *\n             * This can be turned off when for example the labels are rendered\n             * inside the plot area instead of outside.\n             *\n             * @see [labels.align](#xAxis.labels.align)\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-reservespace/\n             *         No reserved space, labels inside plot\n             * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/\n             *         Left-aligned labels on a vertical category axis\n             *\n             * @type      {boolean}\n             * @since     4.1.10\n             * @product   highcharts\n             * @apioption xAxis.labels.reserveSpace\n             */\n\n            /**\n             * Rotation of the labels in degrees.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-rotation/\n             *         X axis labels rotated 90\n             *\n             * @type      {number}\n             * @default   0\n             * @apioption xAxis.labels.rotation\n             */\n\n            /**\n             * Horizontal axes only. The number of lines to spread the labels\n             * over to make room or tighter labels.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-staggerlines/\n             *         Show labels over two lines\n             * @sample {highstock} stock/xaxis/labels-staggerlines/\n             *         Show labels over two lines\n             *\n             * @type      {number}\n             * @since     2.1\n             * @apioption xAxis.labels.staggerLines\n             */\n\n            /**\n             * To show only every _n_'th label on the axis, set the step to _n_.\n             * Setting the step to 2 shows every other label.\n             *\n             * By default, the step is calculated automatically to avoid\n             * overlap. To prevent this, set it to 1\\. This usually only\n             * happens on a category axis, and is often a sign that you have\n             * chosen the wrong axis type.\n             *\n             * Read more at\n             * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)\n             * => What axis should I use?\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-step/\n             *         Showing only every other axis label on a categorized\n             *         x-axis\n             * @sample {highcharts} highcharts/xaxis/labels-step-auto/\n             *         Auto steps on a category axis\n             *\n             * @type      {number}\n             * @since     2.1\n             * @apioption xAxis.labels.step\n             */\n\n            /**\n             * Whether to [use HTML](https://www.highcharts.com/docs/chart-\n             * concepts/labels-and-string-formatting#html) to render the labels.\n             *\n             * @type      {boolean}\n             * @default   false\n             * @apioption xAxis.labels.useHTML\n             */\n\n            /**\n             * The x position offset of the label relative to the tick position\n             * on the axis.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-x/\n             *         Y axis labels placed on grid lines\n             */\n            x: 0,\n\n            /**\n             * The y position offset of the label relative to the tick position\n             * on the axis. The default makes it adapt to the font size on\n             * bottom axis.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-x/\n             *         Y axis labels placed on grid lines\n             *\n             * @type      {number}\n             * @apioption xAxis.labels.y\n             */\n\n            /**\n             * The Z index for the axis labels.\n             *\n             * @type      {number}\n             * @default   7\n             * @apioption xAxis.labels.zIndex\n             */\n\n            \n        },\n\n        /**\n         * Index of another axis that this axis is linked to. When an axis is\n         * linked to a master axis, it will take the same extremes as\n         * the master, but as assigned by min or max or by setExtremes.\n         * It can be used to show additional info, or to ease reading the\n         * chart by duplicating the scales.\n         *\n         * @sample {highcharts} highcharts/xaxis/linkedto/\n         *         Different string formats of the same date\n         * @sample {highcharts} highcharts/yaxis/linkedto/\n         *         Y values on both sides\n         *\n         * @type      {number}\n         * @since     2.0.2\n         * @product   highcharts highstock\n         * @apioption xAxis.linkedTo\n         */\n\n        /**\n         * The maximum value of the axis. If `null`, the max value is\n         * automatically calculated.\n         *\n         * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value\n         * might be rounded up.\n         *\n         * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended\n         * beyond the set max in order to reach the given number of ticks. The\n         * same may happen in a chart with multiple axes, determined by [chart.\n         * alignTicks](#chart), where a `tickAmount` is applied internally.\n         *\n         * @sample {highcharts} highcharts/yaxis/max-200/\n         *         Y axis max of 200\n         * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n         *         Y axis max on logarithmic axis\n         * @sample {highstock} stock/xaxis/min-max/\n         *         Fixed min and max on X axis\n         * @sample {highmaps} maps/axis/min-max/\n         *         Pre-zoomed to a specific area\n         *\n         * @type      {number}\n         * @apioption xAxis.max\n         */\n\n        /**\n         * Padding of the max value relative to the length of the axis. A\n         * padding of 0.05 will make a 100px axis 5px longer. This is useful\n         * when you don't want the highest data value to appear on the edge\n         * of the plot area. When the axis' `max` option is set or a max extreme\n         * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n         *\n         * @sample {highcharts} highcharts/yaxis/maxpadding/\n         *         Max padding of 0.25 on y axis\n         * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n         *         Greater min- and maxPadding\n         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n         *         Add some padding\n         *\n         * @default   {highcharts} 0.01\n         * @default   {highstock|highmaps} 0\n         * @since     1.2.0\n         */\n        maxPadding: 0.01,\n\n        /**\n         * Deprecated. Use `minRange` instead.\n         *\n         * @deprecated\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption xAxis.maxZoom\n         */\n\n        /**\n         * The minimum value of the axis. If `null` the min value is\n         * automatically calculated.\n         *\n         * If the [startOnTick](#yAxis.startOnTick) option is true (default),\n         * the `min` value might be rounded down.\n         *\n         * The automatically calculated minimum value is also affected by\n         * [floor](#yAxis.floor), [softMin](#yAxis.softMin),\n         * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)\n         * as well as [series.threshold](#plotOptions.series.threshold)\n         * and [series.softThreshold](#plotOptions.series.softThreshold).\n         *\n         * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n         *         -50 with startOnTick to false\n         * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n         *         -50 with startOnTick true by default\n         * @sample {highstock} stock/xaxis/min-max/\n         *         Set min and max on X axis\n         * @sample {highmaps} maps/axis/min-max/\n         *         Pre-zoomed to a specific area\n         *\n         * @type      {number}\n         * @apioption xAxis.min\n         */\n\n        /**\n         * The dash or dot style of the minor grid lines. For possible values,\n         * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/\n         * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/\n         * series-dashstyle-all/).\n         *\n         * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/\n         *         Long dashes on minor grid lines\n         * @sample {highstock} stock/xaxis/minorgridlinedashstyle/\n         *         Long dashes on minor grid lines\n         *\n         * @type       {string}\n         * @default    Solid\n         * @since      1.2\n         * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n         *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\",\n         *             \"DashDot\", \"LongDashDot\", \"LongDashDotDot\"]\n         * @apioption  xAxis.minorGridLineDashStyle\n         */\n\n        /**\n         * Specific tick interval in axis units for the minor ticks. On a linear\n         * axis, if `\"auto\"`, the minor tick interval is calculated as a fifth\n         * of the tickInterval. If `null` or `undefined`, minor ticks are not\n         * shown.\n         *\n         * On logarithmic axes, the unit is the power of the value. For example,\n         * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,\n         * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks\n         * between 1 and 10, 10 and 100 etc.\n         *\n         * If user settings dictate minor ticks to become too dense, they don't\n         * make sense, and will be ignored to prevent performance problems.\n         *\n         * @sample {highcharts} highcharts/yaxis/minortickinterval-null/\n         *         Null by default\n         * @sample {highcharts} highcharts/yaxis/minortickinterval-5/\n         *         5 units\n         * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/\n         *         \"auto\"\n         * @sample {highcharts} highcharts/yaxis/minortickinterval-log/\n         *         0.1\n         * @sample {highstock} stock/demo/basic-line/\n         *         Null by default\n         * @sample {highstock} stock/xaxis/minortickinterval-auto/\n         *         \"auto\"\n         *\n         * @type      {number|string|null}\n         * @apioption xAxis.minorTickInterval\n         */\n\n        /**\n         * The pixel length of the minor tick marks.\n         *\n         * @sample {highcharts} highcharts/yaxis/minorticklength/\n         *         10px on Y axis\n         * @sample {highstock} stock/xaxis/minorticks/\n         *         10px on Y axis\n         */\n        minorTickLength: 2,\n\n        /**\n         * The position of the minor tick marks relative to the axis line.\n         *  Can be one of `inside` and `outside`.\n         *\n         * @sample {highcharts} highcharts/yaxis/minortickposition-outside/\n         *         Outside by default\n         * @sample {highcharts} highcharts/yaxis/minortickposition-inside/\n         *         Inside\n         * @sample {highstock} stock/xaxis/minorticks/\n         *         Inside\n         *\n         * @validvalue [\"inside\", \"outside\"]\n         */\n        minorTickPosition: 'outside',\n\n        /**\n         * Enable or disable minor ticks. Unless\n         * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick\n         * interval is calculated as a fifth of the `tickInterval`.\n         *\n         * On a logarithmic axis, minor ticks are laid out based on a best\n         * guess, attempting to enter approximately 5 minor ticks between\n         * each major tick.\n         *\n         * Prior to v6.0.0, ticks were unabled in auto layout by setting\n         * `minorTickInterval` to `\"auto\"`.\n         *\n         * @productdesc {highcharts}\n         * On axes using [categories](#xAxis.categories), minor ticks are not\n         * supported.\n         *\n         * @sample {highcharts} highcharts/yaxis/minorticks-true/\n         *         Enabled on linear Y axis\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     6.0.0\n         * @apioption xAxis.minorTicks\n         */\n\n        /**\n         * The pixel width of the minor tick mark.\n         *\n         * @sample {highcharts} highcharts/yaxis/minortickwidth/\n         *         3px width\n         * @sample {highstock} stock/xaxis/minorticks/\n         *         1px width\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption xAxis.minorTickWidth\n         */\n\n        /**\n         * Padding of the min value relative to the length of the axis. A\n         * padding of 0.05 will make a 100px axis 5px longer. This is useful\n         * when you don't want the lowest data value to appear on the edge\n         * of the plot area. When the axis' `min` option is set or a min extreme\n         * is set using `axis.setExtremes()`, the minPadding will be ignored.\n         *\n         * @sample {highcharts} highcharts/yaxis/minpadding/\n         *         Min padding of 0.2\n         * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n         *         Greater min- and maxPadding\n         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/\n         *         Add some padding\n         *\n         * @default    {highcharts} 0.01\n         * @default    {highstock|highmaps} 0\n         * @since      1.2.0\n         * @product    highcharts highstock\n         */\n        minPadding: 0.01,\n\n        /**\n         * The minimum range to display on this axis. The entire axis will not\n         * be allowed to span over a smaller interval than this. For example,\n         * for a datetime axis the main unit is milliseconds. If minRange is\n         * set to 3600000, you can't zoom in more than to one hour.\n         *\n         * The default minRange for the x axis is five times the smallest\n         * interval between any of the data points.\n         *\n         * On a logarithmic axis, the unit for the minimum range is the power.\n         * So a minRange of 1 means that the axis can be zoomed to 10-100,\n         * 100-1000, 1000-10000 etc.\n         *\n         * Note that the `minPadding`, `maxPadding`, `startOnTick` and\n         * `endOnTick` settings also affect how the extremes of the axis\n         * are computed.\n         *\n         * @sample {highcharts} highcharts/xaxis/minrange/\n         *         Minimum range of 5\n         * @sample {highstock} stock/xaxis/minrange/\n         *         Max zoom of 6 months overrides user selections\n         * @sample {highmaps} maps/axis/minrange/\n         *         Minimum range of 1000\n         *\n         * @type      {number}\n         * @apioption xAxis.minRange\n         */\n\n        /**\n         * The minimum tick interval allowed in axis values. For example on\n         * zooming in on an axis with daily data, this can be used to prevent\n         * the axis from showing hours. Defaults to the closest distance between\n         * two points on the axis.\n         *\n         * @type      {number}\n         * @since     2.3.0\n         * @apioption xAxis.minTickInterval\n         */\n\n        /**\n         * The distance in pixels from the plot area to the axis line.\n         * A positive offset moves the axis with it's line, labels and ticks\n         * away from the plot area. This is typically used when two or more\n         * axes are displayed on the same side of the plot. With multiple\n         * axes the offset is dynamically adjusted to avoid collision, this\n         * can be overridden by setting offset explicitly.\n         *\n         * @sample    {highcharts} highcharts/yaxis/offset/\n         *            Y axis offset of 70\n         * @sample    {highcharts} highcharts/yaxis/offset-centered/\n         *            Axes positioned in the center of the plot\n         * @sample    {highstock} stock/xaxis/offset/\n         *            Y axis offset by 70 px\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption xAxis.offset\n         */\n\n        /**\n         * Whether to display the axis on the opposite side of the normal. The\n         * normal is on the left side for vertical axes and bottom for\n         * horizontal, so the opposite sides will be right and top respectively.\n         * This is typically used with dual or multiple axes.\n         *\n         * @sample {highcharts} highcharts/yaxis/opposite/\n         *         Secondary Y axis opposite\n         * @sample {highstock} stock/xaxis/opposite/\n         *         Y axis on left side\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption xAxis.opposite\n         */\n\n        /**\n         * In an ordinal axis, the points are equally spaced in the chart\n         * regardless of the actual time or x distance between them. This means\n         * that missing data periods (e.g. nights or weekends for a stock chart)\n         * will not take up space in the chart.\n         * Having `ordinal: false` will show any gaps created by the `gapSize`\n         * setting proportionate to their duration.\n         *\n         * In stock charts the X axis is ordinal by default, unless\n         * the boost module is used and at least one of the series' data length\n         * exceeds the [boostThreshold](#series.line.boostThreshold).\n         *\n         * @sample {highstock} stock/xaxis/ordinal-true/\n         *         True by default\n         * @sample {highstock} stock/xaxis/ordinal-false/\n         *         False\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     1.1\n         * @product   highstock\n         * @apioption xAxis.ordinal\n         */\n\n        /**\n         * Additional range on the right side of the xAxis. Works similar to\n         * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for\n         * both main `xAxis` and the navigator's `xAxis`.\n         *\n         * @sample {highstock} stock/xaxis/overscroll/\n         *         One minute overscroll with live data\n         *\n         * @type      {number}\n         * @default   0\n         * @since     6.0.0\n         * @product   highstock\n         * @apioption xAxis.overscroll\n         */\n\n        /**\n         * Refers to the index in the [panes](#panes) array. Used for circular\n         * gauges and polar charts. When the option is not set then first pane\n         * will be used.\n         *\n         * @sample highcharts/demo/gauge-vu-meter\n         *         Two gauges with different center\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption xAxis.pane\n         */\n\n\n        /**\n         * The zoomed range to display when only defining one or none of `min`\n         * or `max`. For example, to show the latest month, a range of one month\n         * can be set.\n         *\n         * @sample {highstock} stock/xaxis/range/\n         *         Setting a zoomed range when the rangeSelector is disabled\n         *\n         * @type      {number}\n         * @product   highstock\n         * @apioption xAxis.range\n         */\n\n        /**\n         * Whether to reverse the axis so that the highest number is closest\n         * to the origin. If the chart is inverted, the x axis is reversed by\n         * default.\n         *\n         * @sample {highcharts} highcharts/yaxis/reversed/\n         *         Reversed Y axis\n         * @sample {highstock} stock/xaxis/reversed/\n         *         Reversed Y axis\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption xAxis.reversed\n         */\n        // reversed: false,\n\n        /**\n         * This option determines how stacks should be ordered within a group.\n         * For example reversed xAxis also reverses stacks, so first series\n         * comes last in a group. To keep order like for non-reversed xAxis\n         * enable this option.\n         *\n         * @sample {highcharts} highcharts/xaxis/reversedstacks/\n         *         Reversed stacks comparison\n         * @sample {highstock} highcharts/xaxis/reversedstacks/\n         *         Reversed stacks comparison\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     6.1.1\n         * @product   highcharts highstock\n         * @apioption xAxis.reversedStacks\n         */\n\n        /**\n         * An optional scrollbar to display on the X axis in response to\n         * limiting the minimum and maximum of the axis values.\n         *\n         * In styled mode, all the presentational options for the scrollbar\n         * are replaced by the classes `.highcharts-scrollbar-thumb`,\n         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n         *\n         * @sample {highstock} stock/yaxis/heatmap-scrollbars/\n         *         Heatmap with both scrollbars\n         *\n         * @type      {*}\n         * @extends   scrollbar\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption xAxis.scrollbar\n         */\n\n        /**\n         * Whether to show the axis line and title when the axis has no data.\n         *\n         * @sample {highcharts} highcharts/yaxis/showempty/\n         *         When clicking the legend to hide series, one axis preserves\n         *         line and title, the other doesn't\n         * @sample {highstock} highcharts/yaxis/showempty/\n         *         When clicking the legend to hide series, one axis preserves\n         *         line and title, the other doesn't\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     1.1\n         * @apioption xAxis.showEmpty\n         */\n\n        /**\n         * Whether to show the first tick label.\n         *\n         * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/\n         *         Set to false on X axis\n         * @sample {highstock} stock/xaxis/showfirstlabel/\n         *         Labels below plot lines on Y axis\n         *\n         * @type      {boolean}\n         * @default   true\n         * @apioption xAxis.showFirstLabel\n         */\n\n        /**\n         * Whether to show the last tick label. Defaults to `true` on cartesian\n         * charts, and `false` on polar charts.\n         *\n         * @sample {highcharts} highcharts/xaxis/showlastlabel-true/\n         *         Set to true on X axis\n         * @sample {highstock} stock/xaxis/showfirstlabel/\n         *         Labels below plot lines on Y axis\n         *\n         * @type      {boolean}\n         * @default   true\n         * @product   highcharts highstock\n         * @apioption xAxis.showLastLabel\n         */\n\n        /**\n         * A soft maximum for the axis. If the series data maximum is less than\n         * this, the axis will stay at this maximum, but if the series data\n         * maximum is higher, the axis will flex to show all data.\n         *\n         * @sample highcharts/yaxis/softmin-softmax/\n         *         Soft min and max\n         *\n         * @type      {number}\n         * @since     5.0.1\n         * @product   highcharts highstock\n         * @apioption xAxis.softMax\n         */\n\n        /**\n         * A soft minimum for the axis. If the series data minimum is greater\n         * than this, the axis will stay at this minimum, but if the series\n         * data minimum is lower, the axis will flex to show all data.\n         *\n         * @sample highcharts/yaxis/softmin-softmax/\n         *         Soft min and max\n         *\n         * @type      {number}\n         * @since     5.0.1\n         * @product   highcharts highstock\n         * @apioption xAxis.softMin\n         */\n\n        /**\n         * For datetime axes, this decides where to put the tick between weeks.\n         *  0 = Sunday, 1 = Monday.\n         *\n         * @sample {highcharts} highcharts/xaxis/startofweek-monday/\n         *         Monday by default\n         * @sample {highcharts} highcharts/xaxis/startofweek-sunday/\n         *         Sunday\n         * @sample {highstock} stock/xaxis/startofweek-1\n         *         Monday by default\n         * @sample {highstock} stock/xaxis/startofweek-0\n         *         Sunday\n         *\n         * @product highcharts highstock\n         */\n        startOfWeek: 1,\n\n        /**\n         * Whether to force the axis to start on a tick. Use this option with\n         * the `minPadding` option to control the axis start.\n         *\n         * @productdesc {highstock}\n         * In Highstock, `startOnTick` is always false when the navigator is\n         * enabled, to prevent jumpy scrolling.\n         *\n         * @sample {highcharts} highcharts/xaxis/startontick-false/\n         *         False by default\n         * @sample {highcharts} highcharts/xaxis/startontick-true/\n         *         True\n         * @sample {highstock} stock/xaxis/endontick/\n         *         False for Y axis\n         *\n         * @since 1.2.0\n         */\n        startOnTick: false,\n\n\n        /**\n         * The amount of ticks to draw on the axis. This opens up for aligning\n         * the ticks of multiple charts or panes within a chart. This option\n         * overrides the `tickPixelInterval` option.\n         *\n         * This option only has an effect on linear axes. Datetime, logarithmic\n         * or category axes are not affected.\n         *\n         * @sample {highcharts} highcharts/yaxis/tickamount/\n         *         8 ticks on Y axis\n         * @sample {highstock} highcharts/yaxis/tickamount/\n         *         8 ticks on Y axis\n         *\n         * @type      {number}\n         * @since     4.1.0\n         * @product   highcharts highstock\n         * @apioption xAxis.tickAmount\n         */\n\n        /**\n         * The interval of the tick marks in axis units. When `undefined`, the\n         * tick interval is computed to approximately follow the\n         * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime\n         * axes. On categorized axes, a `undefined` tickInterval will default to\n         * 1, one category. Note that datetime axes are based on milliseconds,\n         * so for example an interval of one day is expressed as\n         * `24 * 3600 * 1000`.\n         *\n         * On logarithmic axes, the tickInterval is based on powers, so a\n         * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A\n         * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval\n         * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,\n         * 40 etc.\n         *\n         *\n         * If the tickInterval is too dense for labels to be drawn, Highcharts\n         * may remove ticks.\n         *\n         * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)\n         * option may interfere with the `tickInterval` setting.\n         *\n         * @see [tickPixelInterval](#xAxis.tickPixelInterval)\n         * @see [tickPositions](#xAxis.tickPositions)\n         * @see [tickPositioner](#xAxis.tickPositioner)\n         *\n         * @sample {highcharts} highcharts/xaxis/tickinterval-5/\n         *         Tick interval of 5 on a linear axis\n         * @sample {highstock} stock/xaxis/tickinterval/\n         *         Tick interval of 0.01 on Y axis\n         *\n         * @type      {number}\n         * @apioption xAxis.tickInterval\n         */\n\n        /**\n         * The pixel length of the main tick marks.\n         *\n         * @sample {highcharts} highcharts/xaxis/ticklength/\n         *         20 px tick length on the X axis\n         * @sample {highstock} stock/xaxis/ticks/\n         *         Formatted ticks on X axis\n         */\n        tickLength: 10,\n\n        /**\n         * If tickInterval is `null` this option sets the approximate pixel\n         * interval of the tick marks. Not applicable to categorized axis.\n         *\n         * The tick interval is also influenced by the [minTickInterval](\n         * #xAxis.minTickInterval) option, that, by default prevents ticks from\n         * being denser than the data points.\n         *\n         * @see [tickInterval](#xAxis.tickInterval)\n         * @see [tickPositioner](#xAxis.tickPositioner)\n         * @see [tickPositions](#xAxis.tickPositions)\n         *\n         * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/\n         *         50 px on X axis\n         * @sample {highstock} stock/xaxis/tickpixelinterval/\n         *         200 px on X axis\n         */\n        tickPixelInterval: 100,\n\n        /**\n         * For categorized axes only. If `on` the tick mark is placed in the\n         * center of the category, if `between` the tick mark is placed between\n         * categories. The default is `between` if the `tickInterval` is 1,\n         *  else `on`.\n         *\n         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/\n         *         \"between\" by default\n         * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/\n         *         \"on\"\n         *\n         * @product    highcharts\n         * @validvalue [null, \"on\", \"between\"]\n         */\n        tickmarkPlacement: 'between',\n\n        /**\n         * The position of the major tick marks relative to the axis line.\n         * Can be one of `inside` and `outside`.\n         *\n         * @sample {highcharts} highcharts/xaxis/tickposition-outside/\n         *         \"outside\" by default\n         * @sample {highcharts} highcharts/xaxis/tickposition-inside/\n         *         \"inside\"\n         * @sample {highstock} stock/xaxis/ticks/\n         *         Formatted ticks on X axis\n         *\n         * @validvalue [\"inside\", \"outside\"]\n         */\n        tickPosition: 'outside',\n\n        /**\n         * A callback function returning array defining where the ticks are\n         * laid out on the axis. This overrides the default behaviour of\n         * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](\n         * #xAxis.tickInterval). The automatic tick positions are accessible\n         * through `this.tickPositions` and can be modified by the callback.\n         *\n         * @see [tickPositions](#xAxis.tickPositions)\n         *\n         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n         *         Demo of tickPositions and tickPositioner\n         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n         *         Demo of tickPositions and tickPositioner\n         *\n         * @type      {Function}\n         * @apioption xAxis.tickPositioner\n         */\n\n        /**\n         * An array defining where the ticks are laid out on the axis. This\n         * overrides the default behaviour of [tickPixelInterval](\n         * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).\n         *\n         * @see [tickPositioner](#xAxis.tickPositioner)\n         *\n         * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/\n         *         Demo of tickPositions and tickPositioner\n         * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/\n         *         Demo of tickPositions and tickPositioner\n         *\n         * @type      {Array<number>}\n         * @apioption xAxis.tickPositions\n         */\n\n        /**\n         * The pixel width of the major tick marks.\n         *\n         * In styled mode, the stroke width is given in the `.highcharts-tick`\n         * class.\n         *\n         * @sample {highcharts} highcharts/xaxis/tickwidth/\n         *         10 px width\n         * @sample {highcharts} highcharts/css/axis-grid/\n         *         Styled mode\n         * @sample {highstock} stock/xaxis/ticks/\n         *         Formatted ticks on X axis\n         * @sample {highstock} highcharts/css/axis-grid/\n         *         Styled mode\n         *\n         * @type      {number}\n         * @default   {highcharts} 1\n         * @default   {highstock} 1\n         * @default   {highmaps} 0\n         * @apioption xAxis.tickWidth\n         */\n\n        /**\n         * The axis title, showing next to the axis line.\n         *\n         * @productdesc {highmaps}\n         * In Highmaps, the axis is hidden by default, but adding an axis title\n         * is still possible. X axis and Y axis titles will appear at the bottom\n         * and left by default.\n         */\n        title: {\n\n            /**\n             * Deprecated. Set the `text` to `null` to disable the title.\n             *\n             * @deprecated\n             * @type      {string}\n             * @default   middle\n             * @product   highcharts\n             * @apioption xAxis.title.enabled\n             */\n\n            /**\n             * The pixel distance between the axis labels or line and the title.\n             * Defaults to 0 for horizontal axes, 10 for vertical\n             *\n             * @sample {highcharts} highcharts/xaxis/title-margin/\n             *         Y axis title margin of 60\n             *\n             * @type      {number}\n             * @apioption xAxis.title.margin\n             */\n\n            /**\n             * The distance of the axis title from the axis line. By default,\n             * this distance is computed from the offset width of the labels,\n             * the labels' distance from the axis and the title's margin.\n             * However when the offset option is set, it overrides all this.\n             *\n             * @sample {highcharts} highcharts/yaxis/title-offset/\n             *         Place the axis title on top of the axis\n             * @sample {highstock} highcharts/yaxis/title-offset/\n             *         Place the axis title on top of the Y axis\n             *\n             * @type      {number}\n             * @since     2.2.0\n             * @apioption xAxis.title.offset\n             */\n\n            /**\n             * Whether to reserve space for the title when laying out the axis.\n             *\n             * @type      {boolean}\n             * @default   true\n             * @since     5.0.11\n             * @product   highcharts highstock\n             * @apioption xAxis.title.reserveSpace\n             */\n\n            /**\n             * The rotation of the text in degrees. 0 is horizontal, 270 is\n             * vertical reading from bottom to top.\n             *\n             * @sample {highcharts} highcharts/yaxis/title-offset/\n             *         Horizontal\n             *\n             * @type      {number}\n             * @default   0\n             * @apioption xAxis.title.rotation\n             */\n\n            /**\n             * The actual text of the axis title. It can contain basic HTML text\n             * markup like <b>, <i> and spans with style.\n             *\n             * @sample {highcharts} highcharts/xaxis/title-text/\n             *         Custom HTML\n             * @sample {highstock} stock/xaxis/title-text/\n             *         Titles for both axes\n             *\n             * @type      {string}\n             * @apioption xAxis.title.text\n             */\n\n            /**\n             * Alignment of the text, can be `\"left\"`, `\"right\"` or `\"center\"`.\n             * Default alignment depends on the\n             * [title.align](xAxis.title.align):\n             *\n             * Horizontal axes:\n             * - for `align` = `\"low\"`, `textAlign` is set to `left`\n             * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n             * - for `align` = `\"high\"`, `textAlign` is set to `right`\n             *\n             * Vertical axes:\n             * - for `align` = `\"low\"` and `opposite` = `true`, `textAlign` is\n             *   set to `right`\n             * - for `align` = `\"low\"` and `opposite` = `false`, `textAlign` is\n             *   set to `left`\n             * - for `align` = `\"middle\"`, `textAlign` is set to `center`\n             * - for `align` = `\"high\"` and `opposite` = `true` `textAlign` is\n             *   set to `left`\n             * - for `align` = `\"high\"` and `opposite` = `false` `textAlign` is\n             *   set to `right`\n             *\n             * @type      {string}\n             * @apioption xAxis.title.textAlign\n             */\n\n            /**\n             * Whether to [use HTML](https://www.highcharts.com/docs/\n             * chart-concepts/labels-and-string-formatting#html) to render the\n             * axis title.\n             *\n             * @type      {boolean}\n             * @default   false\n             * @product   highcharts highstock\n             * @apioption xAxis.title.useHTML\n             */\n\n            /**\n             * Horizontal pixel offset of the title position.\n             *\n             * @type      {number}\n             * @default   0\n             * @since     4.1.6\n             * @product   highcharts highstock\n             * @apioption xAxis.title.x\n             */\n\n            /**\n             * Vertical pixel offset of the title position.\n             *\n             * @type      {number}\n             * @product   highcharts highstock\n             * @apioption xAxis.title.y\n             */\n\n            /**\n             * Alignment of the title relative to the axis values. Possible\n             * values are \"low\", \"middle\" or \"high\".\n             *\n             * @sample {highcharts} highcharts/xaxis/title-align-low/\n             *         \"low\"\n             * @sample {highcharts} highcharts/xaxis/title-align-center/\n             *         \"middle\" by default\n             * @sample {highcharts} highcharts/xaxis/title-align-high/\n             *         \"high\"\n             * @sample {highcharts} highcharts/yaxis/title-offset/\n             *         Place the Y axis title on top of the axis\n             * @sample {highstock} stock/xaxis/title-align/\n             *         Aligned to \"high\" value\n             *\n             * @validvalue [\"low\", \"middle\", \"high\"]\n             */\n            align: 'middle'\n\n            \n\n        },\n\n        /**\n         * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`\n         * or `category`. In a datetime axis, the numbers are given in\n         * milliseconds, and tick marks are placed on appropriate values like\n         * full hours or days. In a category axis, the\n         * [point names](#series.line.data.name) of the chart's series are used\n         * for categories, if not a [categories](#xAxis.categories) array is\n         * defined.\n         *\n         * @sample {highcharts} highcharts/xaxis/type-linear/\n         *         Linear\n         * @sample {highcharts} highcharts/yaxis/type-log/\n         *         Logarithmic\n         * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/\n         *         Logarithmic with minor grid lines\n         * @sample {highcharts} highcharts/xaxis/type-log-both/\n         *         Logarithmic on two axes\n         * @sample {highcharts} highcharts/yaxis/type-log-negative/\n         *         Logarithmic with extension to emulate negative values\n         *\n         * @product    highcharts\n         * @validvalue [\"linear\", \"logarithmic\", \"datetime\", \"category\"]\n         */\n        type: 'linear',\n\n        /**\n         * Applies only when the axis `type` is `category`. When `uniqueNames`\n         * is true, points are placed on the X axis according to their names.\n         * If the same point name is repeated in the same or another series,\n         * the point is placed on the same X position as other points of the\n         * same name. When `uniqueNames` is false, the points are laid out in\n         * increasing X positions regardless of their names, and the X axis\n         * category will take the name of the last point in each position.\n         *\n         * @sample {highcharts} highcharts/xaxis/uniquenames-true/\n         *         True by default\n         * @sample {highcharts} highcharts/xaxis/uniquenames-false/\n         *         False\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.2.7\n         * @product   highcharts\n         * @apioption xAxis.uniqueNames\n         */\n\n        /**\n         * Datetime axis only. An array determining what time intervals the\n         * ticks are allowed to fall on. Each array item is an array where the\n         * first value is the time unit and the second value another array of\n         * allowed multiples. Defaults to:\n         *\n         * <pre>units: [[\n         *     'millisecond', // unit name\n         *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n         * ], [\n         *     'second',\n         *     [1, 2, 5, 10, 15, 30]\n         * ], [\n         *     'minute',\n         *     [1, 2, 5, 10, 15, 30]\n         * ], [\n         *     'hour',\n         *     [1, 2, 3, 4, 6, 8, 12]\n         * ], [\n         *     'day',\n         *     [1]\n         * ], [\n         *     'week',\n         *     [1]\n         * ], [\n         *     'month',\n         *     [1, 3, 6]\n         * ], [\n         *     'year',\n         *     null\n         * ]]</pre>\n         *\n         * @type      {Array<Array<string|Array<number>>>}\n         * @product   highcharts highstock\n         * @apioption xAxis.units\n         */\n\n        /**\n         * Whether axis, including axis title, line, ticks and labels, should\n         * be visible.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.1.9\n         * @product   highcharts highstock\n         * @apioption xAxis.visible\n         */\n\n        \n\n    },\n\n    /**\n     * The Y axis or value axis. Normally this is the vertical axis,\n     * though if the chart is inverted this is the horizontal axis.\n     * In case of multiple axes, the yAxis node is an array of\n     * configuration objects.\n     *\n     * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n     * access to the axis.\n     *\n     * @extends      xAxis\n     * @excluding    ordinal, overscroll\n     * @optionparent yAxis\n     */\n    defaultYAxisOptions: {\n\n        /**\n         * In a polar chart, this is the angle of the Y axis in degrees, where\n         * 0 is up and 90 is right. The angle determines the position of the\n         * axis line and the labels, though the coordinate system is unaffected.\n         *\n         * @sample {highcharts} highcharts/yaxis/angle/\n         *         Dual axis polar chart\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.2.7\n         * @product   highcharts\n         * @apioption yAxis.angle\n         */\n\n        /**\n         * Polar charts only. Whether the grid lines should draw as a polygon\n         * with straight lines between categories, or as circles. Can be either\n         * `circle` or `polygon`.\n         *\n         * @sample {highcharts} highcharts/demo/polar-spider/\n         *         Polygon grid lines\n         * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/\n         *         Circle and polygon\n         *\n         * @type       {string}\n         * @product    highcharts\n         * @validvalue [\"circle\", \"polygon\"]\n         * @apioption  yAxis.gridLineInterpolation\n         */\n\n        /**\n         * The height of the Y axis. If it's a number, it is interpreted as\n         * pixels.\n         *\n         * Since Highstock 2: If it's a percentage string, it is interpreted\n         * as percentages of the total plot height.\n         *\n         * @see [yAxis.top](#yAxis.top)\n         *\n         * @sample {highstock} stock/demo/candlestick-and-volume/\n         *         Percentage height panes\n         *\n         * @type      {number|string}\n         * @product   highstock\n         * @apioption yAxis.height\n         */\n\n        /**\n         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n         * to represent the maximum value of the Y axis.\n         *\n         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n         *         Min and max colors\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #003399\n         * @since     4.0\n         * @product   highcharts\n         * @apioption yAxis.maxColor\n         */\n\n        /**\n         * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color\n         * to represent the minimum value of the Y axis.\n         *\n         * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/\n         *         Min and max color\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #e6ebf5\n         * @since     4.0\n         * @product   highcharts\n         * @apioption yAxis.minColor\n         */\n\n        /**\n         * Whether to reverse the axis so that the highest number is closest\n         * to the origin.\n         *\n         * @sample {highcharts} highcharts/yaxis/reversed/\n         *         Reversed Y axis\n         * @sample {highstock} stock/xaxis/reversed/\n         *         Reversed Y axis\n         *\n         * @type      {boolean}\n         * @default   {highcharts} false\n         * @default   {highstock} false\n         * @default   {highmaps} true\n         * @apioption yAxis.reversed\n         */\n\n        /**\n         * If `true`, the first series in a stack will be drawn on top in a\n         * positive, non-reversed Y axis. If `false`, the first series is in\n         * the base of the stack.\n         *\n         * @sample {highcharts} highcharts/yaxis/reversedstacks-false/\n         *         Non-reversed stacks\n         * @sample {highstock} highcharts/yaxis/reversedstacks-false/\n         *         Non-reversed stacks\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     3.0.10\n         * @product   highcharts highstock\n         * @apioption yAxis.reversedStacks\n         */\n\n        /**\n         * Solid gauge series only. Color stops for the solid gauge. Use this\n         * in cases where a linear gradient between a `minColor` and `maxColor`\n         * is not sufficient. The stops is an array of tuples, where the first\n         * item is a float between 0 and 1 assigning the relative position in\n         * the gradient, and the second item is the color.\n         *\n         * For solid gauges, the Y axis also inherits the concept of [data classes](http://api.\n         * highcharts.com/highmaps#colorAxis.dataClasses) from the Highmaps\n         * color axis.\n         *\n         * @see [minColor](#yAxis.minColor)\n         * @see [maxColor](#yAxis.maxColor)\n         *\n         * @sample {highcharts} highcharts/demo/gauge-solid/\n         *         True by default\n         *\n         * @type      {Array<Array<number, Highcharts.ColorString>>}\n         * @since     4.0\n         * @product   highcharts\n         * @apioption yAxis.stops\n         */\n\n        /**\n         * The pixel width of the major tick marks.\n         *\n         * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width\n         * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis\n         *\n         * @type      {number}\n         * @default   0\n         * @product   highcharts highstock\n         * @apioption yAxis.tickWidth\n         */\n\n        /**\n         * Angular gauges and solid gauges only. The label's pixel distance\n         * from the perimeter of the plot area.\n         *\n         * @type      {number}\n         * @default   -25\n         * @product   highcharts\n         * @apioption yAxis.labels.distance\n         */\n\n        /**\n         * The y position offset of the label relative to the tick position\n         * on the axis.\n         *\n         * @sample {highcharts} highcharts/xaxis/labels-x/\n         *         Y axis labels placed on grid lines\n         *\n         * @type      {number}\n         * @default   {highcharts} 3\n         * @default   {highstock} -2\n         * @default   {highmaps} 3\n         * @apioption yAxis.labels.y\n         */\n\n        /**\n         * @productdesc {highstock}\n         * In Highstock, `endOnTick` is always false when the navigator is\n         * enabled, to prevent jumpy scrolling.\n         */\n        endOnTick: true,\n\n        /**\n         * Padding of the max value relative to the length of the axis. A\n         * padding of 0.05 will make a 100px axis 5px longer. This is useful\n         * when you don't want the highest data value to appear on the edge\n         * of the plot area. When the axis' `max` option is set or a max extreme\n         * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n         *\n         * @sample {highcharts} highcharts/yaxis/maxpadding-02/\n         *         Max padding of 0.2\n         * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n         *         Greater min- and maxPadding\n         *\n         * @since   1.2.0\n         * @product highcharts highstock\n         */\n        maxPadding: 0.05,\n\n        /**\n         * Padding of the min value relative to the length of the axis. A\n         * padding of 0.05 will make a 100px axis 5px longer. This is useful\n         * when you don't want the lowest data value to appear on the edge\n         * of the plot area. When the axis' `min` option is set or a max extreme\n         * is set using `axis.setExtremes()`, the maxPadding will be ignored.\n         *\n         * @sample {highcharts} highcharts/yaxis/minpadding/\n         *         Min padding of 0.2\n         * @sample {highstock} stock/xaxis/minpadding-maxpadding/\n         *         Greater min- and maxPadding\n         *\n         * @since   1.2.0\n         * @product highcharts highstock\n         */\n        minPadding: 0.05,\n\n        /**\n         * @productdesc {highstock}\n         * In Highstock 1.x, the Y axis was placed on the left side by default.\n         *\n         * @sample {highcharts} highcharts/yaxis/opposite/\n         *         Secondary Y axis opposite\n         * @sample {highstock} stock/xaxis/opposite/\n         *         Y axis on left side\n         *\n         * @type      {boolean}\n         * @default   {highstock} true\n         * @default   {highcharts} false\n         * @product   highstock highcharts\n         * @apioption yAxis.opposite\n         */\n\n        /**\n         * @see [tickInterval](#xAxis.tickInterval)\n         * @see [tickPositioner](#xAxis.tickPositioner)\n         * @see [tickPositions](#xAxis.tickPositions)\n         */\n        tickPixelInterval: 72,\n\n        showLastLabel: true,\n\n        /**\n         * @extends    xAxis.labels\n         */\n        labels: {\n            /**\n             * What part of the string the given position is anchored to. Can\n             * be one of `\"left\"`, `\"center\"` or `\"right\"`. The exact position\n             * also depends on the `labels.x` setting.\n             *\n             * Angular gauges and solid gauges defaults to `center`.\n             *\n             * @sample {highcharts} highcharts/yaxis/labels-align-left/\n             *         Left\n             *\n             * @type       {string}\n             * @default    {highcharts|highmaps} right\n             * @default    {highstock} left\n             * @validvalue [\"left\", \"center\", \"right\"]\n             * @apioption  yAxis.labels.align\n             */\n\n            /**\n             * The x position offset of the label relative to the tick position\n             * on the axis. Defaults to -15 for left axis, 15 for right axis.\n             *\n             * @sample {highcharts} highcharts/xaxis/labels-x/\n             *         Y axis labels placed on grid lines\n             */\n            x: -8\n        },\n\n        /**\n         * @productdesc {highmaps}\n         * In Highmaps, the axis line is hidden by default, because the axis is\n         * not visible by default.\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption yAxis.lineColor\n         */\n\n        /**\n         * @sample {highcharts} highcharts/yaxis/max-200/\n         *         Y axis max of 200\n         * @sample {highcharts} highcharts/yaxis/max-logarithmic/\n         *         Y axis max on logarithmic axis\n         * @sample {highstock} stock/yaxis/min-max/\n         *         Fixed min and max on Y axis\n         * @sample {highmaps} maps/axis/min-max/\n         *         Pre-zoomed to a specific area\n         *\n         * @type      {number}\n         * @apioption yAxis.max\n         */\n\n        /**\n         * @sample {highcharts} highcharts/yaxis/min-startontick-false/\n         *         -50 with startOnTick to false\n         * @sample {highcharts} highcharts/yaxis/min-startontick-true/\n         *         -50 with startOnTick true by default\n         * @sample {highstock} stock/yaxis/min-max/\n         *         Fixed min and max on Y axis\n         * @sample {highmaps} maps/axis/min-max/\n         *         Pre-zoomed to a specific area\n         *\n         * @type      {number}\n         * @apioption yAxis.min\n         */\n\n        /**\n         * An optional scrollbar to display on the Y axis in response to\n         * limiting the minimum an maximum of the axis values.\n         *\n         * In styled mode, all the presentational options for the scrollbar\n         * are replaced by the classes `.highcharts-scrollbar-thumb`,\n         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n         *\n         * @sample {highstock} stock/yaxis/scrollbar/\n         *         Scrollbar on the Y axis\n         *\n         * @extends   scrollbar\n         * @excluding height\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar\n         */\n\n        /**\n         * Enable the scrollbar on the Y axis.\n         *\n         * @sample {highstock} stock/yaxis/scrollbar/\n         *         Enabled on Y axis\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar.enabled\n         */\n\n        /**\n         * Pixel margin between the scrollbar and the axis elements.\n         *\n         * @type      {number}\n         * @default   10\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar.margin\n         */\n\n        /**\n         * Whether to show the scrollbar when it is fully zoomed out at max\n         * range. Setting it to `false` on the Y axis makes the scrollbar stay\n         * hidden until the user zooms in, like common in browsers.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar.showFull\n         */\n\n        /**\n         * The width of a vertical scrollbar or height of a horizontal\n         * scrollbar. Defaults to 20 on touch devices.\n         *\n         * @type      {number}\n         * @default   14\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar.size\n         */\n\n        /**\n         * Z index of the scrollbar elements.\n         *\n         * @type      {number}\n         * @default   3\n         * @since     4.2.6\n         * @product   highstock\n         * @apioption yAxis.scrollbar.zIndex\n         */\n\n        /**\n         * A soft maximum for the axis. If the series data maximum is less\n         * than this, the axis will stay at this maximum, but if the series\n         * data maximum is higher, the axis will flex to show all data.\n         *\n         * **Note**: The [series.softThreshold](\n         * #plotOptions.series.softThreshold) option takes precedence over this\n         * option.\n         *\n         * @sample highcharts/yaxis/softmin-softmax/\n         *         Soft min and max\n         *\n         * @type      {number}\n         * @since     5.0.1\n         * @product   highcharts highstock\n         * @apioption yAxis.softMax\n         */\n\n        /**\n         * A soft minimum for the axis. If the series data minimum is greater\n         * than this, the axis will stay at this minimum, but if the series\n         * data minimum is lower, the axis will flex to show all data.\n         *\n         * **Note**: The [series.softThreshold](\n         * #plotOptions.series.softThreshold) option takes precedence over this\n         * option.\n         *\n         * @sample highcharts/yaxis/softmin-softmax/\n         *         Soft min and max\n         *\n         * @type      {number}\n         * @since     5.0.1\n         * @product   highcharts highstock\n         * @apioption yAxis.softMin\n         */\n\n        /**\n         * Defines the horizontal alignment of the stack total label. Can be one\n         * of `\"left\"`, `\"center\"` or `\"right\"`. The default value is calculated\n         * at runtime and depends on orientation and whether the stack is\n         * positive or negative.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/\n         *         Aligned to the left\n         * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/\n         *         Aligned in center\n         * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/\n         *         Aligned to the right\n         *\n         * @type       {string}\n         * @since      2.1.5\n         * @product    highcharts\n         * @validvalue [\"left\", \"center\", \"right\"]\n         * @apioption  yAxis.stackLabels.align\n         */\n\n        /**\n         * A [format string](http://docs.highcharts.com/#formatting) for the\n         * data label. Available variables are the same as for `formatter`.\n         *\n         * @type      {string}\n         * @default   {total}\n         * @since     3.0.2\n         * @product   highcharts highstock\n         * @apioption yAxis.stackLabels.format\n         */\n\n        /**\n         * Rotation of the labels in degrees.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/\n         *         Labels rotated 45\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.1.5\n         * @product   highcharts\n         * @apioption yAxis.stackLabels.rotation\n         */\n\n        /**\n         * The text alignment for the label. While `align` determines where the\n         * texts anchor point is placed with regards to the stack, `textAlign`\n         * determines how the text is aligned against its anchor point. Possible\n         * values are `\"left\"`, `\"center\"` and `\"right\"`. The default value is\n         * calculated at runtime and depends on orientation and whether the\n         * stack is positive or negative.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/\n         *         Label in center position but text-aligned left\n         *\n         * @type       {string}\n         * @since      2.1.5\n         * @product    highcharts\n         * @validvalue [\"left\", \"center\", \"right\"]\n         * @apioption  yAxis.stackLabels.textAlign\n         */\n\n        /**\n         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/\n         * labels-and-string-formatting#html) to render the labels.\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     3.0\n         * @product   highcharts highstock\n         * @apioption yAxis.stackLabels.useHTML\n         */\n\n        /**\n         * Defines the vertical alignment of the stack total label. Can be one\n         * of `\"top\"`, `\"middle\"` or `\"bottom\"`. The default value is calculated\n         * at runtime and depends on orientation and whether the stack is\n         * positive or negative.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/\n         *         Vertically aligned top\n         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/\n         *         Vertically aligned middle\n         * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/\n         *         Vertically aligned bottom\n         *\n         * @type       {string}\n         * @since      2.1.5\n         * @product    highcharts\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @apioption  yAxis.stackLabels.verticalAlign\n         */\n\n        /**\n         * The x position offset of the label relative to the left of the\n         * stacked bar. The default value is calculated at runtime and depends\n         * on orientation and whether the stack is positive or negative.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-x/\n         *         Stack total labels with x offset\n         *\n         * @type      {number}\n         * @since     2.1.5\n         * @product   highcharts\n         * @apioption yAxis.stackLabels.x\n         */\n\n        /**\n         * The y position offset of the label relative to the tick position\n         * on the axis. The default value is calculated at runtime and depends\n         * on orientation and whether the stack is positive or negative.\n         *\n         * @sample {highcharts} highcharts/yaxis/stacklabels-y/\n         *         Stack total labels with y offset\n         *\n         * @type      {number}\n         * @since     2.1.5\n         * @product   highcharts\n         * @apioption yAxis.stackLabels.y\n         */\n\n        /**\n         * Whether to force the axis to start on a tick. Use this option with\n         * the `maxPadding` option to control the axis start.\n         *\n         * @sample  {highcharts} highcharts/xaxis/startontick-false/\n         *          False by default\n         * @sample  {highcharts} highcharts/xaxis/startontick-true/\n         *          True\n         * @sample  {highstock} stock/xaxis/endontick/\n         *          False for Y axis\n         *\n         * @since   1.2.0\n         * @product highcharts highstock\n         */\n        startOnTick: true,\n\n        title: {\n\n            /**\n             * The pixel distance between the axis labels and the title.\n             * Positive values are outside the axis line, negative are inside.\n             *\n             * @sample {highcharts} highcharts/xaxis/title-margin/\n             *         Y axis title margin of 60\n             *\n             * @type      {number}\n             * @default   40\n             * @apioption yAxis.title.margin\n             */\n\n            /**\n             * The rotation of the text in degrees. 0 is horizontal, 270 is\n             * vertical reading from bottom to top.\n             *\n             * @sample {highcharts} highcharts/yaxis/title-offset/\n             *         Horizontal\n             */\n            rotation: 270,\n\n            /**\n             * The actual text of the axis title. Horizontal texts can contain\n             * HTML, but rotated texts are painted using vector techniques and\n             * must be clean text. The Y axis title is disabled by setting the\n             * `text` option to `undefined`.\n             *\n             * @sample  {highcharts} highcharts/xaxis/title-text/\n             *          Custom HTML\n             *\n             * @default {highcharts} Values\n             * @default {highstock} undefined\n             * @product highcharts highstock\n             */\n            text: 'Values'\n        },\n\n        /**\n         * The top position of the Y axis. If it's a number, it is interpreted\n         * as pixel position relative to the chart.\n         *\n         * Since Highstock 2: If it's a percentage string, it is interpreted\n         * as percentages of the plot height, offset from plot area top.\n         *\n         * @see [yAxis.height](#yAxis.height)\n         *\n         * @sample {highstock} stock/demo/candlestick-and-volume/\n         *         Percentage height panes\n         *\n         * @type      {number|string}\n         * @product   highstock\n         * @apioption yAxis.top\n         */\n\n        /**\n         * The stack labels show the total value for each bar in a stacked\n         * column or bar chart. The label will be placed on top of positive\n         * columns and below negative columns. In case of an inverted column\n         * chart or a bar chart the label is placed to the right of positive\n         * bars and to the left of negative bars.\n         *\n         * @product highcharts\n         */\n        stackLabels: {\n\n            /**\n             * Allow the stack labels to overlap.\n             *\n             * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/\n             *         Default false\n             *\n             * @since   5.0.13\n             * @product highcharts\n             */\n            allowOverlap: false,\n\n            /**\n             * Enable or disable the stack total labels.\n             *\n             * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/\n             *         Enabled stack total labels\n             *\n             * @since   2.1.5\n             * @product highcharts\n             */\n            enabled: false,\n\n            /**\n             * Callback JavaScript function to format the label. The value is\n             * given by `this.total`.\n             *\n             * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/\n             *         Added units to stack total value\n             *\n             * @type    {Highcharts.FormatterCallbackFunction}\n             * @since   2.1.5\n             * @product highcharts\n             */\n            formatter: function () {\n                return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(this.total, -1);\n            }\n\n            \n\n        }\n\n        \n\n    },\n\n    /**\n     * The Z axis or depth axis for 3D plots.\n     *\n     * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic\n     * access to the axis.\n     *\n     * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/\n     *         Z-Axis with Categories\n     * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/\n     *         Z-Axis with styling\n     *\n     * @extends   xAxis\n     * @since     5.0.0\n     * @product   highcharts\n     * @excluding breaks, crosshair, lineColor, lineWidth, nameToX, showEmpty\n     * @apioption zAxis\n     */\n\n    /**\n     * These options extend the defaultOptions for left axes.\n     *\n     * @private\n     * @name Highcharts.Axis#defaultLeftAxisOptions\n     * @type {*}\n     */\n    defaultLeftAxisOptions: {\n        labels: {\n            x: -15\n        },\n        title: {\n            rotation: 270\n        }\n    },\n\n    /**\n     * These options extend the defaultOptions for right axes.\n     *\n     * @private\n     * @name Highcharts.Axis#defaultRightAxisOptions\n     * @type {*}\n     */\n    defaultRightAxisOptions: {\n        labels: {\n            x: 15\n        },\n        title: {\n            rotation: 90\n        }\n    },\n\n    /**\n     * These options extend the defaultOptions for bottom axes.\n     *\n     * @private\n     * @name Highcharts.Axis#defaultBottomAxisOptions\n     * @type {*}\n     */\n    defaultBottomAxisOptions: {\n        labels: {\n            autoRotation: [-45],\n            x: 0\n            // overflow: undefined,\n            // staggerLines: null\n        },\n        title: {\n            rotation: 0\n        }\n    },\n    /**\n     * These options extend the defaultOptions for top axes.\n     *\n     * @private\n     * @name Highcharts.Axis#defaultTopAxisOptions\n     * @type {*}\n     */\n    defaultTopAxisOptions: {\n        labels: {\n            autoRotation: [-45],\n            x: 0\n            // overflow: undefined\n            // staggerLines: null\n        },\n        title: {\n            rotation: 0\n        }\n    },\n\n    /**\n     * Overrideable function to initialize the axis.\n     *\n     * @see {@link Axis}\n     *\n     * @function Highcharts.Axis#init\n     *\n     * @param {Highcharts.Chart} chart\n     *\n     * @param {Highcharts.Options} userOptions\n     *\n     * @fires Highcharts.Axis#event:afterInit\n     * @fires Highcharts.Axis#event:init\n     */\n    init: function (chart, userOptions) {\n\n\n        var isXAxis = userOptions.isX,\n            axis = this;\n\n        /**\n         * The Chart that the axis belongs to.\n         *\n         * @name Highcharts.Axis#chart\n         * @type {Highcharts.Chart}\n         */\n        axis.chart = chart;\n\n        /**\n         * Whether the axis is horizontal.\n         *\n         * @name Highcharts.Axis#horiz\n         * @type {boolean}\n         */\n        axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;\n\n        // Flag, isXAxis\n        axis.isXAxis = isXAxis;\n\n        /**\n         * The collection where the axis belongs, for example `xAxis`, `yAxis`\n         * or `colorAxis`. Corresponds to properties on Chart, for example\n         * {@link Chart.xAxis}.\n         *\n         * @name Highcharts.Axis#coll\n         * @type {string}\n         */\n        axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n\n        fireEvent(this, 'init', { userOptions: userOptions });\n\n        axis.opposite = userOptions.opposite; // needed in setOptions\n\n        /**\n         * The side on which the axis is rendered. 0 is top, 1 is right, 2 is\n         * bottom and 3 is left.\n         *\n         * @name Highcharts.Axis#side\n         * @type {number}\n         */\n        axis.side = userOptions.side || (axis.horiz ?\n                (axis.opposite ? 0 : 2) : // top : bottom\n                (axis.opposite ? 1 : 3));  // right : left\n\n        axis.setOptions(userOptions);\n\n\n        var options = this.options,\n            type = options.type,\n            isDatetimeAxis = type === 'datetime';\n\n        axis.labelFormatter = options.labels.formatter ||\n            axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n        // Flag, stagger lines or not\n        axis.userOptions = userOptions;\n\n        axis.minPixelPadding = 0;\n\n\n        /**\n         * Whether the axis is reversed. Based on the `axis.reversed`,\n         * option, but inverted charts have reversed xAxis by default.\n         *\n         * @name Highcharts.Axis#reversed\n         * @type {boolean}\n         */\n        axis.reversed = options.reversed;\n        axis.visible = options.visible !== false;\n        axis.zoomEnabled = options.zoomEnabled !== false;\n\n        // Initial categories\n        axis.hasNames = type === 'category' || options.categories === true;\n        axis.categories = options.categories || axis.hasNames;\n        if (!axis.names) { // Preserve on update (#3830)\n            axis.names = [];\n            axis.names.keys = {};\n        }\n\n\n        // Placeholder for plotlines and plotbands groups\n        axis.plotLinesAndBandsGroups = {};\n\n        // Shorthand types\n        axis.isLog = type === 'logarithmic';\n        axis.isDatetimeAxis = isDatetimeAxis;\n        axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;\n\n        // Flag, if axis is linked to another axis\n        axis.isLinked = defined(options.linkedTo);\n\n        // Major ticks\n        axis.ticks = {};\n        axis.labelEdge = [];\n        // Minor ticks\n        axis.minorTicks = {};\n\n        // List of plotLines/Bands\n        axis.plotLinesAndBands = [];\n\n        // Alternate bands\n        axis.alternateBands = {};\n\n        // Axis metrics\n        axis.len = 0;\n        axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n        axis.range = options.range;\n        axis.offset = options.offset || 0;\n\n\n        // Dictionary for stacks\n        axis.stacks = {};\n        axis.oldStacks = {};\n        axis.stacksTouched = 0;\n\n\n        /**\n         * The maximum value of the axis. In a logarithmic axis, this is the\n         * logarithm of the real value, and the real value can be obtained from\n         * {@link Axis#getExtremes}.\n         *\n         * @name Highcharts.Axis#max\n         * @type {number}\n         */\n        axis.max = null;\n        /**\n         * The minimum value of the axis. In a logarithmic axis, this is the\n         * logarithm of the real value, and the real value can be obtained from\n         * {@link Axis#getExtremes}.\n         *\n         * @name Highcharts.Axis#min\n         * @type {number}\n         */\n        axis.min = null;\n\n\n        /**\n         * The processed crosshair options.\n         *\n         * @name Highcharts.Axis#crosshair\n         * @type {false|Highcharts.AxisCrosshairOptions}\n         */\n        axis.crosshair = pick(\n            options.crosshair,\n            splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],\n            false\n        );\n\n        var events = axis.options.events;\n\n        // Register. Don't add it again on Axis.update().\n        if (inArray(axis, chart.axes) === -1) { //\n            if (isXAxis) { // #2713\n                chart.axes.splice(chart.xAxis.length, 0, axis);\n            } else {\n                chart.axes.push(axis);\n            }\n\n            chart[axis.coll].push(axis);\n        }\n\n        /**\n         * All series associated to the axis.\n         *\n         * @name Highcharts.Axis#series\n         * @type {Array<Highcharts.Series>}\n         */\n        axis.series = axis.series || []; // populated by Series\n\n        // Reversed axis\n        if (\n            chart.inverted &&\n            !axis.isZAxis &&\n            isXAxis &&\n            axis.reversed === undefined\n        ) {\n            axis.reversed = true;\n        }\n\n        // register event listeners\n        objectEach(events, function (event, eventType) {\n            addEvent(axis, eventType, event);\n        });\n\n        // extend logarithmic axis\n        axis.lin2log = options.linearToLogConverter || axis.lin2log;\n        if (axis.isLog) {\n            axis.val2lin = axis.log2lin;\n            axis.lin2val = axis.lin2log;\n        }\n\n        fireEvent(this, 'afterInit');\n    },\n\n    /**\n     * Merge and set options.\n     *\n     * @private\n     * @function Highcharts.Axis#setOptions\n     *\n     * @param {Highcharts.AxisOptions} userOptions\n     *\n     * @fires Highcharts.Axis#event:afterSetOptions\n     */\n    setOptions: function (userOptions) {\n        this.options = merge(\n            this.defaultOptions,\n            this.coll === 'yAxis' && this.defaultYAxisOptions,\n            [\n                this.defaultTopAxisOptions,\n                this.defaultRightAxisOptions,\n                this.defaultBottomAxisOptions,\n                this.defaultLeftAxisOptions\n            ][this.side],\n            merge(\n                defaultOptions[this.coll], // if set in setOptions (#1053)\n                userOptions\n            )\n        );\n\n        fireEvent(this, 'afterSetOptions', { userOptions: userOptions });\n    },\n\n    /**\n     * The default label formatter. The context is a special config object for\n     * the label. In apps, use the {@link\n     * https://api.highcharts.com/highcharts/xAxis.labels.formatter|\n     * labels.formatter} instead except when a modification is needed.\n     *\n     * @private\n     * @function Highcharts.Axis#defaultLabelFormatter\n     *\n     * @return {string}\n     */\n    defaultLabelFormatter: function () {\n        var axis = this.axis,\n            value = this.value,\n            time = axis.chart.time,\n            categories = axis.categories,\n            dateTimeLabelFormat = this.dateTimeLabelFormat,\n            lang = defaultOptions.lang,\n            numericSymbols = lang.numericSymbols,\n            numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n            i = numericSymbols && numericSymbols.length,\n            multi,\n            ret,\n            formatOption = axis.options.labels.format,\n\n            // make sure the same symbol is added for all labels on a linear\n            // axis\n            numericSymbolDetector = axis.isLog ?\n                Math.abs(value) :\n                axis.tickInterval;\n\n        if (formatOption) {\n            ret = format(formatOption, this, time);\n\n        } else if (categories) {\n            ret = value;\n\n        } else if (dateTimeLabelFormat) { // datetime axis\n            ret = time.dateFormat(dateTimeLabelFormat, value);\n\n        } else if (i && numericSymbolDetector >= 1000) {\n            // Decide whether we should add a numeric symbol like k (thousands)\n            // or M (millions). If we are to enable this in tooltip or other\n            // places as well, we can move this logic to the numberFormatter and\n            // enable it by a parameter.\n            while (i-- && ret === undefined) {\n                multi = Math.pow(numSymMagnitude, i + 1);\n                if (\n                    // Only accept a numeric symbol when the distance is more\n                    // than a full unit. So for example if the symbol is k, we\n                    // don't accept numbers like 0.5k.\n                    numericSymbolDetector >= multi &&\n                    // Accept one decimal before the symbol. Accepts 0.5k but\n                    // not 0.25k. How does this work with the previous?\n                    (value * 10) % multi === 0 &&\n                    numericSymbols[i] !== null &&\n                    value !== 0\n                ) { // #5480\n                    ret = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(value / multi, -1) + numericSymbols[i];\n                }\n            }\n        }\n\n        if (ret === undefined) {\n            if (Math.abs(value) >= 10000) { // add thousands separators\n                ret = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(value, -1);\n            } else { // small numbers\n                ret = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(value, -1, undefined, ''); // #2466\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * Get the minimum and maximum for the series of each axis. The function\n     * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.\n     *\n     * @private\n     * @function Highcharts.Axis#getSeriesExtremes\n     *\n     * @fires Highcharts.Axis#event:afterGetSeriesExtremes\n     * @fires Highcharts.Axis#event:getSeriesExtremes\n     */\n    getSeriesExtremes: function () {\n        var axis = this,\n            chart = axis.chart;\n\n        fireEvent(this, 'getSeriesExtremes', null, function () {\n\n            axis.hasVisibleSeries = false;\n\n            // Reset properties in case we're redrawing (#3353)\n            axis.dataMin = axis.dataMax = axis.threshold = null;\n            axis.softThreshold = !axis.isXAxis;\n\n            if (axis.buildStacks) {\n                axis.buildStacks();\n            }\n\n            // loop through this axis' series\n            each(axis.series, function (series) {\n\n                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                    var seriesOptions = series.options,\n                        xData,\n                        threshold = seriesOptions.threshold,\n                        seriesDataMin,\n                        seriesDataMax;\n\n                    axis.hasVisibleSeries = true;\n\n                    // Validate threshold in logarithmic axes\n                    if (axis.positiveValuesOnly && threshold <= 0) {\n                        threshold = null;\n                    }\n\n                    // Get dataMin and dataMax for X axes\n                    if (axis.isXAxis) {\n                        xData = series.xData;\n                        if (xData.length) {\n                            // If xData contains values which is not numbers,\n                            // then filter them out. To prevent performance hit,\n                            // we only do this after we have already found\n                            // seriesDataMin because in most cases all data is\n                            // valid. #5234.\n                            seriesDataMin = arrayMin(xData);\n                            seriesDataMax = arrayMax(xData);\n\n                            if (\n                                !isNumber(seriesDataMin) &&\n                                !(seriesDataMin instanceof Date) // #5010\n                            ) {\n                                xData = grep(xData, isNumber);\n                                // Do it again with valid data\n                                seriesDataMin = arrayMin(xData);\n                                seriesDataMax = arrayMax(xData);\n                            }\n\n                            if (xData.length) {\n                                axis.dataMin = Math.min(\n                                    pick(axis.dataMin, xData[0], seriesDataMin),\n                                    seriesDataMin\n                                );\n                                axis.dataMax = Math.max(\n                                    pick(axis.dataMax, xData[0], seriesDataMax),\n                                    seriesDataMax\n                                );\n                            }\n                        }\n\n                    // Get dataMin and dataMax for Y axes, as well as handle\n                    // stacking and processed data\n                    } else {\n\n                        // Get this particular series extremes\n                        series.getExtremes();\n                        seriesDataMax = series.dataMax;\n                        seriesDataMin = series.dataMin;\n\n                        // Get the dataMin and dataMax so far. If percentage is\n                        // used, the min and max are always 0 and 100. If\n                        // seriesDataMin and seriesDataMax is null, then series\n                        // doesn't have active y data, we continue with nulls\n                        if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                            axis.dataMin = Math.min(\n                                pick(axis.dataMin, seriesDataMin),\n                                seriesDataMin\n                            );\n                            axis.dataMax = Math.max(\n                                pick(axis.dataMax, seriesDataMax),\n                                seriesDataMax\n                            );\n                        }\n\n                        // Adjust to threshold\n                        if (defined(threshold)) {\n                            axis.threshold = threshold;\n                        }\n                        // If any series has a hard threshold, it takes\n                        // precedence\n                        if (\n                            !seriesOptions.softThreshold ||\n                            axis.positiveValuesOnly\n                        ) {\n                            axis.softThreshold = false;\n                        }\n                    }\n                }\n            });\n        });\n\n        fireEvent(this, 'afterGetSeriesExtremes');\n    },\n\n    /**\n     * Translate from axis value to pixel position on the chart, or back. Use\n     * the `toPixels` and `toValue` functions in applications.\n     *\n     * @private\n     * @function Highcharts.Axis#translate\n     *\n     * @param {number} val\n     *\n     * @param {boolean} [backwards]\n     *\n     * @param {boolean} [cvsCoord]\n     *\n     * @param {boolean} [old]\n     *\n     * @param {boolean} [handleLog]\n     *\n     * @param {number} [pointPlacement=0]\n     *\n     * @return {number|undefined}\n     */\n    translate: function (\n        val,\n        backwards,\n        cvsCoord,\n        old,\n        handleLog,\n        pointPlacement\n    ) {\n        var axis = this.linkedParent || this, // #1417\n            sign = 1,\n            cvsOffset = 0,\n            localA = old ? axis.oldTransA : axis.transA,\n            localMin = old ? axis.oldMin : axis.min,\n            returnValue,\n            minPixelPadding = axis.minPixelPadding,\n            doPostTranslate = (\n                axis.isOrdinal ||\n                axis.isBroken ||\n                (axis.isLog && handleLog)\n            ) && axis.lin2val;\n\n        if (!localA) {\n            localA = axis.transA;\n        }\n\n        // In vertical axes, the canvas coordinates start from 0 at the top like\n        // in SVG.\n        if (cvsCoord) {\n            sign *= -1; // canvas coordinates inverts the value\n            cvsOffset = axis.len;\n        }\n\n        // Handle reversed axis\n        if (axis.reversed) {\n            sign *= -1;\n            cvsOffset -= sign * (axis.sector || axis.len);\n        }\n\n        // From pixels to value\n        if (backwards) { // reverse translation\n\n            val = val * sign + cvsOffset;\n            val -= minPixelPadding;\n            returnValue = val / localA + localMin; // from chart pixel to value\n            if (doPostTranslate) { // log and ordinal axes\n                returnValue = axis.lin2val(returnValue);\n            }\n\n        // From value to pixels\n        } else {\n            if (doPostTranslate) { // log and ordinal axes\n                val = axis.val2lin(val);\n            }\n            returnValue = isNumber(localMin) ?\n                (\n                    sign * (val - localMin) * localA +\n                    cvsOffset +\n                    (sign * minPixelPadding) +\n                    (isNumber(pointPlacement) ? localA * pointPlacement : 0)\n                ) :\n                undefined;\n        }\n\n        return returnValue;\n    },\n\n    /**\n     * Translate a value in terms of axis units into pixels within the chart.\n     *\n     * @function Highcharts.Axis#toPixels\n     *\n     * @param {number} value\n     *        A value in terms of axis units.\n     *\n     * @param {boolean} paneCoordinates\n     *        Whether to return the pixel coordinate relative to the chart or\n     *        just the axis/pane itself.\n     *\n     * @return {number}\n     *         Pixel position of the value on the chart or axis.\n     */\n    toPixels: function (value, paneCoordinates) {\n        return this.translate(value, false, !this.horiz, null, true) +\n            (paneCoordinates ? 0 : this.pos);\n    },\n\n    /**\n     * Translate a pixel position along the axis to a value in terms of axis\n     * units.\n     *\n     * @function Highcharts.Axis#toValue\n     *\n     * @param {number} pixel\n     *        The pixel value coordinate.\n     *\n     * @param {boolean} paneCoordiantes\n     *        Whether the input pixel is relative to the chart or just the\n     *        axis/pane itself.\n     *\n     * @return {number}\n     *         The axis value.\n     */\n    toValue: function (pixel, paneCoordinates) {\n        return this.translate(\n            pixel - (paneCoordinates ? 0 : this.pos),\n            true,\n            !this.horiz,\n            null,\n            true\n        );\n    },\n\n    /**\n     * Create the path for a plot line that goes from the given value on\n     * this axis, across the plot to the opposite side. Also used internally for\n     * grid lines and crosshairs.\n     *\n     * @function Highcharts.Axis#getPlotLinePath\n     *\n     * @param {number} value\n     *        Axis value.\n     *\n     * @param {number} [lineWidth=1]\n     *        Used for calculation crisp line coordinates.\n     *\n     * @param {boolean} [old=false]\n     *        Use old coordinates (for resizing and rescaling).\n     *\n     * @param {boolean} [force=false]\n     *        If `false`, the function will return null when it falls outside\n     *        the axis bounds.\n     *\n     * @param {number} [translatedValue]\n     *        If given, return the plot line path of a pixel position on the\n     *        axis.\n     *\n     * @return {Array<string|number>}\n     *         The SVG path definition for the plot line.\n     */\n    getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n        var axis = this,\n            chart = axis.chart,\n            axisLeft = axis.left,\n            axisTop = axis.top,\n            x1,\n            y1,\n            x2,\n            y2,\n            cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n            cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n            skip,\n            transB = axis.transB,\n            /**\n             * Check if x is between a and b. If not, either move to a/b\n             * or skip, depending on the force parameter.\n             */\n            between = function (x, a, b) {\n                if (x < a || x > b) {\n                    if (force) {\n                        x = Math.min(Math.max(a, x), b);\n                    } else {\n                        skip = true;\n                    }\n                }\n                return x;\n            };\n\n        translatedValue = pick(\n            translatedValue,\n            axis.translate(value, null, null, old)\n        );\n        // Keep the translated value within sane bounds, and avoid Infinity to\n        // fail the isNumber test (#7709).\n        translatedValue = Math.min(Math.max(-1e5, translatedValue), 1e5);\n\n\n        x1 = x2 = Math.round(translatedValue + transB);\n        y1 = y2 = Math.round(cHeight - translatedValue - transB);\n        if (!isNumber(translatedValue)) { // no min or max\n            skip = true;\n            force = false; // #7175, don't force it when path is invalid\n        } else if (axis.horiz) {\n            y1 = axisTop;\n            y2 = cHeight - axis.bottom;\n            x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n        } else {\n            x1 = axisLeft;\n            x2 = cWidth - axis.right;\n            y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n        }\n        return skip && !force ?\n            null :\n            chart.renderer.crispLine(\n                ['M', x1, y1, 'L', x2, y2],\n                lineWidth || 1\n            );\n    },\n\n    /**\n     * Internal function to et the tick positions of a linear axis to round\n     * values like whole tens or every five.\n     *\n     * @function Highcharts.Axis#getLinearTickPositions\n     *\n     * @param {number} tickInterval\n     *        The normalized tick interval.\n     *\n     * @param {number} min\n     *        Axis minimum.\n     *\n     * @param {number} max\n     *        Axis maximum.\n     *\n     * @return {Array<number>}\n     *         An array of axis values where ticks should be placed.\n     */\n    getLinearTickPositions: function (tickInterval, min, max) {\n        var pos,\n            lastPos,\n            roundedMin =\n                correctFloat(Math.floor(min / tickInterval) * tickInterval),\n            roundedMax =\n                correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n            tickPositions = [],\n            precision;\n\n        // When the precision is higher than what we filter out in\n        // correctFloat, skip it (#6183).\n        if (correctFloat(roundedMin + tickInterval) === roundedMin) {\n            precision = 20;\n        }\n\n        // For single points, add a tick regardless of the relative position\n        // (#2662, #6274)\n        if (this.single) {\n            return [min];\n        }\n\n        // Populate the intermediate values\n        pos = roundedMin;\n        while (pos <= roundedMax) {\n\n            // Place the tick on the rounded value\n            tickPositions.push(pos);\n\n            // Always add the raw tickInterval, not the corrected one.\n            pos = correctFloat(\n                pos + tickInterval,\n                precision\n            );\n\n            // If the interval is not big enough in the current min - max range\n            // to actually increase the loop variable, we need to break out to\n            // prevent endless loop. Issue #619\n            if (pos === lastPos) {\n                break;\n            }\n\n            // Record the last value\n            lastPos = pos;\n        }\n        return tickPositions;\n    },\n\n    /**\n     * Resolve the new minorTicks/minorTickInterval options into the legacy\n     * loosely typed minorTickInterval option.\n     *\n     * @function Highcharts.Axis#getMinorTickInterval\n     *\n     * @return {number|'auto'|null}\n     */\n    getMinorTickInterval: function () {\n        var options = this.options;\n\n        if (options.minorTicks === true) {\n            return pick(options.minorTickInterval, 'auto');\n        }\n        if (options.minorTicks === false) {\n            return null;\n        }\n        return options.minorTickInterval;\n    },\n\n    /**\n     * Internal function to return the minor tick positions. For logarithmic\n     * axes, the same logic as for major ticks is reused.\n     *\n     * @function Highcharts.Axis#getMinorTickPositions\n     *\n     * @return {Array<number>}\n     *         An array of axis values where ticks should be placed.\n     */\n    getMinorTickPositions: function () {\n        var axis = this,\n            options = axis.options,\n            tickPositions = axis.tickPositions,\n            minorTickInterval = axis.minorTickInterval,\n            minorTickPositions = [],\n            pos,\n            pointRangePadding = axis.pointRangePadding || 0,\n            min = axis.min - pointRangePadding, // #1498\n            max = axis.max + pointRangePadding, // #1498\n            range = max - min;\n\n        // If minor ticks get too dense, they are hard to read, and may cause\n        // long running script. So we don't draw them.\n        if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n            if (axis.isLog) {\n                // For each interval in the major ticks, compute the minor ticks\n                // separately.\n                each(this.paddedTicks, function (pos, i, paddedTicks) {\n                    if (i) {\n                        minorTickPositions.push.apply(\n                            minorTickPositions,\n                            axis.getLogTickPositions(\n                                minorTickInterval,\n                                paddedTicks[i - 1],\n                                paddedTicks[i],\n                                true\n                            )\n                        );\n                    }\n                });\n\n            } else if (\n                axis.isDatetimeAxis &&\n                this.getMinorTickInterval() === 'auto'\n            ) { // #1314\n                minorTickPositions = minorTickPositions.concat(\n                    axis.getTimeTicks(\n                        axis.normalizeTimeTickInterval(minorTickInterval),\n                        min,\n                        max,\n                        options.startOfWeek\n                    )\n                );\n            } else {\n                for (\n                    pos = min + (tickPositions[0] - min) % minorTickInterval;\n                    pos <= max;\n                    pos += minorTickInterval\n                ) {\n                    // Very, very, tight grid lines (#5771)\n                    if (pos === minorTickPositions[0]) {\n                        break;\n                    }\n                    minorTickPositions.push(pos);\n                }\n            }\n        }\n\n        if (minorTickPositions.length !== 0) {\n            axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n        }\n        return minorTickPositions;\n    },\n\n    /**\n     * Adjust the min and max for the minimum range. Keep in mind that the\n     * series data is not yet processed, so we don't have information on data\n     * cropping and grouping, or updated axis.pointRange or series.pointRange.\n     * The data can't be processed until we have finally established min and\n     * max.\n     *\n     * @private\n     * @function Highcharts.Axis#adjustForMinRange\n     */\n    adjustForMinRange: function () {\n        var axis = this,\n            options = axis.options,\n            min = axis.min,\n            max = axis.max,\n            zoomOffset,\n            spaceAvailable,\n            closestDataRange,\n            i,\n            distance,\n            xData,\n            loopLength,\n            minArgs,\n            maxArgs,\n            minRange;\n\n        // Set the automatic minimum range based on the closest point distance\n        if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n\n            if (defined(options.min) || defined(options.max)) {\n                axis.minRange = null; // don't do this again\n\n            } else {\n\n                // Find the closest distance between raw data points, as opposed\n                // to closestPointRange that applies to processed points\n                // (cropped and grouped)\n                each(axis.series, function (series) {\n                    xData = series.xData;\n                    loopLength = series.xIncrement ? 1 : xData.length - 1;\n                    for (i = loopLength; i > 0; i--) {\n                        distance = xData[i] - xData[i - 1];\n                        if (\n                            closestDataRange === undefined ||\n                            distance < closestDataRange\n                        ) {\n                            closestDataRange = distance;\n                        }\n                    }\n                });\n                axis.minRange = Math.min(\n                    closestDataRange * 5,\n                    axis.dataMax - axis.dataMin\n                );\n            }\n        }\n\n        // if minRange is exceeded, adjust\n        if (max - min < axis.minRange) {\n\n            spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n            minRange = axis.minRange;\n            zoomOffset = (minRange - max + min) / 2;\n\n            // if min and max options have been set, don't go beyond it\n            minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n            // If space is available, stay within the data range\n            if (spaceAvailable) {\n                minArgs[2] = axis.isLog ?\n                    axis.log2lin(axis.dataMin) :\n                    axis.dataMin;\n            }\n            min = arrayMax(minArgs);\n\n            maxArgs = [min + minRange, pick(options.max, min + minRange)];\n            // If space is availabe, stay within the data range\n            if (spaceAvailable) {\n                maxArgs[2] = axis.isLog ?\n                    axis.log2lin(axis.dataMax) :\n                    axis.dataMax;\n            }\n\n            max = arrayMin(maxArgs);\n\n            // now if the max is adjusted, adjust the min back\n            if (max - min < minRange) {\n                minArgs[0] = max - minRange;\n                minArgs[1] = pick(options.min, max - minRange);\n                min = arrayMax(minArgs);\n            }\n        }\n\n        // Record modified extremes\n        axis.min = min;\n        axis.max = max;\n    },\n\n    /**\n     * Find the closestPointRange across all series.\n     *\n     * @private\n     * @function Highcharts.Axis#getClosest\n     *\n     * @return {number}\n     */\n    getClosest: function () {\n        var ret;\n\n        if (this.categories) {\n            ret = 1;\n        } else {\n            each(this.series, function (series) {\n                var seriesClosest = series.closestPointRange,\n                    visible = series.visible ||\n                        !series.chart.options.chart.ignoreHiddenSeries;\n\n                if (\n                    !series.noSharedTooltip &&\n                    defined(seriesClosest) &&\n                    visible\n                ) {\n                    ret = defined(ret) ?\n                        Math.min(ret, seriesClosest) :\n                        seriesClosest;\n                }\n            });\n        }\n        return ret;\n    },\n\n    /**\n     * When a point name is given and no x, search for the name in the existing\n     * categories, or if categories aren't provided, search names or create a\n     * new category (#2522).\n     *\n     * @private\n     * @function Highcharts.Axis#nameToX\n     *\n     * @param {Highcharts.Point} point\n     *        The point to inspect.\n     *\n     * @return {number}\n     *         The X value that the point is given.\n     */\n    nameToX: function (point) {\n        var explicitCategories = isArray(this.categories),\n            names = explicitCategories ? this.categories : this.names,\n            nameX = point.options.x,\n            x;\n\n        point.series.requireSorting = false;\n\n        if (!defined(nameX)) {\n            nameX = this.options.uniqueNames === false ?\n                point.series.autoIncrement() :\n                (\n                    explicitCategories ?\n                        inArray(point.name, names) :\n                        pick(names.keys[point.name], -1)\n\n                );\n        }\n        if (nameX === -1) { // Not found in currenct categories\n            if (!explicitCategories) {\n                x = names.length;\n            }\n        } else {\n            x = nameX;\n        }\n\n        // Write the last point's name to the names array\n        if (x !== undefined) {\n            this.names[x] = point.name;\n            // Backwards mapping is much faster than array searching (#7725)\n            this.names.keys[point.name] = x;\n        }\n\n        return x;\n    },\n\n    /**\n     * When changes have been done to series data, update the axis.names.\n     *\n     * @private\n     * @function Highcharts.Axis#updateNames\n     */\n    updateNames: function () {\n        var axis = this,\n            names = this.names,\n            i = names.length;\n\n        if (i > 0) {\n            each(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keys(names.keys), function (key) {\n                delete names.keys[key];\n            });\n            names.length = 0;\n\n            this.minRange = this.userMinRange; // Reset\n            each(this.series || [], function (series) {\n\n                // Reset incrementer (#5928)\n                series.xIncrement = null;\n\n                // When adding a series, points are not yet generated\n                if (!series.points || series.isDirtyData) {\n                    series.processData();\n                    series.generatePoints();\n                }\n\n                each(series.points, function (point, i) {\n                    var x;\n                    if (point.options) {\n                        x = axis.nameToX(point);\n                        if (x !== undefined && x !== point.x) {\n                            point.x = x;\n                            series.xData[i] = x;\n                        }\n                    }\n                });\n            });\n        }\n    },\n\n    /**\n     * Update translation information.\n     *\n     * @private\n     * @function Highcharts.Axis#setAxisTranslation\n     *\n     * @param {boolean} saveOld\n     *\n     * @fires Highcharts.Axis#event:afterSetAxisTranslation\n     */\n    setAxisTranslation: function (saveOld) {\n        var axis = this,\n            range = axis.max - axis.min,\n            pointRange = axis.axisPointRange || 0,\n            closestPointRange,\n            minPointOffset = 0,\n            pointRangePadding = 0,\n            linkedParent = axis.linkedParent,\n            ordinalCorrection,\n            hasCategories = !!axis.categories,\n            transA = axis.transA,\n            isXAxis = axis.isXAxis;\n\n        // Adjust translation for padding. Y axis with categories need to go\n        // through the same (#1784).\n        if (isXAxis || hasCategories || pointRange) {\n\n            // Get the closest points\n            closestPointRange = axis.getClosest();\n\n            if (linkedParent) {\n                minPointOffset = linkedParent.minPointOffset;\n                pointRangePadding = linkedParent.pointRangePadding;\n            } else {\n                each(axis.series, function (series) {\n                    var seriesPointRange = hasCategories ?\n                        1 :\n                        (\n                            isXAxis ?\n                                pick(\n                                    series.options.pointRange,\n                                    closestPointRange,\n                                    0\n                                ) :\n                                (axis.axisPointRange || 0)\n                        ), // #2806\n                        pointPlacement = series.options.pointPlacement;\n\n                    pointRange = Math.max(pointRange, seriesPointRange);\n\n                    if (!axis.single) {\n                        // minPointOffset is the value padding to the left of\n                        // the axis in order to make room for points with a\n                        // pointRange, typically columns. When the\n                        // pointPlacement option is 'between' or 'on', this\n                        // padding does not apply.\n                        minPointOffset = Math.max(\n                            minPointOffset,\n                            isString(pointPlacement) ? 0 : seriesPointRange / 2\n                        );\n\n                        // Determine the total padding needed to the length of\n                        // the axis to make room for the pointRange. If the\n                        // series' pointPlacement is 'on', no padding is added.\n                        pointRangePadding = Math.max(\n                            pointRangePadding,\n                            pointPlacement === 'on' ? 0 : seriesPointRange\n                        );\n                    }\n                });\n            }\n\n            // Record minPointOffset and pointRangePadding\n            ordinalCorrection = axis.ordinalSlope && closestPointRange ?\n                axis.ordinalSlope / closestPointRange :\n                1; // #988, #1853\n            axis.minPointOffset = minPointOffset =\n                minPointOffset * ordinalCorrection;\n            axis.pointRangePadding =\n                pointRangePadding = pointRangePadding * ordinalCorrection;\n\n            // pointRange means the width reserved for each point, like in a\n            // column chart\n            axis.pointRange = Math.min(pointRange, range);\n\n            // closestPointRange means the closest distance between points. In\n            // columns it is mostly equal to pointRange, but in lines pointRange\n            // is 0 while closestPointRange is some other value\n            if (isXAxis) {\n                axis.closestPointRange = closestPointRange;\n            }\n        }\n\n        // Secondary values\n        if (saveOld) {\n            axis.oldTransA = transA;\n        }\n        axis.translationSlope = axis.transA = transA =\n            axis.options.staticScale ||\n            axis.len / ((range + pointRangePadding) || 1);\n\n        // Translation addend\n        axis.transB = axis.horiz ? axis.left : axis.bottom;\n        axis.minPixelPadding = transA * minPointOffset;\n\n        fireEvent(this, 'afterSetAxisTranslation');\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Axis#minFromRange\n     *\n     * @return {number}\n     */\n    minFromRange: function () {\n        return this.max - this.range;\n    },\n\n    /**\n     * Set the tick positions to round values and optionally extend the extremes\n     * to the nearest tick.\n     *\n     * @private\n     * @function Highcharts.Axis#setTickInterval\n     *\n     * @param {boolean} secondPass\n     *\n     * @fires Highcharts.Axis#event:foundExtremes\n     */\n    setTickInterval: function (secondPass) {\n        var axis = this,\n            chart = axis.chart,\n            options = axis.options,\n            isLog = axis.isLog,\n            isDatetimeAxis = axis.isDatetimeAxis,\n            isXAxis = axis.isXAxis,\n            isLinked = axis.isLinked,\n            maxPadding = options.maxPadding,\n            minPadding = options.minPadding,\n            length,\n            linkedParentExtremes,\n            tickIntervalOption = options.tickInterval,\n            minTickInterval,\n            tickPixelIntervalOption = options.tickPixelInterval,\n            categories = axis.categories,\n            threshold = isNumber(axis.threshold) ? axis.threshold : null,\n            softThreshold = axis.softThreshold,\n            thresholdMin,\n            thresholdMax,\n            hardMin,\n            hardMax;\n\n        if (!isDatetimeAxis && !categories && !isLinked) {\n            this.getTickAmount();\n        }\n\n        // Min or max set either by zooming/setExtremes or initial options\n        hardMin = pick(axis.userMin, options.min);\n        hardMax = pick(axis.userMax, options.max);\n\n        // Linked axis gets the extremes from the parent axis\n        if (isLinked) {\n            axis.linkedParent = chart[axis.coll][options.linkedTo];\n            linkedParentExtremes = axis.linkedParent.getExtremes();\n            axis.min = pick(\n                linkedParentExtremes.min,\n                linkedParentExtremes.dataMin\n            );\n            axis.max = pick(\n                linkedParentExtremes.max,\n                linkedParentExtremes.dataMax\n            );\n            if (options.type !== axis.linkedParent.options.type) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(11, 1); // Can't link axes of different type\n            }\n\n        // Initial min and max from the extreme data values\n        } else {\n\n            // Adjust to hard threshold\n            if (!softThreshold && defined(threshold)) {\n                if (axis.dataMin >= threshold) {\n                    thresholdMin = threshold;\n                    minPadding = 0;\n                } else if (axis.dataMax <= threshold) {\n                    thresholdMax = threshold;\n                    maxPadding = 0;\n                }\n            }\n\n            axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n            axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n        }\n\n        if (isLog) {\n            if (\n                axis.positiveValuesOnly &&\n                !secondPass &&\n                Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0\n            ) { // #978\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(10, 1); // Can't plot negative values on log axis\n            }\n            // The correctFloat cures #934, float errors on full tens. But it\n            // was too aggressive for #4360 because of conversion back to lin,\n            // therefore use precision 15.\n            axis.min = correctFloat(axis.log2lin(axis.min), 15);\n            axis.max = correctFloat(axis.log2lin(axis.max), 15);\n        }\n\n        // handle zoomed range\n        if (axis.range && defined(axis.max)) {\n            axis.userMin = axis.min = hardMin =\n                Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773\n            axis.userMax = hardMax = axis.max;\n\n            axis.range = null;  // don't use it when running setExtremes\n        }\n\n        // Hook for Highstock Scroller. Consider combining with beforePadding.\n        fireEvent(axis, 'foundExtremes');\n\n        // Hook for adjusting this.min and this.max. Used by bubble series.\n        if (axis.beforePadding) {\n            axis.beforePadding();\n        }\n\n        // adjust min and max for the minimum range\n        axis.adjustForMinRange();\n\n        // Pad the values to get clear of the chart's edges. To avoid\n        // tickInterval taking the padding into account, we do this after\n        // computing tick interval (#1337).\n        if (\n            !categories &&\n            !axis.axisPointRange &&\n            !axis.usePercentage &&\n            !isLinked &&\n            defined(axis.min) &&\n            defined(axis.max)\n        ) {\n            length = axis.max - axis.min;\n            if (length) {\n                if (!defined(hardMin) && minPadding) {\n                    axis.min -= length * minPadding;\n                }\n                if (!defined(hardMax) && maxPadding) {\n                    axis.max += length * maxPadding;\n                }\n            }\n        }\n\n        // Handle options for floor, ceiling, softMin and softMax (#6359)\n        if (isNumber(options.softMin) && !isNumber(axis.userMin)) {\n            axis.min = Math.min(axis.min, options.softMin);\n        }\n        if (isNumber(options.softMax) && !isNumber(axis.userMax)) {\n            axis.max = Math.max(axis.max, options.softMax);\n        }\n        if (isNumber(options.floor)) {\n            axis.min = Math.max(axis.min, options.floor);\n        }\n        if (isNumber(options.ceiling)) {\n            axis.max = Math.min(axis.max, options.ceiling);\n        }\n\n\n        // When the threshold is soft, adjust the extreme value only if the data\n        // extreme and the padded extreme land on either side of the threshold.\n        // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick\n        // for -1 because of the default minPadding and startOnTick options.\n        // This is prevented by the softThreshold option.\n        if (softThreshold && defined(axis.dataMin)) {\n            threshold = threshold || 0;\n            if (\n                !defined(hardMin) &&\n                axis.min < threshold &&\n                axis.dataMin >= threshold\n            ) {\n                axis.min = threshold;\n\n            } else if (\n                !defined(hardMax) &&\n                axis.max > threshold &&\n                axis.dataMax <= threshold\n            ) {\n                axis.max = threshold;\n            }\n        }\n\n\n        // get tickInterval\n        if (\n            axis.min === axis.max ||\n            axis.min === undefined ||\n            axis.max === undefined\n        ) {\n            axis.tickInterval = 1;\n\n        } else if (\n            isLinked &&\n            !tickIntervalOption &&\n            tickPixelIntervalOption ===\n                axis.linkedParent.options.tickPixelInterval\n        ) {\n            axis.tickInterval = tickIntervalOption =\n                axis.linkedParent.tickInterval;\n\n        } else {\n            axis.tickInterval = pick(\n                tickIntervalOption,\n                this.tickAmount ?\n                    ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) :\n                    undefined,\n                // For categoried axis, 1 is default, for linear axis use\n                // tickPix\n                categories ?\n                    1 :\n                    // don't let it be more than the data range\n                    (axis.max - axis.min) * tickPixelIntervalOption /\n                        Math.max(axis.len, tickPixelIntervalOption)\n            );\n        }\n\n        /**\n         * Now we're finished detecting min and max, crop and group series data.\n         * This is in turn needed in order to find tick positions in\n         * ordinal axes.\n         */\n        if (isXAxis && !secondPass) {\n            each(axis.series, function (series) {\n                series.processData(\n                    axis.min !== axis.oldMin || axis.max !== axis.oldMax\n                );\n            });\n        }\n\n        // set the translation factor used in translate function\n        axis.setAxisTranslation(true);\n\n        // hook for ordinal axes and radial axes\n        if (axis.beforeSetTickPositions) {\n            axis.beforeSetTickPositions();\n        }\n\n        // hook for extensions, used in Highstock ordinal axes\n        if (axis.postProcessTickInterval) {\n            axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n        }\n\n        // In column-like charts, don't cramp in more ticks than there are\n        // points (#1943, #4184)\n        if (axis.pointRange && !tickIntervalOption) {\n            axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n        }\n\n        // Before normalizing the tick interval, handle minimum tick interval.\n        // This applies only if tickInterval is not defined.\n        minTickInterval = pick(\n            options.minTickInterval,\n            axis.isDatetimeAxis && axis.closestPointRange\n        );\n        if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n            axis.tickInterval = minTickInterval;\n        }\n\n        // for linear axes, get magnitude and normalize the interval\n        if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n            axis.tickInterval = normalizeTickInterval(\n                axis.tickInterval,\n                null,\n                getMagnitude(axis.tickInterval),\n                // If the tick interval is between 0.5 and 5 and the axis max is\n                // in the order of thousands, chances are we are dealing with\n                // years. Don't allow decimals. #3363.\n                pick(\n                    options.allowDecimals,\n                    !(\n                        axis.tickInterval > 0.5 &&\n                        axis.tickInterval < 5 &&\n                        axis.max > 1000 &&\n                        axis.max < 9999\n                    )\n                ),\n                !!this.tickAmount\n            );\n        }\n\n        // Prevent ticks from getting so close that we can't draw the labels\n        if (!this.tickAmount) {\n            axis.tickInterval = axis.unsquish();\n        }\n\n        this.setTickPositions();\n    },\n\n    /**\n     * Now we have computed the normalized tickInterval, get the tick positions\n     *\n     * @function Highcharts.Axis#setTickPositions\n     *\n     * @fires Highcharts.Axis#event:afterSetTickPositions\n     */\n    setTickPositions: function () {\n\n        var options = this.options,\n            tickPositions,\n            tickPositionsOption = options.tickPositions,\n            minorTickIntervalOption = this.getMinorTickInterval(),\n            tickPositioner = options.tickPositioner,\n            startOnTick = options.startOnTick,\n            endOnTick = options.endOnTick;\n\n        // Set the tickmarkOffset\n        this.tickmarkOffset = (\n            this.categories &&\n            options.tickmarkPlacement === 'between' &&\n            this.tickInterval === 1\n        ) ? 0.5 : 0; // #3202\n\n\n        // get minorTickInterval\n        this.minorTickInterval =\n            minorTickIntervalOption === 'auto' &&\n            this.tickInterval ?\n                this.tickInterval / 5 :\n                minorTickIntervalOption;\n\n        // When there is only one point, or all points have the same value on\n        // this axis, then min and max are equal and tickPositions.length is 0\n        // or 1. In this case, add some padding in order to center the point,\n        // but leave it with one tick. #1337.\n        this.single =\n            this.min === this.max &&\n            defined(this.min) &&\n            !this.tickAmount &&\n            (\n                // Data is on integer (#6563)\n                parseInt(this.min, 10) === this.min ||\n\n                // Between integers and decimals are not allowed (#6274)\n                options.allowDecimals !== false\n            );\n\n        // Find the tick positions. Work on a copy (#1565)\n        this.tickPositions = tickPositions =\n            tickPositionsOption && tickPositionsOption.slice();\n        if (!tickPositions) {\n\n            // Too many ticks (#6405). Create a friendly warning and provide two\n            // ticks so at least we can show the data series.\n            if (\n                !this.ordinalPositions &&\n                (\n                    (this.max - this.min) / this.tickInterval >\n                    Math.max(2 * this.len, 200)\n                )\n            ) {\n                tickPositions = [this.min, this.max];\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(19);\n\n            } else if (this.isDatetimeAxis) {\n                tickPositions = this.getTimeTicks(\n                    this.normalizeTimeTickInterval(\n                        this.tickInterval,\n                        options.units\n                    ),\n                    this.min,\n                    this.max,\n                    options.startOfWeek,\n                    this.ordinalPositions,\n                    this.closestPointRange,\n                    true\n                );\n            } else if (this.isLog) {\n                tickPositions = this.getLogTickPositions(\n                    this.tickInterval,\n                    this.min,\n                    this.max\n                );\n            } else {\n                tickPositions = this.getLinearTickPositions(\n                    this.tickInterval,\n                    this.min,\n                    this.max\n                );\n            }\n\n            // Too dense ticks, keep only the first and last (#4477)\n            if (tickPositions.length > this.len) {\n                tickPositions = [tickPositions[0], tickPositions.pop()];\n                // Reduce doubled value (#7339)\n                if (tickPositions[0] === tickPositions[1]) {\n                    tickPositions.length = 1;\n                }\n            }\n\n            this.tickPositions = tickPositions;\n\n            // Run the tick positioner callback, that allows modifying auto tick\n            // positions.\n            if (tickPositioner) {\n                tickPositioner = tickPositioner.apply(\n                    this,\n                    [this.min, this.max]\n                );\n                if (tickPositioner) {\n                    this.tickPositions = tickPositions = tickPositioner;\n                }\n            }\n\n        }\n\n        // Reset min/max or remove extremes based on start/end on tick\n        this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n        this.trimTicks(tickPositions, startOnTick, endOnTick);\n        if (!this.isLinked) {\n\n            // Substract half a unit (#2619, #2846, #2515, #3390),\n            // but not in case of multiple ticks (#6897)\n            if (this.single && tickPositions.length < 2) {\n                this.min -= 0.5;\n                this.max += 0.5;\n            }\n            if (!tickPositionsOption && !tickPositioner) {\n                this.adjustTickAmount();\n            }\n        }\n\n        fireEvent(this, 'afterSetTickPositions');\n    },\n\n    /**\n     * Handle startOnTick and endOnTick by either adapting to padding min/max or\n     * rounded min/max. Also handle single data points.\n     *\n     * @private\n     * @function Highcharts.Axis#trimTicks\n     *\n     * @param {Array<number>} tickPositions\n     *\n     * @param {boolean} startOnTicl\n     *\n     * @param {boolean} endOnTick\n     */\n    trimTicks: function (tickPositions, startOnTick, endOnTick) {\n        var roundedMin = tickPositions[0],\n            roundedMax = tickPositions[tickPositions.length - 1],\n            minPointOffset = this.minPointOffset || 0;\n\n        if (!this.isLinked) {\n            if (startOnTick && roundedMin !== -Infinity) { // #6502\n                this.min = roundedMin;\n            } else {\n                while (this.min - minPointOffset > tickPositions[0]) {\n                    tickPositions.shift();\n                }\n            }\n\n            if (endOnTick) {\n                this.max = roundedMax;\n            } else {\n                while (this.max + minPointOffset <\n                        tickPositions[tickPositions.length - 1]) {\n                    tickPositions.pop();\n                }\n            }\n\n            // If no tick are left, set one tick in the middle (#3195)\n            if (\n                tickPositions.length === 0 &&\n                defined(roundedMin) &&\n                !this.options.tickPositions\n            ) {\n                tickPositions.push((roundedMax + roundedMin) / 2);\n            }\n        }\n    },\n\n    /**\n     * Check if there are multiple axes in the same pane.\n     *\n     * @private\n     * @function Highcharts.Axis#alignToOthers\n     *\n     * @return {boolean}\n     *         True if there are other axes.\n     */\n    alignToOthers: function () {\n        var others = {}, // Whether there is another axis to pair with this one\n            hasOther,\n            options = this.options;\n\n        if (\n            // Only if alignTicks is true\n            this.chart.options.chart.alignTicks !== false &&\n            options.alignTicks !== false &&\n\n            // Disabled when startOnTick or endOnTick are false (#7604)\n            options.startOnTick !== false &&\n            options.endOnTick !== false &&\n\n            // Don't try to align ticks on a log axis, they are not evenly\n            // spaced (#6021)\n            !this.isLog\n        ) {\n            each(this.chart[this.coll], function (axis) {\n                var otherOptions = axis.options,\n                    horiz = axis.horiz,\n                    key = [\n                        horiz ? otherOptions.left : otherOptions.top,\n                        otherOptions.width,\n                        otherOptions.height,\n                        otherOptions.pane\n                    ].join(',');\n\n\n                if (axis.series.length) { // #4442\n                    if (others[key]) {\n                        hasOther = true; // #4201\n                    } else {\n                        others[key] = 1;\n                    }\n                }\n            });\n        }\n        return hasOther;\n    },\n\n    /**\n     * Find the max ticks of either the x and y axis collection, and record it\n     * in `this.tickAmount`.\n     *\n     * @private\n     * @function Highcharts.Axis#getTickAmount\n     */\n    getTickAmount: function () {\n        var options = this.options,\n            tickAmount = options.tickAmount,\n            tickPixelInterval = options.tickPixelInterval;\n\n        if (\n            !defined(options.tickInterval) &&\n            this.len < tickPixelInterval &&\n            !this.isRadial &&\n            !this.isLog &&\n            options.startOnTick &&\n            options.endOnTick\n        ) {\n            tickAmount = 2;\n        }\n\n        if (!tickAmount && this.alignToOthers()) {\n            // Add 1 because 4 tick intervals require 5 ticks (including first\n            // and last)\n            tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n        }\n\n        // For tick amounts of 2 and 3, compute five ticks and remove the\n        // intermediate ones. This prevents the axis from adding ticks that are\n        // too far away from the data extremes.\n        if (tickAmount < 4) {\n            this.finalTickAmt = tickAmount;\n            tickAmount = 5;\n        }\n\n        this.tickAmount = tickAmount;\n    },\n\n    /**\n     * When using multiple axes, adjust the number of ticks to match the highest\n     * number of ticks in that group.\n     *\n     * @private\n     * @function Highcharts.Axis#adjustTickAmount\n     */\n    adjustTickAmount: function () {\n        var tickInterval = this.tickInterval,\n            tickPositions = this.tickPositions,\n            tickAmount = this.tickAmount,\n            finalTickAmt = this.finalTickAmt,\n            currentTickAmount = tickPositions && tickPositions.length,\n            threshold = pick(this.threshold, this.softThreshold ? 0 : null),\n            i,\n            len;\n\n        if (this.hasData()) {\n            if (currentTickAmount < tickAmount) {\n                while (tickPositions.length < tickAmount) {\n\n                    // Extend evenly for both sides unless we're on the\n                    // threshold (#3965)\n                    if (\n                        tickPositions.length % 2 ||\n                        this.min === threshold\n                    ) {\n                        // to the end\n                        tickPositions.push(correctFloat(\n                            tickPositions[tickPositions.length - 1] +\n                            tickInterval\n                        ));\n                    } else {\n                        // to the start\n                        tickPositions.unshift(correctFloat(\n                            tickPositions[0] - tickInterval\n                        ));\n                    }\n                }\n                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                this.min = tickPositions[0];\n                this.max = tickPositions[tickPositions.length - 1];\n\n            // We have too many ticks, run second pass to try to reduce ticks\n            } else if (currentTickAmount > tickAmount) {\n                this.tickInterval *= 2;\n                this.setTickPositions();\n            }\n\n            // The finalTickAmt property is set in getTickAmount\n            if (defined(finalTickAmt)) {\n                i = len = tickPositions.length;\n                while (i--) {\n                    if (\n                        // Remove every other tick\n                        (finalTickAmt === 3 && i % 2 === 1) ||\n                        // Remove all but first and last\n                        (finalTickAmt <= 2 && i > 0 && i < len - 1)\n                    ) {\n                        tickPositions.splice(i, 1);\n                    }\n                }\n                this.finalTickAmt = undefined;\n            }\n        }\n    },\n\n    /**\n     * Set the scale based on data min and max, user set min and max or options.\n     *\n     * @private\n     * @function Highcharts.Axis#setScale\n     *\n     * @fires Highcharts.Axis#event:afterSetScale\n     */\n    setScale: function () {\n        var axis = this,\n            isDirtyData,\n            isDirtyAxisLength;\n\n        axis.oldMin = axis.min;\n        axis.oldMax = axis.max;\n        axis.oldAxisLength = axis.len;\n\n        // set the new axisLength\n        axis.setAxisSize();\n        isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n        // is there new data?\n        each(axis.series, function (series) {\n            if (\n                series.isDirtyData ||\n                series.isDirty ||\n                // When x axis is dirty, we need new data extremes for y as well\n                series.xAxis.isDirty\n            ) {\n                isDirtyData = true;\n            }\n        });\n\n        // do we really need to go through all this?\n        if (\n            isDirtyAxisLength ||\n            isDirtyData ||\n            axis.isLinked ||\n            axis.forceRedraw ||\n            axis.userMin !== axis.oldUserMin ||\n            axis.userMax !== axis.oldUserMax ||\n            axis.alignToOthers()\n        ) {\n\n            if (axis.resetStacks) {\n                axis.resetStacks();\n            }\n\n            axis.forceRedraw = false;\n\n            // get data extremes if needed\n            axis.getSeriesExtremes();\n\n            // get fixed positions based on tickInterval\n            axis.setTickInterval();\n\n            // record old values to decide whether a rescale is necessary later\n            // on (#540)\n            axis.oldUserMin = axis.userMin;\n            axis.oldUserMax = axis.userMax;\n\n            // Mark as dirty if it is not already set to dirty and extremes have\n            // changed. #595.\n            if (!axis.isDirty) {\n                axis.isDirty =\n                    isDirtyAxisLength ||\n                    axis.min !== axis.oldMin ||\n                    axis.max !== axis.oldMax;\n            }\n        } else if (axis.cleanStacks) {\n            axis.cleanStacks();\n        }\n\n        fireEvent(this, 'afterSetScale');\n    },\n\n    /**\n     * Set the minimum and maximum of the axes after render time. If the\n     * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n     * values are rounded off to the nearest tick. To prevent this, these\n     * options can be set to false before calling setExtremes. Also, setExtremes\n     * will not allow a range lower than the `minRange` option, which by default\n     * is the range of five points.\n     *\n     * @sample highcharts/members/axis-setextremes/\n     *         Set extremes from a button\n     * @sample highcharts/members/axis-setextremes-datetime/\n     *         Set extremes on a datetime axis\n     * @sample highcharts/members/axis-setextremes-off-ticks/\n     *         Set extremes off ticks\n     * @sample stock/members/axis-setextremes/\n     *         Set extremes in Highstock\n     * @sample maps/members/axis-setextremes/\n     *         Set extremes in Highmaps\n     *\n     * @function Highcharts.Axis#setExtremes\n     *\n     * @param {number} [newMin]\n     *        The new minimum value.\n     *\n     * @param {number} [newMax]\n     *        The new maximum value.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart or wait for an explicit call to\n     *        {@link Highcharts.Chart#redraw}\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n     *        Enable or modify animations.\n     *\n     * @param {*} [eventArguments]\n     *        Arguments to be accessed in event handler.\n     *\n     * @fires Highcharts.Axis#event:setExtremes\n     */\n    setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n        var axis = this,\n            chart = axis.chart;\n\n        redraw = pick(redraw, true); // defaults to true\n\n        each(axis.series, function (serie) {\n            delete serie.kdTree;\n        });\n\n        // Extend the arguments with min and max\n        eventArguments = extend(eventArguments, {\n            min: newMin,\n            max: newMax\n        });\n\n        // Fire the event\n        fireEvent(axis, 'setExtremes', eventArguments, function () {\n\n            axis.userMin = newMin;\n            axis.userMax = newMax;\n            axis.eventArgs = eventArguments;\n\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        });\n    },\n\n    /**\n     * Overridable method for zooming chart. Pulled out in a separate method to\n     * allow overriding in stock charts.\n     *\n     * @private\n     * @function Highcharts.Axis#zoom\n     *\n     * @param {number} newMin\n     *\n     * @param {number} newMax\n     *\n     * @return {boolean}\n     */\n    zoom: function (newMin, newMax) {\n        var dataMin = this.dataMin,\n            dataMax = this.dataMax,\n            options = this.options,\n            min = Math.min(dataMin, pick(options.min, dataMin)),\n            max = Math.max(dataMax, pick(options.max, dataMax));\n\n        if (newMin !== this.min || newMax !== this.max) { // #5790\n\n            // Prevent pinch zooming out of range. Check for defined is for\n            // #1946. #1734.\n            if (!this.allowZoomOutside) {\n                // #6014, sometimes newMax will be smaller than min (or newMin\n                // will be larger than max).\n                if (defined(dataMin)) {\n                    if (newMin < min) {\n                        newMin = min;\n                    }\n                    if (newMin > max) {\n                        newMin = max;\n                    }\n                }\n                if (defined(dataMax)) {\n                    if (newMax < min) {\n                        newMax = min;\n                    }\n                    if (newMax > max) {\n                        newMax = max;\n                    }\n                }\n            }\n\n            // In full view, displaying the reset zoom button is not required\n            this.displayBtn = newMin !== undefined || newMax !== undefined;\n\n            // Do it\n            this.setExtremes(\n                newMin,\n                newMax,\n                false,\n                undefined,\n                { trigger: 'zoom' }\n            );\n        }\n\n        return true;\n    },\n\n    /**\n     * Update the axis metrics.\n     *\n     * @private\n     * @function Highcharts.Axis#setAxisSize\n     */\n    setAxisSize: function () {\n        var chart = this.chart,\n            options = this.options,\n            // [top, right, bottom, left]\n            offsets = options.offsets || [0, 0, 0, 0],\n            horiz = this.horiz,\n\n            // Check for percentage based input values. Rounding fixes problems\n            // with column overflow and plot line filtering (#4898, #4899)\n            width = this.width = Math.round(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength(\n                pick(\n                    options.width,\n                    chart.plotWidth - offsets[3] + offsets[1]\n                ),\n                chart.plotWidth\n            )),\n            height = this.height = Math.round(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength(\n                pick(\n                    options.height,\n                    chart.plotHeight - offsets[0] + offsets[2]\n                ),\n                chart.plotHeight\n            )),\n            top = this.top = Math.round(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength(\n                pick(options.top, chart.plotTop + offsets[0]),\n                chart.plotHeight,\n                chart.plotTop\n            )),\n            left = this.left = Math.round(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength(\n                pick(options.left, chart.plotLeft + offsets[3]),\n                chart.plotWidth,\n                chart.plotLeft\n            ));\n\n        // Expose basic values to use in Series object and navigator\n        this.bottom = chart.chartHeight - height - top;\n        this.right = chart.chartWidth - width - left;\n\n        // Direction agnostic properties\n        this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n        this.pos = horiz ? left : top; // distance from SVG origin\n    },\n\n    /**\n     * Get the current extremes for the axis.\n     *\n     * @sample highcharts/members/axis-getextremes/\n     *         Report extremes by click on a button\n     * @sample maps/members/axis-getextremes/\n     *         Get extremes in Highmaps\n     *\n     * @function Highcharts.Axis#getExtremes\n     *\n     * @returns {Highcharts.ExtremesObject}\n     *          An object containing extremes information.\n     */\n    getExtremes: function () {\n        var axis = this,\n            isLog = axis.isLog;\n\n        return {\n            min: isLog ? correctFloat(axis.lin2log(axis.min)) : axis.min,\n            max: isLog ? correctFloat(axis.lin2log(axis.max)) : axis.max,\n            dataMin: axis.dataMin,\n            dataMax: axis.dataMax,\n            userMin: axis.userMin,\n            userMax: axis.userMax\n        };\n    },\n\n    /**\n     * Get the zero plane either based on zero or on the min or max value.\n     * Used in bar and area plots.\n     *\n     * @function Highcharts.Axis#getThreshold\n     *\n     * @param {number} threshold\n     *        The threshold in axis values.\n     *\n     * @return {number}\n     *         The translated threshold position in terms of pixels, and\n     *         corrected to stay within the axis bounds.\n     */\n    getThreshold: function (threshold) {\n        var axis = this,\n            isLog = axis.isLog,\n            realMin = isLog ? axis.lin2log(axis.min) : axis.min,\n            realMax = isLog ? axis.lin2log(axis.max) : axis.max;\n\n        if (threshold === null || threshold === -Infinity) {\n            threshold = realMin;\n        } else if (threshold === Infinity) {\n            threshold = realMax;\n        } else if (realMin > threshold) {\n            threshold = realMin;\n        } else if (realMax < threshold) {\n            threshold = realMax;\n        }\n\n        return axis.translate(threshold, 0, 1, 0, 1);\n    },\n\n    /**\n     * Compute auto alignment for the axis label based on which side the axis is\n     * on and the given rotation for the label.\n     *\n     * @private\n     * @function Highcharts.Axis#autoLabelAlign\n     *\n     * @param {number} rotation\n     *        The rotation in degrees as set by either the `rotation` or\n     *        `autoRotation` options.\n     *\n     * @return {string}\n     *         Can be `center`, `left` or `right`.\n     */\n    autoLabelAlign: function (rotation) {\n        var ret,\n            angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n        if (angle > 15 && angle < 165) {\n            ret = 'right';\n        } else if (angle > 195 && angle < 345) {\n            ret = 'left';\n        } else {\n            ret = 'center';\n        }\n        return ret;\n    },\n\n    /**\n     * Get the tick length and width for the axis based on axis options.\n     *\n     * @private\n     * @function Highcharts.Axis#tickSize\n     *\n     * @param {string} prefix\n     *        'tick' or 'minorTick'\n     *\n     * @return {Array<number>}\n     *         An array of tickLength and tickWidth\n     */\n    tickSize: function (prefix) {\n        var options = this.options,\n            tickLength = options[prefix + 'Length'],\n            tickWidth = pick(\n                options[prefix + 'Width'],\n                prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1\n            );\n\n        if (tickWidth && tickLength) {\n            // Negate the length\n            if (options[prefix + 'Position'] === 'inside') {\n                tickLength = -tickLength;\n            }\n            return [tickLength, tickWidth];\n        }\n\n    },\n\n    /**\n     * Return the size of the labels.\n     *\n     * @private\n     * @function Highcharts.Axis#labelMetrics\n     *\n     * @return {Highcharts.FontMetricsObject}\n     */\n    labelMetrics: function () {\n        var index = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(\n            this.options.labels.style && this.options.labels.style.fontSize,\n            this.ticks[index] && this.ticks[index].label\n        );\n    },\n\n    /**\n     * Prevent the ticks from getting so close we can't draw the labels. On a\n     * horizontal axis, this is handled by rotating the labels, removing ticks\n     * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.\n     *\n     * @private\n     * @function Highcharts.Axis#unsquish\n     *\n     * @return {number}\n     */\n    unsquish: function () {\n        var labelOptions = this.options.labels,\n            horiz = this.horiz,\n            tickInterval = this.tickInterval,\n            newTickInterval = tickInterval,\n            slotSize = this.len / (\n                ((this.categories ? 1 : 0) + this.max - this.min) / tickInterval\n            ),\n            rotation,\n            rotationOption = labelOptions.rotation,\n            labelMetrics = this.labelMetrics(),\n            step,\n            bestScore = Number.MAX_VALUE,\n            autoRotation,\n            // Return the multiple of tickInterval that is needed to avoid\n            // collision\n            getStep = function (spaceNeeded) {\n                var step = spaceNeeded / (slotSize || 1);\n                step = step > 1 ? Math.ceil(step) : 1;\n                return correctFloat(step * tickInterval);\n            };\n\n        if (horiz) {\n            autoRotation = !labelOptions.staggerLines &&\n                !labelOptions.step &&\n                ( // #3971\n                    defined(rotationOption) ?\n                        [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) &&\n                            labelOptions.autoRotation\n                );\n\n            if (autoRotation) {\n\n                // Loop over the given autoRotation options, and determine\n                // which gives the best score. The best score is that with\n                // the lowest number of steps and a rotation closest\n                // to horizontal.\n                each(autoRotation, function (rot) {\n                    var score;\n\n                    if (\n                        rot === rotationOption ||\n                        (rot && rot >= -90 && rot <= 90)\n                    ) { // #3891\n\n                        step = getStep(\n                            Math.abs(labelMetrics.h / Math.sin(deg2rad * rot))\n                        );\n\n                        score = step + Math.abs(rot / 360);\n\n                        if (score < bestScore) {\n                            bestScore = score;\n                            rotation = rot;\n                            newTickInterval = step;\n                        }\n                    }\n                });\n            }\n\n        } else if (!labelOptions.step) { // #4411\n            newTickInterval = getStep(labelMetrics.h);\n        }\n\n        this.autoRotation = autoRotation;\n        this.labelRotation = pick(rotation, rotationOption);\n\n        return newTickInterval;\n    },\n\n    /**\n     * Get the general slot width for labels/categories on this axis. This may\n     * change between the pre-render (from Axis.getOffset) and the final tick\n     * rendering and placement.\n     *\n     * @private\n     * @function Highcharts.Axis#getSlotWidth\n     *\n     * @param {*} [tick]\n     *        Optionally, calculate the slot width basing on tick label. It is\n     *        used in highcharts-3d module, where the slots has different widths\n     *        depending on perspective angles.\n     *\n     * @return {number}\n     *         The pixel width allocated to each axis label.\n     */\n    getSlotWidth: function () {\n        // #5086, #1580, #1931\n        var chart = this.chart,\n            horiz = this.horiz,\n            labelOptions = this.options.labels,\n            slotCount = Math.max(\n                this.tickPositions.length - (this.categories ? 0 : 1),\n                1\n            ),\n            marginLeft = chart.margin[3];\n\n        return (\n            horiz &&\n            (labelOptions.step || 0) < 2 &&\n            !labelOptions.rotation && // #4415\n            ((this.staggerLines || 1) * this.len) / slotCount\n        ) || (\n            !horiz && (\n                // #7028\n                (\n                    labelOptions.style &&\n                    parseInt(labelOptions.style.width, 10)\n                ) ||\n                (\n                    marginLeft &&\n                    (marginLeft - chart.spacing[3])\n                ) ||\n                chart.chartWidth * 0.33\n            )\n        );\n\n    },\n\n    /**\n     * Render the axis labels and determine whether ellipsis or rotation need\n     * to be applied.\n     *\n     * @private\n     * @function Highcharts.Axis#renderUnsquish\n     */\n    renderUnsquish: function () {\n        var chart = this.chart,\n            renderer = chart.renderer,\n            tickPositions = this.tickPositions,\n            ticks = this.ticks,\n            labelOptions = this.options.labels,\n            labelStyleOptions = (labelOptions && labelOptions.style || {}),\n            horiz = this.horiz,\n            slotWidth = this.getSlotWidth(),\n            innerWidth = Math.max(\n                1,\n                Math.round(slotWidth - 2 * (labelOptions.padding || 5))\n            ),\n            attr = {},\n            labelMetrics = this.labelMetrics(),\n            textOverflowOption = labelOptions.style &&\n                labelOptions.style.textOverflow,\n            commonWidth,\n            commonTextOverflow,\n            maxLabelLength = 0,\n            label,\n            i,\n            pos;\n\n        // Set rotation option unless it is \"auto\", like in gauges\n        if (!isString(labelOptions.rotation)) {\n            attr.rotation = labelOptions.rotation || 0; // #4443\n        }\n\n        // Get the longest label length\n        each(tickPositions, function (tick) {\n            tick = ticks[tick];\n            if (\n                tick &&\n                tick.label &&\n                tick.label.textPxLength > maxLabelLength\n            ) {\n                maxLabelLength = tick.label.textPxLength;\n            }\n        });\n        this.maxLabelLength = maxLabelLength;\n\n\n        // Handle auto rotation on horizontal axis\n        if (this.autoRotation) {\n\n            // Apply rotation only if the label is too wide for the slot, and\n            // the label is wider than its height.\n            if (\n                maxLabelLength > innerWidth &&\n                maxLabelLength > labelMetrics.h\n            ) {\n                attr.rotation = this.labelRotation;\n            } else {\n                this.labelRotation = 0;\n            }\n\n        // Handle word-wrap or ellipsis on vertical axis\n        } else if (slotWidth) {\n            // For word-wrap or ellipsis\n            commonWidth = innerWidth;\n\n            if (!textOverflowOption) {\n                commonTextOverflow = 'clip';\n\n                // On vertical axis, only allow word wrap if there is room\n                // for more lines.\n                i = tickPositions.length;\n                while (!horiz && i--) {\n                    pos = tickPositions[i];\n                    label = ticks[pos].label;\n                    if (label) {\n                        // Reset ellipsis in order to get the correct\n                        // bounding box (#4070)\n                        if (\n                            label.styles &&\n                            label.styles.textOverflow === 'ellipsis'\n                        ) {\n                            label.css({ textOverflow: 'clip' });\n\n                        // Set the correct width in order to read\n                        // the bounding box height (#4678, #5034)\n                        } else if (label.textPxLength > slotWidth) {\n                            label.css({ width: slotWidth + 'px' });\n                        }\n\n                        if (\n                            label.getBBox().height > (\n                                this.len / tickPositions.length -\n                                (labelMetrics.h - labelMetrics.f)\n                            )\n                        ) {\n                            label.specificTextOverflow = 'ellipsis';\n                        }\n                    }\n                }\n            }\n        }\n\n\n        // Add ellipsis if the label length is significantly longer than ideal\n        if (attr.rotation) {\n            commonWidth = (\n                maxLabelLength > chart.chartHeight * 0.5 ?\n                    chart.chartHeight * 0.33 :\n                    maxLabelLength\n            );\n            if (!textOverflowOption) {\n                commonTextOverflow = 'ellipsis';\n            }\n        }\n\n        // Set the explicit or automatic label alignment\n        this.labelAlign = labelOptions.align ||\n            this.autoLabelAlign(this.labelRotation);\n        if (this.labelAlign) {\n            attr.align = this.labelAlign;\n        }\n\n        // Apply general and specific CSS\n        each(tickPositions, function (pos) {\n            var tick = ticks[pos],\n                label = tick && tick.label,\n                widthOption = labelStyleOptions.width,\n                css = {};\n            if (label) {\n                // This needs to go before the CSS in old IE (#4502)\n                label.attr(attr);\n\n                if (\n                    commonWidth &&\n                    !widthOption &&\n                    // Setting width in this case messes with the bounding box\n                    // (#7975)\n                    labelStyleOptions.whiteSpace !== 'nowrap' &&\n                    (\n                        // Speed optimizing, #7656\n                        commonWidth < label.textPxLength ||\n                        // Resetting CSS, #4928\n                        label.element.tagName === 'SPAN'\n                    )\n                ) {\n                    css.width = commonWidth;\n                    if (!textOverflowOption) {\n                        css.textOverflow = (\n                            label.specificTextOverflow ||\n                            commonTextOverflow\n                        );\n                    }\n                    label.css(css);\n\n                // Reset previously shortened label (#8210)\n                } else if (\n                    label.styles &&\n                    label.styles.width &&\n                    !css.width &&\n                    !widthOption\n                ) {\n                    label.css({ width: null });\n                }\n\n                delete label.specificTextOverflow;\n                tick.rotation = attr.rotation;\n            }\n        });\n\n        // Note: Why is this not part of getLabelPosition?\n        this.tickRotCorr = renderer.rotCorr(\n            labelMetrics.b,\n            this.labelRotation || 0,\n            this.side !== 0\n        );\n    },\n\n    /**\n     * Return true if the axis has associated data.\n     *\n     * @function Highcharts.Axis#hasData\n     *\n     * @return {boolean}\n     *         True if the axis has associated visible series and those series\n     *         have either valid data points or explicit `min` and `max`\n     *         settings.\n     */\n    hasData: function () {\n        return (\n            this.hasVisibleSeries ||\n            (\n                defined(this.min) &&\n                defined(this.max) &&\n                this.tickPositions &&\n                this.tickPositions.length > 0\n            )\n        );\n    },\n\n    /**\n     * Adds the title defined in axis.options.title.\n     *\n     * @function Highcharts.Axis#addTitle\n     *\n     * @param {boolean} display\n     *        Whether or not to display the title.\n     */\n    addTitle: function (display) {\n        var axis = this,\n            renderer = axis.chart.renderer,\n            horiz = axis.horiz,\n            opposite = axis.opposite,\n            options = axis.options,\n            axisTitleOptions = options.title,\n            textAlign;\n\n        if (!axis.axisTitle) {\n            textAlign = axisTitleOptions.textAlign;\n            if (!textAlign) {\n                textAlign = (horiz ? {\n                    low: 'left',\n                    middle: 'center',\n                    high: 'right'\n                } : {\n                    low: opposite ? 'right' : 'left',\n                    middle: 'center',\n                    high: opposite ? 'left' : 'right'\n                })[axisTitleOptions.align];\n            }\n            axis.axisTitle = renderer.text(\n                axisTitleOptions.text,\n                0,\n                0,\n                axisTitleOptions.useHTML\n            )\n            .attr({\n                zIndex: 7,\n                rotation: axisTitleOptions.rotation || 0,\n                align: textAlign\n            })\n            .addClass('highcharts-axis-title')\n            \n            .add(axis.axisGroup);\n            axis.axisTitle.isNew = true;\n        }\n\n        // Max width defaults to the length of the axis\n        \n            axis.axisTitle.css({\n                width: axis.len\n            });\n        \n\n        // hide or show the title depending on whether showEmpty is set\n        axis.axisTitle[display ? 'show' : 'hide'](true);\n    },\n\n    /**\n     * Generates a tick for initial positioning.\n     *\n     * @private\n     * @function Highcharts.Axis#generateTick\n     *\n     * @param {number} pos\n     *        The tick position in axis values.\n     *\n     * @param {number} i\n     *        The index of the tick in {@link Axis.tickPositions}.\n     */\n    generateTick: function (pos) {\n        var ticks = this.ticks;\n\n        if (!ticks[pos]) {\n            ticks[pos] = new Tick(this, pos);\n        } else {\n            ticks[pos].addLabel(); // update labels depending on tick interval\n        }\n    },\n\n    /**\n     * Render the tick labels to a preliminary position to get their sizes.\n     *\n     * @private\n     * @function Highcharts.Axis#getOffset\n     *\n     * @fires Highcharts.Axis#event:afterGetOffset\n     */\n    getOffset: function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            options = axis.options,\n            tickPositions = axis.tickPositions,\n            ticks = axis.ticks,\n            horiz = axis.horiz,\n            side = axis.side,\n            invertedSide = chart.inverted &&\n                !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n            hasData,\n            showAxis,\n            titleOffset = 0,\n            titleOffsetOption,\n            titleMargin = 0,\n            axisTitleOptions = options.title,\n            labelOptions = options.labels,\n            labelOffset = 0, // reset\n            labelOffsetPadded,\n            axisOffset = chart.axisOffset,\n            clipOffset = chart.clipOffset,\n            clip,\n            directionFactor = [-1, 1, 1, -1][side],\n            className = options.className,\n            axisParent = axis.axisParent, // Used in color axis\n            lineHeightCorrection,\n            tickSize = this.tickSize('tick');\n\n        // For reuse in Axis.render\n        hasData = axis.hasData();\n        axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n        // Set/reset staggerLines\n        axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n        // Create the axisGroup and gridGroup elements on first iteration\n        if (!axis.axisGroup) {\n            axis.gridGroup = renderer.g('grid')\n                .attr({ zIndex: options.gridZIndex || 1 })\n                .addClass(\n                    'highcharts-' + this.coll.toLowerCase() + '-grid ' +\n                    (className || '')\n                )\n                .add(axisParent);\n            axis.axisGroup = renderer.g('axis')\n                .attr({ zIndex: options.zIndex || 2 })\n                .addClass(\n                    'highcharts-' + this.coll.toLowerCase() + ' ' +\n                    (className || '')\n                )\n                .add(axisParent);\n            axis.labelGroup = renderer.g('axis-labels')\n                .attr({ zIndex: labelOptions.zIndex || 7 })\n                .addClass(\n                    'highcharts-' + axis.coll.toLowerCase() + '-labels ' +\n                    (className || '')\n                )\n                .add(axisParent);\n        }\n\n        if (hasData || axis.isLinked) {\n\n            // Generate ticks\n            each(tickPositions, function (pos, i) {\n                // i is not used here, but may be used in overrides\n                axis.generateTick(pos, i);\n            });\n\n            axis.renderUnsquish();\n\n\n            // Left side must be align: right and right side must\n            // have align: left for labels\n            axis.reserveSpaceDefault = (\n                side === 0 ||\n                side === 2 ||\n                { 1: 'left', 3: 'right' }[side] === axis.labelAlign\n            );\n            if (pick(\n                labelOptions.reserveSpace,\n                axis.labelAlign === 'center' ? true : null,\n                axis.reserveSpaceDefault)\n            ) {\n                each(tickPositions, function (pos) {\n                    // get the highest offset\n                    labelOffset = Math.max(\n                        ticks[pos].getLabelSize(),\n                        labelOffset\n                    );\n                });\n            }\n\n            if (axis.staggerLines) {\n                labelOffset *= axis.staggerLines;\n            }\n            axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n\n        } else { // doesn't have data\n            objectEach(ticks, function (tick, n) {\n                tick.destroy();\n                delete ticks[n];\n            });\n        }\n\n        if (\n            axisTitleOptions &&\n            axisTitleOptions.text &&\n            axisTitleOptions.enabled !== false\n        ) {\n            axis.addTitle(showAxis);\n\n            if (showAxis && axisTitleOptions.reserveSpace !== false) {\n                axis.titleOffset = titleOffset =\n                    axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                titleOffsetOption = axisTitleOptions.offset;\n                titleMargin = defined(titleOffsetOption) ?\n                    0 :\n                    pick(axisTitleOptions.margin, horiz ? 5 : 10);\n            }\n        }\n\n        // Render the axis line\n        axis.renderLine();\n\n        // handle automatic or user set offset\n        axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n        axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n        if (side === 0) {\n            lineHeightCorrection = -axis.labelMetrics().h;\n        } else if (side === 2) {\n            lineHeightCorrection = axis.tickRotCorr.y;\n        } else {\n            lineHeightCorrection = 0;\n        }\n\n        // Find the padded label offset\n        labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n        if (labelOffset) {\n            labelOffsetPadded -= lineHeightCorrection;\n            labelOffsetPadded += directionFactor * (\n                horiz ?\n                    pick(\n                        labelOptions.y,\n                        axis.tickRotCorr.y + directionFactor * 8\n                    ) :\n                    labelOptions.x\n            );\n        }\n\n        axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n        axisOffset[side] = Math.max(\n            axisOffset[side],\n            axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n            labelOffsetPadded, // #3027\n            hasData && tickPositions.length && tickSize ?\n                tickSize[0] + directionFactor * axis.offset :\n                0 // #4866\n        );\n\n        // Decide the clipping needed to keep the graph inside\n        // the plot area and axis lines\n        clip = options.offset ?\n            0 :\n            Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n        clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n\n        fireEvent(this, 'afterGetOffset');\n    },\n\n    /**\n     * Internal function to get the path for the axis line. Extended for polar\n     * charts.\n     *\n     * @function Highcharts.Axis#getLinePath\n     *\n     * @param {number} lineWidth\n     *        The line width in pixels.\n     *\n     * @return {Highcharts.SVGPathArray}\n     *         The SVG path definition in array form.\n     */\n    getLinePath: function (lineWidth) {\n        var chart = this.chart,\n            opposite = this.opposite,\n            offset = this.offset,\n            horiz = this.horiz,\n            lineLeft = this.left + (opposite ? this.width : 0) + offset,\n            lineTop = chart.chartHeight - this.bottom -\n                (opposite ? this.height : 0) + offset;\n\n        if (opposite) {\n            lineWidth *= -1; // crispify the other way - #1480, #1687\n        }\n\n        return chart.renderer\n            .crispLine([\n                'M',\n                horiz ?\n                    this.left :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    this.top,\n                'L',\n                horiz ?\n                    chart.chartWidth - this.right :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    chart.chartHeight - this.bottom\n            ], lineWidth);\n    },\n\n    /**\n     * Render the axis line. Called internally when rendering and redrawing the\n     * axis.\n     *\n     * @function Highcharts.Axis#renderLine\n     */\n    renderLine: function () {\n        if (!this.axisLine) {\n            this.axisLine = this.chart.renderer.path()\n                .addClass('highcharts-axis-line')\n                .add(this.axisGroup);\n\n            \n        }\n    },\n\n    /**\n     * Position the axis title.\n     *\n     * @private\n     * @function Highcharts.Axis#getTitlePosition\n     *\n     * @return {Highcharts.AxisTitlePositionObject}\n     *         X and Y positions for the title.\n     */\n    getTitlePosition: function () {\n        // compute anchor points for each of the title align options\n        var horiz = this.horiz,\n            axisLeft = this.left,\n            axisTop = this.top,\n            axisLength = this.len,\n            axisTitleOptions = this.options.title,\n            margin = horiz ? axisLeft : axisTop,\n            opposite = this.opposite,\n            offset = this.offset,\n            xOption = axisTitleOptions.x || 0,\n            yOption = axisTitleOptions.y || 0,\n            axisTitle = this.axisTitle,\n            fontMetrics = this.chart.renderer.fontMetrics(\n                axisTitleOptions.style && axisTitleOptions.style.fontSize,\n                axisTitle\n            ),\n            // The part of a multiline text that is below the baseline of the\n            // first line. Subtract 1 to preserve pixel-perfectness from the\n            // old behaviour (v5.0.12), where only one line was allowed.\n            textHeightOvershoot = Math.max(\n                axisTitle.getBBox(null, 0).height - fontMetrics.h - 1,\n                0\n            ),\n\n            // the position in the length direction of the axis\n            alongAxis = {\n                low: margin + (horiz ? 0 : axisLength),\n                middle: margin + axisLength / 2,\n                high: margin + (horiz ? axisLength : 0)\n            }[axisTitleOptions.align],\n\n            // the position in the perpendicular direction of the axis\n            offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                (opposite ? -1 : 1) * // so does opposite axes\n                this.axisTitleMargin +\n                [\n                    -textHeightOvershoot, // top\n                    textHeightOvershoot, // right\n                    fontMetrics.f, // bottom\n                    -textHeightOvershoot // left\n                ][this.side];\n\n\n        return {\n            x: horiz ?\n                alongAxis + xOption :\n                offAxis + (opposite ? this.width : 0) + offset + xOption,\n            y: horiz ?\n                offAxis + yOption - (opposite ? this.height : 0) + offset :\n                alongAxis + yOption\n        };\n    },\n\n    /**\n     * Render a minor tick into the given position. If a minor tick already\n     * exists in this position, move it.\n     *\n     * @function Highcharts.Axis#renderMinorTick\n     *\n     * @param {number} pos\n     *        The position in axis values.\n     */\n    renderMinorTick: function (pos) {\n        var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),\n            minorTicks = this.minorTicks;\n\n        if (!minorTicks[pos]) {\n            minorTicks[pos] = new Tick(this, pos, 'minor');\n        }\n\n        // Render new ticks in old position\n        if (slideInTicks && minorTicks[pos].isNew) {\n            minorTicks[pos].render(null, true);\n        }\n\n        minorTicks[pos].render(null, false, 1);\n    },\n\n    /**\n     * Render a major tick into the given position. If a tick already exists\n     * in this position, move it.\n     *\n     * @function Highcharts.Axis#renderTick\n     *\n     * @param {number} pos\n     *        The position in axis values.\n     *\n     * @param {number} i\n     *        The tick index.\n     */\n    renderTick: function (pos, i) {\n        var isLinked = this.isLinked,\n            ticks = this.ticks,\n            slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);\n\n        // Linked axes need an extra check to find out if\n        if (!isLinked || (pos >= this.min && pos <= this.max)) {\n\n            if (!ticks[pos]) {\n                ticks[pos] = new Tick(this, pos);\n            }\n\n            // render new ticks in old position\n            if (slideInTicks && ticks[pos].isNew) {\n                ticks[pos].render(i, true, 0.1);\n            }\n\n            ticks[pos].render(i);\n        }\n    },\n\n    /**\n     * Render the axis.\n     *\n     * @private\n     * @function Highcharts.Axis#render\n     *\n     * @fires Highcharts.Axis#event:afterRender\n     */\n    render: function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            options = axis.options,\n            isLog = axis.isLog,\n            isLinked = axis.isLinked,\n            tickPositions = axis.tickPositions,\n            axisTitle = axis.axisTitle,\n            ticks = axis.ticks,\n            minorTicks = axis.minorTicks,\n            alternateBands = axis.alternateBands,\n            stackLabelOptions = options.stackLabels,\n            alternateGridColor = options.alternateGridColor,\n            tickmarkOffset = axis.tickmarkOffset,\n            axisLine = axis.axisLine,\n            showAxis = axis.showAxis,\n            animation = animObject(renderer.globalAnimation),\n            from,\n            to;\n\n        // Reset\n        axis.labelEdge.length = 0;\n        axis.overlap = false;\n\n        // Mark all elements inActive before we go over and mark the active ones\n        each([ticks, minorTicks, alternateBands], function (coll) {\n            objectEach(coll, function (tick) {\n                tick.isActive = false;\n            });\n        });\n\n        // If the series has data draw the ticks. Else only the line and title\n        if (axis.hasData() || isLinked) {\n\n            // minor ticks\n            if (axis.minorTickInterval && !axis.categories) {\n                each(axis.getMinorTickPositions(), function (pos) {\n                    axis.renderMinorTick(pos);\n                });\n            }\n\n            // Major ticks. Pull out the first item and render it last so that\n            // we can get the position of the neighbour label. #808.\n            if (tickPositions.length) { // #1300\n                each(tickPositions, function (pos, i) {\n                    axis.renderTick(pos, i);\n                });\n                // In a categorized axis, the tick marks are displayed\n                // between labels. So we need to add a tick mark and\n                // grid line at the left edge of the X axis.\n                if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                    if (!ticks[-1]) {\n                        ticks[-1] = new Tick(axis, -1, null, true);\n                    }\n                    ticks[-1].render(-1);\n                }\n\n            }\n\n            // alternate grid color\n            if (alternateGridColor) {\n                each(tickPositions, function (pos, i) {\n                    to = tickPositions[i + 1] !== undefined ?\n                        tickPositions[i + 1] + tickmarkOffset :\n                        axis.max - tickmarkOffset;\n\n                    if (\n                        i % 2 === 0 &&\n                        pos < axis.max &&\n                        to <= axis.max + (\n                            chart.polar ?\n                                -tickmarkOffset :\n                                tickmarkOffset\n                        )\n                    ) { // #2248, #4660\n                        if (!alternateBands[pos]) {\n                            alternateBands[pos] = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PlotLineOrBand(axis);\n                        }\n                        from = pos + tickmarkOffset; // #949\n                        alternateBands[pos].options = {\n                            from: isLog ? axis.lin2log(from) : from,\n                            to: isLog ? axis.lin2log(to) : to,\n                            color: alternateGridColor\n                        };\n                        alternateBands[pos].render();\n                        alternateBands[pos].isActive = true;\n                    }\n                });\n            }\n\n            // custom plot lines and bands\n            if (!axis._addedPlotLB) { // only first time\n                each(\n                    (options.plotLines || []).concat(options.plotBands || []),\n                    function (plotLineOptions) {\n                        axis.addPlotBandOrLine(plotLineOptions);\n                    }\n                );\n                axis._addedPlotLB = true;\n            }\n\n        } // end if hasData\n\n        // Remove inactive ticks\n        each([ticks, minorTicks, alternateBands], function (coll) {\n            var i,\n                forDestruction = [],\n                delay = animation.duration,\n                destroyInactiveItems = function () {\n                    i = forDestruction.length;\n                    while (i--) {\n                        // When resizing rapidly, the same items\n                        // may be destroyed in different timeouts,\n                        // or the may be reactivated\n                        if (\n                            coll[forDestruction[i]] &&\n                            !coll[forDestruction[i]].isActive\n                        ) {\n                            coll[forDestruction[i]].destroy();\n                            delete coll[forDestruction[i]];\n                        }\n                    }\n\n                };\n\n            objectEach(coll, function (tick, pos) {\n                if (!tick.isActive) {\n                    // Render to zero opacity\n                    tick.render(pos, false, 0);\n                    tick.isActive = false;\n                    forDestruction.push(pos);\n                }\n            });\n\n            // When the objects are finished fading out, destroy them\n            syncTimeout(\n                destroyInactiveItems,\n                coll === alternateBands ||\n                    !chart.hasRendered ||\n                    !delay ?\n                        0 :\n                        delay\n            );\n        });\n\n        // Set the axis line path\n        if (axisLine) {\n            axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n                d: this.getLinePath(axisLine.strokeWidth())\n            });\n            axisLine.isPlaced = true;\n\n            // Show or hide the line depending on options.showEmpty\n            axisLine[showAxis ? 'show' : 'hide'](true);\n        }\n\n        if (axisTitle && showAxis) {\n            var titleXy = axis.getTitlePosition();\n            if (isNumber(titleXy.y)) {\n                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);\n                axisTitle.isNew = false;\n            } else {\n                axisTitle.attr('y', -9999);\n                axisTitle.isNew = true;\n            }\n        }\n\n        // Stacked totals:\n        if (stackLabelOptions && stackLabelOptions.enabled) {\n            axis.renderStackTotals();\n        }\n        // End stacked totals\n\n        axis.isDirty = false;\n\n        fireEvent(this, 'afterRender');\n    },\n\n    /**\n     * Redraw the axis to reflect changes in the data or axis extremes. Called\n     * internally from {@link Chart#redraw}.\n     *\n     * @private\n     * @function Highcharts.Axis#redraw\n     */\n    redraw: function () {\n\n        if (this.visible) {\n            // render the axis\n            this.render();\n\n            // move plot lines and bands\n            each(this.plotLinesAndBands, function (plotLine) {\n                plotLine.render();\n            });\n        }\n\n        // mark associated series as dirty and ready for redraw\n        each(this.series, function (series) {\n            series.isDirty = true;\n        });\n\n    },\n\n    // Properties to survive after destroy, needed for Axis.update (#4317,\n    // #5773, #5881).\n    keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],\n\n    /**\n     * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n     * to fully remove the axis.\n     *\n     * @private\n     * @function Highcharts.Axis#destroy\n     *\n     * @param {boolean} keepEvents\n     *        Whether to preserve events, used internally in Axis.update.\n     */\n    destroy: function (keepEvents) {\n        var axis = this,\n            stacks = axis.stacks,\n            plotLinesAndBands = axis.plotLinesAndBands,\n            plotGroup,\n            i;\n\n        fireEvent(this, 'destroy', { keepEvents: keepEvents });\n\n        // Remove the events\n        if (!keepEvents) {\n            removeEvent(axis);\n        }\n\n        // Destroy each stack total\n        objectEach(stacks, function (stack, stackKey) {\n            destroyObjectProperties(stack);\n\n            stacks[stackKey] = null;\n        });\n\n        // Destroy collections\n        each(\n            [axis.ticks, axis.minorTicks, axis.alternateBands],\n            function (coll) {\n                destroyObjectProperties(coll);\n            }\n        );\n        if (plotLinesAndBands) {\n            i = plotLinesAndBands.length;\n            while (i--) { // #1975\n                plotLinesAndBands[i].destroy();\n            }\n        }\n\n        // Destroy elements\n        each(\n            ['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup',\n                'gridGroup', 'labelGroup', 'cross', 'scrollbar'],\n            function (prop) {\n                if (axis[prop]) {\n                    axis[prop] = axis[prop].destroy();\n                }\n            }\n        );\n\n        // Destroy each generated group for plotlines and plotbands\n        for (plotGroup in axis.plotLinesAndBandsGroups) {\n            axis.plotLinesAndBandsGroups[plotGroup] =\n                axis.plotLinesAndBandsGroups[plotGroup].destroy();\n        }\n\n        // Delete all properties and fall back to the prototype.\n        objectEach(axis, function (val, key) {\n            if (inArray(key, axis.keepProps) === -1) {\n                delete axis[key];\n            }\n        });\n    },\n\n    /**\n     * Internal function to draw a crosshair.\n     *\n     * @function Highcharts.Axis#drawCrosshair\n     *\n     * @param {Highcharts.PointerEventObject} [e]\n     *        The event arguments from the modified pointer event, extended with\n     *        `chartX` and `chartY`\n     *\n     * @param {Highcharts.Point} [point]\n     *        The Point object if the crosshair snaps to points.\n     *\n     * @fires Highcharts.Axis#event:afterDrawCrosshair\n     * @fires Highcharts.Axis#event:drawCrosshair\n     */\n    drawCrosshair: function (e, point) {\n\n        var path,\n            options = this.crosshair,\n            snap = pick(options.snap, true),\n            pos,\n            categorized,\n            graphic = this.cross;\n\n        fireEvent(this, 'drawCrosshair', { e: e, point: point });\n\n        // Use last available event when updating non-snapped crosshairs without\n        // mouse interaction (#5287)\n        if (!e) {\n            e = this.cross && this.cross.e;\n        }\n\n        if (\n            // Disabled in options\n            !this.crosshair ||\n            // Snap\n            ((defined(point) || !snap) === false)\n        ) {\n            this.hideCrosshair();\n        } else {\n\n            // Get the path\n            if (!snap) {\n                pos = e &&\n                    (\n                        this.horiz ?\n                            e.chartX - this.pos :\n                            this.len - e.chartY + this.pos\n                    );\n            } else if (defined(point)) {\n                // #3834\n                pos = pick(\n                    point.crosshairPos, // 3D axis extension\n                    this.isXAxis ? point.plotX : this.len - point.plotY\n                );\n            }\n\n            if (defined(pos)) {\n                path = this.getPlotLinePath(\n                    // First argument, value, only used on radial\n                    point && (this.isXAxis ?\n                        point.x :\n                        pick(point.stackY, point.y)\n                    ),\n                    null,\n                    null,\n                    null,\n                    pos // Translated position\n                ) || null; // #3189\n            }\n\n            if (!defined(path)) {\n                this.hideCrosshair();\n                return;\n            }\n\n            categorized = this.categories && !this.isRadial;\n\n            // Draw the cross\n            if (!graphic) {\n                this.cross = graphic = this.chart.renderer\n                    .path()\n                    .addClass(\n                        'highcharts-crosshair highcharts-crosshair-' +\n                        (categorized ? 'category ' : 'thin ') +\n                        options.className\n                    )\n                    .attr({\n                        zIndex: pick(options.zIndex, 2)\n                    })\n                    .add();\n\n                \n\n            }\n\n            graphic.show().attr({\n                d: path\n            });\n\n            if (categorized && !options.width) {\n                graphic.attr({\n                    'stroke-width': this.transA\n                });\n            }\n            this.cross.e = e;\n        }\n\n        fireEvent(this, 'afterDrawCrosshair', { e: e, point: point });\n    },\n\n    /**\n     * Hide the crosshair if visible.\n     *\n     * @function Highcharts.Axis#hideCrosshair\n     */\n    hideCrosshair: function () {\n        if (this.cross) {\n            this.cross.hide();\n        }\n    }\n}); // end Axis\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis = Axis;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axis);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Axis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/BarSeries.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/BarSeries.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _ColumnSeries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColumnSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType;\n\n/**\n * The Bar series class\n */\nseriesType('bar', 'column', null, {\n    inverted: true\n});\n/**\n * A bar series is a special type of column series where the columns are\n * horizontal.\n *\n * @sample       highcharts/demo/bar-basic/\n *               Bar chart\n * @extends      {plotOptions.column}\n * @product      highcharts\n * @optionparent plotOptions.bar\n */\n\n\n/**\n * A `bar` series. If the [type](#series.bar.type) option is not specified,\n * it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.bar\n * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,\n *            lineWidth,marker,connectEnds,step\n * @product   highcharts\n * @apioption series.bar\n */\n\n/**\n * An array of data points for the series. For the `bar` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 5],\n *         [1, 10],\n *         [2, 3]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.bar.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 1,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 10,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.column.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.bar.data\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.bar.states.hover\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.bar.states.select\n */\n\n/**\n * Alignment of the data label relative to the data point.\n *\n * @type      {String}\n * @sample    {highcharts}\n *            highcharts/plotoptions/bar-datalabels-align-inside-bar/\n *            Data labels inside the bar\n * @default   left\n * @product   highcharts\n * @apioption plotOptions.bar.dataLabels.align\n */\n\n/**\n * The x position of the data label relative to the data point.\n *\n * @type      {Number}\n * @sample    {highcharts}\n *            highcharts/plotoptions/bar-datalabels-align-inside-bar/\n *            Data labels inside the bar\n * @default   5\n * @product   highcharts\n * @apioption plotOptions.bar.dataLabels.x\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/BarSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/CandlestickSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/CandlestickSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * A candlestick chart is a style of financial chart used to describe price\n * movements over time.\n *\n * @sample stock/demo/candlestick/ Candlestick chart\n *\n * @extends plotOptions.ohlc\n * @excluding borderColor,borderRadius,borderWidth\n * @product highstock\n * @optionparent plotOptions.candlestick\n */\nvar candlestickOptions = {\n\n    /**\n     * The specific line color for up candle sticks. The default is to inherit\n     * the general `lineColor` setting.\n     *\n     * @type {Color}\n     * @sample  {highstock} stock/plotoptions/candlestick-linecolor/\n     *          Candlestick line colors\n     * @default null\n     * @since 1.3.6\n     * @product highstock\n     * @apioption plotOptions.candlestick.upLineColor\n     */\n\n    /**\n     * @default ohlc\n     * @apioption plotOptions.candlestick.dataGrouping.approximation\n     */\n\n    states: {\n\n        /**\n         * @extends plotOptions.column.states.hover\n         * @product highstock\n         */\n        hover: {\n\n            /**\n             * The pixel width of the line/border around the candlestick.\n             *\n             * @type {Number}\n             * @default 2\n             * @product highstock\n             */\n            lineWidth: 2\n        }\n    },\n\n    /**\n     * @extends plotOptions.ohlc.tooltip\n     */\n    tooltip: defaultPlotOptions.ohlc.tooltip,\n\n    threshold: null,\n    \n\n    stickyTracking: true\n\n};\n\n/**\n * The candlestick series type.\n *\n * @constructor seriesTypes.candlestick\n * @augments seriesTypes.ohlc\n */\nseriesType('candlestick', 'ohlc', merge(\n    defaultPlotOptions.column,\n    candlestickOptions\n), /** @lends seriesTypes.candlestick */ {\n    \n    /**\n     * Draw the data points\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            chart = series.chart,\n            reversedYAxis = series.yAxis.reversed;\n\n\n        each(points, function (point) {\n\n            var graphic = point.graphic,\n                plotOpen,\n                plotClose,\n                topBox,\n                bottomBox,\n                hasTopWhisker,\n                hasBottomWhisker,\n                crispCorr,\n                crispX,\n                path,\n                halfWidth,\n                isNew = !graphic;\n\n            if (point.plotY !== undefined) {\n\n                if (!graphic) {\n                    point.graphic = graphic = chart.renderer.path()\n                        .add(series.group);\n                }\n\n                \n\n                // Crisp vector coordinates\n                crispCorr = (graphic.strokeWidth() % 2) / 2;\n                crispX = Math.round(point.plotX) - crispCorr; // #2596\n                plotOpen = point.plotOpen;\n                plotClose = point.plotClose;\n                topBox = Math.min(plotOpen, plotClose);\n                bottomBox = Math.max(plotOpen, plotClose);\n                halfWidth = Math.round(point.shapeArgs.width / 2);\n                hasTopWhisker = reversedYAxis ?\n                    bottomBox !== point.yBottom :\n                    Math.round(topBox) !== Math.round(point.plotHigh);\n                hasBottomWhisker = reversedYAxis ?\n                    Math.round(topBox) !== Math.round(point.plotHigh) :\n                    bottomBox !== point.yBottom;\n                topBox = Math.round(topBox) + crispCorr;\n                bottomBox = Math.round(bottomBox) + crispCorr;\n\n                // Create the path. Due to a bug in Chrome 49, the path is first\n                // instanciated with no values, then the values pushed. For\n                // unknown reasons, instanciating the path array with all the\n                // values would lead to a crash when updating frequently\n                // (#5193).\n                path = [];\n                path.push(\n                    'M',\n                    crispX - halfWidth, bottomBox,\n                    'L',\n                    crispX - halfWidth, topBox,\n                    'L',\n                    crispX + halfWidth, topBox,\n                    'L',\n                    crispX + halfWidth, bottomBox,\n                    'Z', // Ensure a nice rectangle #2602\n                    'M',\n                    crispX, topBox,\n                    'L',\n                    // #460, #2094\n                    crispX, hasTopWhisker ?\n                        Math.round(\n                            reversedYAxis ? point.yBottom : point.plotHigh\n                        ) :\n                        topBox,\n                    'M',\n                    crispX, bottomBox,\n                    'L',\n                    // #460, #2094\n                    crispX, hasBottomWhisker ?\n                        Math.round(\n                            reversedYAxis ? point.plotHigh : point.yBottom\n                        ) :\n                        bottomBox\n                );\n\n                graphic[isNew ? 'attr' : 'animate']({ d: path })\n                    .addClass(point.getClassName(), true);\n\n            }\n        });\n\n    }\n\n\n});\n\n/**\n * A `candlestick` series. If the [type](#series.candlestick.type)\n * option is not specified, it is inherited from [chart.type](\n * #chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.candlestick\n * @excluding dataParser,dataURL\n * @product highstock\n * @apioption series.candlestick\n */\n\n/**\n * An array of data points for the series. For the `candlestick` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of arrays with 5 or 4 values. In this case, the values\n * correspond to `x,open,high,low,close`. If the first value is a string,\n * it is applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 4\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 7, 2, 0, 4],\n *         [1, 1, 4, 2, 8],\n *         [2, 3, 3, 9, 3]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](\n * #series.candlestick.turboThreshold), this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         open: 9,\n *         high: 2,\n *         low: 4,\n *         close: 6,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         open: 1,\n *         high: 4,\n *         low: 7,\n *         close: 7,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Array>}\n * @extends series.ohlc.data\n * @excluding y\n * @product highstock\n * @apioption series.candlestick.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/CandlestickSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Chart.js":
/*!**************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Chart.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ \"./node_modules/highcharts/js/es-modules/parts/Pointer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Callback for chart constructors.\n *\n * @callback Highcharts.ChartCallbackFunction\n *\n * @param {Highcharts.Chart} chart\n *        Created chart.\n */\n\n/**\n * The chart title. The title has an `update` method that allows modifying the\n * options directly or indirectly via `chart.update`.\n *\n * @interface Highcharts.TitleObject\n * @extends Highcharts.SVGElement\n *//**\n * Modify options for the title.\n *\n * @function Highcharts.TitleObject#update\n *\n * @param {Highcharts.TitleOptions} titleOptions\n *        Options to modify.\n */\n\n/**\n * The chart subtitle. The subtitle has an `update` method that\n * allows modifying the options directly or indirectly via\n * `chart.update`.\n *\n * @interface Highcharts.SubtitleObject\n * @extends Highcharts.SVGElement\n *//**\n * Modify options for the subtitle.\n *\n * @function Highcharts.SubtitleObject#update\n *\n * @param {Highcharts.SubtitleOptions} subtitleOptions\n *        Options to modify.\n */\n\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    animate = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animate,\n    animObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    attr = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].attr,\n    doc = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis, // @todo add as requirement\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    discardElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].discardElement,\n    charts = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    find = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isString = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    Legend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend, // @todo add as requirement\n    marginNames = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].marginNames,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    Pointer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer, // @todo add as requirement\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    syncTimeout = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win;\n\n/**\n * The Chart class. The recommended constructor is {@link Highcharts#chart}.\n *\n * @example\n * var chart = Highcharts.chart('container', {\n *        title: {\n *               text: 'My chart'\n *        },\n *        series: [{\n *            data: [1, 3, 2, 4]\n *        }]\n * })\n *\n * @class\n * @name Highcharts.Chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n *//**\n * @class\n * @name Highcharts.Chart\n *\n * @param {string|Highcharts.HTMLDOMElement} renderTo\n *        The DOM element to render to, or its id.\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n */\nvar Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart = function () {\n    this.getArgs.apply(this, arguments);\n};\n\n/**\n * Factory function for basic charts.\n *\n * @example\n * // Render a chart in to div#container\n * var chart = Highcharts.chart('container', {\n *     title: {\n *         text: 'My chart'\n *     },\n *     series: [{\n *         data: [1, 3, 2, 4]\n *     }]\n * });\n *\n * @function Highcharts.chart\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n *\n * @return {Highcharts.Chart}\n *         Returns the Chart object.\n *//**\n * @function Highcharts.chart\n *\n * @param {string|Highcharts.HTMLDOMElement} renderTo\n *        The DOM element to render to, or its id.\n *\n * @param {Highcharts.Options} options\n *        The chart options structure.\n *\n * @param {Highcharts.ChartCallbackFunction|undefined} [callback]\n *        Function to run when the chart has loaded and and all external images\n *        are loaded. Defining a\n *        {@link https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n *        handler is equivalent.\n *\n * @return {Highcharts.Chart}\n *         Returns the Chart object.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chart = function (a, b, c) {\n    return new Chart(a, b, c);\n};\n\nextend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n    // Hook for adding callbacks in modules\n    callbacks: [],\n\n    /**\n     * Handle the arguments passed to the constructor.\n     *\n     * @private\n     * @function Highcharts.Chart#getArgs\n     *\n     * @param {...Array<*>} arguments\n     *        All arguments for the constructor.\n     *\n     * @return {Array<*>}\n     *         Passed arguments without renderTo.\n     *\n     * @fires Highcharts.Chart#event:init\n     * @fires Highcharts.Chart#event:afterInit\n     */\n    getArgs: function () {\n        var args = [].slice.call(arguments);\n\n        // Remove the optional first argument, renderTo, and\n        // set it on this.\n        if (isString(args[0]) || args[0].nodeName) {\n            this.renderTo = args.shift();\n        }\n        this.init(args[0], args[1]);\n    },\n\n    /**\n     * Overridable function that initializes the chart. The constructor's\n     * arguments are passed on directly.\n     *\n     * @function Highcharts.Chart#init\n     *\n     * @param {Highcharts.Options} userOptions\n     *        Custom options.\n     *\n     * @param {Function|undefined} [callback]\n     *        Function to run when the chart has loaded and and all external\n     *        images are loaded.\n     *\n     * @fires Highcharts.Chart#event:init\n     * @fires Highcharts.Chart#event:afterInit\n     */\n    init: function (userOptions, callback) {\n\n        // Handle regular options\n        var options,\n            type,\n            // skip merging data points to increase performance\n            seriesOptions = userOptions.series,\n            userPlotOptions = userOptions.plotOptions || {};\n\n        // Fire the event with a default function\n        fireEvent(this, 'init', { args: arguments }, function () {\n\n            userOptions.series = null;\n            options = merge(defaultOptions, userOptions); // do the merge\n\n            // Override (by copy of user options) or clear tooltip options\n            // in chart.options.plotOptions (#6218)\n            for (type in options.plotOptions) {\n                options.plotOptions[type].tooltip = (\n                    userPlotOptions[type] &&\n                    merge(userPlotOptions[type].tooltip) // override by copy\n                ) || undefined; // or clear\n            }\n            // User options have higher priority than default options\n            // (#6218). In case of exporting: path is changed\n            options.tooltip.userOptions = (\n                userOptions.chart &&\n                userOptions.chart.forExport &&\n                userOptions.tooltip.userOptions\n            ) || userOptions.tooltip;\n\n            // set back the series data\n            options.series = userOptions.series = seriesOptions;\n            this.userOptions = userOptions;\n\n            var optionsChart = options.chart;\n\n            var chartEvents = optionsChart.events;\n\n            this.margin = [];\n            this.spacing = [];\n\n            // Pixel data bounds for touch zoom\n            this.bounds = { h: {}, v: {} };\n\n            // An array of functions that returns labels that should be\n            // considered for anti-collision\n            this.labelCollectors = [];\n\n            this.callback = callback;\n            this.isResizing = 0;\n\n            /**\n             * The options structure for the chart. It contains members for\n             * the sub elements like series, legend, tooltip etc.\n             *\n             * @name Highcharts.Chart#options\n             * @type {Highcharts.Options}\n             */\n            this.options = options;\n\n            /**\n             * All the axes in the chart.\n             *\n             * @see  Highcharts.Chart.xAxis\n             * @see  Highcharts.Chart.yAxis\n             *\n             * @name Highcharts.Chart#axes\n             * @type {Array<Highcharts.Axis>}\n             */\n            this.axes = [];\n\n            /**\n             * All the current series in the chart.\n             *\n             * @name Highcharts.Chart#series\n             * @type {Array<Highcharts.Series>}\n             */\n            this.series = [];\n\n            /**\n             * The `Time` object associated with the chart. Since v6.0.5,\n             * time settings can be applied individually for each chart. If\n             * no individual settings apply, the `Time` object is shared by\n             * all instances.\n             *\n             * @name Highcharts.Chart#time\n             * @type {Highcharts.Time}\n             */\n            this.time =\n                userOptions.time && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keys(userOptions.time).length ?\n                    new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Time(userOptions.time) :\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time;\n\n\n            this.hasCartesianSeries = optionsChart.showAxes;\n\n            var chart = this;\n\n            // Add the chart to the global lookup\n            chart.index = charts.length;\n\n            charts.push(chart);\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chartCount++;\n\n            // Chart event handlers\n            if (chartEvents) {\n                objectEach(chartEvents, function (event, eventType) {\n                    addEvent(chart, eventType, event);\n                });\n            }\n\n            /**\n             * A collection of the X axes in the chart.\n             *\n             * @name Highcharts.Chart#xAxis\n             * @type {Array<Highcharts.Axis>}\n             */\n            chart.xAxis = [];\n\n            /**\n             * A collection of the Y axes in the chart.\n             *\n             * @name Highcharts.Chart#yAxis\n             * @type {Array<Highcharts.Axis>}\n             *\n             * @todo\n             * Make events official: Fire the event `afterInit`.\n             */\n            chart.yAxis = [];\n\n            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n            // Fire after init but before first render, before axes and series\n            // have been initialized.\n            fireEvent(chart, 'afterInit');\n\n            chart.firstRender();\n        });\n    },\n\n    /**\n     * Internal function to unitialize an individual series.\n     *\n     * @private\n     * @function Highcharts.Chart#initSeries\n     *\n     * @param {Highcharts.ChartOptions} options\n     *\n     * @return {Highcharts.Series}\n     */\n    initSeries: function (options) {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            type = (\n                options.type ||\n                optionsChart.type ||\n                optionsChart.defaultSeriesType\n            ),\n            series,\n            Constr = seriesTypes[type];\n\n        // No such series type\n        if (!Constr) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(17, true);\n        }\n\n        series = new Constr();\n        series.init(this, options);\n        return series;\n    },\n\n    /**\n     * Order all series above a given index. When series are added and ordered\n     * by configuration, only the last series is handled (#248, #1123, #2456,\n     * #6112). This function is called on series initialization and destroy.\n     *\n     * @private\n     * @function Highcharts.Series#orderSeries\n     *\n     * @param {number} fromIndex\n     *        If this is given, only the series above this index are handled.\n     */\n    orderSeries: function (fromIndex) {\n        var series = this.series,\n            i = fromIndex || 0;\n        for (; i < series.length; i++) {\n            if (series[i]) {\n                series[i].index = i;\n                series[i].name = series[i].getName();\n            }\n        }\n    },\n\n    /**\n     * Check whether a given point is within the plot area.\n     *\n     * @function Highcharts.Chart#isInsidePlot\n     *\n     * @param {number} plotX\n     *        Pixel x relative to the plot area.\n     *\n     * @param {number} plotY\n     *        Pixel y relative to the plot area.\n     *\n     * @param {boolean} inverted\n     *        Whether the chart is inverted.\n     *\n     * @return {boolean}\n     *         Returns true if the given point is inside the plot area.\n     */\n    isInsidePlot: function (plotX, plotY, inverted) {\n        var x = inverted ? plotY : plotX,\n            y = inverted ? plotX : plotY;\n\n        return x >= 0 &&\n            x <= this.plotWidth &&\n            y >= 0 &&\n            y <= this.plotHeight;\n    },\n\n    /**\n     * Redraw the chart after changes have been done to the data, axis extremes\n     * chart size or chart elements. All methods for updating axes, series or\n     * points have a parameter for redrawing the chart. This is `true` by\n     * default. But in many cases you want to do more than one operation on the\n     * chart before redrawing, for example add a number of points. In those\n     * cases it is a waste of resources to redraw the chart for each new point\n     * added. So you add the points and call `chart.redraw()` after.\n     *\n     * @function Highcharts.Chart#redraw\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject|undefined} [animation]\n     *        If or how to apply animation to the redraw.\n     *\n     * @fires Highcharts.Chart#event:afterSetExtremes\n     * @fires Highcharts.Chart#event:beforeRedraw\n     * @fires Highcharts.Chart#event:predraw\n     * @fires Highcharts.Chart#event:redraw\n     * @fires Highcharts.Chart#event:render\n     * @fires Highcharts.Chart#event:updatedData\n     */\n    redraw: function (animation) {\n\n        fireEvent(this, 'beforeRedraw');\n\n        var chart = this,\n            axes = chart.axes,\n            series = chart.series,\n            pointer = chart.pointer,\n            legend = chart.legend,\n            legendUserOptions = chart.userOptions.legend,\n            redrawLegend = chart.isDirtyLegend,\n            hasStackedSeries,\n            hasDirtyStacks,\n            hasCartesianSeries = chart.hasCartesianSeries,\n            isDirtyBox = chart.isDirtyBox,\n            i,\n            serie,\n            renderer = chart.renderer,\n            isHiddenChart = renderer.isHidden(),\n            afterRedraw = [];\n\n        // Handle responsive rules, not only on resize (#6130)\n        if (chart.setResponsive) {\n            chart.setResponsive(false);\n        }\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setAnimation(animation, chart);\n\n        if (isHiddenChart) {\n            chart.temporaryDisplay();\n        }\n\n        // Adjust title layout (reflow multiline text)\n        chart.layOutTitles();\n\n        // link stacked series\n        i = series.length;\n        while (i--) {\n            serie = series[i];\n\n            if (serie.options.stacking) {\n                hasStackedSeries = true;\n\n                if (serie.isDirty) {\n                    hasDirtyStacks = true;\n                    break;\n                }\n            }\n        }\n        if (hasDirtyStacks) { // mark others as dirty\n            i = series.length;\n            while (i--) {\n                serie = series[i];\n                if (serie.options.stacking) {\n                    serie.isDirty = true;\n                }\n            }\n        }\n\n        // Handle updated data in the series\n        each(series, function (serie) {\n            if (serie.isDirty) {\n                if (serie.options.legendType === 'point') {\n                    if (serie.updateTotals) {\n                        serie.updateTotals();\n                    }\n                    redrawLegend = true;\n                } else if (\n                    legendUserOptions &&\n                    (\n                        legendUserOptions.labelFormatter ||\n                        legendUserOptions.labelFormat\n                    )\n                ) {\n                    redrawLegend = true; // #2165\n                }\n            }\n            if (serie.isDirtyData) {\n                fireEvent(serie, 'updatedData');\n            }\n        });\n\n        // handle added or removed series\n        if (redrawLegend && legend && legend.options.enabled) {\n            // draw legend graphics\n            legend.render();\n\n            chart.isDirtyLegend = false;\n        }\n\n        // reset stacks\n        if (hasStackedSeries) {\n            chart.getStacks();\n        }\n\n\n        if (hasCartesianSeries) {\n            // set axes scales\n            each(axes, function (axis) {\n                axis.updateNames();\n                axis.setScale();\n            });\n        }\n\n        chart.getMargins(); // #3098\n\n        if (hasCartesianSeries) {\n            // If one axis is dirty, all axes must be redrawn (#792, #2169)\n            each(axes, function (axis) {\n                if (axis.isDirty) {\n                    isDirtyBox = true;\n                }\n            });\n\n            // redraw axes\n            each(axes, function (axis) {\n\n                // Fire 'afterSetExtremes' only if extremes are set\n                var key = axis.min + ',' + axis.max;\n                if (axis.extKey !== key) { // #821, #4452\n                    axis.extKey = key;\n\n                    // prevent a recursive call to chart.redraw() (#1119)\n                    afterRedraw.push(function () {\n                        fireEvent(\n                            axis,\n                            'afterSetExtremes',\n                            extend(axis.eventArgs, axis.getExtremes())\n                        ); // #747, #751\n                        delete axis.eventArgs;\n                    });\n                }\n                if (isDirtyBox || hasStackedSeries) {\n                    axis.redraw();\n                }\n            });\n        }\n\n        // the plot areas size has changed\n        if (isDirtyBox) {\n            chart.drawChartBox();\n        }\n\n        // Fire an event before redrawing series, used by the boost module to\n        // clear previous series renderings.\n        fireEvent(chart, 'predraw');\n\n        // redraw affected series\n        each(series, function (serie) {\n            if ((isDirtyBox || serie.isDirty) && serie.visible) {\n                serie.redraw();\n            }\n            // Set it here, otherwise we will have unlimited 'updatedData' calls\n            // for a hidden series after setData(). Fixes #6012\n            serie.isDirtyData = false;\n        });\n\n        // move tooltip or reset\n        if (pointer) {\n            pointer.reset(true);\n        }\n\n        // redraw if canvas\n        renderer.draw();\n\n        // Fire the events\n        fireEvent(chart, 'redraw');\n        fireEvent(chart, 'render');\n\n        if (isHiddenChart) {\n            chart.temporaryDisplay(true);\n        }\n\n        // Fire callbacks that are put on hold until after the redraw\n        each(afterRedraw, function (callback) {\n            callback.call();\n        });\n    },\n\n    /**\n     * Get an axis, series or point object by `id` as given in the configuration\n     * options. Returns `undefined` if no item is found.\n     *\n     * @sample highcharts/plotoptions/series-id/\n     *         Get series by id\n     *\n     * @function Highcharts.Chart#get\n     *\n     * @param {string} id\n     *        The id as given in the configuration options.\n     *\n     * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}\n     *         The retrieved item.\n     */\n    get: function (id) {\n\n        var ret,\n            series = this.series,\n            i;\n\n        function itemById(item) {\n            return item.id === id || (item.options && item.options.id === id);\n        }\n\n        ret =\n            // Search axes\n            find(this.axes, itemById) ||\n\n            // Search series\n            find(this.series, itemById);\n\n        // Search points\n        for (i = 0; !ret && i < series.length; i++) {\n            ret = find(series[i].points || [], itemById);\n        }\n\n        return ret;\n    },\n\n    /**\n     * Create the Axis instances based on the config options.\n     *\n     * @private\n     * @function Highcharts.Chart#getAxes\n     *\n     * @fires Highcharts.Chart#event:afterGetAxes\n     * @fires Highcharts.Chart#event:getAxes\n     */\n    getAxes: function () {\n        var chart = this,\n            options = this.options,\n            xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n            yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n            optionsArray;\n\n        fireEvent(this, 'getAxes');\n\n        // make sure the options are arrays and add some members\n        each(xAxisOptions, function (axis, i) {\n            axis.index = i;\n            axis.isX = true;\n        });\n\n        each(yAxisOptions, function (axis, i) {\n            axis.index = i;\n        });\n\n        // concatenate all axis options into one array\n        optionsArray = xAxisOptions.concat(yAxisOptions);\n\n        each(optionsArray, function (axisOptions) {\n            new Axis(chart, axisOptions); // eslint-disable-line no-new\n        });\n\n        fireEvent(this, 'afterGetAxes');\n    },\n\n\n    /**\n     * Returns an array of all currently selected points in the chart. Points\n     * can be selected by clicking or programmatically by the\n     * {@link Highcharts.Point#select}\n     * function.\n     *\n     * @sample highcharts/plotoptions/series-allowpointselect-line/\n     *         Get selected points\n     *\n     * @function Highcharts.Chart#getSelectedPoints\n     *\n     * @return {Array<Highcharts.Point>}\n     *         The currently selected points.\n     */\n    getSelectedPoints: function () {\n        var points = [];\n        each(this.series, function (serie) {\n            // series.data - for points outside of viewed range (#6445)\n            points = points.concat(grep(serie.data || [], function (point) {\n                return point.selected;\n            }));\n        });\n        return points;\n    },\n\n    /**\n     * Returns an array of all currently selected series in the chart. Series\n     * can be selected either programmatically by the\n     * {@link Highcharts.Series#select}\n     * function or by checking the checkbox next to the legend item if\n     * {@link https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox| series.showCheckBox}\n     * is true.\n     *\n     * @sample highcharts/members/chart-getselectedseries/\n     *         Get selected series\n     *\n     * @function Highcharts.Chart#getSelectedSeries\n     *\n     * @return {Array<Highcharts.Series>}\n     *         The currently selected series.\n     */\n    getSelectedSeries: function () {\n        return grep(this.series, function (serie) {\n            return serie.selected;\n        });\n    },\n\n    /**\n     * Set a new title or subtitle for the chart.\n     *\n     * @sample highcharts/members/chart-settitle/\n     *         Set title text and styles\n     *\n     * @function Highcharts.Chart#setTitle\n     *\n     * @param {Highcharts.TitleOptions} titleOptions\n     *        New title options. The title text itself is set by the\n     *        `titleOptions.text` property.\n     *\n     * @param {Highcharts.SubtitleOptions} subtitleOptions\n     *        New subtitle options. The subtitle text itself is set by the\n     *        `subtitleOptions.text` property.\n     *\n     * @param {boolean} redraw\n     *        Whether to redraw the chart or wait for a later call to\n     *        `chart.redraw()`.\n     */\n    setTitle: function (titleOptions, subtitleOptions, redraw) {\n        var chart = this,\n            options = chart.options,\n            chartTitleOptions,\n            chartSubtitleOptions;\n\n        chartTitleOptions = options.title = merge(\n            \n            options.title,\n            titleOptions\n        );\n        chartSubtitleOptions = options.subtitle = merge(\n            \n            options.subtitle,\n            subtitleOptions\n        );\n\n\n        // add title and subtitle\n\n        /**\n         * The chart title. The title has an `update` method that allows\n         * modifying the options directly or indirectly via\n         * `chart.update`.\n         *\n         * @sample highcharts/members/title-update/\n         *         Updating titles\n         *\n         * @name Highcharts.Chart#title\n         * @type {Highcharts.TitleObject}\n         */\n\n        /**\n         * The chart subtitle. The subtitle has an `update` method that\n         * allows modifying the options directly or indirectly via\n         * `chart.update`.\n         *\n         * @name Highcharts.Chart#subtitle\n         * @type {Highcharts.SubtitleObject}\n         */\n\n        each([\n            ['title', titleOptions, chartTitleOptions],\n            ['subtitle', subtitleOptions, chartSubtitleOptions]\n        ], function (arr, i) {\n            var name = arr[0],\n                title = chart[name],\n                titleOptions = arr[1],\n                chartTitleOptions = arr[2];\n\n            if (title && titleOptions) {\n                chart[name] = title = title.destroy(); // remove old\n            }\n\n            if (chartTitleOptions && !title) {\n                chart[name] = chart.renderer.text(\n                    chartTitleOptions.text,\n                    0,\n                    0,\n                    chartTitleOptions.useHTML\n                )\n                .attr({\n                    align: chartTitleOptions.align,\n                    'class': 'highcharts-' + name,\n                    zIndex: chartTitleOptions.zIndex || 4\n                })\n                .add();\n\n                // Update methods, shortcut to Chart.setTitle\n                chart[name].update = function (o) {\n                    chart.setTitle(!i && o, i && o);\n                };\n\n                \n\n            }\n        });\n        chart.layOutTitles(redraw);\n    },\n\n    /**\n     * Internal function to lay out the chart titles and cache the full offset\n     * height for use in `getMargins`. The result is stored in\n     * `this.titleOffset`.\n     *\n     * @private\n     * @function Highcharts.Chart#layOutTitles\n     *\n     * @param {boolean|undefined} [redraw=true]\n     */\n    layOutTitles: function (redraw) {\n        var titleOffset = 0,\n            requiresDirtyBox,\n            renderer = this.renderer,\n            spacingBox = this.spacingBox;\n\n        // Lay out the title and the subtitle respectively\n        each(['title', 'subtitle'], function (key) {\n            var title = this[key],\n                titleOptions = this.options[key],\n                offset = key === 'title' ? -3 :\n                    // Floating subtitle (#6574)\n                    titleOptions.verticalAlign ? 0 : titleOffset + 2,\n                titleSize;\n\n            if (title) {\n                \n                titleSize = renderer.fontMetrics(titleSize, title).b;\n                title\n                    .css({\n                        width: (titleOptions.width ||\n                            spacingBox.width + titleOptions.widthAdjust) + 'px'\n                    })\n                    .align(extend({\n                        y: offset + titleSize\n                    }, titleOptions), false, 'spacingBox');\n\n                if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                    titleOffset = Math.ceil(\n                        titleOffset +\n                        // Skip the cache for HTML (#3481)\n                        title.getBBox(titleOptions.useHTML).height\n                    );\n                }\n            }\n        }, this);\n\n        requiresDirtyBox = this.titleOffset !== titleOffset;\n        this.titleOffset = titleOffset; // used in getMargins\n\n        if (!this.isDirtyBox && requiresDirtyBox) {\n            this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;\n            // Redraw if necessary (#2719, #2744)\n            if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                this.redraw();\n            }\n        }\n    },\n\n    /**\n     * Internal function to get the chart width and height according to options\n     * and container size. Sets\n     * {@link Chart.chartWidth} and\n     * {@link Chart.chartHeight}.\n     *\n     * @function Highcharts.Chart#getChartSize\n     *\n     * @return {void}\n     */\n    getChartSize: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            widthOption = optionsChart.width,\n            heightOption = optionsChart.height,\n            renderTo = chart.renderTo;\n\n        // Get inner width and height\n        if (!defined(widthOption)) {\n            chart.containerWidth = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(renderTo, 'width');\n        }\n        if (!defined(heightOption)) {\n            chart.containerHeight = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(renderTo, 'height');\n        }\n\n        /**\n         * The current pixel width of the chart.\n         *\n         * @name Highcharts.Chart#chartWidth\n         * @type {number}\n         */\n        chart.chartWidth = Math.max( // #1393\n            0,\n            widthOption || chart.containerWidth || 600 // #1460\n        );\n        /**\n         * The current pixel height of the chart.\n         *\n         * @name Highcharts.Chart#chartHeight\n         * @type {number}\n         */\n        chart.chartHeight = Math.max(\n            0,\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength(\n                heightOption,\n                chart.chartWidth\n            ) ||\n            (chart.containerHeight > 1 ? chart.containerHeight : 400)\n        );\n    },\n\n    /**\n     * If the renderTo element has no offsetWidth, most likely one or more of\n     * its parents are hidden. Loop up the DOM tree to temporarily display the\n     * parents, then save the original display properties, and when the true\n     * size is retrieved, reset them. Used on first render and on redraws.\n     *\n     * @private\n     * @function Highcharts.Chart#temporaryDisplay\n     *\n     * @param {boolean} revert\n     *        Revert to the saved original styles.\n     */\n    temporaryDisplay: function (revert) {\n        var node = this.renderTo,\n            tempStyle;\n        if (!revert) {\n            while (node && node.style) {\n\n                // When rendering to a detached node, it needs to be temporarily\n                // attached in order to read styling and bounding boxes (#5783,\n                // #7024).\n                if (!doc.body.contains(node) && !node.parentNode) {\n                    node.hcOrigDetached = true;\n                    doc.body.appendChild(node);\n                }\n                if (\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(node, 'display', false) === 'none' ||\n                    node.hcOricDetached\n                ) {\n                    node.hcOrigStyle = {\n                        display: node.style.display,\n                        height: node.style.height,\n                        overflow: node.style.overflow\n                    };\n                    tempStyle = {\n                        display: 'block',\n                        overflow: 'hidden'\n                    };\n                    if (node !== this.renderTo) {\n                        tempStyle.height = 0;\n                    }\n\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css(node, tempStyle);\n\n                    // If it still doesn't have an offset width after setting\n                    // display to block, it probably has an !important priority\n                    // #2631, 6803\n                    if (!node.offsetWidth) {\n                        node.style.setProperty('display', 'block', 'important');\n                    }\n                }\n                node = node.parentNode;\n\n                if (node === doc.body) {\n                    break;\n                }\n            }\n        } else {\n            while (node && node.style) {\n                if (node.hcOrigStyle) {\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css(node, node.hcOrigStyle);\n                    delete node.hcOrigStyle;\n                }\n                if (node.hcOrigDetached) {\n                    doc.body.removeChild(node);\n                    node.hcOrigDetached = false;\n                }\n                node = node.parentNode;\n            }\n        }\n    },\n\n    /**\n     * Set the {@link Chart.container|chart container's} class name, in\n     * addition to `highcharts-container`.\n     *\n     * @function Highcharts.Chart#setClassName\n     *\n     * @param {string} className\n     */\n    setClassName: function (className) {\n        this.container.className = 'highcharts-container ' + (className || '');\n    },\n\n    /**\n     * Get the containing element, determine the size and create the inner\n     * container div to hold the chart.\n     *\n     * @private\n     * @function Highcharts.Chart#afterGetContainer\n     *\n     * @fires Highcharts.Chart#event:afterGetContainer\n     */\n    getContainer: function () {\n        var chart = this,\n            container,\n            options = chart.options,\n            optionsChart = options.chart,\n            chartWidth,\n            chartHeight,\n            renderTo = chart.renderTo,\n            indexAttrName = 'data-highcharts-chart',\n            oldChartIndex,\n            Ren,\n            containerId = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey(),\n            containerStyle,\n            key;\n\n        if (!renderTo) {\n            chart.renderTo = renderTo = optionsChart.renderTo;\n        }\n\n        if (isString(renderTo)) {\n            chart.renderTo = renderTo = doc.getElementById(renderTo);\n        }\n\n        // Display an error if the renderTo is wrong\n        if (!renderTo) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(13, true);\n        }\n\n        // If the container already holds a chart, destroy it. The check for\n        // hasRendered is there because web pages that are saved to disk from\n        // the browser, will preserve the data-highcharts-chart attribute and\n        // the SVG contents, but not an interactive chart. So in this case,\n        // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n        oldChartIndex = pInt(attr(renderTo, indexAttrName));\n        if (\n            isNumber(oldChartIndex) &&\n            charts[oldChartIndex] &&\n            charts[oldChartIndex].hasRendered\n        ) {\n            charts[oldChartIndex].destroy();\n        }\n\n        // Make a reference to the chart from the div\n        attr(renderTo, indexAttrName, chart.index);\n\n        // remove previous chart\n        renderTo.innerHTML = '';\n\n        // If the container doesn't have an offsetWidth, it has or is a child of\n        // a node that has display:none. We need to temporarily move it out to a\n        // visible state to determine the size, else the legend and tooltips\n        // won't render properly. The skipClone option is used in sparklines as\n        // a micro optimization, saving about 1-2 ms each chart.\n        if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n            chart.temporaryDisplay();\n        }\n\n        // get the width and height\n        chart.getChartSize();\n        chartWidth = chart.chartWidth;\n        chartHeight = chart.chartHeight;\n\n        // Create the inner container\n        \n\n        /**\n         * The containing HTML element of the chart. The container is\n         * dynamically inserted into the element given as the `renderTo`\n         * parameter in the {@link Highcharts#chart} constructor.\n         *\n         * @name Highcharts.Chart#container\n         * @type {Highcharts.HTMLDOMElement}\n         */\n        container = createElement(\n            'div',\n            {\n                id: containerId\n            },\n            containerStyle,\n            renderTo\n        );\n        chart.container = container;\n\n        // cache the cursor (#1650)\n        chart._cursor = container.style.cursor;\n\n        // Initialize the renderer\n        Ren = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][optionsChart.renderer] || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer;\n\n        /**\n         * The renderer instance of the chart. Each chart instance has only one\n         * associated renderer.\n         *\n         * @name Highcharts.Chart#renderer\n         * @type {Highcharts.SVGRenderer}\n         */\n        chart.renderer = new Ren(\n            container,\n            chartWidth,\n            chartHeight,\n            null,\n            optionsChart.forExport,\n            options.exporting && options.exporting.allowHTML\n        );\n\n\n        chart.setClassName(optionsChart.className);\n        \n        // Initialize definitions\n        for (key in options.defs) {\n            this.renderer.definition(options.defs[key]);\n        }\n        \n\n        // Add a reference to the charts index\n        chart.renderer.chartIndex = chart.index;\n\n        fireEvent(this, 'afterGetContainer');\n    },\n\n    /**\n     * Calculate margins by rendering axis labels in a preliminary position.\n     * Title, subtitle and legend have already been rendered at this stage, but\n     * will be moved into their final positions.\n     *\n     * @private\n     * @function Highcharts.Chart#getMargins\n     *\n     * @param  {boolean} skipAxes\n     *\n     * @fires Highcharts.Chart#event:getMargins\n     */\n    getMargins: function (skipAxes) {\n        var chart = this,\n            spacing = chart.spacing,\n            margin = chart.margin,\n            titleOffset = chart.titleOffset;\n\n        chart.resetMargins();\n\n        // Adjust for title and subtitle\n        if (titleOffset && !defined(margin[0])) {\n            chart.plotTop = Math.max(\n                chart.plotTop,\n                titleOffset + chart.options.title.margin + spacing[0]\n            );\n        }\n\n        // Adjust for legend\n        if (chart.legend && chart.legend.display) {\n            chart.legend.adjustMargins(margin, spacing);\n        }\n\n        fireEvent(this, 'getMargins');\n\n        if (!skipAxes) {\n            this.getAxisMargins();\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Chart#getAxisMargins\n     */\n    getAxisMargins: function () {\n\n        var chart = this,\n            // [top, right, bottom, left]\n            axisOffset = chart.axisOffset = [0, 0, 0, 0],\n            margin = chart.margin;\n\n        // pre-render axes to get labels offset width\n        if (chart.hasCartesianSeries) {\n            each(chart.axes, function (axis) {\n                if (axis.visible) {\n                    axis.getOffset();\n                }\n            });\n        }\n\n        // Add the axis offsets\n        each(marginNames, function (m, side) {\n            if (!defined(margin[side])) {\n                chart[m] += axisOffset[side];\n            }\n        });\n\n        chart.setChartSize();\n\n    },\n\n    /**\n     * Reflows the chart to its container. By default, the chart reflows\n     * automatically to its container following a `window.resize` event, as per\n     * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}\n     * option. However, there are no reliable events for div resize, so if the\n     * container is resized without a window resize event, this must be called\n     * explicitly.\n     *\n     * @sample highcharts/members/chart-reflow/\n     *         Resize div and reflow\n     * @sample highcharts/chart/events-container/\n     *         Pop up and reflow\n     *\n     * @function Highcharts.Chart#reflow\n     *\n     * @param  {global.Event} e\n     *         Event arguments. Used primarily when the function is called\n     *         internally as a response to window resize.\n     */\n    reflow: function (e) {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            renderTo = chart.renderTo,\n            hasUserSize = (\n                defined(optionsChart.width) &&\n                defined(optionsChart.height)\n            ),\n            width = optionsChart.width || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(renderTo, 'width'),\n            height = optionsChart.height || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(renderTo, 'height'),\n            target = e ? e.target : win;\n\n        // Width and height checks for display:none. Target is doc in IE8 and\n        // Opera, win in Firefox, Chrome and IE9.\n        if (\n            !hasUserSize &&\n            !chart.isPrinting &&\n            width &&\n            height &&\n            (target === win || target === doc)\n        ) {\n            if (\n                width !== chart.containerWidth ||\n                height !== chart.containerHeight\n            ) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(chart.reflowTimeout);\n                // When called from window.resize, e is set, else it's called\n                // directly (#2224)\n                chart.reflowTimeout = syncTimeout(function () {\n                    // Set size, it may have been destroyed in the meantime\n                    // (#1257)\n                    if (chart.container) {\n                        chart.setSize(undefined, undefined, false);\n                    }\n                }, e ? 100 : 0);\n            }\n            chart.containerWidth = width;\n            chart.containerHeight = height;\n        }\n    },\n\n    /**\n     * Toggle the event handlers necessary for auto resizing, depending on the\n     * `chart.reflow` option.\n     *\n     * @private\n     * @function Highcharts.Chart#setReflow\n     *\n     * @param  {boolean} reflow\n     */\n    setReflow: function (reflow) {\n\n        var chart = this;\n\n        if (reflow !== false && !this.unbindReflow) {\n            this.unbindReflow = addEvent(win, 'resize', function (e) {\n                chart.reflow(e);\n            });\n            addEvent(this, 'destroy', this.unbindReflow);\n\n        } else if (reflow === false && this.unbindReflow) {\n\n            // Unbind and unset\n            this.unbindReflow = this.unbindReflow();\n        }\n\n        // The following will add listeners to re-fit the chart before and after\n        // printing (#2284). However it only works in WebKit. Should have worked\n        // in Firefox, but not supported in IE.\n        /*\n        if (win.matchMedia) {\n            win.matchMedia('print').addListener(function reflow() {\n                chart.reflow();\n            });\n        }\n        //*/\n    },\n\n    /**\n     * Resize the chart to a given width and height. In order to set the width\n     * only, the height argument may be skipped. To set the height only, pass\n     * `undefined` for the width.\n     *\n     * @sample highcharts/members/chart-setsize-button/\n     *         Test resizing from buttons\n     * @sample highcharts/members/chart-setsize-jquery-resizable/\n     *         Add a jQuery UI resizable\n     * @sample stock/members/chart-setsize/\n     *         Highstock with UI resizable\n     *\n     * @function Highcharts.Chart#setSize\n     *\n     * @param  {number|null|undefined} [width]\n     *         The new pixel width of the chart. Since v4.2.6, the argument can\n     *         be `undefined` in order to preserve the current value (when\n     *         setting height only), or `null` to adapt to the width of the\n     *         containing element.\n     *\n     * @param  {number|null|undefined} [height]\n     *         The new pixel height of the chart. Since v4.2.6, the argument can\n     *         be `undefined` in order to preserve the current value, or `null`\n     *         in order to adapt to the height of the containing element.\n     *\n     * @param  {Highcharts.AnimationOptionsObject|undefined} [animation=true]\n     *         Whether and how to apply animation.\n     *\n     * @fires Highcharts.Chart#event:endResize\n     * @fires Highcharts.Chart#event:resize\n     */\n    setSize: function (width, height, animation) {\n        var chart = this,\n            renderer = chart.renderer,\n            globalAnimation;\n\n        // Handle the isResizing counter\n        chart.isResizing += 1;\n\n        // set the animation for the current process\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setAnimation(animation, chart);\n\n        chart.oldChartHeight = chart.chartHeight;\n        chart.oldChartWidth = chart.chartWidth;\n        if (width !== undefined) {\n            chart.options.chart.width = width;\n        }\n        if (height !== undefined) {\n            chart.options.chart.height = height;\n        }\n        chart.getChartSize();\n\n        // Resize the container with the global animation applied if enabled\n        // (#2503)\n        \n\n        chart.setChartSize(true);\n        renderer.setSize(chart.chartWidth, chart.chartHeight, animation);\n\n        // handle axes\n        each(chart.axes, function (axis) {\n            axis.isDirty = true;\n            axis.setScale();\n        });\n\n        chart.isDirtyLegend = true; // force legend redraw\n        chart.isDirtyBox = true; // force redraw of plot and chart border\n\n        chart.layOutTitles(); // #2857\n        chart.getMargins();\n\n        chart.redraw(animation);\n\n\n        chart.oldChartHeight = null;\n        fireEvent(chart, 'resize');\n\n        // Fire endResize and set isResizing back. If animation is disabled,\n        // fire without delay\n        syncTimeout(function () {\n            if (chart) {\n                fireEvent(chart, 'endResize', null, function () {\n                    chart.isResizing -= 1;\n                });\n            }\n        }, animObject(globalAnimation).duration);\n    },\n\n    /**\n     * Set the public chart properties. This is done before and after the\n     * pre-render to determine margin sizes.\n     *\n     * @private\n     * @function Highcharts.Chart#setChartSize\n     *\n     * @param  {boolean} skipAxes\n     *\n     * @fires Highcharts.Chart#event:afterSetChartSize\n     */\n    setChartSize: function (skipAxes) {\n        var chart = this,\n            inverted = chart.inverted,\n            renderer = chart.renderer,\n            chartWidth = chart.chartWidth,\n            chartHeight = chart.chartHeight,\n            optionsChart = chart.options.chart,\n            spacing = chart.spacing,\n            clipOffset = chart.clipOffset,\n            clipX,\n            clipY,\n            plotLeft,\n            plotTop,\n            plotWidth,\n            plotHeight,\n            plotBorderWidth;\n\n        /**\n         * The current left position of the plot area in pixels.\n         *\n         * @name Highcharts.Chart#plotLeft\n         * @type {number}\n         */\n        chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n\n        /**\n         * The current top position of the plot area in pixels.\n         *\n         * @name Highcharts.Chart#plotTop\n         * @type {number}\n         */\n        chart.plotTop = plotTop = Math.round(chart.plotTop);\n\n        /**\n         * The current width of the plot area in pixels.\n         *\n         * @name Highcharts.Chart#plotWidth\n         * @type {number}\n         */\n        chart.plotWidth = plotWidth = Math.max(\n            0,\n            Math.round(chartWidth - plotLeft - chart.marginRight)\n        );\n\n        /**\n         * The current height of the plot area in pixels.\n         *\n         * @name Highcharts.Chart#plotHeight\n         * @type {number}\n         */\n        chart.plotHeight = plotHeight = Math.max(\n            0,\n            Math.round(chartHeight - plotTop - chart.marginBottom)\n        );\n\n        chart.plotSizeX = inverted ? plotHeight : plotWidth;\n        chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n        chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n        // Set boxes used for alignment\n        chart.spacingBox = renderer.spacingBox = {\n            x: spacing[3],\n            y: spacing[0],\n            width: chartWidth - spacing[3] - spacing[1],\n            height: chartHeight - spacing[0] - spacing[2]\n        };\n        chart.plotBox = renderer.plotBox = {\n            x: plotLeft,\n            y: plotTop,\n            width: plotWidth,\n            height: plotHeight\n        };\n\n        plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n        clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);\n        clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);\n        chart.clipBox = {\n            x: clipX,\n            y: clipY,\n            width: Math.floor(\n                chart.plotSizeX -\n                Math.max(plotBorderWidth, clipOffset[1]) / 2 -\n                clipX\n            ),\n            height: Math.max(\n                0,\n                Math.floor(\n                    chart.plotSizeY -\n                    Math.max(plotBorderWidth, clipOffset[2]) / 2 -\n                    clipY\n                )\n            )\n        };\n\n        if (!skipAxes) {\n            each(chart.axes, function (axis) {\n                axis.setAxisSize();\n                axis.setAxisTranslation();\n            });\n        }\n\n        fireEvent(chart, 'afterSetChartSize', { skipAxes: skipAxes });\n    },\n\n    /**\n     * Initial margins before auto size margins are applied.\n     *\n     * @private\n     * @function Highcharts.Chart#resetMargins\n     */\n    resetMargins: function () {\n        var chart = this,\n            chartOptions = chart.options.chart;\n\n        // Create margin and spacing array\n        each(['margin', 'spacing'], function splashArrays(target) {\n            var value = chartOptions[target],\n                values = isObject(value) ? value : [value, value, value, value];\n\n            each(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {\n                chart[target][side] = pick(\n                    chartOptions[target + sideName],\n                    values[side]\n                );\n            });\n        });\n\n        // Set margin names like chart.plotTop, chart.plotLeft,\n        // chart.marginRight, chart.marginBottom.\n        each(marginNames, function (m, side) {\n            chart[m] = pick(chart.margin[side], chart.spacing[side]);\n        });\n        chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n        chart.clipOffset = [0, 0, 0, 0];\n    },\n\n    /**\n     * Internal function to draw or redraw the borders and backgrounds for chart\n     * and plot area.\n     *\n     * @private\n     * @function Highcharts.Chart#drawChartBox\n     *\n     * @fires Highcharts.Chart#event:afterDrawChartBox\n     */\n    drawChartBox: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            renderer = chart.renderer,\n            chartWidth = chart.chartWidth,\n            chartHeight = chart.chartHeight,\n            chartBackground = chart.chartBackground,\n            plotBackground = chart.plotBackground,\n            plotBorder = chart.plotBorder,\n            chartBorderWidth,\n            \n            mgn,\n            bgAttr,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop,\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            plotBox = chart.plotBox,\n            clipRect = chart.clipRect,\n            clipBox = chart.clipBox,\n            verb = 'animate';\n\n        // Chart area\n        if (!chartBackground) {\n            chart.chartBackground = chartBackground = renderer.rect()\n                .addClass('highcharts-background')\n                .add();\n            verb = 'attr';\n        }\n\n        \n        chartBorderWidth = mgn = chartBackground.strokeWidth();\n        \n        chartBackground[verb]({\n            x: mgn / 2,\n            y: mgn / 2,\n            width: chartWidth - mgn - chartBorderWidth % 2,\n            height: chartHeight - mgn - chartBorderWidth % 2,\n            r: optionsChart.borderRadius\n        });\n\n        // Plot background\n        verb = 'animate';\n        if (!plotBackground) {\n            verb = 'attr';\n            chart.plotBackground = plotBackground = renderer.rect()\n                .addClass('highcharts-plot-background')\n                .add();\n        }\n        plotBackground[verb](plotBox);\n\n        \n\n        // Plot clip\n        if (!clipRect) {\n            chart.clipRect = renderer.clipRect(clipBox);\n        } else {\n            clipRect.animate({\n                width: clipBox.width,\n                height: clipBox.height\n            });\n        }\n\n        // Plot area border\n        verb = 'animate';\n        if (!plotBorder) {\n            verb = 'attr';\n            chart.plotBorder = plotBorder = renderer.rect()\n                .addClass('highcharts-plot-border')\n                .attr({\n                    zIndex: 1 // Above the grid\n                })\n                .add();\n        }\n\n        \n\n        plotBorder[verb](plotBorder.crisp({\n            x: plotLeft,\n            y: plotTop,\n            width: plotWidth,\n            height: plotHeight\n        }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;\n\n        // reset\n        chart.isDirtyBox = false;\n\n        fireEvent(this, 'afterDrawChartBox');\n    },\n\n    /**\n     * Detect whether a certain chart property is needed based on inspecting its\n     * options and series. This mainly applies to the chart.inverted property,\n     * and in extensions to the chart.angular and chart.polar properties.\n     *\n     * @private\n     * @function Highcharts.Chart#propFromSeries\n     */\n    propFromSeries: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            klass,\n            seriesOptions = chart.options.series,\n            i,\n            value;\n\n\n        each(['inverted', 'angular', 'polar'], function (key) {\n\n            // The default series type's class\n            klass = seriesTypes[optionsChart.type ||\n                optionsChart.defaultSeriesType];\n\n            // Get the value from available chart-wide properties\n            value =\n                optionsChart[key] || // It is set in the options\n                (klass && klass.prototype[key]); // The default series class\n                    // requires it\n\n            // 4. Check if any the chart's series require it\n            i = seriesOptions && seriesOptions.length;\n            while (!value && i--) {\n                klass = seriesTypes[seriesOptions[i].type];\n                if (klass && klass.prototype[key]) {\n                    value = true;\n                }\n            }\n\n            // Set the chart property\n            chart[key] = value;\n        });\n\n    },\n\n    /**\n     * Internal function to link two or more series together, based on the\n     * `linkedTo` option. This is done from `Chart.render`, and after\n     * `Chart.addSeries` and `Series.remove`.\n     *\n     * @private\n     * @function Highcharts.Chart#linkSeries\n     *\n     * @fires Highcharts.Chart#event:afterLinkSeries\n     */\n    linkSeries: function () {\n        var chart = this,\n            chartSeries = chart.series;\n\n        // Reset links\n        each(chartSeries, function (series) {\n            series.linkedSeries.length = 0;\n        });\n\n        // Apply new links\n        each(chartSeries, function (series) {\n            var linkedTo = series.options.linkedTo;\n            if (isString(linkedTo)) {\n                if (linkedTo === ':previous') {\n                    linkedTo = chart.series[series.index - 1];\n                } else {\n                    linkedTo = chart.get(linkedTo);\n                }\n                // #3341 avoid mutual linking\n                if (linkedTo && linkedTo.linkedParent !== series) {\n                    linkedTo.linkedSeries.push(series);\n                    series.linkedParent = linkedTo;\n                    series.visible = pick(\n                        series.options.visible,\n                        linkedTo.options.visible,\n                        series.visible\n                    ); // #3879\n                }\n            }\n        });\n\n        fireEvent(this, 'afterLinkSeries');\n    },\n\n    /**\n     * Render series for the chart.\n     *\n     * @private\n     * @function Highcharts.Chart#renderSeries\n     */\n    renderSeries: function () {\n        each(this.series, function (serie) {\n            serie.translate();\n            serie.render();\n        });\n    },\n\n    /**\n     * Render labels for the chart.\n     *\n     * @private\n     * @function Highcharts.Chart#renderLabels\n     */\n    renderLabels: function () {\n        var chart = this,\n            labels = chart.options.labels;\n        if (labels.items) {\n            each(labels.items, function (label) {\n                var style = extend(labels.style, label.style),\n                    x = pInt(style.left) + chart.plotLeft,\n                    y = pInt(style.top) + chart.plotTop + 12;\n\n                // delete to prevent rewriting in IE\n                delete style.left;\n                delete style.top;\n\n                chart.renderer.text(\n                    label.html,\n                    x,\n                    y\n                )\n                .attr({ zIndex: 2 })\n                .css(style)\n                .add();\n\n            });\n        }\n    },\n\n    /**\n     * Render all graphics for the chart. Runs internally on initialization.\n     *\n     * @private\n     * @function Highcharts.Chart#render\n     */\n    render: function () {\n        var chart = this,\n            axes = chart.axes,\n            renderer = chart.renderer,\n            options = chart.options,\n            tempWidth,\n            tempHeight,\n            redoHorizontal,\n            redoVertical;\n\n        // Title\n        chart.setTitle();\n\n        /**\n         * The overview of the chart's series.\n         *\n         * @name Highcharts.Chart#legend\n         * @type {Highcharts.Legend}\n         */\n        chart.legend = new Legend(chart, options.legend);\n\n        // Get stacks\n        if (chart.getStacks) {\n            chart.getStacks();\n        }\n\n        // Get chart margins\n        chart.getMargins(true);\n        chart.setChartSize();\n\n        // Record preliminary dimensions for later comparison\n        tempWidth = chart.plotWidth;\n        // 21 is the most common correction for X axis labels\n        // use Math.max to prevent negative plotHeight\n        tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0);\n\n        // Get margins by pre-rendering axes\n        each(axes, function (axis) {\n            axis.setScale();\n        });\n        chart.getAxisMargins();\n\n        // If the plot area size has changed significantly, calculate tick\n        // positions again\n        redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n        // Height is more sensitive, use lower threshold\n        redoVertical = tempHeight / chart.plotHeight > 1.05;\n\n        if (redoHorizontal || redoVertical) {\n\n            each(axes, function (axis) {\n                if (\n                    (axis.horiz && redoHorizontal) ||\n                    (!axis.horiz && redoVertical)\n                ) {\n                    // update to reflect the new margins\n                    axis.setTickInterval(true);\n                }\n            });\n            chart.getMargins(); // second pass to check for new labels\n        }\n\n        // Draw the borders and backgrounds\n        chart.drawChartBox();\n\n\n        // Axes\n        if (chart.hasCartesianSeries) {\n            each(axes, function (axis) {\n                if (axis.visible) {\n                    axis.render();\n                }\n            });\n        }\n\n        // The series\n        if (!chart.seriesGroup) {\n            chart.seriesGroup = renderer.g('series-group')\n                .attr({ zIndex: 3 })\n                .add();\n        }\n        chart.renderSeries();\n\n        // Labels\n        chart.renderLabels();\n\n        // Credits\n        chart.addCredits();\n\n        // Handle responsiveness\n        if (chart.setResponsive) {\n            chart.setResponsive();\n        }\n\n        // Set flag\n        chart.hasRendered = true;\n\n    },\n\n    /**\n     * Set a new credits label for the chart.\n     *\n     * @sample highcharts/credits/credits-update/\n     *         Add and update credits\n     *\n     * @function Highcharts.Chart#addCredits\n     *\n     * @param  {Highcharts.CreditsOptions} options\n     *         A configuration object for the new credits.\n     */\n    addCredits: function (credits) {\n        var chart = this;\n\n        credits = merge(true, this.options.credits, credits);\n        if (credits.enabled && !this.credits) {\n\n            /**\n             * The chart's credits label. The label has an `update` method that\n             * allows setting new options as per the\n             * {@link https://api.highcharts.com/highcharts/credits|credits options set}.\n             *\n             * @name Highcharts.Chart#credits\n             * @type {Highcharts.SVGElement}\n             */\n            this.credits = this.renderer.text(\n                credits.text + (this.mapCredits || ''),\n                0,\n                0\n            )\n            .addClass('highcharts-credits')\n            .on('click', function () {\n                if (credits.href) {\n                    win.location.href = credits.href;\n                }\n            })\n            .attr({\n                align: credits.position.align,\n                zIndex: 8\n            })\n            \n            .add()\n            .align(credits.position);\n\n            // Dynamically update\n            this.credits.update = function (options) {\n                chart.credits = chart.credits.destroy();\n                chart.addCredits(options);\n            };\n        }\n    },\n\n    /**\n     * Remove the chart and purge memory. This method is called internally\n     * before adding a second chart into the same container, as well as on\n     * window unload to prevent leaks.\n     *\n     * @sample highcharts/members/chart-destroy/\n     *         Destroy the chart from a button\n     * @sample stock/members/chart-destroy/\n     *         Destroy with Highstock\n     *\n     * @function Highcharts.Chart#destroy\n     *\n     * @fires Highcharts.Chart#event:destroy\n     */\n    destroy: function () {\n        var chart = this,\n            axes = chart.axes,\n            series = chart.series,\n            container = chart.container,\n            i,\n            parentNode = container && container.parentNode;\n\n        // fire the chart.destoy event\n        fireEvent(chart, 'destroy');\n\n        // Delete the chart from charts lookup array\n        if (chart.renderer.forExport) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase(charts, chart); // #6569\n        } else {\n            charts[chart.index] = undefined;\n        }\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chartCount--;\n        chart.renderTo.removeAttribute('data-highcharts-chart');\n\n        // remove events\n        removeEvent(chart);\n\n        // ==== Destroy collections:\n        // Destroy axes\n        i = axes.length;\n        while (i--) {\n            axes[i] = axes[i].destroy();\n        }\n\n        // Destroy scroller & scroller series before destroying base series\n        if (this.scroller && this.scroller.destroy) {\n            this.scroller.destroy();\n        }\n\n        // Destroy each series\n        i = series.length;\n        while (i--) {\n            series[i] = series[i].destroy();\n        }\n\n        // ==== Destroy chart properties:\n        each([\n            'title', 'subtitle', 'chartBackground', 'plotBackground',\n            'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',\n            'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',\n            'renderer'\n        ], function (name) {\n            var prop = chart[name];\n\n            if (prop && prop.destroy) {\n                chart[name] = prop.destroy();\n            }\n        });\n\n        // Remove container and all SVG, check container as it can break in IE\n        // when destroyed before finished loading\n        if (container) {\n            container.innerHTML = '';\n            removeEvent(container);\n            if (parentNode) {\n                discardElement(container);\n            }\n\n        }\n\n        // clean it all up\n        objectEach(chart, function (val, key) {\n            delete chart[key];\n        });\n\n    },\n\n    /**\n     * Prepare for first rendering after all data are loaded.\n     *\n     * @private\n     * @function Highcharts.Chart#firstRender\n     *\n     * @fires Highcharts.Chart#event:beforeRender\n     */\n    firstRender: function () {\n        var chart = this,\n            options = chart.options;\n\n        // Hook for oldIE to check whether the chart is ready to render\n        if (chart.isReadyToRender && !chart.isReadyToRender()) {\n            return;\n        }\n\n        // Create the container\n        chart.getContainer();\n\n        chart.resetMargins();\n        chart.setChartSize();\n\n        // Set the common chart properties (mainly invert) from the given series\n        chart.propFromSeries();\n\n        // get axes\n        chart.getAxes();\n\n        // Initialize the series\n        each(options.series || [], function (serieOptions) {\n            chart.initSeries(serieOptions);\n        });\n\n        chart.linkSeries();\n\n        // Run an event after axes and series are initialized, but before\n        // render. At this stage, the series data is indexed and cached in the\n        // xData and yData arrays, so we can access those before rendering. Used\n        // in Highstock.\n        fireEvent(chart, 'beforeRender');\n\n        // depends on inverted and on margins being set\n        if (Pointer) {\n\n            /**\n             * The Pointer that keeps track of mouse and touch interaction.\n             *\n             * @memberof Highcharts.Chart\n             * @name pointer\n             * @type {Highcharts.Pointer}\n             * @instance\n             */\n            chart.pointer = new Pointer(chart, options);\n        }\n\n        chart.render();\n\n        // Fire the load event if there are no external images\n        if (!chart.renderer.imgCount && chart.onload) {\n            chart.onload();\n        }\n\n        // If the chart was rendered outside the top container, put it back in\n        // (#3679)\n        chart.temporaryDisplay(true);\n\n    },\n\n    /**\n     * Internal function that runs on chart load, async if any images are loaded\n     * in the chart. Runs the callbacks and triggers the `load` and `render`\n     * events.\n     *\n     * @private\n     * @function Highcharts.Chart#onload\n     *\n     * @fires Highcharts.Chart#event:load\n     * @fires Highcharts.Chart#event:render\n     */\n    onload: function () {\n\n        // Run callbacks\n        each([this.callback].concat(this.callbacks), function (fn) {\n            // Chart destroyed in its own callback (#3600)\n            if (fn && this.index !== undefined) {\n                fn.apply(this, [this]);\n            }\n        }, this);\n\n        fireEvent(this, 'load');\n        fireEvent(this, 'render');\n\n\n        // Set up auto resize, check for not destroyed (#6068)\n        if (defined(this.index)) {\n            this.setReflow(this.options.chart.reflow);\n        }\n\n        // Don't run again\n        this.onload = null;\n    }\n\n}); // end Chart\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Chart.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Color.js":
/*!**************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Color.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * A valid color to be parsed and handled by Highcharts. Highcharts internally\n * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and\n * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the\n * browsers and displayed correctly, but Highcharts is not able to process them\n * and apply concepts like opacity and brightening.\n *\n * @typedef {string} Highcharts.ColorString\n */\n\n\n\n\nvar each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pInt = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt;\n\n/**\n * Handle color operations. The object methods are chainable.\n *\n * @ignore\n * @class Highcharts.Color\n *\n * @param {Highcharts.ColorString} input\n *        The input color in either rbga or hex format\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color = function (input) {\n    // Backwards compatibility, allow instanciation without new\n    if (!(this instanceof _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color)) {\n        return new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color(input);\n    }\n    // Initialize\n    this.init(input);\n};\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color.prototype = {\n\n    // Collection of parsers. This can be extended from the outside by pushing\n    // parsers to Highcharts.Color.prototype.parsers.\n    parsers: [{\n        // RGBA color\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/, // eslint-disable-line security/detect-unsafe-regex\n        parse: function (result) {\n            return [\n                pInt(result[1]),\n                pInt(result[2]),\n                pInt(result[3]),\n                parseFloat(result[4], 10)\n            ];\n        }\n    }, {\n        // RGB color\n        regex:\n            /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (result) {\n            return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n        }\n    }],\n\n    // Collection of named colors. Can be extended from the outside by adding\n    // colors to Highcharts.Color.prototype.names.\n    names: {\n        white: '#ffffff',\n        black: '#000000'\n    },\n\n    /**\n     * Parse the input color to rgba array\n     *\n     * @private\n     * @function Highcharts.Color#init\n     *\n     * @param  {Highcharts.ColorString} input\n     *         The input color in either rbga or hex format\n     *\n     * @return {void}\n     */\n    init: function (input) {\n        var result,\n            rgba,\n            i,\n            parser,\n            len;\n\n        this.input = input = this.names[\n                                input && input.toLowerCase ?\n                                    input.toLowerCase() :\n                                    ''\n                            ] || input;\n\n        // Gradients\n        if (input && input.stops) {\n            this.stops = map(input.stops, function (stop) {\n                return new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color(stop[1]);\n            });\n\n        // Solid colors\n        } else {\n\n            // Bitmasking as input[0] is not working for legacy IE.\n            if (input && input.charAt && input.charAt() === '#') {\n\n                len = input.length;\n                input = parseInt(input.substr(1), 16);\n\n                // Handle long-form, e.g. #AABBCC\n                if (len === 7) {\n\n                    rgba = [\n                        (input & 0xFF0000) >> 16,\n                        (input & 0xFF00) >> 8,\n                        (input & 0xFF),\n                        1\n                    ];\n\n                // Handle short-form, e.g. #ABC\n                // In short form, the value is assumed to be the same\n                // for both nibbles for each component. e.g. #ABC = #AABBCC\n                } else if (len === 4) {\n\n                    rgba = [\n                        ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,\n                        ((input & 0xF0) >> 4) | (input & 0xF0),\n                        ((input & 0xF) << 4) | (input & 0xF),\n                        1\n                    ];\n                }\n            }\n\n            // Otherwise, check regex parsers\n            if (!rgba) {\n                i = this.parsers.length;\n                while (i-- && !rgba) {\n                    parser = this.parsers[i];\n                    result = parser.regex.exec(input);\n                    if (result) {\n                        rgba = parser.parse(result);\n                    }\n                }\n            }\n        }\n        this.rgba = rgba || [];\n    },\n\n    /**\n     * Return the color in the specified format\n     *\n     * @function Highcharts.Color#get\n     *\n     * @param  {string} format\n     *         Possible values are 'a', 'rgb', undefined\n     *\n     * @return {Highcharts.ColorString}\n     *         This color as a string.\n     */\n    get: function (format) {\n        var input = this.input,\n            rgba = this.rgba,\n            ret;\n\n        if (this.stops) {\n            ret = merge(input);\n            ret.stops = [].concat(ret.stops);\n            each(this.stops, function (stop, i) {\n                ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n            });\n\n        // it's NaN if gradient colors on a column chart\n        } else if (rgba && isNumber(rgba[0])) {\n            if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n            } else if (format === 'a') {\n                ret = rgba[3];\n            } else {\n                ret = 'rgba(' + rgba.join(',') + ')';\n            }\n        } else {\n            ret = input;\n        }\n        return ret;\n    },\n\n    /**\n     * Brighten the color instance.\n     *\n     * @function Highcharts.Color#brighten\n     *\n     * @param  {number} alpha\n     *         The alpha value.\n     *\n     * @return {Highcharts.ColorString}\n     *         This color with modifications.\n     */\n    brighten: function (alpha) {\n        var i,\n            rgba = this.rgba;\n\n        if (this.stops) {\n            each(this.stops, function (stop) {\n                stop.brighten(alpha);\n            });\n\n        } else if (isNumber(alpha) && alpha !== 0) {\n            for (i = 0; i < 3; i++) {\n                rgba[i] += pInt(alpha * 255);\n\n                if (rgba[i] < 0) {\n                    rgba[i] = 0;\n                }\n                if (rgba[i] > 255) {\n                    rgba[i] = 255;\n                }\n            }\n        }\n        return this;\n    },\n\n    /**\n     * Set the color's opacity to a given alpha value.\n     *\n     * @function Highcharts.Color#setOpacity\n     *\n     * @param  {number} alpha\n     *         Opacity between 0 and 1.\n     *\n     * @return {Highcharts.ColorString}\n     *         Color with modifications.\n     */\n    setOpacity: function (alpha) {\n        this.rgba[3] = alpha;\n        return this;\n    },\n\n    /**\n     * Return an intermediate color between two colors.\n     *\n     * @function Highcharts.Color#tweenTo\n     *\n     * @param  {Highcharts.Color} to\n     *         The color object to tween to.\n     *\n     * @param  {number} pos\n     *         The intermediate position, where 0 is the from color (current\n     *         color item), and 1 is the `to` color.\n     *\n     * @return {Highcharts.ColorString}\n     *         The intermediate color in rgba notation.\n     */\n    tweenTo: function (to, pos) {\n        // Check for has alpha, because rgba colors perform worse due to lack of\n        // support in WebKit.\n        var fromRgba = this.rgba,\n            toRgba = to.rgba,\n            hasAlpha,\n            ret;\n\n        // Unsupported color, return to-color (#3920, #7034)\n        if (!toRgba.length || !fromRgba || !fromRgba.length) {\n            ret = to.input || 'none';\n\n        // Interpolate\n        } else {\n            hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);\n            ret = (hasAlpha ? 'rgba(' : 'rgb(') +\n                Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) +\n                ',' +\n                Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) +\n                ',' +\n                Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) +\n                (\n                    hasAlpha ?\n                        (\n                            ',' +\n                            (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))\n                        ) :\n                        ''\n                ) +\n                ')';\n        }\n        return ret;\n    }\n};\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color = function (input) {\n    return new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Color(input);\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Color.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar animObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    LegendSymbolMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    svg = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg;\n/**\n * The column series type.\n *\n * @constructor seriesTypes.column\n * @augments    Series\n */\n\n/**\n * Column series display one column per value along an X axis.\n *\n * @sample       {highcharts} highcharts/demo/column-basic/ Column chart\n * @sample       {highstock} stock/demo/column/ Column chart\n *\n * @extends      {plotOptions.line}\n * @product      highcharts highstock\n * @excluding    connectNulls,dashStyle,gapSize,gapUnit,linecap,lineWidth,\n *               marker,connectEnds,step\n * @optionparent plotOptions.column\n */\nseriesType('column', 'line', {\n\n    /**\n     * The corner radius of the border surrounding each column or bar.\n     *\n     * @type    {Number}\n     * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n     *          Rounded columns\n     * @default 0\n     * @product highcharts highstock\n     */\n    borderRadius: 0,\n\n    /**\n     * When using automatic point colors pulled from the global [colors](colors)\n     * or series-specific [plotOptions.column.colors](series.colors)\n     * collections, this option determines whether the chart should receive\n     * one color per series or one color per point.\n     *\n     * In styled mode, the `colors` or `series.colors` arrays are not supported,\n     * and instead this option gives the points individual color class names on\n     * the form `highcharts-color-{n}`.\n     *\n     * @type      {Boolean}\n     * @see       [series colors](#plotOptions.column.colors)\n     * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-false/\n     *            False by default\n     * @sample    {highcharts} highcharts/plotoptions/column-colorbypoint-true/\n     *            True\n     * @default   false\n     * @since     2.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.column.colorByPoint\n     */\n\n    /**\n     * A series specific or series type specific color set to apply instead\n     * of the global [colors](#colors) when [colorByPoint](\n     * #plotOptions.column.colorByPoint) is true.\n     *\n     * @type      {Array<Color>}\n     * @since     3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.column.colors\n     */\n\n    /**\n     * When true, each column edge is rounded to its nearest pixel in order\n     * to render sharp on screen. In some cases, when there are a lot of\n     * densely packed columns, this leads to visible difference in column\n     * widths or distance between columns. In these cases, setting `crisp`\n     * to `false` may look better, even though each column is rendered\n     * blurry.\n     *\n     * @sample  {highcharts} highcharts/plotoptions/column-crisp-false/\n     *          Crisp is false\n     * @since   5.0.10\n     * @product highcharts highstock\n     */\n    crisp: true,\n\n    /**\n     * Padding between each value groups, in x axis units.\n     *\n     * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-default/\n     *          0.2 by default\n     * @sample  {highcharts} highcharts/plotoptions/column-grouppadding-none/\n     *          No group padding - all columns are evenly spaced\n     * @product highcharts highstock\n     */\n    groupPadding: 0.2,\n\n    /**\n     * Whether to group non-stacked columns or to let them render independent\n     * of each other. Non-grouped columns will be laid out individually\n     * and overlap each other.\n     *\n     * @type      {Boolean}\n     * @sample    {highcharts} highcharts/plotoptions/column-grouping-false/\n     *            Grouping disabled\n     * @sample    {highstock} highcharts/plotoptions/column-grouping-false/\n     *            Grouping disabled\n     * @default   true\n     * @since     2.3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.column.grouping\n     */\n\n    /**\n     * @ignore-option\n     */\n    marker: null, // point options are specified in the base options\n\n    /**\n     * The maximum allowed pixel width for a column, translated to the height\n     * of a bar in a bar chart. This prevents the columns from becoming\n     * too wide when there is a small number of points in the chart.\n     *\n     * @type      {Number}\n     * @see       [pointWidth](#plotOptions.column.pointWidth)\n     * @sample    {highcharts} highcharts/plotoptions/column-maxpointwidth-20/\n     *            Limited to 50\n     * @sample    {highstock} highcharts/plotoptions/column-maxpointwidth-20/\n     *            Limited to 50\n     * @default   null\n     * @since     4.1.8\n     * @product   highcharts highstock\n     * @apioption plotOptions.column.maxPointWidth\n     */\n\n    /**\n     * Padding between each column or bar, in x axis units.\n     *\n     * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-default/\n     *          0.1 by default\n     * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-025/\n     *          0.25\n     * @sample  {highcharts} highcharts/plotoptions/column-pointpadding-none/\n     *          0 for tightly packed columns\n     * @product highcharts highstock\n     */\n    pointPadding: 0.1,\n\n    /**\n     * A pixel value specifying a fixed width for each column or bar. When\n     * `null`, the width is calculated from the `pointPadding` and\n     * `groupPadding`.\n     *\n     * @type      {Number}\n     * @see       [maxPointWidth](#plotOptions.column.maxPointWidth)\n     * @sample    {highcharts} highcharts/plotoptions/column-pointwidth-20/\n     *            20px wide columns regardless of chart width or the amount\n     *            of data points\n     * @default   null\n     * @since     1.2.5\n     * @product   highcharts highstock\n     * @apioption plotOptions.column.pointWidth\n     */\n\n    /**\n     * The minimal height for a column or width for a bar. By default,\n     * 0 values are not shown. To visualize a 0 (or close to zero) point,\n     * set the minimal point length to a pixel value like 3\\. In stacked\n     * column charts, minPointLength might not be respected for tightly\n     * packed values.\n     *\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/column-minpointlength/\n     *          Zero base value\n     * @sample  {highcharts}\n     *          highcharts/plotoptions/column-minpointlength-pos-and-neg/\n     *          Positive and negative close to zero values\n     * @product highcharts highstock\n     */\n    minPointLength: 0,\n\n    /**\n     * When the series contains less points than the crop threshold, all\n     * points are drawn, event if the points fall outside the visible plot\n     * area at the current zoom. The advantage of drawing all points (including\n     * markers and columns), is that animation is performed on updates.\n     * On the other hand, when the series contains more points than the\n     * crop threshold, the series data is cropped to only contain points\n     * that fall within the plot area. The advantage of cropping away invisible\n     * points is to increase performance on large series. .\n     *\n     * @product highcharts highstock\n     */\n    cropThreshold: 50,\n\n    /**\n     * The X axis range that each point is valid for. This determines the\n     * width of the column. On a categorized axis, the range will be 1\n     * by default (one category unit). On linear and datetime axes, the\n     * range will be computed as the distance between the two closest data\n     * points.\n     *\n     * The default `null` means it is computed automatically, but this option\n     * can be used to override the automatic value.\n     *\n     * @type    {Number}\n     * @sample  {highcharts} highcharts/plotoptions/column-pointrange/\n     *          Set the point range to one day on a data set with one week\n     *          between the points\n     * @since   2.3\n     * @product highcharts highstock\n     */\n    pointRange: null,\n\n    states: {\n\n        /**\n         * Options for the hovered point. These settings override the normal\n         * state options when a point is moused over or touched.\n         *\n         * @extends   plotOptions.series.states.hover\n         * @excluding halo,lineWidth,lineWidthPlus,marker\n         * @product   highcharts highstock\n         */\n        hover: {\n\n            /** @ignore-option */\n            halo: false,\n\n            /**\n             * A specific border color for the hovered point. Defaults to\n             * inherit the normal state border color.\n             *\n             * @type      {Color}\n             * @product   highcharts\n             * @apioption plotOptions.column.states.hover.borderColor\n             */\n\n            /**\n             * A specific color for the hovered point.\n             *\n             * @type      {Color}\n             * @default   undefined\n             * @product   highcharts\n             * @apioption plotOptions.column.states.hover.color\n             */\n\n            \n        }\n        \n    },\n\n    dataLabels: {\n        align: null, // auto\n        verticalAlign: null, // auto\n        y: null\n    },\n\n    /**\n     * When this is true, the series will not cause the Y axis to cross\n     * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n     * unless the data actually crosses the plane.\n     *\n     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n     * 3 will make the Y axis show negative values according to the `minPadding`\n     * option. If `softThreshold` is `true`, the Y axis starts at 0.\n     *\n     * @since   4.1.9\n     * @product highcharts highstock\n     */\n    softThreshold: false,\n\n    // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/\n    /**\n     * @ignore-option\n     */\n    startFromThreshold: true,\n\n    stickyTracking: false,\n\n    tooltip: {\n        distance: 6\n    },\n\n    /**\n     * The Y axis value to serve as the base for the columns, for distinguishing\n     * between values above and below a threshold. If `null`, the columns\n     * extend from the padding Y axis minimum.\n     *\n     * @since   2.0\n     * @product highcharts\n     */\n    threshold: 0\n\n    \n\n}, /** @lends seriesTypes.column.prototype */ {\n    cropShoulder: 0,\n    // When tooltip is not shared, this series (and derivatives) requires direct\n    // touch/hover. KD-tree does not apply.\n    directTouch: true,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    // use separate negative stacks, unlike area stacks where a negative point\n    // is substracted from previous (#1910)\n    negStacks: true,\n\n    /**\n     * Initialize the series. Extends the basic Series.init method by\n     * marking other series of the same type as dirty.\n     *\n     * @function #init\n     * @memberof seriesTypes.column\n     *\n     */\n    init: function () {\n        Series.prototype.init.apply(this, arguments);\n\n        var series = this,\n            chart = series.chart;\n\n        // if the series is added dynamically, force redraw of other\n        // series affected by a new column\n        if (chart.hasRendered) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n    },\n\n    /**\n     * Return the width and x offset of the columns adjusted for grouping,\n     * groupPadding, pointPadding, pointWidth etc.\n     */\n    getColumnMetrics: function () {\n\n        var series = this,\n            options = series.options,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            reversedStacks = xAxis.options.reversedStacks,\n            // Keep backward compatibility: reversed xAxis had reversed stacks\n            reverseStacks = (xAxis.reversed && !reversedStacks) ||\n                (!xAxis.reversed && reversedStacks),\n            stackKey,\n            stackGroups = {},\n            columnCount = 0;\n\n        // Get the total number of column type series. This is called on every\n        // series. Consider moving this logic to a chart.orderStacks() function\n        // and call it on init, addSeries and removeSeries\n        if (options.grouping === false) {\n            columnCount = 1;\n        } else {\n            each(series.chart.series, function (otherSeries) {\n                var otherOptions = otherSeries.options,\n                    otherYAxis = otherSeries.yAxis,\n                    columnIndex;\n                if (\n                    otherSeries.type === series.type &&\n                    (\n                        otherSeries.visible ||\n                        !series.chart.options.chart.ignoreHiddenSeries\n                    ) &&\n                    yAxis.len === otherYAxis.len &&\n                    yAxis.pos === otherYAxis.pos\n                ) {  // #642, #2086\n                    if (otherOptions.stacking) {\n                        stackKey = otherSeries.stackKey;\n                        if (stackGroups[stackKey] === undefined) {\n                            stackGroups[stackKey] = columnCount++;\n                        }\n                        columnIndex = stackGroups[stackKey];\n                    } else if (otherOptions.grouping !== false) { // #1162\n                        columnIndex = columnCount++;\n                    }\n                    otherSeries.columnIndex = columnIndex;\n                }\n            });\n        }\n\n        var categoryWidth = Math.min(\n                Math.abs(xAxis.transA) * (\n                    xAxis.ordinalSlope ||\n                    options.pointRange ||\n                    xAxis.closestPointRange ||\n                    xAxis.tickInterval ||\n                    1\n                ), // #2610\n                xAxis.len // #1535\n            ),\n            groupPadding = categoryWidth * options.groupPadding,\n            groupWidth = categoryWidth - 2 * groupPadding,\n            pointOffsetWidth = groupWidth / (columnCount || 1),\n            pointWidth = Math.min(\n                options.maxPointWidth || xAxis.len,\n                pick(\n                    options.pointWidth,\n                    pointOffsetWidth * (1 - 2 * options.pointPadding)\n                )\n            ),\n            pointPadding = (pointOffsetWidth - pointWidth) / 2,\n            // #1251, #3737\n            colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),\n            pointXOffset =\n                pointPadding +\n                (\n                    groupPadding +\n                    colIndex * pointOffsetWidth -\n                    (categoryWidth / 2)\n                ) * (reverseStacks ? -1 : 1);\n\n        // Save it for reading in linked series (Error bars particularly)\n        series.columnMetrics = {\n            width: pointWidth,\n            offset: pointXOffset\n        };\n        return series.columnMetrics;\n\n    },\n\n    /**\n     * Make the columns crisp. The edges are rounded to the nearest full pixel.\n     */\n    crispCol: function (x, y, w, h) {\n        var chart = this.chart,\n            borderWidth = this.borderWidth,\n            xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n            yCrisp = borderWidth % 2 ? 0.5 : 1,\n            right,\n            bottom,\n            fromTop;\n\n        if (chart.inverted && chart.renderer.isVML) {\n            yCrisp += 1;\n        }\n\n        // Horizontal. We need to first compute the exact right edge, then round\n        // it and compute the width from there.\n        if (this.options.crisp) {\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n        }\n\n        // Vertical\n        bottom = Math.round(y + h) + yCrisp;\n        fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n        y = Math.round(y) + yCrisp;\n        h = bottom - y;\n\n        // Top edges are exceptions\n        if (fromTop && h) { // #5146\n            y -= 1;\n            h += 1;\n        }\n\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        };\n    },\n\n    /**\n     * Translate each point to the plot area coordinate system and find shape\n     * positions\n     */\n    translate: function () {\n        var series = this,\n            chart = series.chart,\n            options = series.options,\n            dense = series.dense =\n                series.closestPointRange * series.xAxis.transA < 2,\n            borderWidth = series.borderWidth = pick(\n                options.borderWidth,\n                dense ? 0 : 1  // #3635\n            ),\n            yAxis = series.yAxis,\n            threshold = options.threshold,\n            translatedThreshold = series.translatedThreshold =\n                yAxis.getThreshold(threshold),\n            minPointLength = pick(options.minPointLength, 5),\n            metrics = series.getColumnMetrics(),\n            pointWidth = metrics.width,\n            // postprocessed for border width\n            seriesBarW = series.barW =\n                Math.max(pointWidth, 1 + 2 * borderWidth),\n            pointXOffset = series.pointXOffset = metrics.offset;\n\n        if (chart.inverted) {\n            translatedThreshold -= 0.5; // #3355\n        }\n\n        // When the pointPadding is 0, we want the columns to be packed tightly,\n        // so we allow individual columns to have individual sizes. When\n        // pointPadding is greater, we strive for equal-width columns (#2694).\n        if (options.pointPadding) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n\n        Series.prototype.translate.apply(series);\n\n        // Record the new values\n        each(series.points, function (point) {\n            var yBottom = pick(point.yBottom, translatedThreshold),\n                safeDistance = 999 + Math.abs(yBottom),\n                plotY = Math.min(\n                    Math.max(-safeDistance, point.plotY),\n                    yAxis.len + safeDistance\n                ), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                barX = point.plotX + pointXOffset,\n                barW = seriesBarW,\n                barY = Math.min(plotY, yBottom),\n                up,\n                barH = Math.max(plotY, yBottom) - barY;\n\n            // Handle options.minPointLength\n            if (minPointLength && Math.abs(barH) < minPointLength) {\n                barH = minPointLength;\n                up = (!yAxis.reversed && !point.negative) ||\n                    (yAxis.reversed && point.negative);\n\n                // Reverse zeros if there's no positive value in the series\n                // in visible range (#7046)\n                if (\n                    point.y === threshold &&\n                    series.dataMax <= threshold &&\n                    yAxis.min < threshold // and if there's room for it (#7311)\n                ) {\n                    up = !up;\n                }\n\n                // If stacked...\n                barY = Math.abs(barY - translatedThreshold) > minPointLength ?\n                        // ...keep position\n                        yBottom - minPointLength :\n                        // #1485, #4051\n                        translatedThreshold - (up ? minPointLength : 0);\n            }\n\n            // Cache for access in polar\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n\n            // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n            point.tooltipPos = chart.inverted ?\n            [\n                yAxis.len + yAxis.pos - chart.plotLeft - plotY,\n                series.xAxis.len - barX - barW / 2, barH\n            ] :\n            [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n            // Register shape type and arguments to be used in drawPoints\n            point.shapeType = 'rect';\n            point.shapeArgs = series.crispCol.apply(\n                series,\n                point.isNull ?\n                    // #3169, drilldown from null must have a position to work\n                    // from #6585, dataLabel should be placed on xAxis, not\n                    // floating in the middle of the chart\n                    [barX, translatedThreshold, barW, 0] :\n                    [barX, barY, barW, barH]\n            );\n        });\n\n    },\n\n    getSymbol: noop,\n\n    /**\n     * Use a solid rectangle like the area series types\n     */\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n    /**\n     * Columns have no graph\n     */\n    drawGraph: function () {\n        this.group[\n            this.dense ? 'addClass' : 'removeClass'\n        ]('highcharts-dense-data');\n    },\n\n    \n\n    /**\n     * Draw the columns. For bars, the series.group is rotated, so the same\n     * coordinates apply for columns and bars. This method is inherited by\n     * scatter series.\n     */\n    drawPoints: function () {\n        var series = this,\n            chart = this.chart,\n            options = series.options,\n            renderer = chart.renderer,\n            animationLimit = options.animationLimit || 250,\n            shapeArgs;\n\n        // draw the columns\n        each(series.points, function (point) {\n            var plotY = point.plotY,\n                graphic = point.graphic,\n                verb = graphic && chart.pointCount < animationLimit ?\n                    'animate' : 'attr';\n\n            if (isNumber(plotY) && point.y !== null) {\n                shapeArgs = point.shapeArgs;\n\n                if (graphic) { // update\n                    graphic[verb](\n                        merge(shapeArgs)\n                    );\n\n                } else {\n                    point.graphic = graphic =\n                        renderer[point.shapeType](shapeArgs)\n                            .add(point.group || series.group);\n                }\n\n                // Border radius is not stylable (#6900)\n                if (options.borderRadius) {\n                    graphic.attr({\n                        r: options.borderRadius\n                    });\n                }\n\n                \n\n                graphic.addClass(point.getClassName(), true);\n\n\n            } else if (graphic) {\n                point.graphic = graphic.destroy(); // #1269\n            }\n        });\n    },\n\n    /**\n     * Animate the column heights one by one from zero\n     * @param {Boolean} init Whether to initialize the animation or run it\n     */\n    animate: function (init) {\n        var series = this,\n            yAxis = this.yAxis,\n            options = series.options,\n            inverted = this.chart.inverted,\n            attr = {},\n            translateProp = inverted ? 'translateX' : 'translateY',\n            translateStart,\n            translatedThreshold;\n\n        if (svg) { // VML is too slow anyway\n            if (init) {\n                attr.scaleY = 0.001;\n                translatedThreshold = Math.min(\n                    yAxis.pos + yAxis.len,\n                    Math.max(yAxis.pos, yAxis.toPixels(options.threshold))\n                );\n                if (inverted) {\n                    attr.translateX = translatedThreshold - yAxis.len;\n                } else {\n                    attr.translateY = translatedThreshold;\n                }\n                series.group.attr(attr);\n\n            } else { // run the animation\n                translateStart = series.group.attr(translateProp);\n                series.group.animate(\n                    { scaleY: 1 },\n                    extend(animObject(series.options.animation\n                ), {\n                    // Do the scale synchronously to ensure smooth updating\n                    // (#5030, #7228)\n                    step: function (val, fx) {\n\n                        attr[translateProp] =\n                            translateStart +\n                            fx.pos * (yAxis.pos - translateStart);\n                        series.group.attr(attr);\n                    }\n                }));\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        }\n    },\n\n    /**\n     * Remove this series from the chart\n     */\n    remove: function () {\n        var series = this,\n            chart = series.chart;\n\n        // column and bar series affects other series of the same type\n        // as they are either stacked or grouped\n        if (chart.hasRendered) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n\n        Series.prototype.remove.apply(series, arguments);\n    }\n});\n\n\n/**\n * A `column` series. If the [type](#series.column.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.column\n * @excluding connectNulls,dashStyle,dataParser,dataURL,gapSize,gapUnit,linecap,\n *            lineWidth,marker,connectEnds,step\n * @product   highcharts highstock\n * @apioption series.column\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.hover\n */\n\n/**\n * @excluding halo,lineWidth,lineWidthPlus,marker\n * @product   highcharts highstock\n * @apioption series.column.states.select\n */\n\n/**\n * An array of data points for the series. For the `column` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 6],\n *         [1, 2],\n *         [2, 6]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.column.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @excluding marker\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.column.data\n */\n\n/**\n * The color of the border surrounding the column or bar.\n *\n * In styled mode, the border stroke can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Color}\n * @sample    {highcharts} highcharts/plotoptions/column-bordercolor/\n *            Dark gray border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderColor\n */\n\n/**\n * The width of the border surrounding the column or bar.\n *\n * In styled mode, the stroke width can be set with the `.highcharts-point`\n * rule.\n *\n * @type      {Number}\n * @sample    {highcharts} highcharts/plotoptions/column-borderwidth/\n *            2px black border\n * @default   undefined\n * @product   highcharts highstock\n * @apioption series.column.data.borderWidth\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/DataGrouping.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/DataGrouping.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tooltip.js */ \"./node_modules/highcharts/js/es-modules/parts/Tooltip.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    Tooltip = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tooltip,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n/* ****************************************************************************\n * Start data grouping module                                                 *\n ******************************************************************************/\n\n/**\n * Data grouping is the concept of sampling the data values into larger\n * blocks in order to ease readability and increase performance of the\n * JavaScript charts. Highstock by default applies data grouping when\n * the points become closer than a certain pixel value, determined by\n * the `groupPixelWidth` option.\n *\n * If data grouping is applied, the grouping information of grouped\n * points can be read from the [Point.dataGroup](\n * /class-reference/Highcharts.Point#.dataGroup). If point options other than\n * the data itself are set, for example `name` or `color` or custom properties,\n * the grouping logic doesn't know how to group it. In this case the options of\n * the first point instance are copied over to the group point. This can be\n * altered through a custom `approximation` callback function.\n *\n * @product highstock\n * @apioption plotOptions.series.dataGrouping\n */\n\n/**\n * The method of approximation inside a group. When for example 30 days\n * are grouped into one month, this determines what value should represent\n * the group. Possible values are \"average\", \"averages\", \"open\", \"high\",\n * \"low\", \"close\" and \"sum\". For OHLC and candlestick series the approximation\n * is \"ohlc\" by default, which finds the open, high, low and close values\n * within all the grouped data. For ranges, the approximation is \"range\",\n * which finds the low and high values. For multi-dimensional data,\n * like ranges and OHLC, \"averages\" will compute the average for each\n * dimension.\n *\n * Custom aggregate methods can be added by assigning a callback function\n * as the approximation. This function takes a numeric array as the\n * argument and should return a single numeric value or `null`. Note\n * that the numeric array will never contain null values, only true\n * numbers. Instead, if null values are present in the raw data, the\n * numeric array will have an `.hasNulls` property set to `true`. For\n * single-value data sets the data is available in the first argument\n * of the callback function. For OHLC data sets, all the open values\n * are in the first argument, all high values in the second etc.\n *\n * Since v4.2.7, grouping meta data is available in the approximation\n * callback from `this.dataGroupInfo`. It can be used to extract information\n * from the raw data.\n *\n * Defaults to `average` for line-type series, `sum` for columns, `range`\n * for range series and `ohlc` for OHLC and candlestick.\n *\n * @validvalue [\"average\", \"averages\", \"open\", \"high\", \"low\", \"close\", \"sum\"]\n * @type {String|Function}\n * @sample {highstock} stock/plotoptions/series-datagrouping-approximation\n *         Approximation callback with custom data\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.approximation\n */\n\n/**\n * Datetime formats for the header of the tooltip in a stock chart.\n * The format can vary within a chart depending on the currently selected\n * time range and the current data grouping.\n *\n * The default formats are:\n *\n * <pre>{\n *     millisecond: [\n *         '%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'\n *     ],\n *     second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],\n *     minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n *     hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n *     day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n *     week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n *     month: ['%B %Y', '%B', '-%B %Y'],\n *     year: ['%Y', '%Y', '-%Y']\n * }</pre>\n *\n * For each of these array definitions, the first item is the format\n * used when the active time span is one unit. For instance, if the\n * current data applies to one week, the first item of the week array\n * is used. The second and third items are used when the active time\n * span is more than two units. For instance, if the current data applies\n * to two weeks, the second and third item of the week array are used,\n *  and applied to the start and end date of the time span.\n *\n * @type {Object}\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.dateTimeLabelFormats\n */\n\n/**\n * Enable or disable data grouping.\n *\n * @type {Boolean}\n * @default true\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.enabled\n */\n\n/**\n * When data grouping is forced, it runs no matter how small the intervals\n * are. This can be handy for example when the sum should be calculated\n * for values appearing at random times within each hour.\n *\n * @type {Boolean}\n * @default false\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.forced\n */\n\n/**\n * The approximate pixel width of each group. If for example a series\n * with 30 points is displayed over a 600 pixel wide plot area, no grouping\n * is performed. If however the series contains so many points that\n * the spacing is less than the groupPixelWidth, Highcharts will try\n * to group it into appropriate groups so that each is more or less\n * two pixels wide. If multiple series with different group pixel widths\n * are drawn on the same x axis, all series will take the greatest width.\n * For example, line series have 2px default group width, while column\n * series have 10px. If combined, both the line and the column will\n * have 10px by default.\n *\n * @type {Number}\n * @default 2\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.groupPixelWidth\n */\n\n /**\n * By default only points within the visible range are grouped. Enabling this\n * option will force data grouping to calculate all grouped points for a given\n * dataset. That option prevents for example a column series from calculating\n * a grouped point partially. The effect is similar to\n * [Series.getExtremesFromAll](#plotOptions.series.getExtremesFromAll) but does\n * not affect yAxis extremes.\n *\n * @type {Boolean}\n * @sample {highstock} stock/plotoptions/series-datagrouping-groupall/\n *         Two series with the same data but different groupAll setting\n * @default false\n * @since 6.1.0\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.groupAll\n */\n\n/**\n * Normally, a group is indexed by the start of that group, so for example\n * when 30 daily values are grouped into one month, that month's x value\n * will be the 1st of the month. This apparently shifts the data to\n * the left. When the smoothed option is true, this is compensated for.\n * The data is shifted to the middle of the group, and min and max\n * values are preserved. Internally, this is used in the Navigator series.\n *\n * @type {Boolean}\n * @default false\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.smoothed\n */\n\n/**\n * An array determining what time intervals the data is allowed to be\n * grouped to. Each array item is an array where the first value is\n * the time unit and the second value another array of allowed multiples.\n * Defaults to:\n *\n * <pre>units: [[\n *     'millisecond', // unit name\n *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n * ], [\n *     'second',\n *     [1, 2, 5, 10, 15, 30]\n * ], [\n *     'minute',\n *     [1, 2, 5, 10, 15, 30]\n * ], [\n *     'hour',\n *     [1, 2, 3, 4, 6, 8, 12]\n * ], [\n *     'day',\n *     [1]\n * ], [\n *     'week',\n *     [1]\n * ], [\n *     'month',\n *     [1, 3, 6]\n * ], [\n *     'year',\n *     null\n * ]]</pre>\n *\n * @type {Array}\n * @product highstock\n * @apioption plotOptions.series.dataGrouping.units\n */\n\n/**\n * The approximate pixel width of each group. If for example a series\n * with 30 points is displayed over a 600 pixel wide plot area, no grouping\n * is performed. If however the series contains so many points that\n * the spacing is less than the groupPixelWidth, Highcharts will try\n * to group it into appropriate groups so that each is more or less\n * two pixels wide. Defaults to `10`.\n *\n * @type {Number}\n * @sample {highstock} stock/plotoptions/series-datagrouping-grouppixelwidth/\n *         Two series with the same data density but different groupPixelWidth\n * @default 10\n * @product highstock\n * @apioption plotOptions.column.dataGrouping.groupPixelWidth\n */\n\nvar seriesProto = Series.prototype,\n    baseProcessData = seriesProto.processData,\n    baseGeneratePoints = seriesProto.generatePoints,\n\n    /**\n     *\n     */\n    commonOptions = {\n        approximation: 'average', // average, open, high, low, close, sum\n        // enabled: null, // (true for stock charts, false for basic),\n        // forced: undefined,\n        groupPixelWidth: 2,\n        // the first one is the point or start value, the second is the start\n        // value if we're dealing with range, the third one is the end value if\n        // dealing with a range\n        dateTimeLabelFormats: {\n            millisecond: [\n                '%A, %b %e, %H:%M:%S.%L',\n                '%A, %b %e, %H:%M:%S.%L',\n                '-%H:%M:%S.%L'\n            ],\n            second: [\n                '%A, %b %e, %H:%M:%S',\n                '%A, %b %e, %H:%M:%S',\n                '-%H:%M:%S'\n            ],\n            minute: [\n                '%A, %b %e, %H:%M',\n                '%A, %b %e, %H:%M',\n                '-%H:%M'\n            ],\n            hour: [\n                '%A, %b %e, %H:%M',\n                '%A, %b %e, %H:%M',\n                '-%H:%M'\n            ],\n            day: [\n                '%A, %b %e, %Y',\n                '%A, %b %e',\n                '-%A, %b %e, %Y'\n            ],\n            week: [\n                'Week from %A, %b %e, %Y',\n                '%A, %b %e',\n                '-%A, %b %e, %Y'\n            ],\n            month: [\n                '%B %Y',\n                '%B',\n                '-%B %Y'\n            ],\n            year: [\n                '%Y',\n                '%Y',\n                '-%Y'\n            ]\n        }\n        // smoothed = false, // enable this for navigator series only\n    },\n\n    specificOptions = { // extends common options\n        line: {},\n        spline: {},\n        area: {},\n        areaspline: {},\n        column: {\n            approximation: 'sum',\n            groupPixelWidth: 10\n        },\n        arearange: {\n            approximation: 'range'\n        },\n        areasplinerange: {\n            approximation: 'range'\n        },\n        columnrange: {\n            approximation: 'range',\n            groupPixelWidth: 10\n        },\n        candlestick: {\n            approximation: 'ohlc',\n            groupPixelWidth: 10\n        },\n        ohlc: {\n            approximation: 'ohlc',\n            groupPixelWidth: 5\n        }\n    },\n\n    // units are defined in a separate array to allow complete overriding in\n    // case of a user option\n    defaultDataGroupingUnits = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultDataGroupingUnits = [\n        [\n            'millisecond', // unit name\n            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n        ], [\n            'second',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'minute',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'hour',\n            [1, 2, 3, 4, 6, 8, 12]\n        ], [\n            'day',\n            [1]\n        ], [\n            'week',\n            [1]\n        ], [\n            'month',\n            [1, 3, 6]\n        ], [\n            'year',\n            null\n        ]\n    ],\n\n\n    /**\n     * Define the available approximation types. The data grouping\n     * approximations takes an array or numbers as the first parameter. In case\n     * of ohlc, four arrays are sent in as four parameters. Each array consists\n     * only of numbers. In case null values belong to the group, the property\n     * .hasNulls will be set to true on the array.\n     */\n    approximations = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].approximations = {\n        sum: function (arr) {\n            var len = arr.length,\n                ret;\n\n            // 1. it consists of nulls exclusively\n            if (!len && arr.hasNulls) {\n                ret = null;\n            // 2. it has a length and real values\n            } else if (len) {\n                ret = 0;\n                while (len--) {\n                    ret += arr[len];\n                }\n            }\n            // 3. it has zero length, so just return undefined\n            // => doNothing()\n\n            return ret;\n        },\n        average: function (arr) {\n            var len = arr.length,\n                ret = approximations.sum(arr);\n\n            // If we have a number, return it divided by the length. If not,\n            // return null or undefined based on what the sum method finds.\n            if (isNumber(ret) && len) {\n                ret = ret / len;\n            }\n\n            return ret;\n        },\n        // The same as average, but for series with multiple values, like area\n        // ranges.\n        averages: function () { // #5479\n            var ret = [];\n\n            each(arguments, function (arr) {\n                ret.push(approximations.average(arr));\n            });\n\n            // Return undefined when first elem. is undefined and let\n            // sum method handle null (#7377)\n            return ret[0] === undefined ? undefined : ret;\n        },\n        open: function (arr) {\n            return arr.length ? arr[0] : (arr.hasNulls ? null : undefined);\n        },\n        high: function (arr) {\n            return arr.length ?\n                arrayMax(arr) :\n                (arr.hasNulls ? null : undefined);\n        },\n        low: function (arr) {\n            return arr.length ?\n                arrayMin(arr) :\n                (arr.hasNulls ? null : undefined);\n        },\n        close: function (arr) {\n            return arr.length ?\n                arr[arr.length - 1] :\n                (arr.hasNulls ? null : undefined);\n        },\n        // ohlc and range are special cases where a multidimensional array is\n        // input and an array is output\n        ohlc: function (open, high, low, close) {\n            open = approximations.open(open);\n            high = approximations.high(high);\n            low = approximations.low(low);\n            close = approximations.close(close);\n\n            if (\n                isNumber(open) ||\n                isNumber(high) ||\n                isNumber(low) ||\n                isNumber(close)\n            ) {\n                return [open, high, low, close];\n            }\n            // else, return is undefined\n        },\n        range: function (low, high) {\n            low = approximations.low(low);\n            high = approximations.high(high);\n\n            if (isNumber(low) || isNumber(high)) {\n                return [low, high];\n            } else if (low === null && high === null) {\n                return null;\n            }\n            // else, return is undefined\n        }\n    };\n\n/**\n * Takes parallel arrays of x and y data and groups the data into intervals\n * defined by groupPositions, a collection of starting x values for each group.\n */\nseriesProto.groupData = function (xData, yData, groupPositions, approximation) {\n    var series = this,\n        data = series.data,\n        dataOptions = series.options.data,\n        groupedXData = [],\n        groupedYData = [],\n        groupMap = [],\n        dataLength = xData.length,\n        pointX,\n        pointY,\n        groupedY,\n        // when grouping the fake extended axis for panning,\n        // we don't need to consider y\n        handleYData = !!yData,\n        values = [],\n        approximationFn = typeof approximation === 'function' ?\n            approximation :\n            approximations[approximation] ||\n                // if the approximation is not found use default series type\n                // approximation (#2914)\n                (\n                    specificOptions[series.type] &&\n                    approximations[specificOptions[series.type].approximation]\n                ) || approximations[commonOptions.approximation],\n        pointArrayMap = series.pointArrayMap,\n        pointArrayMapLength = pointArrayMap && pointArrayMap.length,\n        extendedPointArrayMap = ['x'].concat(pointArrayMap || ['y']),\n        pos = 0,\n        start = 0,\n        valuesLen,\n        i, j;\n\n    // Calculate values array size from pointArrayMap length\n    if (pointArrayMapLength) {\n        each(pointArrayMap, function () {\n            values.push([]);\n        });\n    } else {\n        values.push([]);\n    }\n    valuesLen = pointArrayMapLength || 1;\n\n    // Start with the first point within the X axis range (#2696)\n    for (i = 0; i <= dataLength; i++) {\n        if (xData[i] >= groupPositions[0]) {\n            break;\n        }\n    }\n\n    for (i; i <= dataLength; i++) {\n\n        // when a new group is entered, summarize and initiate\n        // the previous group\n        while ((\n                    groupPositions[pos + 1] !== undefined &&\n                    xData[i] >= groupPositions[pos + 1]\n                ) || i === dataLength) { // get the last group\n\n            // get group x and y\n            pointX = groupPositions[pos];\n            series.dataGroupInfo = { start: start, length: values[0].length };\n            groupedY = approximationFn.apply(series, values);\n\n            // By default, let options of the first grouped point be passed over\n            // to the grouped point. This allows preserving properties like\n            // `name` and `color` or custom properties. Implementers can\n            // override this from the approximation function, where they can\n            // write custom options to `this.dataGroupInfo.options`.\n            if (!defined(series.dataGroupInfo.options)) {\n                // Convert numbers and arrays into objects\n                series.dataGroupInfo.options = series.pointClass.prototype\n                    .optionsToObject.call(\n                        { series: series },\n                        series.options.data[start]\n                    );\n                // Make sure the raw data (x, y, open, high etc) is not copied\n                // over and overwriting approximated data.\n                each(extendedPointArrayMap, function (key) {\n                    delete series.dataGroupInfo.options[key];\n                });\n            }\n\n            // push the grouped data\n            if (groupedY !== undefined) {\n                groupedXData.push(pointX);\n                groupedYData.push(groupedY);\n                groupMap.push(series.dataGroupInfo);\n            }\n\n            // reset the aggregate arrays\n            start = i;\n            for (j = 0; j < valuesLen; j++) {\n                values[j].length = 0; // faster than values[j] = []\n                values[j].hasNulls = false;\n            }\n\n            // Advance on the group positions\n            pos += 1;\n\n            // don't loop beyond the last group\n            if (i === dataLength) {\n                break;\n            }\n        }\n\n        // break out\n        if (i === dataLength) {\n            break;\n        }\n\n        // for each raw data point, push it to an array that contains all values\n        // for this specific group\n        if (pointArrayMap) {\n\n            var index = series.cropStart + i,\n                point = (data && data[index]) ||\n                    series.pointClass.prototype.applyOptions.apply({\n                        series: series\n                    }, [dataOptions[index]]),\n                val;\n\n            for (j = 0; j < pointArrayMapLength; j++) {\n                val = point[pointArrayMap[j]];\n                if (isNumber(val)) {\n                    values[j].push(val);\n                } else if (val === null) {\n                    values[j].hasNulls = true;\n                }\n            }\n\n        } else {\n            pointY = handleYData ? yData[i] : null;\n\n            if (isNumber(pointY)) {\n                values[0].push(pointY);\n            } else if (pointY === null) {\n                values[0].hasNulls = true;\n            }\n        }\n    }\n\n    return [groupedXData, groupedYData, groupMap];\n};\n\n/**\n * Extend the basic processData method, that crops the data to the current zoom\n * range, with data grouping logic.\n */\nseriesProto.processData = function () {\n    var series = this,\n        chart = series.chart,\n        options = series.options,\n        dataGroupingOptions = options.dataGrouping,\n        groupingEnabled = series.allowDG !== false && dataGroupingOptions &&\n            pick(dataGroupingOptions.enabled, chart.options.isStock),\n        visible = series.visible || !chart.options.chart.ignoreHiddenSeries,\n        hasGroupedData,\n        skip,\n        lastDataGrouping = this.currentDataGrouping,\n        currentDataGrouping,\n        croppedData;\n\n    // Run base method\n    series.forceCrop = groupingEnabled; // #334\n    series.groupPixelWidth = null; // #2110\n    series.hasProcessed = true; // #2692\n\n    // Skip if processData returns false or if grouping is disabled (in that\n    // order)\n    skip = (\n        baseProcessData.apply(series, arguments) === false ||\n        !groupingEnabled\n    );\n    if (!skip) {\n        series.destroyGroupedData();\n\n        var i,\n            processedXData = dataGroupingOptions.groupAll ? series.xData :\n                series.processedXData,\n            processedYData = dataGroupingOptions.groupAll ? series.yData :\n                series.processedYData,\n            plotSizeX = chart.plotSizeX,\n            xAxis = series.xAxis,\n            ordinal = xAxis.options.ordinal,\n            groupPixelWidth = series.groupPixelWidth =\n                xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();\n\n        // Execute grouping if the amount of points is greater than the limit\n        // defined in groupPixelWidth\n        if (groupPixelWidth) {\n            hasGroupedData = true;\n\n            // Force recreation of point instances in series.translate, #5699\n            series.isDirty = true;\n            series.points = null; // #6709\n\n            var extremes = xAxis.getExtremes(),\n                xMin = extremes.min,\n                xMax = extremes.max,\n                groupIntervalFactor = (\n                    ordinal &&\n                    xAxis.getGroupIntervalFactor(xMin, xMax, series)\n                ) || 1,\n                interval =\n                    (groupPixelWidth * (xMax - xMin) / plotSizeX) *\n                    groupIntervalFactor,\n                groupPositions = xAxis.getTimeTicks(\n                    xAxis.normalizeTimeTickInterval(\n                        interval,\n                        dataGroupingOptions.units || defaultDataGroupingUnits\n                    ),\n                    // Processed data may extend beyond axis (#4907)\n                    Math.min(xMin, processedXData[0]),\n                    Math.max(xMax, processedXData[processedXData.length - 1]),\n                    xAxis.options.startOfWeek,\n                    processedXData,\n                    series.closestPointRange\n                ),\n                groupedData = seriesProto.groupData.apply(\n                    series,\n                    [\n                        processedXData,\n                        processedYData,\n                        groupPositions,\n                        dataGroupingOptions.approximation\n                    ]),\n                groupedXData = groupedData[0],\n                groupedYData = groupedData[1];\n\n            // Prevent the smoothed data to spill out left and right, and make\n            // sure data is not shifted to the left\n            if (dataGroupingOptions.smoothed && groupedXData.length) {\n                i = groupedXData.length - 1;\n                groupedXData[i] = Math.min(groupedXData[i], xMax);\n                while (i-- && i > 0) {\n                    groupedXData[i] += interval / 2;\n                }\n                groupedXData[0] = Math.max(groupedXData[0], xMin);\n            }\n\n            // Record what data grouping values were used\n            currentDataGrouping = groupPositions.info;\n            series.closestPointRange = groupPositions.info.totalRange;\n            series.groupMap = groupedData[2];\n\n            // Make sure the X axis extends to show the first group (#2533)\n            // But only for visible series (#5493, #6393)\n            if (\n                defined(groupedXData[0]) &&\n                groupedXData[0] < xAxis.dataMin &&\n                visible\n            ) {\n                if (\n                    (\n                        !defined(xAxis.options.min) &&\n                        xAxis.min <= xAxis.dataMin\n                    ) ||\n                    xAxis.min === xAxis.dataMin\n                ) {\n                    xAxis.min = groupedXData[0];\n                }\n                xAxis.dataMin = groupedXData[0];\n            }\n\n            // We calculated all group positions but we should render\n            // only the ones within the visible range\n            if (dataGroupingOptions.groupAll) {\n                croppedData = series.cropData(\n                    groupedXData,\n                    groupedYData,\n                    xAxis.min,\n                    xAxis.max,\n                    1 // Ordinal xAxis will remove left-most points otherwise\n                );\n                groupedXData = croppedData.xData;\n                groupedYData = croppedData.yData;\n            }\n            // Set series props\n            series.processedXData = groupedXData;\n            series.processedYData = groupedYData;\n        } else {\n            series.groupMap = null;\n        }\n        series.hasGroupedData = hasGroupedData;\n        series.currentDataGrouping = currentDataGrouping;\n\n        series.preventGraphAnimation =\n            (lastDataGrouping && lastDataGrouping.totalRange) !==\n            (currentDataGrouping && currentDataGrouping.totalRange);\n    }\n};\n\n/**\n * Destroy the grouped data points. #622, #740\n */\nseriesProto.destroyGroupedData = function () {\n\n    var groupedData = this.groupedData;\n\n    // clear previous groups\n    each(groupedData || [], function (point, i) {\n        if (point) {\n            groupedData[i] = point.destroy ? point.destroy() : null;\n        }\n    });\n    this.groupedData = null;\n};\n\n/**\n * Override the generatePoints method by adding a reference to grouped data\n */\nseriesProto.generatePoints = function () {\n\n    baseGeneratePoints.apply(this);\n\n    // Record grouped data in order to let it be destroyed the next time\n    // processData runs\n    this.destroyGroupedData(); // #622\n    this.groupedData = this.hasGroupedData ? this.points : null;\n};\n\n/**\n * Override point prototype to throw a warning when trying to update grouped\n * points\n */\naddEvent(Point, 'update', function () {\n    if (this.dataGroup) {\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(24);\n        return false;\n    }\n});\n\n/**\n * Extend the original method, make the tooltip's header reflect the grouped\n * range\n */\nwrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function (\n    proceed,\n    labelConfig,\n    isFooter\n) {\n    var tooltip = this,\n        time = this.chart.time,\n        series = labelConfig.series,\n        options = series.options,\n        tooltipOptions = series.tooltipOptions,\n        dataGroupingOptions = options.dataGrouping,\n        xDateFormat = tooltipOptions.xDateFormat,\n        xDateFormatEnd,\n        xAxis = series.xAxis,\n        currentDataGrouping,\n        dateTimeLabelFormats,\n        labelFormats,\n        formattedKey;\n\n    // apply only to grouped series\n    if (\n        xAxis &&\n        xAxis.options.type === 'datetime' &&\n        dataGroupingOptions &&\n        isNumber(labelConfig.key)\n    ) {\n\n        // set variables\n        currentDataGrouping = series.currentDataGrouping;\n        dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;\n\n        // if we have grouped data, use the grouping information to get the\n        // right format\n        if (currentDataGrouping) {\n            labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];\n            if (currentDataGrouping.count === 1) {\n                xDateFormat = labelFormats[0];\n            } else {\n                xDateFormat = labelFormats[1];\n                xDateFormatEnd = labelFormats[2];\n            }\n        // if not grouped, and we don't have set the xDateFormat option, get the\n        // best fit, so if the least distance between points is one minute, show\n        // it, but if the least distance is one day, skip hours and minutes etc.\n        } else if (!xDateFormat && dateTimeLabelFormats) {\n            xDateFormat = tooltip.getXDateFormat(\n                labelConfig,\n                tooltipOptions,\n                xAxis\n            );\n        }\n\n        // now format the key\n        formattedKey = time.dateFormat(xDateFormat, labelConfig.key);\n        if (xDateFormatEnd) {\n            formattedKey += time.dateFormat(\n                xDateFormatEnd,\n                labelConfig.key + currentDataGrouping.totalRange - 1\n            );\n        }\n\n        // return the replaced format\n        return format(\n            tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {\n                point: extend(labelConfig.point, { key: formattedKey }),\n                series: series\n            },\n            time\n        );\n\n    }\n\n    // else, fall back to the regular formatter\n    return proceed.call(tooltip, labelConfig, isFooter);\n});\n\n/**\n * Destroy grouped data on series destroy\n */\naddEvent(Series, 'destroy', seriesProto.destroyGroupedData);\n\n\n// Handle default options for data grouping. This must be set at runtime because\n// some series types are defined after this.\naddEvent(Series, 'afterSetOptions', function (e) {\n\n    var options = e.options,\n        type = this.type,\n        plotOptions = this.chart.options.plotOptions,\n        defaultOptions = defaultPlotOptions[type].dataGrouping,\n        // External series, for example technical indicators should also\n        // inherit commonOptions which are not available outside this module\n        baseOptions = this.useCommonDataGrouping && commonOptions;\n\n    if (specificOptions[type] || baseOptions) { // #1284\n        if (!defaultOptions) {\n            defaultOptions = merge(commonOptions, specificOptions[type]);\n        }\n\n        options.dataGrouping = merge(\n            baseOptions,\n            defaultOptions,\n            plotOptions.series && plotOptions.series.dataGrouping, // #1228\n            plotOptions[type].dataGrouping, // Set by the StockChart constructor\n            this.userOptions.dataGrouping\n        );\n    }\n\n    if (this.chart.options.isStock) {\n        this.requireSorting = true;\n    }\n});\n\n\n/**\n * When resetting the scale reset the hasProccessed flag to avoid taking\n * previous data grouping of neighbour series into accound when determining\n * group pixel width (#2692).\n */\naddEvent(Axis, 'afterSetScale', function () {\n    each(this.series, function (series) {\n        series.hasProcessed = false;\n    });\n});\n\n/**\n * Get the data grouping pixel width based on the greatest defined individual\n * width\n * of the axis' series, and if whether one of the axes need grouping.\n */\nAxis.prototype.getGroupPixelWidth = function () {\n\n    var series = this.series,\n        len = series.length,\n        i,\n        groupPixelWidth = 0,\n        doGrouping = false,\n        dataLength,\n        dgOptions;\n\n    // If multiple series are compared on the same x axis, give them the same\n    // group pixel width (#334)\n    i = len;\n    while (i--) {\n        dgOptions = series[i].options.dataGrouping;\n        if (dgOptions) {\n            groupPixelWidth = Math.max(\n                groupPixelWidth,\n                dgOptions.groupPixelWidth\n            );\n\n        }\n    }\n\n    // If one of the series needs grouping, apply it to all (#1634)\n    i = len;\n    while (i--) {\n        dgOptions = series[i].options.dataGrouping;\n\n        if (dgOptions && series[i].hasProcessed) { // #2692\n\n            dataLength = (series[i].processedXData || series[i].data).length;\n\n            // Execute grouping if the amount of points is greater than the\n            // limit defined in groupPixelWidth\n            if (\n                series[i].groupPixelWidth ||\n                dataLength > (this.chart.plotSizeX / groupPixelWidth) ||\n                (dataLength && dgOptions.forced)\n            ) {\n                doGrouping = true;\n            }\n        }\n    }\n\n    return doGrouping ? groupPixelWidth : 0;\n};\n\n/**\n * Highstock only. Force data grouping on all the axis' series.\n *\n * @param  {SeriesDatagroupingOptions} [dataGrouping]\n *         A `dataGrouping` configuration. Use `false` to disable data grouping\n *         dynamically.\n * @param  {Boolean} [redraw=true]\n *         Whether to redraw the chart or wait for a later call to {@link\n *         Chart#redraw}.\n *\n * @function setDataGrouping\n * @memberof Axis.prototype\n */\nAxis.prototype.setDataGrouping = function (dataGrouping, redraw) {\n    var i;\n\n    redraw = pick(redraw, true);\n\n    if (!dataGrouping) {\n        dataGrouping = {\n            forced: false,\n            units: null\n        };\n    }\n\n    // Axis is instantiated, update all series\n    if (this instanceof Axis) {\n        i = this.series.length;\n        while (i--) {\n            this.series[i].update({\n                dataGrouping: dataGrouping\n            }, false);\n        }\n\n    // Axis not yet instanciated, alter series options\n    } else {\n        each(this.chart.options.series, function (seriesOptions) {\n            seriesOptions.dataGrouping = dataGrouping;\n        }, false);\n    }\n\n    // Clear ordinal slope, so we won't accidentaly use the old one (#7827)\n    this.ordinalSlope = null;\n\n    if (redraw) {\n        this.chart.redraw();\n    }\n};\n\n\n\n/* ****************************************************************************\n * End data grouping module                                                   *\n ******************************************************************************/\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/DataGrouping.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/DataLabels.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/DataLabels.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * A label box.\n *\n * @typedef {object} Highcharts.DataLabelBoxObject\n *\n * @property {number} align\n *\n * @property {number} pos\n *\n * @property {number} rank\n *\n * @property {number} size\n *\n * @property {number} target\n */\n\n/**\n * Alignment offset for a label.\n *\n * @typedef {object} Highcharts.DataLabelAlignObject\n *\n * @property {number} x\n *\n * @property {number} y\n */\n\n/**\n * Label position for a pie slice.\n *\n * @typedef {Array<number|string>} Highcharts.DataLabelPiePosObject\n *\n * @property {number} x\n *\n * @property {number} y\n */\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    relativeLength = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    some = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].some,\n    stableSort = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stableSort;\n\n\n/**\n * General distribution algorithm for distributing labels of differing size\n * along a confined length in two dimensions. The algorithm takes an array of\n * objects containing a size, a target and a rank. It will place the labels as\n * close as possible to their targets, skipping the lowest ranked labels if\n * necessary.\n *\n * @function Highcharts.distribute\n *\n * @param  {Array<Highcharts.DataLabelBoxObject>} boxes\n *\n * @param  {number} len\n *\n * @param  {number} maxDistance\n *\n * @return {void}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].distribute = function (boxes, len, maxDistance) {\n\n    var i,\n        overlapping = true,\n        origBoxes = boxes, // Original array will be altered with added .pos\n        restBoxes = [], // The outranked overshoot\n        box,\n        target,\n        total = 0,\n        reducedLen = origBoxes.reducedLen || len;\n\n    function sortByTarget(a, b) {\n        return a.target - b.target;\n    }\n\n    // If the total size exceeds the len, remove those boxes with the lowest\n    // rank\n    i = boxes.length;\n    while (i--) {\n        total += boxes[i].size;\n    }\n\n    // Sort by rank, then slice away overshoot\n    if (total > reducedLen) {\n        stableSort(boxes, function (a, b) {\n            return (b.rank || 0) - (a.rank || 0);\n        });\n        i = 0;\n        total = 0;\n        while (total <= reducedLen) {\n            total += boxes[i].size;\n            i++;\n        }\n        restBoxes = boxes.splice(i - 1, boxes.length);\n    }\n\n    // Order by target\n    stableSort(boxes, sortByTarget);\n\n\n    // So far we have been mutating the original array. Now\n    // create a copy with target arrays\n    boxes = map(boxes, function (box) {\n        return {\n            size: box.size,\n            targets: [box.target],\n            align: pick(box.align, 0.5)\n        };\n    });\n\n    while (overlapping) {\n        // Initial positions: target centered in box\n        i = boxes.length;\n        while (i--) {\n            box = boxes[i];\n            // Composite box, average of targets\n            target = (\n                Math.min.apply(0, box.targets) +\n                Math.max.apply(0, box.targets)\n            ) / 2;\n            box.pos = Math.min(\n                Math.max(0, target - box.size * box.align),\n                len - box.size\n            );\n        }\n\n        // Detect overlap and join boxes\n        i = boxes.length;\n        overlapping = false;\n        while (i--) {\n            // Overlap\n            if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {\n                // Add this size to the previous box\n                boxes[i - 1].size += boxes[i].size;\n                boxes[i - 1].targets = boxes[i - 1]\n                    .targets\n                    .concat(boxes[i].targets);\n                boxes[i - 1].align = 0.5;\n\n                // Overlapping right, push left\n                if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n                    boxes[i - 1].pos = len - boxes[i - 1].size;\n                }\n                boxes.splice(i, 1); // Remove this item\n                overlapping = true;\n            }\n        }\n    }\n\n    // Add the rest (hidden boxes)\n    origBoxes.push.apply(origBoxes, restBoxes);\n\n\n    // Now the composite boxes are placed, we need to put the original boxes\n    // within them\n    i = 0;\n    some(boxes, function (box) {\n        var posInCompositeBox = 0;\n        if (some(box.targets, function () {\n            origBoxes[i].pos = box.pos + posInCompositeBox;\n\n            // If the distance between the position and the target exceeds\n            // maxDistance, abort the loop and decrease the length in increments\n            // of 10% to recursively reduce the  number of visible boxes by\n            // rank. Once all boxes are within the maxDistance, we're good.\n            if (\n                Math.abs(origBoxes[i].pos - origBoxes[i].target) >\n                maxDistance\n            ) {\n                // Reset the positions that are already set\n                each(origBoxes.slice(0, i + 1), function (box) {\n                    delete box.pos;\n                });\n\n                // Try with a smaller length\n                origBoxes.reducedLen =\n                    (origBoxes.reducedLen || len) - (len * 0.1);\n\n                // Recurse\n                if (origBoxes.reducedLen > len * 0.1) {\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].distribute(origBoxes, len, maxDistance);\n                }\n\n                // Exceeded maxDistance => abort\n                return true;\n            }\n\n            posInCompositeBox += origBoxes[i].size;\n            i++;\n\n        })) {\n            // Exceeded maxDistance => abort\n            return true;\n        }\n    });\n\n    // Add the rest (hidden) boxes and sort by target\n    stableSort(origBoxes, sortByTarget);\n};\n\n\n/**\n * Draw the data labels\n *\n * @function Highcharts.Series#drawDataLabels\n *\n * @return {void}\n *\n * @todo\n * Make events official: Fires the event `afterDrawDataLabels`.\n */\nSeries.prototype.drawDataLabels = function () {\n    var series = this,\n        chart = series.chart,\n        seriesOptions = series.options,\n        options = seriesOptions.dataLabels,\n        points = series.points,\n        pointOptions,\n        generalOptions,\n        hasRendered = series.hasRendered || 0,\n        str,\n        dataLabelsGroup,\n        defer = pick(options.defer, !!seriesOptions.animation),\n        renderer = chart.renderer;\n\n    /*\n     * Handle the dataLabels.filter option.\n     */\n    function applyFilter(point, options) {\n        var filter = options.filter,\n            op,\n            prop,\n            val;\n        if (filter) {\n            op = filter.operator;\n            prop = point[filter.property];\n            val = filter.value;\n            if (\n                (op === '>' && prop > val) ||\n                (op === '<' && prop < val) ||\n                (op === '>=' && prop >= val) ||\n                (op === '<=' && prop <= val) ||\n                (op === '==' && prop == val) || // eslint-disable-line eqeqeq\n                (op === '===' && prop === val)\n            ) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n\n    if (options.enabled || series._hasPointLabels) {\n\n        // Process default alignment of data labels for columns\n        if (series.dlProcessOptions) {\n            series.dlProcessOptions(options);\n        }\n\n        // Create a separate group for the data labels to avoid rotation\n        dataLabelsGroup = series.plotGroup(\n            'dataLabelsGroup',\n            'data-labels',\n            defer && !hasRendered ? 'hidden' : 'visible', // #5133\n            options.zIndex || 6\n        );\n\n        if (defer) {\n            dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n            if (!hasRendered) {\n                addEvent(series, 'afterAnimate', function () {\n                    if (series.visible) { // #2597, #3023, #3024\n                        dataLabelsGroup.show(true);\n                    }\n                    dataLabelsGroup[\n                        seriesOptions.animation ? 'animate' : 'attr'\n                    ]({ opacity: 1 }, { duration: 200 });\n                });\n            }\n        }\n\n        // Make the labels for each point\n        generalOptions = options;\n        each(points, function (point) {\n            var enabled,\n                dataLabel = point.dataLabel,\n                labelConfig,\n                attr,\n                rotation,\n                connector = point.connector,\n                isNew = !dataLabel,\n                style,\n                formatString;\n\n            // Determine if each data label is enabled\n            // @note dataLabelAttribs (like pointAttribs) would eradicate\n            // the need for dlOptions, and simplify the section below.\n            pointOptions = point.dlOptions || // dlOptions is used in treemaps\n                (point.options && point.options.dataLabels);\n            enabled = pick(\n                pointOptions && pointOptions.enabled,\n                generalOptions.enabled\n            ) && !point.isNull; // #2282, #4641, #7112\n\n            if (enabled) {\n                enabled = applyFilter(point, pointOptions || options) === true;\n            }\n\n            if (enabled) {\n                // Create individual options structure that can be extended\n                // without affecting others\n                options = merge(generalOptions, pointOptions);\n                labelConfig = point.getLabelConfig();\n                formatString = (\n                    options[point.formatPrefix + 'Format'] ||\n                    options.format\n                );\n\n                str = defined(formatString) ?\n                    format(formatString, labelConfig, chart.time) :\n                    (\n                        options[point.formatPrefix + 'Formatter'] ||\n                        options.formatter\n                    ).call(labelConfig, options);\n\n                style = options.style;\n                rotation = options.rotation;\n                \n\n                attr = {\n                    \n                    r: options.borderRadius || 0,\n                    rotation: rotation,\n                    padding: options.padding,\n                    zIndex: 1\n                };\n\n                // Remove unused attributes (#947)\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(attr, function (val, name) {\n                    if (val === undefined) {\n                        delete attr[name];\n                    }\n                });\n            }\n            // If the point is outside the plot area, destroy it. #678, #820\n            if (dataLabel && (!enabled || !defined(str))) {\n                point.dataLabel = dataLabel = dataLabel.destroy();\n                if (connector) {\n                    point.connector = connector.destroy();\n                }\n            // Individual labels are disabled if the are explicitly disabled\n            // in the point options, or if they fall outside the plot area.\n            } else if (enabled && defined(str)) {\n                // create new label\n                if (!dataLabel) {\n                    dataLabel = point.dataLabel = rotation ?\n\n                        renderer\n                            .text( // labels don't rotate\n                                str,\n                                0,\n                                -9999,\n                                options.useHTML\n                            )\n                            .addClass('highcharts-data-label') :\n\n                        renderer.label(\n                            str,\n                            0,\n                            -9999,\n                            options.shape,\n                            null,\n                            null,\n                            options.useHTML,\n                            null,\n                            'data-label'\n                        );\n\n                    dataLabel.addClass(\n                        ' highcharts-data-label-color-' + point.colorIndex +\n                        ' ' + (options.className || '') +\n                        (options.useHTML ? ' highcharts-tracker' : '') // #3398\n                    );\n                } else {\n                    attr.text = str;\n                }\n                dataLabel.attr(attr);\n                \n\n                if (!dataLabel.added) {\n                    dataLabel.add(dataLabelsGroup);\n                }\n                // Now the data label is created and placed at 0,0, so we need\n                // to align it\n                series.alignDataLabel(point, dataLabel, options, null, isNew);\n            }\n        });\n    }\n\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent(this, 'afterDrawDataLabels');\n};\n\n/**\n * Align each individual data label.\n *\n * @function Highcharts.Series#alignDataLabel\n *\n * @param  {Highcharts.Point} point\n *\n * @param  {Highcharts.SVGElement} dataLabel\n *\n * @param  {Highcharts.PlotSeriesDataLabelsOptions} options\n *\n * @param  {Highcharts.BBoxObject} alignTo\n *\n * @param  {boolean} isNew\n *\n * @return {void}\n */\nSeries.prototype.alignDataLabel = function (\n    point,\n    dataLabel,\n    options,\n    alignTo,\n    isNew\n) {\n    var chart = this.chart,\n        inverted = chart.inverted,\n        plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX, -9999),\n        plotY = pick(point.plotY, -9999),\n        bBox = dataLabel.getBBox(),\n        fontSize,\n        baseline,\n        rotation = options.rotation,\n        normRotation,\n        negRotation,\n        align = options.align,\n        rotCorr, // rotation correction\n        // Math.round for rounding errors (#2683), alignTo to allow column\n        // labels (#2700)\n        visible =\n            this.visible &&\n            (\n                point.series.forceDL ||\n                chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||\n                (\n                    alignTo && chart.isInsidePlot(\n                        plotX,\n                        inverted ?\n                            alignTo.x + 1 :\n                            alignTo.y + alignTo.height - 1,\n                        inverted\n                    )\n                )\n            ),\n        alignAttr, // the final position;\n        justify = pick(options.overflow, 'justify') === 'justify';\n\n    if (visible) {\n\n        \n\n        baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;\n\n        // The alignment box is a singular point\n        alignTo = extend({\n            x: inverted ? this.yAxis.len - plotY : plotX,\n            y: Math.round(inverted ? this.xAxis.len - plotX : plotY),\n            width: 0,\n            height: 0\n        }, alignTo);\n\n        // Add the text size for alignment calculation\n        extend(options, {\n            width: bBox.width,\n            height: bBox.height\n        });\n\n        // Allow a hook for changing alignment in the last moment, then do the\n        // alignment\n        if (rotation) {\n            justify = false; // Not supported for rotated text\n            rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n            alignAttr = {\n                x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                y: (\n                    alignTo.y +\n                    options.y +\n                    { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] *\n                        alignTo.height\n                )\n            };\n            dataLabel[isNew ? 'attr' : 'animate'](alignAttr)\n                .attr({ // #3003\n                    align: align\n                });\n\n            // Compensate for the rotated label sticking out on the sides\n            normRotation = (rotation + 720) % 360;\n            negRotation = normRotation > 180 && normRotation < 360;\n\n            if (align === 'left') {\n                alignAttr.y -= negRotation ? bBox.height : 0;\n            } else if (align === 'center') {\n                alignAttr.x -= bBox.width / 2;\n                alignAttr.y -= bBox.height / 2;\n            } else if (align === 'right') {\n                alignAttr.x -= bBox.width;\n                alignAttr.y -= negRotation ? 0 : bBox.height;\n            }\n            dataLabel.placed = true;\n            dataLabel.alignAttr = alignAttr;\n\n        } else {\n            dataLabel.align(options, null, alignTo);\n            alignAttr = dataLabel.alignAttr;\n        }\n\n        // Handle justify or crop\n        if (justify && alignTo.height >= 0) { // #8830\n            point.isLabelJustified = this.justifyDataLabel(\n                dataLabel,\n                options,\n                alignAttr,\n                bBox,\n                alignTo,\n                isNew\n            );\n\n        // Now check that the data label is within the plot area\n        } else if (pick(options.crop, true)) {\n            visible =\n                chart.isInsidePlot(\n                    alignAttr.x,\n                    alignAttr.y\n                ) &&\n                chart.isInsidePlot(\n                    alignAttr.x + bBox.width,\n                    alignAttr.y + bBox.height\n                );\n        }\n\n        // When we're using a shape, make it possible with a connector or an\n        // arrow pointing to thie point\n        if (options.shape && !rotation) {\n            dataLabel[isNew ? 'attr' : 'animate']({\n                anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,\n                anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY\n            });\n        }\n    }\n\n    // Show or hide based on the final aligned position\n    if (!visible) {\n        dataLabel.attr({ y: -9999 });\n        dataLabel.placed = false; // don't animate back in\n    }\n\n};\n\n/**\n * If data labels fall partly outside the plot area, align them back in, in a\n * way that doesn't hide the point.\n *\n * @function Highcharts.Series#justifyDataLabel\n *\n * @param  {Highcharts.SVGElement} dataLabel\n *\n * @param  {Highcharts.PlotSeriesDataLabelsOptions} options\n *\n * @param  {Highcharts.DataLabelAlignObject} alignAttr\n *\n * @param  {Highcharts.BBoxObject} bBox\n *\n * @param  {boolean} isNew\n *\n * @return {boolean}\n */\nSeries.prototype.justifyDataLabel = function (\n    dataLabel,\n    options,\n    alignAttr,\n    bBox,\n    alignTo,\n    isNew\n) {\n    var chart = this.chart,\n        align = options.align,\n        verticalAlign = options.verticalAlign,\n        off,\n        justified,\n        padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n    // Off left\n    off = alignAttr.x + padding;\n    if (off < 0) {\n        if (align === 'right') {\n            options.align = 'left';\n        } else {\n            options.x = -off;\n        }\n        justified = true;\n    }\n\n    // Off right\n    off = alignAttr.x + bBox.width - padding;\n    if (off > chart.plotWidth) {\n        if (align === 'left') {\n            options.align = 'right';\n        } else {\n            options.x = chart.plotWidth - off;\n        }\n        justified = true;\n    }\n\n    // Off top\n    off = alignAttr.y + padding;\n    if (off < 0) {\n        if (verticalAlign === 'bottom') {\n            options.verticalAlign = 'top';\n        } else {\n            options.y = -off;\n        }\n        justified = true;\n    }\n\n    // Off bottom\n    off = alignAttr.y + bBox.height - padding;\n    if (off > chart.plotHeight) {\n        if (verticalAlign === 'top') {\n            options.verticalAlign = 'bottom';\n        } else {\n            options.y = chart.plotHeight - off;\n        }\n        justified = true;\n    }\n\n    if (justified) {\n        dataLabel.placed = !isNew;\n        dataLabel.align(options, null, alignTo);\n    }\n\n    return justified;\n};\n\nif (seriesTypes.pie) {\n    /**\n     * Override the base drawDataLabels method by pie specific functionality\n     *\n     * @function Highcharts.seriesTypes.pie#drawDataLabels\n     *\n     * @return {void}\n     */\n    seriesTypes.pie.prototype.drawDataLabels = function () {\n        var series = this,\n            data = series.data,\n            point,\n            chart = series.chart,\n            options = series.options.dataLabels,\n            connectorPadding = pick(options.connectorPadding, 10),\n            connectorWidth = pick(options.connectorWidth, 1),\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            maxWidth = Math.round(chart.chartWidth / 3),\n            connector,\n            seriesCenter = series.center,\n            radius = seriesCenter[2] / 2,\n            centerY = seriesCenter[1],\n            dataLabel,\n            dataLabelWidth,\n            labelPos,\n            labelHeight,\n            // divide the points into right and left halves for anti collision\n            halves = [\n                [], // right\n                []  // left\n            ],\n            x,\n            y,\n            visibility,\n            j,\n            overflow = [0, 0, 0, 0]; // top, right, bottom, left\n\n        // get out if not enabled\n        if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n            return;\n        }\n\n        // Reset all labels that have been shortened\n        each(data, function (point) {\n            if (point.dataLabel && point.visible && point.dataLabel.shortened) {\n                point.dataLabel\n                    .attr({\n                        width: 'auto'\n                    }).css({\n                        width: 'auto',\n                        textOverflow: 'clip'\n                    });\n                point.dataLabel.shortened = false;\n            }\n        });\n\n\n        // run parent method\n        Series.prototype.drawDataLabels.apply(series);\n\n        each(data, function (point) {\n            if (point.dataLabel) {\n\n                if (point.visible) { // #407, #2510\n\n                    // Arrange points for detection collision\n                    halves[point.half].push(point);\n\n                    // Reset positions (#4905)\n                    point.dataLabel._pos = null;\n\n                    // Avoid long labels squeezing the pie size too far down\n                    \n                        if (point.dataLabel.getBBox().width > maxWidth) {\n                            point.dataLabel.css({\n                                // Use a fraction of the maxWidth to avoid\n                                // wrapping close to the end of the string.\n                                width: maxWidth * 0.7\n                            });\n                            point.dataLabel.shortened = true;\n                        }\n                    \n                } else {\n                    point.dataLabel = point.dataLabel.destroy();\n                }\n            }\n        });\n\n        /* Loop over the points in each half, starting from the top and bottom\n         * of the pie to detect overlapping labels.\n         */\n        each(halves, function (points, i) {\n\n            var top,\n                bottom,\n                length = points.length,\n                positions = [],\n                naturalY,\n                sideOverflow,\n                size,\n                distributionLength;\n\n            if (!length) {\n                return;\n            }\n\n            // Sort by angle\n            series.sortByAngle(points, i - 0.5);\n            // Only do anti-collision when we have dataLabels outside the pie\n            // and have connectors. (#856)\n            if (series.maxLabelDistance > 0) {\n                top = Math.max(\n                    0,\n                    centerY - radius - series.maxLabelDistance\n                );\n                bottom = Math.min(\n                    centerY + radius + series.maxLabelDistance,\n                    chart.plotHeight\n                );\n                each(points, function (point) {\n                    // check if specific points' label is outside the pie\n                    if (point.labelDistance > 0 && point.dataLabel) {\n                        // point.top depends on point.labelDistance value\n                        // Used for calculation of y value in getX method\n                        point.top = Math.max(\n                            0,\n                            centerY - radius - point.labelDistance\n                        );\n                        point.bottom = Math.min(\n                            centerY + radius + point.labelDistance,\n                            chart.plotHeight\n                        );\n                        size = point.dataLabel.getBBox().height || 21;\n\n                        // point.positionsIndex is needed for getting index of\n                        // parameter related to specific point inside positions\n                        // array - not every point is in positions array.\n                        point.distributeBox = {\n                            target: point.labelPos[1] - point.top + size / 2,\n                            size: size,\n                            rank: point.y\n                        };\n                        positions.push(point.distributeBox);\n                    }\n                });\n                distributionLength = bottom + size - top;\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].distribute(\n                    positions,\n                    distributionLength,\n                    distributionLength / 5\n                );\n            }\n\n            // Now the used slots are sorted, fill them up sequentially\n            for (j = 0; j < length; j++) {\n\n                point = points[j];\n                labelPos = point.labelPos;\n                dataLabel = point.dataLabel;\n                visibility = point.visible === false ? 'hidden' : 'inherit';\n                naturalY = labelPos[1];\n                y = naturalY;\n\n                if (positions && defined(point.distributeBox)) {\n                    if (point.distributeBox.pos === undefined) {\n                        visibility = 'hidden';\n                    } else {\n                        labelHeight = point.distributeBox.size;\n                        y = point.top + point.distributeBox.pos;\n                    }\n                }\n\n                // It is needed to delete point.positionIndex for\n                // dynamically added points etc.\n\n                delete point.positionIndex;\n\n                // get the x - use the natural x position for labels near the\n                // top and bottom, to prevent the top and botton slice\n                // connectors from touching each other on either side\n                if (options.justify) {\n                    x = seriesCenter[0] +\n                        (i ? -1 : 1) * (radius + point.labelDistance);\n                } else {\n                    x = series.getX(\n                        y < point.top + 2 || y > point.bottom - 2 ?\n                            naturalY :\n                            y,\n                        i,\n                        point\n                    );\n                }\n\n\n                // Record the placement and visibility\n                dataLabel._attr = {\n                    visibility: visibility,\n                    align: labelPos[6]\n                };\n                dataLabel._pos = {\n                    x: (\n                        x +\n                        options.x +\n                        ({\n                            left: connectorPadding,\n                            right: -connectorPadding\n                        }[labelPos[6]] || 0)\n                    ),\n\n                    // 10 is for the baseline (label vs text)\n                    y: y + options.y - 10\n                };\n                labelPos.x = x;\n                labelPos.y = y;\n\n\n                // Detect overflowing data labels\n                if (pick(options.crop, true)) {\n                    dataLabelWidth = dataLabel.getBBox().width;\n\n                    sideOverflow = null;\n                    // Overflow left\n                    if (\n                        x - dataLabelWidth < connectorPadding &&\n                        i === 1 // left half\n                    ) {\n                        sideOverflow = Math.round(\n                            dataLabelWidth - x + connectorPadding\n                        );\n                        overflow[3] = Math.max(sideOverflow, overflow[3]);\n\n                    // Overflow right\n                    } else if (\n                        x + dataLabelWidth > plotWidth - connectorPadding &&\n                        i === 0 // right half\n                    ) {\n                        sideOverflow = Math.round(\n                            x + dataLabelWidth - plotWidth + connectorPadding\n                        );\n                        overflow[1] = Math.max(sideOverflow, overflow[1]);\n                    }\n\n                    // Overflow top\n                    if (y - labelHeight / 2 < 0) {\n                        overflow[0] = Math.max(\n                            Math.round(-y + labelHeight / 2),\n                            overflow[0]\n                        );\n\n                    // Overflow left\n                    } else if (y + labelHeight / 2 > plotHeight) {\n                        overflow[2] = Math.max(\n                            Math.round(y + labelHeight / 2 - plotHeight),\n                            overflow[2]\n                        );\n                    }\n                    dataLabel.sideOverflow = sideOverflow;\n                }\n            } // for each point\n        }); // for each half\n\n        // Do not apply the final placement and draw the connectors until we\n        // have verified that labels are not spilling over.\n        if (\n            arrayMax(overflow) === 0 ||\n            this.verifyDataLabelOverflow(overflow)\n        ) {\n\n            // Place the labels in the final position\n            this.placeDataLabels();\n\n            // Draw the connectors\n            if (connectorWidth) {\n                each(this.points, function (point) {\n                    var isNew;\n\n                    connector = point.connector;\n                    dataLabel = point.dataLabel;\n\n                    if (\n                        dataLabel &&\n                        dataLabel._pos &&\n                        point.visible &&\n                        point.labelDistance > 0\n                    ) {\n                        visibility = dataLabel._attr.visibility;\n\n                        isNew = !connector;\n\n                        if (isNew) {\n                            point.connector = connector = chart.renderer.path()\n                                .addClass('highcharts-data-label-connector ' +\n                                    ' highcharts-color-' + point.colorIndex +\n                                    (\n                                        point.className ?\n                                            ' ' + point.className :\n                                            ''\n                                    )\n                                )\n                                .add(series.dataLabelsGroup);\n\n                            \n                        }\n                        connector[isNew ? 'attr' : 'animate']({\n                            d: series.connectorPath(point.labelPos)\n                        });\n                        connector.attr('visibility', visibility);\n\n                    } else if (connector) {\n                        point.connector = connector.destroy();\n                    }\n                });\n            }\n        }\n    };\n\n    /**\n     * Extendable method for getting the path of the connector between the data\n     * label and the pie slice.\n     *\n     * @function Highcharts.seriesTypes.pie#connectorPath\n     *\n     * @param  {Highcharts.DataLabelPiePosObject} labelPos\n     *\n     * @return {Highcharts.PathObject}\n     */\n    seriesTypes.pie.prototype.connectorPath = function (labelPos) {\n        var x = labelPos.x,\n            y = labelPos.y;\n        return pick(this.options.dataLabels.softConnector, true) ? [\n            'M',\n            // end of the string at the label\n            x + (labelPos[6] === 'left' ? 5 : -5), y,\n            'C',\n            x, y, // first break, next to the label\n            2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n            labelPos[2], labelPos[3], // second break\n            'L',\n            labelPos[4], labelPos[5] // base\n        ] : [\n            'M',\n            // end of the string at the label\n            x + (labelPos[6] === 'left' ? 5 : -5), y,\n            'L',\n            labelPos[2], labelPos[3], // second break\n            'L',\n            labelPos[4], labelPos[5] // base\n        ];\n    };\n\n    /**\n     * Perform the final placement of the data labels after we have verified\n     * that they fall within the plot area.\n     *\n     * @function Highcharts.seriesTypes.pie#placeDataLabels\n     *\n     * @return {void}\n     */\n    seriesTypes.pie.prototype.placeDataLabels = function () {\n        each(this.points, function (point) {\n            var dataLabel = point.dataLabel,\n                _pos;\n            if (dataLabel && point.visible) {\n                _pos = dataLabel._pos;\n                if (_pos) {\n\n                    // Shorten data labels with ellipsis if they still overflow\n                    // after the pie has reached minSize (#223).\n                    if (dataLabel.sideOverflow) {\n                        dataLabel._attr.width =\n                            dataLabel.getBBox().width - dataLabel.sideOverflow;\n\n                        dataLabel.css({\n                            width: dataLabel._attr.width + 'px',\n                            textOverflow: (\n                                (this.options.dataLabels.style || {})\n                                    .textOverflow ||\n                                'ellipsis'\n                            )\n                        });\n                        dataLabel.shortened = true;\n                    }\n\n                    dataLabel.attr(dataLabel._attr);\n                    dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                    dataLabel.moved = true;\n                } else if (dataLabel) {\n                    dataLabel.attr({ y: -9999 });\n                }\n            }\n        }, this);\n    };\n\n    seriesTypes.pie.prototype.alignDataLabel = noop;\n\n    /**\n     * Verify whether the data labels are allowed to draw, or we should run more\n     * translation and data label positioning to keep them inside the plot area.\n     * Returns true when data labels are ready to draw.\n     *\n     * @function Highcharts.seriesTypes.pie#verifyDataLabelOverflow\n     *\n     * @param  {boolean} overflow\n     *\n     * @return {boolean}\n     */\n    seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n        var center = this.center,\n            options = this.options,\n            centerOption = options.center,\n            minSize = options.minSize || 80,\n            newSize = minSize,\n            // If a size is set, return true and don't try to shrink the pie\n            // to fit the labels.\n            ret = options.size !== null;\n\n        if (!ret) {\n            // Handle horizontal size and center\n            if (centerOption[0] !== null) { // Fixed center\n                newSize = Math.max(center[2] -\n                    Math.max(overflow[1], overflow[3]), minSize);\n\n            } else { // Auto center\n                newSize = Math.max(\n                    // horizontal overflow\n                    center[2] - overflow[1] - overflow[3],\n                    minSize\n                );\n                // horizontal center\n                center[0] += (overflow[3] - overflow[1]) / 2;\n            }\n\n            // Handle vertical size and center\n            if (centerOption[1] !== null) { // Fixed center\n                newSize = Math.max(Math.min(newSize, center[2] -\n                    Math.max(overflow[0], overflow[2])), minSize);\n\n            } else { // Auto center\n                newSize = Math.max(\n                    Math.min(\n                        newSize,\n                        // vertical overflow\n                        center[2] - overflow[0] - overflow[2]\n                    ),\n                    minSize\n                );\n                // vertical center\n                center[1] += (overflow[0] - overflow[2]) / 2;\n            }\n\n            // If the size must be decreased, we need to run translate and\n            // drawDataLabels again\n            if (newSize < center[2]) {\n                center[2] = newSize;\n                center[3] = Math.min( // #3632\n                    relativeLength(options.innerSize || 0, newSize),\n                    newSize\n                );\n                this.translate(center);\n\n                if (this.drawDataLabels) {\n                    this.drawDataLabels();\n                }\n            // Else, return true to indicate that the pie and its labels is\n            // within the plot area\n            } else {\n                ret = true;\n            }\n        }\n        return ret;\n    };\n}\n\nif (seriesTypes.column) {\n\n    /**\n     * Override the basic data label alignment by adjusting for the position of\n     * the column.\n     *\n     * @function Highcharts.seriesTypes.column#alignDataLabel\n     *\n     * @param  {Highcharts.Point} point\n     *\n     * @param  {Highcharts.SVGElement} dataLabel\n     *\n     * @param  {Highcharts.PlotSeriesDataLabelsOptions} options\n     *\n     * @param  {Highcharts.BBoxObject} alignTo\n     *\n     * @param  {boolean} isNew\n     *\n     * @return {void}\n     */\n    seriesTypes.column.prototype.alignDataLabel = function (\n        point,\n        dataLabel,\n        options,\n        alignTo,\n        isNew\n    ) {\n        var inverted = this.chart.inverted,\n            series = point.series,\n            // data label box for alignment\n            dlBox = point.dlBox || point.shapeArgs,\n            below = pick(\n                point.below, // range series\n                point.plotY > pick(this.translatedThreshold, series.yAxis.len)\n            ),\n            // draw it inside the box?\n            inside = pick(options.inside, !!this.options.stacking),\n            overshoot;\n\n        // Align to the column itself, or the top of it\n        if (dlBox) { // Area range uses this method but not alignTo\n            alignTo = merge(dlBox);\n\n            if (alignTo.y < 0) {\n                alignTo.height += alignTo.y;\n                alignTo.y = 0;\n            }\n            overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n            if (overshoot > 0) {\n                alignTo.height -= overshoot;\n            }\n\n            if (inverted) {\n                alignTo = {\n                    x: series.yAxis.len - alignTo.y - alignTo.height,\n                    y: series.xAxis.len - alignTo.x - alignTo.width,\n                    width: alignTo.height,\n                    height: alignTo.width\n                };\n            }\n\n            // Compute the alignment box\n            if (!inside) {\n                if (inverted) {\n                    alignTo.x += below ? 0 : alignTo.width;\n                    alignTo.width = 0;\n                } else {\n                    alignTo.y += below ? alignTo.height : 0;\n                    alignTo.height = 0;\n                }\n            }\n        }\n\n\n        // When alignment is undefined (typically columns and bars), display the\n        // individual point below or above the point depending on the threshold\n        options.align = pick(\n            options.align,\n            !inverted || inside ? 'center' : below ? 'right' : 'left'\n        );\n        options.verticalAlign = pick(\n            options.verticalAlign,\n            inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n        );\n\n        // Call the parent method\n        Series.prototype.alignDataLabel.call(\n            this,\n            point,\n            dataLabel,\n            options,\n            alignTo,\n            isNew\n        );\n\n        // If label was justified and we have contrast, set it:\n        if (point.isLabelJustified && point.contrastColor) {\n            point.dataLabel.css({\n                color: point.contrastColor\n            });\n        }\n    };\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/DataLabels.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/DateTimeAxis.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/DateTimeAxis.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    getMagnitude = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMagnitude,\n    normalizeTickInterval = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeTickInterval,\n    timeUnits = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timeUnits;\n/**\n * Set the tick positions to a time unit that makes sense, for example\n * on the first of each month or on every Monday. Return an array\n * with the time positions. Used in datetime axes as well as for grouping\n * data on a datetime axis.\n *\n * @param {Object} normalizedInterval\n *        The interval in axis values (ms) and thecount\n * @param {Number} min The minimum in axis values\n * @param {Number} max The maximum in axis values\n * @param {Number} startOfWeek\n * @ignore\n */\nAxis.prototype.getTimeTicks = function () {\n    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n};\n\n/**\n * Get a normalized tick interval for dates. Returns a configuration object with\n * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n * of segments in stock charts, the normalizing logic was extracted in order to\n * prevent it for running over again for each segment having the same interval.\n * #662, #697.\n *\n * @ignore\n */\nAxis.prototype.normalizeTimeTickInterval = function (\n    tickInterval,\n    unitsOption\n) {\n    var units = unitsOption || [[\n            'millisecond', // unit name\n            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n        ], [\n            'second',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'minute',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'hour',\n            [1, 2, 3, 4, 6, 8, 12]\n        ], [\n            'day',\n            [1, 2]\n        ], [\n            'week',\n            [1, 2]\n        ], [\n            'month',\n            [1, 2, 3, 4, 6]\n        ], [\n            'year',\n            null\n        ]],\n        unit = units[units.length - 1], // default unit is years\n        interval = timeUnits[unit[0]],\n        multiples = unit[1],\n        count,\n        i;\n\n    // loop through the units to find the one that best fits the tickInterval\n    for (i = 0; i < units.length; i++) {\n        unit = units[i];\n        interval = timeUnits[unit[0]];\n        multiples = unit[1];\n\n\n        if (units[i + 1]) {\n            // lessThan is in the middle between the highest multiple and the\n            // next unit.\n            var lessThan = (interval * multiples[multiples.length - 1] +\n                        timeUnits[units[i + 1][0]]) / 2;\n\n            // break and keep the current unit\n            if (tickInterval <= lessThan) {\n                break;\n            }\n        }\n    }\n\n    // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n    if (interval === timeUnits.year && tickInterval < 5 * interval) {\n        multiples = [1, 2, 5];\n    }\n\n    // get the count\n    count = normalizeTickInterval(\n        tickInterval / interval,\n        multiples,\n        unit[0] === 'year' ?\n            Math.max(getMagnitude(tickInterval / interval), 1) : // #1913, #2360\n            1\n    );\n\n    return {\n        unitRange: interval,\n        count: count,\n        unitName: unit[0]\n    };\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/DateTimeAxis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Dynamics.js":
/*!*****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Dynamics.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    animate = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animate,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    erase = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    setAnimation = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setAnimation,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat;\n\n// Extend the Chart prototype for dynamic methods\nextend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n    /**\n     * Add a series to the chart after render time. Note that this method should\n     * never be used when adding data synchronously at chart render time, as it\n     * adds expense to the calculations and rendering. When adding data at the\n     * same time as the chart is initialized, add the series as a configuration\n     * option instead. With multiple axes, the `offset` is dynamically adjusted.\n     *\n     * @sample highcharts/members/chart-addseries/\n     *         Add a series from a button\n     * @sample stock/members/chart-addseries/\n     *         Add a series in Highstock\n     *\n     * @function Highcharts.Chart#addSeries\n     *\n     * @param {Highcharts.SeriesOptions} options\n     *        The config options for the series.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after adding.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @return {Highcharts.Series}\n     *         The newly created series object.\n     *\n     * @fires Highcharts.Chart#event:addSeries\n     * @fires Highcharts.Chart#event:afterAddSeries\n     */\n    addSeries: function (options, redraw, animation) {\n        var series,\n            chart = this;\n\n        if (options) {\n            redraw = pick(redraw, true); // defaults to true\n\n            fireEvent(chart, 'addSeries', { options: options }, function () {\n                series = chart.initSeries(options);\n\n                chart.isDirtyLegend = true;\n                chart.linkSeries();\n\n                fireEvent(chart, 'afterAddSeries');\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            });\n        }\n\n        return series;\n    },\n\n    /**\n     * Add an axis to the chart after render time. Note that this method should\n     * never be used when adding data synchronously at chart render time, as it\n     * adds expense to the calculations and rendering. When adding data at the\n     * same time as the chart is initialized, add the axis as a configuration\n     * option instead.\n     *\n     * @sample highcharts/members/chart-addaxis/\n     *         Add and remove axes\n     *\n     * @function Highcharts.Chart#addAxis\n     *\n     * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options\n     *        The axis options.\n     *\n     * @param {boolean} [isX=false]\n     *        Whether it is an X axis or a value axis.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after adding.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n     *        Whether and how to apply animation in the redraw.\n     *\n     * @return {Highcharts.Axis}\n     *         The newly generated Axis object.\n     */\n    addAxis: function (options, isX, redraw, animation) {\n        var key = isX ? 'xAxis' : 'yAxis',\n            chartOptions = this.options,\n            userOptions = merge(options, {\n                index: this[key].length,\n                isX: isX\n            }),\n            axis;\n\n        axis = new Axis(this, userOptions);\n\n        // Push the new axis options to the chart options\n        chartOptions[key] = splat(chartOptions[key] || {});\n        chartOptions[key].push(userOptions);\n\n        if (pick(redraw, true)) {\n            this.redraw(animation);\n        }\n\n        return axis;\n    },\n\n    /**\n     * Dim the chart and show a loading text or symbol. Options for the loading\n     * screen are defined in {@link\n     * https://api.highcharts.com/highcharts/loading|the loading options}.\n     *\n     * @sample highcharts/members/chart-hideloading/\n     *         Show and hide loading from a button\n     * @sample highcharts/members/chart-showloading/\n     *         Apply different text labels\n     * @sample stock/members/chart-show-hide-loading/\n     *         Toggle loading in Highstock\n     *\n     * @function Highcharts.Chart#showLoading\n     *\n     * @param {string} str\n     *        An optional text to show in the loading label instead of the\n     *        default one. The default text is set in\n     *        {@link http://api.highcharts.com/highcharts/lang.loading|lang.loading}.\n     */\n    showLoading: function (str) {\n        var chart = this,\n            options = chart.options,\n            loadingDiv = chart.loadingDiv,\n            loadingOptions = options.loading,\n            setLoadingSize = function () {\n                if (loadingDiv) {\n                    css(loadingDiv, {\n                        left: chart.plotLeft + 'px',\n                        top: chart.plotTop + 'px',\n                        width: chart.plotWidth + 'px',\n                        height: chart.plotHeight + 'px'\n                    });\n                }\n            };\n\n        // create the layer at the first call\n        if (!loadingDiv) {\n            chart.loadingDiv = loadingDiv = createElement('div', {\n                className: 'highcharts-loading highcharts-loading-hidden'\n            }, null, chart.container);\n\n            chart.loadingSpan = createElement(\n                'span',\n                { className: 'highcharts-loading-inner' },\n                null,\n                loadingDiv\n            );\n            addEvent(chart, 'redraw', setLoadingSize); // #1080\n        }\n\n        loadingDiv.className = 'highcharts-loading';\n\n        // Update text\n        chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n        \n\n        chart.loadingShown = true;\n        setLoadingSize();\n    },\n\n    /**\n     * Hide the loading layer.\n     *\n     * @see Highcharts.Chart#showLoading\n     *\n     * @sample highcharts/members/chart-hideloading/\n     *         Show and hide loading from a button\n     * @sample stock/members/chart-show-hide-loading/\n     *         Toggle loading in Highstock\n     *\n     * @function Highcharts.Chart#hideLoading\n     */\n    hideLoading: function () {\n\n        var options = this.options,\n            loadingDiv = this.loadingDiv;\n\n        if (loadingDiv) {\n            loadingDiv.className =\n                'highcharts-loading highcharts-loading-hidden';\n            \n        }\n\n        this.loadingShown = false;\n    },\n\n    /**\n     * These properties cause isDirtyBox to be set to true when updating. Can be\n     * extended from plugins.\n     */\n    propsRequireDirtyBox: [\n        'backgroundColor',\n        'borderColor',\n        'borderWidth',\n        'margin',\n        'marginTop',\n        'marginRight',\n        'marginBottom',\n        'marginLeft',\n        'spacing',\n        'spacingTop',\n        'spacingRight',\n        'spacingBottom',\n        'spacingLeft',\n        'borderRadius',\n        'plotBackgroundColor',\n        'plotBackgroundImage',\n        'plotBorderColor',\n        'plotBorderWidth',\n        'plotShadow',\n        'shadow'\n    ],\n\n    /**\n     * These properties cause all series to be updated when updating. Can be\n     * extended from plugins.\n     */\n    propsRequireUpdateSeries: [\n        'chart.inverted',\n        'chart.polar',\n        'chart.ignoreHiddenSeries',\n        'chart.type',\n        'colors',\n        'plotOptions',\n        'time',\n        'tooltip'\n    ],\n\n    /**\n     * A generic function to update any element of the chart. Elements can be\n     * enabled and disabled, moved, re-styled, re-formatted etc.\n     *\n     * A special case is configuration objects that take arrays, for example\n     * {@link https://api.highcharts.com/highcharts/xAxis|xAxis},\n     * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or\n     * {@link https://api.highcharts.com/highcharts/series|series}. For these\n     * collections, an `id` option is used to map the new option set to an\n     * existing object. If an existing object of the same id is not found, the\n     * corresponding item is updated. So for example, running `chart.update`\n     * with a series item without an id, will cause the existing chart's series\n     * with the same index in the series array to be updated. When the\n     * `oneToOne` parameter is true, `chart.update` will also take care of\n     * adding and removing items from the collection. Read more under the\n     * parameter description below.\n     *\n     * See also the\n     * {@link https://api.highcharts.com/highcharts/responsive|responsive option set}.\n     * Switching between `responsive.rules` basically runs `chart.update` under\n     * the hood.\n     *\n     * @sample highcharts/members/chart-update/\n     *         Update chart geometry\n     *\n     * @function Highcharts.Chart#update\n     *\n     * @param {Highcharts.Options} options\n     *        A configuration object for the new chart options.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart.\n     *\n     * @param {boolean} [oneToOne=false]\n     *        When `true`, the `series`, `xAxis` and `yAxis` collections will\n     *        be updated one to one, and items will be either added or removed\n     *        to match the new updated options. For example, if the chart has\n     *        two series and we call `chart.update` with a configuration\n     *        containing three series, one will be added. If we call\n     *        `chart.update` with one series, one will be removed. Setting an\n     *        empty `series` array will remove all series, but leaving out the\n     *        `series` property will leave all series untouched. If the series\n     *        have id's, the new series options will be matched by id, and the\n     *        remaining ones removed.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @fires Highcharts.Chart#event:update\n     * @fires Highcharts.Chart#event:afterUpdate\n     */\n    update: function (options, redraw, oneToOne, animation) {\n        var chart = this,\n            adders = {\n                credits: 'addCredits',\n                title: 'setTitle',\n                subtitle: 'setSubtitle'\n            },\n            optionsChart = options.chart,\n            updateAllAxes,\n            updateAllSeries,\n            newWidth,\n            newHeight,\n            itemsForRemoval = [];\n\n        fireEvent(chart, 'update', { options: options });\n\n        // If the top-level chart option is present, some special updates are\n        // required\n        if (optionsChart) {\n            merge(true, chart.options.chart, optionsChart);\n\n            // Setter function\n            if ('className' in optionsChart) {\n                chart.setClassName(optionsChart.className);\n            }\n\n            if ('reflow' in optionsChart) {\n                chart.setReflow(optionsChart.reflow);\n            }\n\n            if (\n                'inverted' in optionsChart ||\n                'polar' in optionsChart ||\n                'type' in optionsChart\n            ) {\n                // Parse options.chart.inverted and options.chart.polar together\n                // with the available series.\n                chart.propFromSeries();\n                updateAllAxes = true;\n            }\n\n            if ('alignTicks' in optionsChart) { // #6452\n                updateAllAxes = true;\n            }\n\n            objectEach(optionsChart, function (val, key) {\n                if (\n                    inArray('chart.' + key, chart.propsRequireUpdateSeries) !==\n                    -1\n                ) {\n                    updateAllSeries = true;\n                }\n                // Only dirty box\n                if (inArray(key, chart.propsRequireDirtyBox) !== -1) {\n                    chart.isDirtyBox = true;\n                }\n            });\n\n            \n        }\n\n        // Moved up, because tooltip needs updated plotOptions (#6218)\n        \n\n        if (options.plotOptions) {\n            merge(true, this.options.plotOptions, options.plotOptions);\n        }\n\n        // Some option stuctures correspond one-to-one to chart objects that\n        // have update methods, for example\n        // options.credits => chart.credits\n        // options.legend => chart.legend\n        // options.title => chart.title\n        // options.tooltip => chart.tooltip\n        // options.subtitle => chart.subtitle\n        // options.mapNavigation => chart.mapNavigation\n        // options.navigator => chart.navigator\n        // options.scrollbar => chart.scrollbar\n        objectEach(options, function (val, key) {\n            if (chart[key] && typeof chart[key].update === 'function') {\n                chart[key].update(val, false);\n\n            // If a one-to-one object does not exist, look for an adder function\n            } else if (typeof chart[adders[key]] === 'function') {\n                chart[adders[key]](val);\n            }\n\n            if (\n                key !== 'chart' &&\n                inArray(key, chart.propsRequireUpdateSeries) !== -1\n            ) {\n                updateAllSeries = true;\n            }\n        });\n\n        // Setters for collections. For axes and series, each item is referred\n        // by an id. If the id is not found, it defaults to the corresponding\n        // item in the collection, so setting one series without an id, will\n        // update the first series in the chart. Setting two series without\n        // an id will update the first and the second respectively (#6019)\n        // chart.update and responsive.\n        each([\n            'xAxis',\n            'yAxis',\n            'zAxis',\n            'series',\n            'colorAxis',\n            'pane'\n        ], function (coll) {\n            var indexMap;\n\n            if (options[coll]) {\n\n                // In stock charts, the navigator series are also part of the\n                // chart.series array, but those series should not be handled\n                // here (#8196).\n                if (coll === 'series') {\n                    indexMap = [];\n                    each(chart[coll], function (s, i) {\n                        if (!s.options.isInternal) {\n                            indexMap.push(i);\n                        }\n                    });\n                }\n\n\n                each(splat(options[coll]), function (newOptions, i) {\n                    var item = (\n                        defined(newOptions.id) &&\n                        chart.get(newOptions.id)\n                    ) || chart[coll][indexMap ? indexMap[i] : i];\n                    if (item && item.coll === coll) {\n                        item.update(newOptions, false);\n\n                        if (oneToOne) {\n                            item.touched = true;\n                        }\n                    }\n\n                    // If oneToOne and no matching item is found, add one\n                    if (!item && oneToOne) {\n                        if (coll === 'series') {\n                            chart.addSeries(newOptions, false)\n                                .touched = true;\n                        } else if (coll === 'xAxis' || coll === 'yAxis') {\n                            chart.addAxis(newOptions, coll === 'xAxis', false)\n                                .touched = true;\n                        }\n                    }\n\n                });\n\n                // Add items for removal\n                if (oneToOne) {\n                    each(chart[coll], function (item) {\n                        if (!item.touched && !item.options.isInternal) {\n                            itemsForRemoval.push(item);\n                        } else {\n                            delete item.touched;\n                        }\n                    });\n                }\n\n\n            }\n        });\n\n        each(itemsForRemoval, function (item) {\n            item.remove(false);\n        });\n\n        if (updateAllAxes) {\n            each(chart.axes, function (axis) {\n                axis.update({}, false);\n            });\n        }\n\n        // Certain options require the whole series structure to be thrown away\n        // and rebuilt\n        if (updateAllSeries) {\n            each(chart.series, function (series) {\n                series.update({}, false);\n            });\n        }\n\n        // For loading, just update the options, do not redraw\n        if (options.loading) {\n            merge(true, chart.options.loading, options.loading);\n        }\n\n        // Update size. Redraw is forced.\n        newWidth = optionsChart && optionsChart.width;\n        newHeight = optionsChart && optionsChart.height;\n        if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||\n                (isNumber(newHeight) && newHeight !== chart.chartHeight)) {\n            chart.setSize(newWidth, newHeight, animation);\n        } else if (pick(redraw, true)) {\n            chart.redraw(animation);\n        }\n\n        fireEvent(chart, 'afterUpdate', { options: options });\n\n    },\n\n    /**\n     * Shortcut to set the subtitle options. This can also be done from {@link\n     * Chart#update} or {@link Chart#setTitle}.\n     *\n     * @function Highcharts.Chart#setSubtitle\n     *\n     * @param {Highcharts.SubtitleOptions} options\n     *        New subtitle options. The subtitle text itself is set by the\n     *        `options.text` property.\n     */\n    setSubtitle: function (options) {\n        this.setTitle(undefined, options);\n    }\n\n\n});\n\n// extend the Point prototype for dynamic methods\nextend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n    /**\n     * Update point with new options (typically x/y data) and optionally redraw\n     * the series.\n     *\n     * @sample highcharts/members/point-update-column/\n     *         Update column value\n     * @sample highcharts/members/point-update-pie/\n     *         Update pie slice\n     * @sample maps/members/point-update/\n     *         Update map area value in Highmaps\n     *\n     * @function Highcharts.Point#update\n     *\n     * @param {*} options\n     *        The point options. Point options are handled as described under\n     *        the `series.type.data` item for each series type. For example\n     *        for a line series, if options is a single number, the point will\n     *        be given that number as the main y value. If it is an array, it\n     *        will be interpreted as x and y values respectively. If it is an\n     *        object, advanced options are applied.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is updated. If doing\n     *        more operations on the chart, it is best practice to set\n     *        `redraw` to false and call `chart.redraw()` after.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=true]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @fires Highcharts.Point#event:update\n     */\n    update: function (options, redraw, animation, runEvent) {\n        var point = this,\n            series = point.series,\n            graphic = point.graphic,\n            i,\n            chart = series.chart,\n            seriesOptions = series.options;\n\n        redraw = pick(redraw, true);\n\n        function update() {\n\n            point.applyOptions(options);\n\n            // Update visuals\n            if (point.y === null && graphic) { // #4146\n                point.graphic = graphic.destroy();\n            }\n            if (isObject(options, true)) {\n                // Destroy so we can get new elements\n                if (graphic && graphic.element) {\n                    // \"null\" is also a valid symbol\n                    if (\n                        options &&\n                        options.marker &&\n                        options.marker.symbol !== undefined\n                    ) {\n                        point.graphic = graphic.destroy();\n                    }\n                }\n                if (options && options.dataLabels && point.dataLabel) { // #2468\n                    point.dataLabel = point.dataLabel.destroy();\n                }\n                if (point.connector) {\n                    point.connector = point.connector.destroy(); // #7243\n                }\n            }\n\n            // record changes in the parallel arrays\n            i = point.index;\n            series.updateParallelArrays(point, i);\n\n            // Record the options to options.data. If the old or the new config\n            // is an object, use point options, otherwise use raw options\n            // (#4701, #4916).\n            seriesOptions.data[i] = (\n                    isObject(seriesOptions.data[i], true) ||\n                    isObject(options, true)\n                ) ?\n                point.options :\n                pick(options, seriesOptions.data[i]);\n\n            // redraw\n            series.isDirty = series.isDirtyData = true;\n            if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                chart.isDirtyBox = true;\n            }\n\n            if (seriesOptions.legendType === 'point') { // #1831, #1885\n                chart.isDirtyLegend = true;\n            }\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        }\n\n        // Fire the event with a default handler of doing the update\n        if (runEvent === false) { // When called from setData\n            update();\n        } else {\n            point.firePointEvent('update', { options: options }, update);\n        }\n    },\n\n    /**\n     * Remove a point and optionally redraw the series and if necessary the axes\n     *\n     * @sample highcharts/plotoptions/series-point-events-remove/\n     *         Remove point and confirm\n     * @sample highcharts/members/point-remove/\n     *         Remove pie slice\n     * @sample maps/members/point-remove/\n     *         Remove selected points in Highmaps\n     *\n     * @function Highcharts.Point#remove\n     *\n     * @param {boolean} redraw\n     *        Whether to redraw the chart or wait for an explicit call. When\n     *        doing more operations on the chart, for example running\n     *        `point.remove()` in a loop, it is best practice to set `redraw`\n     *        to false and call `chart.redraw()` after.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=false]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     */\n    remove: function (redraw, animation) {\n        this.series.removePoint(\n            inArray(this, this.series.data),\n            redraw,\n            animation\n        );\n    }\n});\n\n// Extend the series prototype for dynamic methods\nextend(Series.prototype, /** @lends Series.prototype */ {\n    /**\n     * Add a point to the series after render time. The point can be added at\n     * the end, or by giving it an X value, to the start or in the middle of the\n     * series.\n     *\n     * @sample highcharts/members/series-addpoint-append/\n     *         Append point\n     * @sample highcharts/members/series-addpoint-append-and-shift/\n     *         Append and shift\n     * @sample highcharts/members/series-addpoint-x-and-y/\n     *         Both X and Y values given\n     * @sample highcharts/members/series-addpoint-pie/\n     *         Append pie slice\n     * @sample stock/members/series-addpoint/\n     *         Append 100 points in Highstock\n     * @sample stock/members/series-addpoint-shift/\n     *         Append and shift in Highstock\n     * @sample maps/members/series-addpoint/\n     *         Add a point in Highmaps\n     *\n     * @function Highcharts.Series#addPoint\n     *\n     * @param {number|Array<number>|*} options\n     *        The point options. If options is a single number, a point with\n     *        that y value is appended to the series. If it is an array, it will\n     *        be interpreted as x and y values respectively. If it is an\n     *        object, advanced options as outlined under `series.data` are\n     *        applied.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is added. When adding\n     *        more than one point, it is highly recommended that the redraw\n     *        option be set to false, and instead {@link Chart#redraw} is\n     *        explicitly called after the adding of points is finished.\n     *        Otherwise, the chart will redraw after adding each point.\n     *\n     * @param {boolean} [shift=false]\n     *        If true, a point is shifted off the start of the series as one is\n     *        appended to the end.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     */\n    addPoint: function (options, redraw, shift, animation) {\n        var series = this,\n            seriesOptions = series.options,\n            data = series.data,\n            chart = series.chart,\n            xAxis = series.xAxis,\n            names = xAxis && xAxis.hasNames && xAxis.names,\n            dataOptions = seriesOptions.data,\n            point,\n            isInTheMiddle,\n            xData = series.xData,\n            i,\n            x;\n\n        // Optional redraw, defaults to true\n        redraw = pick(redraw, true);\n\n        // Get options and push the point to xData, yData and series.options. In\n        // series.generatePoints the Point instance will be created on demand\n        // and pushed to the series.data array.\n        point = { series: series };\n        series.pointClass.prototype.applyOptions.apply(point, [options]);\n        x = point.x;\n\n        // Get the insertion point\n        i = xData.length;\n        if (series.requireSorting && x < xData[i - 1]) {\n            isInTheMiddle = true;\n            while (i && xData[i - 1] > x) {\n                i--;\n            }\n        }\n\n        // Insert undefined item\n        series.updateParallelArrays(point, 'splice', i, 0, 0);\n        // Update it\n        series.updateParallelArrays(point, i);\n\n        if (names && point.name) {\n            names[x] = point.name;\n        }\n        dataOptions.splice(i, 0, options);\n\n        if (isInTheMiddle) {\n            series.data.splice(i, 0, null);\n            series.processData();\n        }\n\n        // Generate points to be added to the legend (#1329)\n        if (seriesOptions.legendType === 'point') {\n            series.generatePoints();\n        }\n\n        // Shift the first point off the parallel arrays\n        if (shift) {\n            if (data[0] && data[0].remove) {\n                data[0].remove(false);\n            } else {\n                data.shift();\n                series.updateParallelArrays(point, 'shift');\n\n                dataOptions.shift();\n            }\n        }\n\n        // redraw\n        series.isDirty = true;\n        series.isDirtyData = true;\n\n        if (redraw) {\n            chart.redraw(animation); // Animation is set anyway on redraw, #5665\n        }\n    },\n\n    /**\n     * Remove a point from the series. Unlike the\n     * {@link Highcharts.Point#remove} method, this can also be done on a point\n     * that is not instanciated because it is outside the view or subject to\n     * Highstock data grouping.\n     *\n     * @sample highcharts/members/series-removepoint/\n     *         Remove cropped point\n     *\n     * @function Highcharts.Series#removePoint\n     *\n     * @param {number} i\n     *        The index of the point in the {@link Highcharts.Series.data|data}\n     *        array.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is added. When\n     *        removing more than one point, it is highly recommended that the\n     *        `redraw` option be set to `false`, and instead {@link\n     *        Highcharts.Chart#redraw} is explicitly called after the adding of\n     *        points is finished.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]\n     *        Whether and optionally how the series should be animated.\n     *\n     * @fires Highcharts.Point#event:remove\n     */\n    removePoint: function (i, redraw, animation) {\n\n        var series = this,\n            data = series.data,\n            point = data[i],\n            points = series.points,\n            chart = series.chart,\n            remove = function () {\n\n                if (points && points.length === data.length) { // #4935\n                    points.splice(i, 1);\n                }\n                data.splice(i, 1);\n                series.options.data.splice(i, 1);\n                series.updateParallelArrays(\n                    point || { series: series },\n                    'splice',\n                    i,\n                    1\n                );\n\n                if (point) {\n                    point.destroy();\n                }\n\n                // redraw\n                series.isDirty = true;\n                series.isDirtyData = true;\n                if (redraw) {\n                    chart.redraw();\n                }\n            };\n\n        setAnimation(animation, chart);\n        redraw = pick(redraw, true);\n\n        // Fire the event with a default handler of removing the point\n        if (point) {\n            point.firePointEvent('remove', null, remove);\n        } else {\n            remove();\n        }\n    },\n\n    /**\n     * Remove a series and optionally redraw the chart.\n     *\n     * @sample highcharts/members/series-remove/\n     *         Remove first series from a button\n     *\n     * @function Highcharts.Series#remove\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart or wait for an explicit call to\n     *        {@link Highcharts.Chart#redraw}.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animation]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @param {boolean} [withEvent=true]\n     *        Used internally, whether to fire the series `remove` event.\n     *\n     * @fires Highcharts.Series#event:remove\n     */\n    remove: function (redraw, animation, withEvent) {\n        var series = this,\n            chart = series.chart;\n\n        function remove() {\n\n            // Destroy elements\n            series.destroy();\n\n            // Redraw\n            chart.isDirtyLegend = chart.isDirtyBox = true;\n            chart.linkSeries();\n\n            if (pick(redraw, true)) {\n                chart.redraw(animation);\n            }\n        }\n\n        // Fire the event with a default handler of removing the point\n        if (withEvent !== false) {\n            fireEvent(series, 'remove', null, remove);\n        } else {\n            remove();\n        }\n    },\n\n    /**\n     * Update the series with a new set of options. For a clean and precise\n     * handling of new options, all methods and elements from the series are\n     * removed, and it is initiated from scratch. Therefore, this method is more\n     * performance expensive than some other utility methods like {@link\n     * Series#setData} or {@link Series#setVisible}.\n     *\n     * @sample highcharts/members/series-update/\n     *         Updating series options\n     * @sample maps/members/series-update/\n     *         Update series options in Highmaps\n     *\n     * @function Highcharts.Series#update\n     *\n     * @param {Highcharts.SeriesOptions} options\n     *        New options that will be merged with the series' existing options.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the series is altered. If doing\n     *        more operations on the chart, it is a good idea to set redraw to\n     *        false and call {@link Chart#redraw} after.\n     *\n     * @fires Highcharts.Series#event:afterUpdate\n     */\n    update: function (newOptions, redraw) {\n        var series = this,\n            chart = series.chart,\n            // must use user options when changing type because series.options\n            // is merged in with type specific plotOptions\n            oldOptions = series.userOptions,\n            oldType = series.oldType || series.type,\n            newType = (\n                newOptions.type ||\n                oldOptions.type ||\n                chart.options.chart.type\n            ),\n            proto = seriesTypes[oldType].prototype,\n            n,\n            groups = [\n                'group',\n                'markerGroup',\n                'dataLabelsGroup'\n            ],\n            preserve = [\n                'navigatorSeries',\n                'baseSeries'\n            ],\n\n            // Animation must be enabled when calling update before the initial\n            // animation has first run. This happens when calling update\n            // directly after chart initialization, or when applying responsive\n            // rules (#6912).\n            animation = series.finishedAnimating && { animation: false },\n            allowSoftUpdate = [\n                'data',\n                'name',\n                'turboThreshold'\n            ],\n            keys = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keys(newOptions),\n            doSoftUpdate = keys.length > 0;\n\n        // Running Series.update to update the data only is an intuitive usage,\n        // so we want to make sure that when used like this, we run the\n        // cheaper setData function and allow animation instead of completely\n        // recreating the series instance. This includes sideways animation when\n        // adding points to the data set. The `name` should also support soft\n        // update because the data module sets name and data when setting new\n        // data by `chart.update`.\n        each(keys, function (key) {\n            if (inArray(key, allowSoftUpdate) === -1) {\n                doSoftUpdate = false;\n            }\n        });\n        if (doSoftUpdate) {\n            if (newOptions.data) {\n                this.setData(newOptions.data, false);\n            }\n            if (newOptions.name) {\n                this.setName(newOptions.name, false);\n            }\n        } else {\n\n            // Make sure preserved properties are not destroyed (#3094)\n            preserve = groups.concat(preserve);\n            each(preserve, function (prop) {\n                preserve[prop] = series[prop];\n                delete series[prop];\n            });\n\n            // Do the merge, with some forced options\n            newOptions = merge(oldOptions, animation, {\n                index: series.index,\n                pointStart: pick(\n                    oldOptions.pointStart, // when updating from blank (#7933)\n                    series.xData[0] // when updating after addPoint\n                )\n            }, { data: series.options.data }, newOptions);\n\n            // Destroy the series and delete all properties. Reinsert all\n            // methods and properties from the new type prototype (#2270,\n            // #3719).\n            series.remove(false, null, false);\n            for (n in proto) {\n                series[n] = undefined;\n            }\n            if (seriesTypes[newType || oldType]) {\n                extend(series, seriesTypes[newType || oldType].prototype);\n            } else {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(17, true);\n            }\n\n            // Re-register groups (#3094) and other preserved properties\n            each(preserve, function (prop) {\n                series[prop] = preserve[prop];\n            });\n\n            series.init(chart, newOptions);\n\n            // Update the Z index of groups (#3380, #7397)\n            if (newOptions.zIndex !== oldOptions.zIndex) {\n                each(groups, function (groupName) {\n                    if (series[groupName]) {\n                        series[groupName].attr({\n                            zIndex: newOptions.zIndex\n                        });\n                    }\n                });\n            }\n\n\n            series.oldType = oldType;\n            chart.linkSeries(); // Links are lost in series.remove (#3028)\n\n        }\n        fireEvent(this, 'afterUpdate');\n\n        if (pick(redraw, true)) {\n            chart.redraw(doSoftUpdate ? undefined : false);\n        }\n    },\n\n    /**\n     * Used from within series.update\n     *\n     * @private\n     * @function Highcharts.Series#setName\n     *\n     * @param {string} name\n     */\n    setName: function (name) {\n        this.name = this.options.name = this.userOptions.name = name;\n        this.chart.isDirtyLegend = true;\n    }\n});\n\n// Extend the Axis.prototype for dynamic methods\nextend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n    /**\n     * Update an axis object with a new set of options. The options are merged\n     * with the existing options, so only new or altered options need to be\n     * specified.\n     *\n     * @sample highcharts/members/axis-update/\n     *         Axis update demo\n     *\n     * @function Highcharts.Axis#update\n     *\n     * @param {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} options\n     *        The new options that will be merged in with existing options on\n     *        the axis.\n     */\n    update: function (options, redraw) {\n        var chart = this.chart,\n            newEvents = ((options && options.events) || {});\n\n        options = merge(this.userOptions, options);\n\n        // Color Axis is not an array,\n        // This change is applied in the ColorAxis wrapper\n        if (chart.options[this.coll].indexOf) {\n            // Don't use this.options.index,\n            // StockChart has Axes in navigator too\n            chart.options[this.coll][\n                chart.options[this.coll].indexOf(this.userOptions)\n            ] = options;\n        }\n\n        // Remove old events, if no new exist (#8161)\n        objectEach(chart.options[this.coll].events, function (fn, ev) {\n            if (typeof newEvents[ev] === 'undefined') {\n                newEvents[ev] = undefined;\n            }\n        });\n\n        this.destroy(true);\n        this.init(chart, extend(options, { events: newEvents }));\n\n        chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Remove the axis from the chart.\n     *\n     * @sample highcharts/members/chart-addaxis/\n     *         Add and remove axes\n     *\n     * @function Highcharts.Axis#remove\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart following the remove.\n     */\n    remove: function (redraw) {\n        var chart = this.chart,\n            key = this.coll, // xAxis or yAxis\n            axisSeries = this.series,\n            i = axisSeries.length;\n\n        // Remove associated series (#2687)\n        while (i--) {\n            if (axisSeries[i]) {\n                axisSeries[i].remove(false);\n            }\n        }\n\n        // Remove the axis\n        erase(chart.axes, this);\n        erase(chart[key], this);\n\n        if (isArray(chart.options[key])) {\n            chart.options[key].splice(this.options.index, 1);\n        } else { // color axis, #6488\n            delete chart.options[key];\n        }\n\n        each(chart[key], function (axis, i) { // Re-index, #1706, #8075\n            axis.options.index = axis.userOptions.index = i;\n        });\n        this.destroy();\n        chart.isDirtyBox = true;\n\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Update the axis title by options after render time.\n     *\n     * @sample highcharts/members/axis-settitle/\n     *         Set a new Y axis title\n     *\n     * @function Highcharts.Axis#setTitle\n     *\n     * @param {Highcharts.XAxisTitleOptions|Highcharts.YAxisTitleOptions|Highcharts.ZAxisTitleOptions} titleOptions\n     *        The additional title options.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after setting the title.\n     */\n    setTitle: function (titleOptions, redraw) {\n        this.update({ title: titleOptions }, redraw);\n    },\n\n    /**\n     * Set new axis categories and optionally redraw.\n     *\n     * @sample highcharts/members/axis-setcategories/\n     *         Set categories by click on a button\n     *\n     * @function Highcharts.Axis#setCategories\n     *\n     * @param {Array<string>} categories\n     *        The new categories.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart.\n     */\n    setCategories: function (categories, redraw) {\n        this.update({ categories: categories }, redraw);\n    }\n\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Dynamics.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/FlagsSeries.js":
/*!********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/FlagsSeries.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _SvgRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/* harmony import */ var _mixins_on_series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mixins/on-series.js */ \"./node_modules/highcharts/js/es-modules/mixins/on-series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    Renderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    SVGRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer,\n    TrackerMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TrackerMixin,\n    VMLRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VMLRenderer,\n    symbols = SVGRenderer.prototype.symbols;\n\n/**\n * The Flags series.\n *\n * @constructor seriesTypes.flags\n * @augments seriesTypes.column\n */\n/**\n * Flags are used to mark events in stock charts. They can be added on the\n * timeline, or attached to a specific series.\n *\n * @sample       stock/demo/flags-general/ Flags on a line series\n * @extends      {plotOptions.column}\n * @excluding    animation,borderColor,borderRadius,borderWidth,colorByPoint,\n *               dataGrouping,pointPadding,pointWidth,turboThreshold\n * @product      highstock\n * @optionparent plotOptions.flags\n */\nseriesType('flags', 'column', {\n\n    /**\n     * In case the flag is placed on a series, on what point key to place\n     * it. Line and columns have one key, `y`. In range or OHLC-type series,\n     * however, the flag can optionally be placed on the `open`, `high`,\n     *  `low` or `close` key.\n     *\n     * @validvalue [\"y\", \"open\", \"high\", \"low\", \"close\"]\n     * @type       {String}\n     * @sample     {highstock} stock/plotoptions/flags-onkey/\n     *             Range series, flag on high\n     * @default    y\n     * @since      4.2.2\n     * @product    highstock\n     * @apioption  plotOptions.flags.onKey\n     */\n\n    /**\n     * The id of the series that the flags should be drawn on. If no id\n     * is given, the flags are drawn on the x axis.\n     *\n     * @type      {String}\n     * @sample    {highstock} stock/plotoptions/flags/\n     *            Flags on series and on x axis\n     * @default   undefined\n     * @product   highstock\n     * @apioption plotOptions.flags.onSeries\n     */\n\n    pointRange: 0, // #673\n\n    /**\n     * Whether the flags are allowed to overlap sideways. If `false`, the flags\n     * are moved sideways using an algorithm that seeks to place every flag as\n     * close as possible to its original position.\n     *\n     * @sample {highstock} stock/plotoptions/flags-allowoverlapx\n     *         Allow sideways overlap\n     * @since  6.0.4\n     */\n    allowOverlapX: false,\n\n    /**\n     * The shape of the marker. Can be one of \"flag\", \"circlepin\", \"squarepin\",\n     * or an image of the format `url(/path-to-image.jpg)`. Individual\n     * shapes can also be set for each point.\n     *\n     * @validvalue [\"flag\", \"circlepin\", \"squarepin\"]\n     * @sample     {highstock} stock/plotoptions/flags/ Different shapes\n     * @product    highstock\n     */\n    shape: 'flag',\n\n    /**\n     * When multiple flags in the same series fall on the same value, this\n     * number determines the vertical offset between them.\n     *\n     * @sample  {highstock} stock/plotoptions/flags-stackdistance/\n     *          A greater stack distance\n     * @product highstock\n     */\n    stackDistance: 12,\n\n    /**\n     * Text alignment for the text inside the flag.\n     *\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @since      5.0.0\n     * @product    highstock\n     */\n    textAlign: 'center',\n\n    /**\n     * Specific tooltip options for flag series. Flag series tooltips are\n     * different from most other types in that a flag doesn't have a data\n     * value, so the tooltip rather displays the `text` option for each\n     * point.\n     *\n     * @type      {Object}\n     * @extends   plotOptions.series.tooltip\n     * @excluding changeDecimals,valueDecimals,valuePrefix,valueSuffix\n     * @product   highstock\n     */\n    tooltip: {\n        pointFormat: '{point.text}<br/>'\n    },\n\n    threshold: null,\n\n    /**\n     * The text to display on each flag. This can be defined on series level,\n     *  or individually for each point. Defaults to `\"A\"`.\n     *\n     * @type      {String}\n     * @default   A\n     * @product   highstock\n     * @apioption plotOptions.flags.title\n     */\n\n    /**\n     * The y position of the top left corner of the flag relative to either\n     * the series (if onSeries is defined), or the x axis. Defaults to\n     * `-30`.\n     *\n     * @product highstock\n     */\n    y: -30,\n\n    /**\n     * Whether to use HTML to render the flag texts. Using HTML allows for\n     * advanced formatting, images and reliable bi-directional text rendering.\n     * Note that exported images won't respect the HTML, and that HTML\n     * won't respect Z-index settings.\n     *\n     * @type      {Boolean}\n     * @default   false\n     * @since     1.3\n     * @product   highstock\n     * @apioption plotOptions.flags.useHTML\n     */\n\n    /**\n     * Fixed width of the flag's shape. By default, width is autocalculated\n     * according to the flag's title.\n     *\n     * @type      {Number}\n     * @default   undefined\n     * @product   highstock\n     * @sample    {highstock} stock/demo/flags-shapes/ Flags with fixed width\n     * @apioption plotOptions.flags.width\n     */\n\n     /**\n     * Fixed height of the flag's shape. By default, height is autocalculated\n     * according to the flag's title.\n     *\n     * @type      {Number}\n     * @default   undefined\n     * @product   highstock\n     * @apioption plotOptions.flags.height\n     */\n\n    \n\n}, /** @lends seriesTypes.flags.prototype */ {\n    sorted: false,\n    noSharedTooltip: true,\n    allowDG: false,\n    takeOrdinalPosition: false, // #1074\n    trackerGroups: ['markerGroup'],\n    forceCrop: true,\n    /**\n     * Inherit the initialization from base Series.\n     */\n    init: Series.prototype.init,\n\n    \n\n    translate: _mixins_on_series_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translate,\n    getPlotBox: _mixins_on_series_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getPlotBox,\n\n    /**\n     * Draw the markers\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            chart = series.chart,\n            renderer = chart.renderer,\n            plotX,\n            plotY,\n            inverted = chart.inverted,\n            options = series.options,\n            optionsY = options.y,\n            shape,\n            i,\n            point,\n            graphic,\n            stackIndex,\n            anchorY,\n            attribs,\n            outsideRight,\n            yAxis = series.yAxis,\n            boxesMap = {},\n            boxes = [];\n\n        i = points.length;\n        while (i--) {\n            point = points[i];\n            outsideRight =\n                (inverted ? point.plotY : point.plotX) > series.xAxis.len;\n            plotX = point.plotX;\n            stackIndex = point.stackIndex;\n            shape = point.options.shape || options.shape;\n            plotY = point.plotY;\n\n            if (plotY !== undefined) {\n                plotY = point.plotY + optionsY -\n                    (\n                        stackIndex !== undefined &&\n                        stackIndex * options.stackDistance\n                    );\n            }\n            // skip connectors for higher level stacked points\n            point.anchorX = stackIndex ? undefined : point.plotX;\n            anchorY = stackIndex ? undefined : point.plotY;\n\n            graphic = point.graphic;\n\n            // Only draw the point if y is defined and the flag is within\n            // the visible area\n            if (plotY !== undefined && plotX >= 0 && !outsideRight) {\n\n                // Create the flag\n                if (!graphic) {\n                    graphic = point.graphic = renderer.label(\n                        '',\n                        null,\n                        null,\n                        shape,\n                        null,\n                        null,\n                        options.useHTML\n                    )\n                    \n                    .attr({\n                        align: shape === 'flag' ? 'left' : 'center',\n                        width: options.width,\n                        height: options.height,\n                        'text-align': options.textAlign\n                    })\n                    .addClass('highcharts-point')\n                    .add(series.markerGroup);\n\n                    // Add reference to the point for tracker (#6303)\n                    if (point.graphic.div) {\n                        point.graphic.div.point = point;\n                    }\n\n                    \n                    graphic.isNew = true;\n                }\n\n                if (plotX > 0) { // #3119\n                    plotX -= graphic.strokeWidth() % 2; // #4285\n                }\n\n                // Plant the flag\n                attribs = {\n                    y: plotY,\n                    anchorY: anchorY\n                };\n                if (options.allowOverlapX) {\n                    attribs.x = plotX;\n                    attribs.anchorX = point.anchorX;\n                }\n                graphic.attr({\n                    text: point.options.title || options.title || 'A'\n                })[graphic.isNew ? 'attr' : 'animate'](attribs);\n\n                // Rig for the distribute function\n                if (!options.allowOverlapX) {\n                    if (!boxesMap[point.plotX]) {\n                        boxesMap[point.plotX] = {\n                            align: 0,\n                            size: graphic.width,\n                            target: plotX,\n                            anchorX: plotX\n                        };\n                    } else {\n                        boxesMap[point.plotX].size = Math.max(\n                            boxesMap[point.plotX].size,\n                            graphic.width\n                        );\n                    }\n                }\n\n                // Set the tooltip anchor position\n                point.tooltipPos = [\n                    plotX,\n                    plotY + yAxis.pos - chart.plotTop\n                ]; // #6327\n\n            } else if (graphic) {\n                point.graphic = graphic.destroy();\n            }\n\n        }\n\n        // Handle X-dimension overlapping\n        if (!options.allowOverlapX) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(boxesMap, function (box) {\n                box.plotX = box.anchorX;\n                boxes.push(box);\n            });\n\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].distribute(boxes, inverted ? yAxis.len : this.xAxis.len, 100);\n\n            each(points, function (point) {\n                var box = point.graphic && boxesMap[point.plotX];\n                if (box) {\n                    point.graphic[point.graphic.isNew ? 'attr' : 'animate']({\n                        x: box.pos,\n                        anchorX: point.anchorX\n                    });\n                    // Hide flag when its box position is not specified (#8573)\n                    if (!box.pos) {\n                        point.graphic.attr({\n                            x: -9999,\n                            anchorX: -9999\n                        });\n                        point.graphic.isNew = true;\n                    } else {\n                        point.graphic.isNew = false;\n                    }\n                }\n            });\n        }\n\n        // Might be a mix of SVG and HTML and we need events for both (#6303)\n        if (options.useHTML) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap(series.markerGroup, 'on', function (proceed) {\n                return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement.prototype.on.apply(\n                    // for HTML\n                    proceed.apply(this, [].slice.call(arguments, 1)),\n                    // and for SVG\n                    [].slice.call(arguments, 1));\n            });\n        }\n\n    },\n\n    /**\n     * Extend the column trackers with listeners to expand and contract stacks\n     */\n    drawTracker: function () {\n        var series = this,\n            points = series.points;\n\n        TrackerMixin.drawTrackerPoint.apply(this);\n\n        /**\n         * Bring each stacked flag up on mouse over, this allows readability\n         * of vertically stacked elements as well as tight points on\n         * the x axis. #1924.\n         */\n        each(points, function (point) {\n            var graphic = point.graphic;\n            if (graphic) {\n                addEvent(graphic.element, 'mouseover', function () {\n\n                    // Raise this point\n                    if (point.stackIndex > 0 && !point.raised) {\n                        point._y = graphic.y;\n                        graphic.attr({\n                            y: point._y - 8\n                        });\n                        point.raised = true;\n                    }\n\n                    // Revert other raised points\n                    each(points, function (otherPoint) {\n                        if (\n                            otherPoint !== point &&\n                            otherPoint.raised &&\n                            otherPoint.graphic\n                        ) {\n                            otherPoint.graphic.attr({\n                                y: otherPoint._y\n                            });\n                            otherPoint.raised = false;\n                        }\n                    });\n                });\n            }\n        });\n    },\n\n    // Disable animation, but keep clipping (#8546):\n    animate: function (init) {\n        if (init) {\n            this.setClip();\n        } else {\n            this.animate = null;\n        }\n    },\n    setClip: function () {\n        Series.prototype.setClip.apply(this, arguments);\n        if (this.options.clip !== false && this.sharedClipKey) {\n            this.markerGroup.clip(this.chart[this.sharedClipKey]);\n        }\n    },\n    buildKDTree: noop,\n    /**\n     * Don't invert the flag marker group (#4960)\n     */\n    invertGroups: noop\n\n});\n\n// create the flag icon with anchor\nsymbols.flag = function (x, y, w, h, options) {\n    var anchorX = (options && options.anchorX) || x,\n        anchorY = (options && options.anchorY) || y;\n\n    return symbols.circle(anchorX - 1, anchorY - 1, 2, 2).concat(\n        [\n            'M', anchorX, anchorY,\n            'L', x, y + h,\n            x, y,\n            x + w, y,\n            x + w, y + h,\n            x, y + h,\n            'Z'\n        ]\n    );\n};\n\n/*\n * Create the circlepin and squarepin icons with anchor\n */\nfunction createPinSymbol(shape) {\n    symbols[shape + 'pin'] = function (x, y, w, h, options) {\n\n        var anchorX = options && options.anchorX,\n            anchorY = options && options.anchorY,\n            path,\n            labelTopOrBottomY;\n\n        // For single-letter flags, make sure circular flags are not taller\n        // than their width\n        if (shape === 'circle' && h > w) {\n            x -= Math.round((h - w) / 2);\n            w = h;\n        }\n\n        path = symbols[shape](x, y, w, h);\n\n        if (anchorX && anchorY) {\n            /**\n             * If the label is below the anchor, draw the connecting line\n             * from the top edge of the label\n             * otherwise start drawing from the bottom edge\n             */\n            labelTopOrBottomY = (y > anchorY) ? y : y + h;\n            path.push(\n                'M',\n                shape === 'circle' ? path[1] - path[4] : path[1] + path[4] / 2,\n                labelTopOrBottomY,\n                'L',\n                anchorX,\n                anchorY\n            );\n            path = path.concat(\n                symbols.circle(anchorX - 1, anchorY - 1, 2, 2)\n            );\n        }\n\n        return path;\n    };\n}\ncreatePinSymbol('circle');\ncreatePinSymbol('square');\n\n\n\n/**\n * A `flags` series. If the [type](#series.flags.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.flags\n * @excluding dataParser,dataURL\n * @product   highstock\n * @apioption series.flags\n */\n\n/**\n * An array of data points for the series. For the `flags` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.flags.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *     x: 1,\n *     title: \"A\",\n *     text: \"First event\"\n * }, {\n *     x: 1,\n *     title: \"B\",\n *     text: \"Second event\"\n * }]</pre>\n *\n * @type {Array<Object>}\n * @extends series.line.data\n * @excluding y,dataLabels,marker,name\n * @product highstock\n * @apioption series.flags.data\n */\n\n/**\n * The fill color of an individual flag. By default it inherits from\n * the series color.\n *\n * @type      {Color}\n * @product   highstock\n * @apioption series.flags.data.fillColor\n */\n\n/**\n * The longer text to be shown in the flag's tooltip.\n *\n * @type      {String}\n * @product   highstock\n * @apioption series.flags.data.text\n */\n\n/**\n * The short text to be shown on the flag.\n *\n * @type      {String}\n * @product   highstock\n * @apioption series.flags.data.title\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/FlagsSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Globals.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Globals.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/* global win, window */\n\n// glob is a temporary fix to allow our es-modules to work.\nvar glob = typeof win === 'undefined' ? window : win,\n    doc = glob.document,\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    userAgent = (glob.navigator && glob.navigator.userAgent) || '',\n    svg = (\n        doc &&\n        doc.createElementNS &&\n        !!doc.createElementNS(SVG_NS, 'svg').createSVGRect\n    ),\n    isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,\n    isFirefox = userAgent.indexOf('Firefox') !== -1,\n    isChrome = userAgent.indexOf('Chrome') !== -1,\n    hasBidiBug = (\n        isFirefox &&\n        parseInt(userAgent.split('Firefox/')[1], 10) < 4 // issue #38\n    );\n\nvar Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {\n    product: '@product.name@',\n    version: '@product.version@',\n    deg2rad: Math.PI * 2 / 360,\n    doc: doc,\n    hasBidiBug: hasBidiBug,\n    hasTouch: doc && doc.documentElement.ontouchstart !== undefined,\n    isMS: isMS,\n    isWebKit: userAgent.indexOf('AppleWebKit') !== -1,\n    isFirefox: isFirefox,\n    isChrome: isChrome,\n    isSafari: !isChrome && userAgent.indexOf('Safari') !== -1,\n    isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n    SVG_NS: SVG_NS,\n    chartCount: 0,\n    seriesTypes: {},\n    symbolSizes: {},\n    svg: svg,\n    win: glob,\n    marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n    noop: function () {\n        return undefined;\n    },\n    /**\n     * An array containing the current chart objects in the page. A chart's\n     * position in the array is preserved throughout the page's lifetime. When\n     * a chart is destroyed, the array item becomes `undefined`.\n     *\n     * @name Highcharts.charts\n     * @type {Array<Highcharts.Chart>}\n     */\n    charts: []\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Highcharts);\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Globals.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Html.js":
/*!*************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Html.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _SvgRenderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar attr = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].attr,\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    isFirefox = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFirefox,\n    isMS = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isMS,\n    isWebKit = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isWebKit,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    SVGElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement,\n    SVGRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n// Extend SvgElement for useHTML option\nextend(SVGElement.prototype, /** @lends SVGElement.prototype */ {\n    /**\n     * Apply CSS to HTML elements. This is used in text within SVG rendering and\n     * by the VML renderer\n     */\n    htmlCss: function (styles) {\n        var wrapper = this,\n            element = wrapper.element,\n            // When setting or unsetting the width style, we need to update\n            // transform (#8809)\n            isSettingWidth = (\n                element.tagName === 'SPAN' &&\n                styles &&\n                'width' in styles\n            ),\n            textWidth = pick(\n                isSettingWidth && styles.width,\n                undefined\n            );\n\n        if (isSettingWidth) {\n            delete styles.width;\n            wrapper.textWidth = textWidth;\n            wrapper.htmlUpdateTransform();\n        }\n        if (styles && styles.textOverflow === 'ellipsis') {\n            styles.whiteSpace = 'nowrap';\n            styles.overflow = 'hidden';\n        }\n        wrapper.styles = extend(wrapper.styles, styles);\n        css(wrapper.element, styles);\n\n        return wrapper;\n    },\n\n    /**\n     * VML and useHTML method for calculating the bounding box based on offsets\n     * @param {Boolean} refresh Whether to force a fresh value from the DOM or\n     * to use the cached value.\n     *\n     * @return {Object} A hash containing values for x, y, width and height\n     */\n\n    htmlGetBBox: function () {\n        var wrapper = this,\n            element = wrapper.element;\n\n        return {\n            x: element.offsetLeft,\n            y: element.offsetTop,\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    },\n\n    /**\n     * VML override private method to update elements based on internal\n     * properties based on SVG transform\n     */\n    htmlUpdateTransform: function () {\n        // aligning non added elements is expensive\n        if (!this.added) {\n            this.alignOnAdd = true;\n            return;\n        }\n\n        var wrapper = this,\n            renderer = wrapper.renderer,\n            elem = wrapper.element,\n            translateX = wrapper.translateX || 0,\n            translateY = wrapper.translateY || 0,\n            x = wrapper.x || 0,\n            y = wrapper.y || 0,\n            align = wrapper.textAlign || 'left',\n            alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n            styles = wrapper.styles,\n            whiteSpace = styles && styles.whiteSpace;\n\n        function getTextPxLength() {\n            // Reset multiline/ellipsis in order to read width (#4928,\n            // #5417)\n            css(elem, {\n                width: '',\n                whiteSpace: whiteSpace || 'nowrap'\n            });\n            return elem.offsetWidth;\n        }\n\n        // apply translate\n        css(elem, {\n            marginLeft: translateX,\n            marginTop: translateY\n        });\n\n        \n\n        // apply inversion\n        if (wrapper.inverted) { // wrapper is a group\n            each(elem.childNodes, function (child) {\n                renderer.invertChild(child, elem);\n            });\n        }\n\n        if (elem.tagName === 'SPAN') {\n\n            var rotation = wrapper.rotation,\n                baseline,\n                textWidth = wrapper.textWidth && pInt(wrapper.textWidth),\n                currentTextTransform = [\n                    rotation,\n                    align,\n                    elem.innerHTML,\n                    wrapper.textWidth,\n                    wrapper.textAlign\n                ].join(',');\n\n            // Update textWidth. Use the memoized textPxLength if possible, to\n            // avoid the getTextPxLength function using elem.offsetWidth.\n            // Calling offsetWidth affects rendering time as it forces layout\n            // (#7656).\n            if (\n                textWidth !== wrapper.oldTextWidth &&\n                (\n                    (textWidth > wrapper.oldTextWidth) ||\n                    (wrapper.textPxLength || getTextPxLength()) > textWidth\n                ) &&\n                /[ \\-]/.test(elem.textContent || elem.innerText)\n            ) { // #983, #1254\n                css(elem, {\n                    width: textWidth + 'px',\n                    display: 'block',\n                    whiteSpace: whiteSpace || 'normal' // #3331\n                });\n                wrapper.oldTextWidth = textWidth;\n                wrapper.hasBoxWidthChanged = true; // #8159\n            } else {\n                wrapper.hasBoxWidthChanged = false; // #8159\n            }\n\n            // Do the calculations and DOM access only if properties changed\n            if (currentTextTransform !== wrapper.cTT) {\n                baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                // Renderer specific handling of span rotation, but only if we\n                // have something to update.\n                if (\n                    defined(rotation) &&\n                    (\n                        (rotation !== (wrapper.oldRotation || 0)) ||\n                        (align !== wrapper.oldAlign)\n                    )\n                ) {\n                    wrapper.setSpanRotation(\n                        rotation,\n                        alignCorrection,\n                        baseline\n                    );\n                }\n\n                wrapper.getSpanCorrection(\n                    // Avoid elem.offsetWidth if we can, it affects rendering\n                    // time heavily (#7656)\n                    (\n                        (!defined(rotation) && wrapper.textPxLength) || // #7920\n                        elem.offsetWidth\n                    ),\n                    baseline,\n                    alignCorrection,\n                    rotation,\n                    align\n                );\n            }\n\n            // apply position with correction\n            css(elem, {\n                left: (x + (wrapper.xCorr || 0)) + 'px',\n                top: (y + (wrapper.yCorr || 0)) + 'px'\n            });\n\n            // record current text transform\n            wrapper.cTT = currentTextTransform;\n            wrapper.oldRotation = rotation;\n            wrapper.oldAlign = align;\n        }\n    },\n\n    /**\n     * Set the rotation of an individual HTML span\n     */\n    setSpanRotation: function (rotation, alignCorrection, baseline) {\n        var rotationStyle = {},\n            cssTransformKey = this.renderer.getTransformKey();\n\n        rotationStyle[cssTransformKey] = rotationStyle.transform =\n            'rotate(' + rotation + 'deg)';\n        rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] =\n        rotationStyle.transformOrigin =\n            (alignCorrection * 100) + '% ' + baseline + 'px';\n        css(this.element, rotationStyle);\n    },\n\n    /**\n     * Get the correction in X and Y positioning as the element is rotated.\n     */\n    getSpanCorrection: function (width, baseline, alignCorrection) {\n        this.xCorr = -width * alignCorrection;\n        this.yCorr = -baseline;\n    }\n});\n\n// Extend SvgRenderer for useHTML option.\nextend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {\n\n    getTransformKey: function () {\n        return isMS && !/Edge/.test(win.navigator.userAgent) ?\n            '-ms-transform' :\n            isWebKit ?\n                '-webkit-transform' :\n                isFirefox ?\n                    'MozTransform' :\n                    win.opera ?\n                        '-o-transform' :\n                        '';\n    },\n\n    /**\n     * Create HTML text node. This is used by the VML renderer as well as the\n     * SVG renderer through the useHTML option.\n     *\n     * @param {String} str\n     * @param {Number} x\n     * @param {Number} y\n     */\n    html: function (str, x, y) {\n        var wrapper = this.createElement('span'),\n            element = wrapper.element,\n            renderer = wrapper.renderer,\n            isSVG = renderer.isSVG,\n            addSetters = function (element, style) {\n                // These properties are set as attributes on the SVG group, and\n                // as identical CSS properties on the div. (#3542)\n                each(['opacity', 'visibility'], function (prop) {\n                    wrap(element, prop + 'Setter', function (\n                        proceed,\n                        value,\n                        key,\n                        elem\n                    ) {\n                        proceed.call(this, value, key, elem);\n                        style[key] = value;\n                    });\n                });\n                element.addedSetters = true;\n            };\n\n        // Text setter\n        wrapper.textSetter = function (value) {\n            if (value !== element.innerHTML) {\n                delete this.bBox;\n            }\n            this.textStr = value;\n            element.innerHTML = pick(value, '');\n            wrapper.doTransform = true;\n        };\n\n        // Add setters for the element itself (#4938)\n        if (isSVG) { // #4938, only for HTML within SVG\n            addSetters(wrapper, wrapper.element.style);\n        }\n\n        // Various setters which rely on update transform\n        wrapper.xSetter =\n        wrapper.ySetter =\n        wrapper.alignSetter =\n        wrapper.rotationSetter =\n        function (value, key) {\n            if (key === 'align') {\n                // Do not overwrite the SVGElement.align method. Same as VML.\n                key = 'textAlign';\n            }\n            wrapper[key] = value;\n            wrapper.doTransform = true;\n        };\n\n        // Runs at the end of .attr()\n        wrapper.afterSetters = function () {\n            // Update transform. Do this outside the loop to prevent redundant\n            // updating for batch setting of attributes.\n            if (this.doTransform) {\n                this.htmlUpdateTransform();\n                this.doTransform = false;\n            }\n        };\n\n        // Set the default attributes\n        wrapper\n            .attr({\n                text: str,\n                x: Math.round(x),\n                y: Math.round(y)\n            })\n            .css({\n                \n                position: 'absolute'\n            });\n\n        // Keep the whiteSpace style outside the wrapper.styles collection\n        element.style.whiteSpace = 'nowrap';\n\n        // Use the HTML specific .css method\n        wrapper.css = wrapper.htmlCss;\n\n        // This is specific for HTML within SVG\n        if (isSVG) {\n            wrapper.add = function (svgGroupWrapper) {\n\n                var htmlGroup,\n                    container = renderer.box.parentNode,\n                    parentGroup,\n                    parents = [];\n\n                this.parentGroup = svgGroupWrapper;\n\n                // Create a mock group to hold the HTML elements\n                if (svgGroupWrapper) {\n                    htmlGroup = svgGroupWrapper.div;\n                    if (!htmlGroup) {\n\n                        // Read the parent chain into an array and read from top\n                        // down\n                        parentGroup = svgGroupWrapper;\n                        while (parentGroup) {\n\n                            parents.push(parentGroup);\n\n                            // Move up to the next parent group\n                            parentGroup = parentGroup.parentGroup;\n                        }\n\n                        // Ensure dynamically updating position when any parent\n                        // is translated\n                        each(parents.reverse(), function (parentGroup) {\n                            var htmlGroupStyle,\n                                cls = attr(parentGroup.element, 'class');\n\n                            // Common translate setter for X and Y on the HTML\n                            // group. Reverted the fix for #6957 du to\n                            // positioning problems and offline export (#7254,\n                            // #7280, #7529)\n                            function translateSetter(value, key) {\n                                parentGroup[key] = value;\n\n                                if (key === 'translateX') {\n                                    htmlGroupStyle.left = value + 'px';\n                                } else {\n                                    htmlGroupStyle.top = value + 'px';\n                                }\n\n                                parentGroup.doTransform = true;\n                            }\n\n                            if (cls) {\n                                cls = { className: cls };\n                            } // else null\n\n                            // Create a HTML div and append it to the parent div\n                            // to emulate the SVG group structure\n                            htmlGroup =\n                            parentGroup.div =\n                            parentGroup.div || createElement('div', cls, {\n                                position: 'absolute',\n                                left: (parentGroup.translateX || 0) + 'px',\n                                top: (parentGroup.translateY || 0) + 'px',\n                                display: parentGroup.display,\n                                opacity: parentGroup.opacity, // #5075\n                                pointerEvents: (\n                                    parentGroup.styles &&\n                                    parentGroup.styles.pointerEvents\n                                ) // #5595\n\n                            // the top group is appended to container\n                            }, htmlGroup || container);\n\n                            // Shortcut\n                            htmlGroupStyle = htmlGroup.style;\n\n                            // Set listeners to update the HTML div's position\n                            // whenever the SVG group position is changed.\n                            extend(parentGroup, {\n                                // (#7287) Pass htmlGroup to use\n                                // the related group\n                                classSetter: (function (htmlGroup) {\n                                    return function (value) {\n                                        this.element.setAttribute(\n                                            'class',\n                                            value\n                                        );\n                                        htmlGroup.className = value;\n                                    };\n                                }(htmlGroup)),\n                                on: function () {\n                                    if (parents[0].div) { // #6418\n                                        wrapper.on.apply(\n                                            { element: parents[0].div },\n                                            arguments\n                                        );\n                                    }\n                                    return parentGroup;\n                                },\n                                translateXSetter: translateSetter,\n                                translateYSetter: translateSetter\n                            });\n                            if (!parentGroup.addedSetters) {\n                                addSetters(parentGroup, htmlGroupStyle);\n                            }\n                        });\n\n                    }\n                } else {\n                    htmlGroup = container;\n                }\n\n                htmlGroup.appendChild(element);\n\n                // Shared with VML:\n                wrapper.added = true;\n                if (wrapper.alignOnAdd) {\n                    wrapper.htmlUpdateTransform();\n                }\n\n                return wrapper;\n            };\n        }\n        return wrapper;\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Html.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Interaction.js":
/*!********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Interaction.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    hasTouch = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasTouch,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    Legend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    svg = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg,\n    TrackerMixin;\n\n/**\n * TrackerMixin for points and graphs.\n *\n * @ignore\n */\nTrackerMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TrackerMixin = {\n\n    /**\n     * Draw the tracker for a point.\n     */\n    drawTrackerPoint: function () {\n        var series = this,\n            chart = series.chart,\n            pointer = chart.pointer,\n            onMouseOver = function (e) {\n                var point = pointer.getPointFromEvent(e);\n                // undefined on graph in scatterchart\n                if (point !== undefined) {\n                    pointer.isDirectTouch = true;\n                    point.onMouseOver(e);\n                }\n            };\n\n        // Add reference to the point\n        each(series.points, function (point) {\n            if (point.graphic) {\n                point.graphic.element.point = point;\n            }\n            if (point.dataLabel) {\n                if (point.dataLabel.div) {\n                    point.dataLabel.div.point = point;\n                } else {\n                    point.dataLabel.element.point = point;\n                }\n            }\n        });\n\n        // Add the event listeners, we need to do this only once\n        if (!series._hasTracking) {\n            each(series.trackerGroups, function (key) {\n                if (series[key]) { // we don't always have dataLabelsGroup\n                    series[key]\n                        .addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                            pointer.onTrackerMouseOut(e);\n                        });\n                    if (hasTouch) {\n                        series[key].on('touchstart', onMouseOver);\n                    }\n\n                    \n                }\n            });\n            series._hasTracking = true;\n        }\n\n        fireEvent(this, 'afterDrawTracker');\n    },\n\n    /**\n     * Draw the tracker object that sits above all data labels and markers to\n     * track mouse events on the graph or points. For the line type charts\n     * the tracker uses the same graphPath, but with a greater stroke width\n     * for better control.\n     */\n    drawTrackerGraph: function () {\n        var series = this,\n            options = series.options,\n            trackByArea = options.trackByArea,\n            trackerPath = [].concat(\n                trackByArea ? series.areaPath : series.graphPath\n            ),\n            trackerPathLength = trackerPath.length,\n            chart = series.chart,\n            pointer = chart.pointer,\n            renderer = chart.renderer,\n            snap = chart.options.tooltip.snap,\n            tracker = series.tracker,\n            i,\n            onMouseOver = function () {\n                if (chart.hoverSeries !== series) {\n                    series.onMouseOver();\n                }\n            },\n            /*\n             * Empirical lowest possible opacities for TRACKER_FILL for an\n             * element to stay invisible but clickable\n             * IE6: 0.002\n             * IE7: 0.002\n             * IE8: 0.002\n             * IE9: 0.00000000001 (unlimited)\n             * IE10: 0.0001 (exporting only)\n             * FF: 0.00000000001 (unlimited)\n             * Chrome: 0.000001\n             * Safari: 0.000001\n             * Opera: 0.00000000001 (unlimited)\n             */\n            TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n\n        // Extend end points. A better way would be to use round linecaps,\n        // but those are not clickable in VML.\n        if (trackerPathLength && !trackByArea) {\n            i = trackerPathLength + 1;\n            while (i--) {\n                if (trackerPath[i] === 'M') { // extend left side\n                    trackerPath.splice(\n                        i + 1, 0,\n                        trackerPath[i + 1] - snap,\n                        trackerPath[i + 2],\n                        'L'\n                    );\n                }\n                if (\n                    (i && trackerPath[i] === 'M') ||\n                    i === trackerPathLength\n                ) { // extend right side\n                    trackerPath.splice(\n                        i,\n                        0,\n                        'L',\n                        trackerPath[i - 2] + snap,\n                        trackerPath[i - 1]\n                    );\n                }\n            }\n        }\n\n        // draw the tracker\n        if (tracker) {\n            tracker.attr({ d: trackerPath });\n        } else if (series.graph) { // create\n\n            series.tracker = renderer.path(trackerPath)\n            .attr({\n                \n                visibility: series.visible ? 'visible' : 'hidden',\n                zIndex: 2\n            })\n            .addClass(\n                trackByArea ?\n                    'highcharts-tracker-area' :\n                    'highcharts-tracker-line'\n            )\n            .add(series.group);\n\n            // The tracker is added to the series group, which is clipped, but\n            // is covered by the marker group. So the marker group also needs to\n            // capture events.\n            each([series.tracker, series.markerGroup], function (tracker) {\n                tracker.addClass('highcharts-tracker')\n                    .on('mouseover', onMouseOver)\n                    .on('mouseout', function (e) {\n                        pointer.onTrackerMouseOut(e);\n                    });\n\n                \n\n                if (hasTouch) {\n                    tracker.on('touchstart', onMouseOver);\n                }\n            });\n        }\n        fireEvent(this, 'afterDrawTracker');\n    }\n};\n/* End TrackerMixin */\n\n\n/**\n * Add tracking event listener to the series group, so the point graphics\n * themselves act as trackers\n */\n\nif (seriesTypes.column) {\n    seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.pie) {\n    seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.scatter) {\n    seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\n/*\n * Extend Legend for item events\n */\nextend(Legend.prototype, {\n\n    setItemEvents: function (item, legendItem, useHTML) {\n        var legend = this,\n            boxWrapper = legend.chart.renderer.boxWrapper,\n            activeClass = 'highcharts-legend-' +\n                (item instanceof Point ? 'point' : 'series') + '-active';\n\n        // Set the events on the item group, or in case of useHTML, the item\n        // itself (#1249)\n        (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n            item.setState('hover');\n\n            // A CSS class to dim or hide other than the hovered series\n            boxWrapper.addClass(activeClass);\n\n            \n        })\n        .on('mouseout', function () {\n            \n\n            // A CSS class to dim or hide other than the hovered series\n            boxWrapper.removeClass(activeClass);\n\n            item.setState();\n        })\n        .on('click', function (event) {\n            var strLegendItemClick = 'legendItemClick',\n                fnLegendItemClick = function () {\n                    if (item.setVisible) {\n                        item.setVisible();\n                    }\n                };\n\n            // A CSS class to dim or hide other than the hovered series. Event\n            // handling in iOS causes the activeClass to be added prior to click\n            // in some cases (#7418).\n            boxWrapper.removeClass(activeClass);\n\n            // Pass over the click/touch event. #4.\n            event = {\n                browserEvent: event\n            };\n\n            // click the name or symbol\n            if (item.firePointEvent) { // point\n                item.firePointEvent(\n                    strLegendItemClick,\n                    event,\n                    fnLegendItemClick\n                );\n            } else {\n                fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n            }\n        });\n    },\n\n    createCheckboxForItem: function (item) {\n        var legend = this;\n\n        item.checkbox = createElement('input', {\n            type: 'checkbox',\n            className: 'highcharts-legend-checkbox',\n            checked: item.selected,\n            defaultChecked: item.selected // required by IE7\n        }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n        addEvent(item.checkbox, 'click', function (event) {\n            var target = event.target;\n            fireEvent(\n                item.series || item,\n                'checkboxClick',\n                { // #3712\n                    checked: target.checked,\n                    item: item\n                },\n                function () {\n                    item.select();\n                }\n            );\n        });\n    }\n});\n\n\n\n\n\n/*\n * Extend the Chart object with interaction\n */\n\nextend(Chart.prototype, /** @lends Chart.prototype */ {\n    /**\n     * Display the zoom button.\n     *\n     * @private\n     */\n    showResetZoom: function () {\n        var chart = this,\n            lang = defaultOptions.lang,\n            btnOptions = chart.options.chart.resetZoomButton,\n            theme = btnOptions.theme,\n            states = theme.states,\n            alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n        function zoomOut() {\n            chart.zoomOut();\n        }\n\n        fireEvent(this, 'beforeShowResetZoom', null, function () {\n            chart.resetZoomButton = chart.renderer.button(\n                    lang.resetZoom,\n                    null,\n                    null,\n                    zoomOut,\n                    theme,\n                    states && states.hover\n                )\n                .attr({\n                    align: btnOptions.position.align,\n                    title: lang.resetZoomTitle\n                })\n                .addClass('highcharts-reset-zoom')\n                .add()\n                .align(btnOptions.position, false, alignTo);\n        });\n\n    },\n\n    /**\n     * Zoom the chart out after a user has zoomed in. See also\n     * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).\n     */\n    zoomOut: function () {\n        fireEvent(this, 'selection', { resetSelection: true }, this.zoom);\n    },\n\n    /**\n     * Zoom into a given portion of the chart given by axis coordinates.\n     * @param {Object} event\n     *\n     * @private\n     */\n    zoom: function (event) {\n        var chart = this,\n            hasZoomed,\n            pointer = chart.pointer,\n            displayButton = false,\n            resetZoomButton;\n\n        // If zoom is called with no arguments, reset the axes\n        if (!event || event.resetSelection) {\n            each(chart.axes, function (axis) {\n                hasZoomed = axis.zoom();\n            });\n            pointer.initiated = false; // #6804\n\n        } else { // else, zoom in on all axes\n            each(event.xAxis.concat(event.yAxis), function (axisData) {\n                var axis = axisData.axis,\n                    isXAxis = axis.isXAxis;\n\n                // don't zoom more than minRange\n                if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {\n                    hasZoomed = axis.zoom(axisData.min, axisData.max);\n                    if (axis.displayBtn) {\n                        displayButton = true;\n                    }\n                }\n            });\n        }\n\n        // Show or hide the Reset zoom button\n        resetZoomButton = chart.resetZoomButton;\n        if (displayButton && !resetZoomButton) {\n            chart.showResetZoom();\n        } else if (!displayButton && isObject(resetZoomButton)) {\n            chart.resetZoomButton = resetZoomButton.destroy();\n        }\n\n\n        // Redraw\n        if (hasZoomed) {\n            chart.redraw(\n                pick(\n                    chart.options.chart.animation,\n                    event && event.animation,\n                    chart.pointCount < 100\n                )\n            );\n        }\n    },\n\n    /**\n     * Pan the chart by dragging the mouse across the pane. This function is\n     * called on mouse move, and the distance to pan is computed from chartX\n     * compared to the first chartX position in the dragging operation.\n     *\n     * @private\n     */\n    pan: function (e, panning) {\n\n        var chart = this,\n            hoverPoints = chart.hoverPoints,\n            doRedraw;\n\n        // remove active points for shared tooltip\n        if (hoverPoints) {\n            each(hoverPoints, function (point) {\n                point.setState();\n            });\n        }\n\n        // xy is used in maps\n        each(panning === 'xy' ? [1, 0] : [1], function (isX) {\n            var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                horiz = axis.horiz,\n                mousePos = e[horiz ? 'chartX' : 'chartY'],\n                mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                startPos = chart[mouseDown],\n                halfPointRange = (axis.pointRange || 0) / 2,\n                pointRangeDirection =\n                    (axis.reversed && !chart.inverted) ||\n                    (!axis.reversed && chart.inverted) ?\n                        -1 :\n                        1,\n                extremes = axis.getExtremes(),\n                panMin = axis.toValue(startPos - mousePos, true) +\n                    halfPointRange * pointRangeDirection,\n                panMax = axis.toValue(startPos + axis.len - mousePos, true) -\n                    halfPointRange * pointRangeDirection,\n                flipped = panMax < panMin,\n                newMin = flipped ? panMax : panMin,\n                newMax = flipped ? panMin : panMax,\n                paddedMin = Math.min(\n                    extremes.dataMin,\n                    halfPointRange ?\n                        extremes.min :\n                        axis.toValue(\n                            axis.toPixels(extremes.min) - axis.minPixelPadding\n                        )\n                ),\n                paddedMax = Math.max(\n                    extremes.dataMax,\n                    halfPointRange ?\n                        extremes.max :\n                        axis.toValue(\n                            axis.toPixels(extremes.max) + axis.minPixelPadding\n                        )\n                ),\n                spill;\n\n            // If the new range spills over, either to the min or max, adjust\n            // the new range.\n            spill = paddedMin - newMin;\n            if (spill > 0) {\n                newMax += spill;\n                newMin = paddedMin;\n            }\n            spill = newMax - paddedMax;\n            if (spill > 0) {\n                newMax = paddedMax;\n                newMin -= spill;\n            }\n\n            // Set new extremes if they are actually new\n            if (\n                axis.series.length &&\n                newMin !== extremes.min &&\n                newMax !== extremes.max\n            ) {\n                axis.setExtremes(\n                    newMin,\n                    newMax,\n                    false,\n                    false,\n                    { trigger: 'pan' }\n                );\n                doRedraw = true;\n            }\n\n            chart[mouseDown] = mousePos; // set new reference for next run\n        });\n\n        if (doRedraw) {\n            chart.redraw(false);\n        }\n        css(chart.container, { cursor: 'move' });\n    }\n});\n\n/*\n * Extend the Point object with interaction\n */\nextend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n    /**\n     * Toggle the selection status of a point.\n     * @param  {Boolean} [selected]\n     *         When `true`, the point is selected. When `false`, the point is\n     *         unselected. When `null` or `undefined`, the selection state is\n     *         toggled.\n     * @param  {Boolean} [accumulate=false]\n     *         When `true`, the selection is added to other selected points.\n     *         When `false`, other selected points are deselected. Internally in\n     *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}\n     *         is `true`, selected points are accumulated on Control, Shift or\n     *         Cmd clicking the point.\n     *\n     * @see    Highcharts.Chart#getSelectedPoints\n     *\n     * @sample highcharts/members/point-select/\n     *         Select a point from a button\n     * @sample highcharts/chart/events-selection-points/\n     *         Select a range of points through a drag selection\n     * @sample maps/series/data-id/\n     *         Select a point in Highmaps\n     */\n    select: function (selected, accumulate) {\n        var point = this,\n            series = point.series,\n            chart = series.chart;\n\n        selected = pick(selected, !point.selected);\n\n        // fire the event with the default handler\n        point.firePointEvent(\n            selected ? 'select' : 'unselect',\n            { accumulate: accumulate },\n            function () {\n\n                /**\n                 * Whether the point is selected or not.\n                 * @see Point#select\n                 * @see Chart#getSelectedPoints\n                 * @memberof Point\n                 * @name selected\n                 * @type {Boolean}\n                 */\n                point.selected = point.options.selected = selected;\n                series.options.data[inArray(point, series.data)] =\n                    point.options;\n\n                point.setState(selected && 'select');\n\n                // unselect all other points unless Ctrl or Cmd + click\n                if (!accumulate) {\n                    each(chart.getSelectedPoints(), function (loopPoint) {\n                        if (loopPoint.selected && loopPoint !== point) {\n                            loopPoint.selected = loopPoint.options.selected =\n                                false;\n                            series.options.data[\n                                inArray(loopPoint, series.data)\n                            ] = loopPoint.options;\n                            loopPoint.setState('');\n                            loopPoint.firePointEvent('unselect');\n                        }\n                    });\n                }\n            }\n        );\n    },\n\n    /**\n     * Runs on mouse over the point. Called internally from mouse and touch\n     * events.\n     *\n     * @param {Object} e The event arguments\n     */\n    onMouseOver: function (e) {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            pointer = chart.pointer;\n        e = e ?\n            pointer.normalize(e) :\n            // In cases where onMouseOver is called directly without an event\n            pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n        pointer.runPointActions(e, point);\n    },\n\n    /**\n     * Runs on mouse out from the point. Called internally from mouse and touch\n     * events.\n     */\n    onMouseOut: function () {\n        var point = this,\n            chart = point.series.chart;\n        point.firePointEvent('mouseOut');\n        each(chart.hoverPoints || [], function (p) {\n            p.setState();\n        });\n        chart.hoverPoints = chart.hoverPoint = null;\n    },\n\n    /**\n     * Import events from the series' and point's options. Only do it on\n     * demand, to save processing time on hovering.\n     *\n     * @private\n     */\n    importEvents: function () {\n        if (!this.hasImportedEvents) {\n            var point = this,\n                options = merge(point.series.options.point, point.options),\n                events = options.events;\n\n            point.events = events;\n\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(events, function (event, eventType) {\n                addEvent(point, eventType, event);\n            });\n            this.hasImportedEvents = true;\n\n        }\n    },\n\n    /**\n     * Set the point's state.\n     * @param  {String} [state]\n     *         The new state, can be one of `''` (an empty string), `hover` or\n     *         `select`.\n     */\n    setState: function (state, move) {\n        var point = this,\n            plotX = Math.floor(point.plotX), // #4586\n            plotY = point.plotY,\n            series = point.series,\n            stateOptions = series.options.states[state || 'normal'] || {},\n            markerOptions = defaultPlotOptions[series.type].marker &&\n                series.options.marker,\n            normalDisabled = markerOptions && markerOptions.enabled === false,\n            markerStateOptions = (\n                markerOptions &&\n                markerOptions.states &&\n                markerOptions.states[state || 'normal']\n            ) || {},\n            stateDisabled = markerStateOptions.enabled === false,\n            stateMarkerGraphic = series.stateMarkerGraphic,\n            pointMarker = point.marker || {},\n            chart = series.chart,\n            halo = series.halo,\n            haloOptions,\n            markerAttribs,\n            hasMarkers = markerOptions && series.markerAttribs,\n            newSymbol;\n\n        state = state || ''; // empty string\n\n        if (\n            // already has this state\n            (state === point.state && !move) ||\n\n            // selected points don't respond to hover\n            (point.selected && state !== 'select') ||\n\n            // series' state options is disabled\n            (stateOptions.enabled === false) ||\n\n            // general point marker's state options is disabled\n            (state && (\n                stateDisabled ||\n                (normalDisabled && markerStateOptions.enabled === false)\n            )) ||\n\n            // individual point marker's state options is disabled\n            (\n                state &&\n                pointMarker.states &&\n                pointMarker.states[state] &&\n                pointMarker.states[state].enabled === false\n            ) // #1610\n\n        ) {\n            return;\n        }\n\n        if (hasMarkers) {\n            markerAttribs = series.markerAttribs(point, state);\n        }\n\n        // Apply hover styles to the existing point\n        if (point.graphic) {\n\n            if (point.state) {\n                point.graphic.removeClass('highcharts-point-' + point.state);\n            }\n            if (state) {\n                point.graphic.addClass('highcharts-point-' + state);\n            }\n\n            \n\n            if (markerAttribs) {\n                point.graphic.animate(\n                    markerAttribs,\n                    pick(\n                        chart.options.chart.animation, // Turn off globally\n                        markerStateOptions.animation,\n                        markerOptions.animation\n                    )\n                );\n            }\n\n            // Zooming in from a range with no markers to a range with markers\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic.hide();\n            }\n        } else {\n            // if a graphic is not applied to each point in the normal state,\n            // create a shared graphic for the hover state\n            if (state && markerStateOptions) {\n                newSymbol = pointMarker.symbol || series.symbol;\n\n                // If the point has another symbol than the previous one, throw\n                // away the state marker graphic and force a new one (#1459)\n                if (\n                    stateMarkerGraphic &&\n                    stateMarkerGraphic.currentSymbol !== newSymbol\n                ) {\n                    stateMarkerGraphic = stateMarkerGraphic.destroy();\n                }\n\n                // Add a new state marker graphic\n                if (!stateMarkerGraphic) {\n                    if (newSymbol) {\n                        series.stateMarkerGraphic = stateMarkerGraphic =\n                            chart.renderer.symbol(\n                                newSymbol,\n                                markerAttribs.x,\n                                markerAttribs.y,\n                                markerAttribs.width,\n                                markerAttribs.height\n                            )\n                            .add(series.markerGroup);\n                        stateMarkerGraphic.currentSymbol = newSymbol;\n                    }\n\n                // Move the existing graphic\n                } else {\n                    stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                        x: markerAttribs.x,\n                        y: markerAttribs.y\n                    });\n                }\n                \n            }\n\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic[\n                    state && chart.isInsidePlot(plotX, plotY, chart.inverted) ?\n                        'show' :\n                        'hide'\n                ](); // #2450\n                stateMarkerGraphic.element.point = point; // #4310\n            }\n        }\n\n        // Show me your halo\n        haloOptions = stateOptions.halo;\n        if (haloOptions && haloOptions.size) {\n            if (!halo) {\n                series.halo = halo = chart.renderer.path()\n                    // #5818, #5903, #6705\n                    .add((point.graphic || stateMarkerGraphic).parentGroup);\n            }\n            halo.show()[move ? 'animate' : 'attr']({\n                d: point.haloPath(haloOptions.size)\n            });\n            halo.attr({\n                'class': 'highcharts-halo highcharts-color-' +\n                    pick(point.colorIndex, series.colorIndex) +\n                    (point.className ? ' ' + point.className : ''),\n                'zIndex': -1 // #4929, #8276\n            });\n            halo.point = point; // #6055\n\n            \n\n        } else if (halo && halo.point && halo.point.haloPath) {\n            // Animate back to 0 on the current halo point (#6055)\n            halo.animate(\n                { d: halo.point.haloPath(0) },\n                null,\n                // Hide after unhovering. The `complete` callback runs in the\n                // halo's context (#7681).\n                halo.hide\n            );\n        }\n\n        point.state = state;\n\n        fireEvent(point, 'afterSetState');\n    },\n\n    /**\n     * Get the path definition for the halo, which is usually a shadow-like\n     * circle around the currently hovered point.\n     * @param  {Number} size\n     *         The radius of the circular halo.\n     * @return {Array} The path definition\n     */\n    haloPath: function (size) {\n        var series = this.series,\n            chart = series.chart;\n\n        return chart.renderer.symbols.circle(\n            Math.floor(this.plotX) - size,\n            this.plotY - size,\n            size * 2,\n            size * 2\n        );\n    }\n});\n\n/*\n * Extend the Series object with interaction\n */\n\nextend(Series.prototype, /** @lends Highcharts.Series.prototype */ {\n    /**\n     * Runs on mouse over the series graphical items.\n     */\n    onMouseOver: function () {\n        var series = this,\n            chart = series.chart,\n            hoverSeries = chart.hoverSeries;\n\n        // set normal state to previous series\n        if (hoverSeries && hoverSeries !== series) {\n            hoverSeries.onMouseOut();\n        }\n\n        // trigger the event, but to save processing time,\n        // only if defined\n        if (series.options.events.mouseOver) {\n            fireEvent(series, 'mouseOver');\n        }\n\n        // hover this\n        series.setState('hover');\n        chart.hoverSeries = series;\n    },\n\n    /**\n     * Runs on mouse out of the series graphical items.\n     */\n    onMouseOut: function () {\n        // trigger the event only if listeners exist\n        var series = this,\n            options = series.options,\n            chart = series.chart,\n            tooltip = chart.tooltip,\n            hoverPoint = chart.hoverPoint;\n\n        // #182, set to null before the mouseOut event fires\n        chart.hoverSeries = null;\n\n        // trigger mouse out on the point, which must be in this series\n        if (hoverPoint) {\n            hoverPoint.onMouseOut();\n        }\n\n        // fire the mouse out event\n        if (series && options.events.mouseOut) {\n            fireEvent(series, 'mouseOut');\n        }\n\n\n        // hide the tooltip\n        if (\n            tooltip &&\n            !series.stickyTracking &&\n            (!tooltip.shared || series.noSharedTooltip)\n        ) {\n            tooltip.hide();\n        }\n\n        // set normal state\n        series.setState();\n    },\n\n    /**\n     * Set the state of the series. Called internally on mouse interaction\n     * operations, but it can also be called directly to visually\n     * highlight a series.\n     *\n     * @param  {String} [state]\n     *         Can be either `hover` or undefined to set to normal\n     *         state.\n     */\n    setState: function (state) {\n        var series = this,\n            options = series.options,\n            graph = series.graph,\n            stateOptions = options.states,\n            lineWidth = options.lineWidth,\n            attribs,\n            i = 0;\n\n        state = state || '';\n\n        if (series.state !== state) {\n\n            // Toggle class names\n            each([\n                series.group,\n                series.markerGroup,\n                series.dataLabelsGroup\n            ], function (group) {\n                if (group) {\n                    // Old state\n                    if (series.state) {\n                        group.removeClass('highcharts-series-' + series.state);\n                    }\n                    // New state\n                    if (state) {\n                        group.addClass('highcharts-series-' + state);\n                    }\n                }\n            });\n\n            series.state = state;\n\n            \n        }\n    },\n\n    /**\n     * Show or hide the series.\n     *\n     * @param  {Boolean} [visible]\n     *         True to show the series, false to hide. If undefined, the\n     *         visibility is toggled.\n     * @param  {Boolean} [redraw=true]\n     *         Whether to redraw the chart after the series is altered. If doing\n     *         more operations on the chart, it is a good idea to set redraw to\n     *         false and call {@link Chart#redraw|chart.redraw()} after.\n     */\n    setVisible: function (vis, redraw) {\n        var series = this,\n            chart = series.chart,\n            legendItem = series.legendItem,\n            showOrHide,\n            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n            oldVisibility = series.visible;\n\n        // if called without an argument, toggle visibility\n        series.visible =\n            vis =\n            series.options.visible =\n            series.userOptions.visible =\n            vis === undefined ? !oldVisibility : vis; // #5618\n        showOrHide = vis ? 'show' : 'hide';\n\n        // show or hide elements\n        each([\n            'group',\n            'dataLabelsGroup',\n            'markerGroup',\n            'tracker',\n            'tt'\n        ], function (key) {\n            if (series[key]) {\n                series[key][showOrHide]();\n            }\n        });\n\n\n        // hide tooltip (#1361)\n        if (\n            chart.hoverSeries === series ||\n            (chart.hoverPoint && chart.hoverPoint.series) === series\n        ) {\n            series.onMouseOut();\n        }\n\n\n        if (legendItem) {\n            chart.legend.colorizeItem(series, vis);\n        }\n\n\n        // rescale or adapt to resized chart\n        series.isDirty = true;\n        // in a stack, all other series are affected\n        if (series.options.stacking) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.options.stacking && otherSeries.visible) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n\n        // show or hide linked series\n        each(series.linkedSeries, function (otherSeries) {\n            otherSeries.setVisible(vis, false);\n        });\n\n        if (ignoreHiddenSeries) {\n            chart.isDirtyBox = true;\n        }\n\n        fireEvent(series, showOrHide);\n\n        if (redraw !== false) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Show the series if hidden.\n     *\n     * @sample highcharts/members/series-hide/\n     *         Toggle visibility from a button\n     */\n    show: function () {\n        this.setVisible(true);\n    },\n\n    /**\n     * Hide the series if visible. If the {@link\n     * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|\n     * chart.ignoreHiddenSeries} option is true, the chart is redrawn without\n     * this series.\n     *\n     * @sample highcharts/members/series-hide/\n     *         Toggle visibility from a button\n     */\n    hide: function () {\n        this.setVisible(false);\n    },\n\n\n    /**\n     * Select or unselect the series. This means its {@link\n     * Highcharts.Series.selected|selected} property is set, the checkbox in the\n     * legend is toggled and when selected, the series is returned by the\n     * {@link Highcharts.Chart#getSelectedSeries} function.\n     *\n     * @param  {Boolean} [selected]\n     *         True to select the series, false to unselect. If undefined, the\n     *         selection state is toggled.\n     *\n     * @sample highcharts/members/series-select/\n     *         Select a series from a button\n     */\n    select: function (selected) {\n        var series = this;\n\n        series.selected = selected = (selected === undefined) ?\n            !series.selected :\n            selected;\n\n        if (series.checkbox) {\n            series.checkbox.checked = selected;\n        }\n\n        fireEvent(series, selected ? 'select' : 'unselect');\n    },\n\n    drawTracker: TrackerMixin.drawTrackerGraph\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Interaction.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Legend.js":
/*!***************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Legend.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar H = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n\n    addEvent = H.addEvent,\n    css = H.css,\n    discardElement = H.discardElement,\n    defined = H.defined,\n    each = H.each,\n    fireEvent = H.fireEvent,\n    isFirefox = H.isFirefox,\n    marginNames = H.marginNames,\n    merge = H.merge,\n    pick = H.pick,\n    setAnimation = H.setAnimation,\n    stableSort = H.stableSort,\n    win = H.win,\n    wrap = H.wrap;\n\n/**\n * The overview of the chart's series. The legend object is instanciated\n * internally in the chart constructor, and is available from the `chart.legend`\n * property. Each chart has only one legend.\n *\n * @class\n * @name Highcharts.Legend\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.LegendOptions} options\n *        Legend options.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend = function (chart, options) {\n    this.init(chart, options);\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend.prototype = {\n\n    /**\n     * Initialize the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#init\n     *\n     * @param {Highcharts.Chart} chart\n     *        The chart instance.\n     *\n     * @param {Highcharts.LegendOptions} options\n     *        Legend options.\n     */\n    init: function (chart, options) {\n\n        /**\n         * Chart of this legend.\n         *\n         * @readonly\n         * @name Highcharts.Legend#chart\n         * @type {Highcharts.Chart}\n         */\n        this.chart = chart;\n\n        this.setOptions(options);\n\n        if (options.enabled) {\n\n            // Render it\n            this.render();\n\n            // move checkboxes\n            addEvent(this.chart, 'endResize', function () {\n                this.legend.positionCheckboxes();\n            });\n\n            if (this.proximate) {\n                this.unchartrender = addEvent(\n                    this.chart,\n                    'render',\n                    function () {\n                        this.legend.proximatePositions();\n                        this.legend.positionItems();\n                    }\n                );\n            } else if (this.unchartrender) {\n                this.unchartrender();\n            }\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Legend#setOptions\n     *\n     * @param {Highcharts.LegendOptions} options\n     */\n    setOptions: function (options) {\n\n        var padding = pick(options.padding, 8);\n\n        /**\n         * Legend options.\n         *\n         * @readonly\n         * @name Highcharts.Legend#options\n         * @type {Highcharts.LegendOptions}\n         */\n        this.options = options;\n\n        \n        this.itemMarginTop = options.itemMarginTop || 0;\n        this.padding = padding;\n        this.initialItemY = padding - 5; // 5 is pixels above the text\n        this.symbolWidth = pick(options.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = options.layout === 'proximate' && !this.chart.inverted;\n\n    },\n\n    /**\n     * Update the legend with new options. Equivalent to running `chart.update`\n     * with a legend configuration option.\n     *\n     * @sample highcharts/legend/legend-update/\n     *         Legend update\n     *\n     * @function Highcharts.Legend#update\n     *\n     * @param {Highcharts.LegendOptions} options\n     *        Legend options.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart.\n     *\n     * @todo\n     * Make events official: Fires the event `afterUpdate`.\n     */\n    update: function (options, redraw) {\n        var chart = this.chart;\n\n        this.setOptions(merge(true, this.options, options));\n        this.destroy();\n        chart.isDirtyLegend = chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n\n        fireEvent(this, 'afterUpdate');\n    },\n\n    /**\n     * Set the colors for the legend item.\n     *\n     * @private\n     * @function Highcharts.Legend#colorizeItem\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        A Series or Point instance\n     *\n     * @param {boolean} [visible=false]\n     *        Dimmed or colored\n     *\n     * @todo\n     * Make events official: Fires the event `afterColorizeItem`.\n     */\n    colorizeItem: function (item, visible) {\n        item.legendGroup[visible ? 'removeClass' : 'addClass'](\n            'highcharts-legend-item-hidden'\n        );\n\n        \n\n        fireEvent(this, 'afterColorizeItem', { item: item, visible: visible });\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Legend#positionItems\n     */\n    positionItems: function () {\n\n        // Now that the legend width and height are established, put the items\n        // in the final position\n        each(this.allItems, this.positionItem, this);\n\n        if (!this.chart.isResizing) {\n            this.positionCheckboxes();\n        }\n    },\n\n    /**\n     * Position the legend item.\n     *\n     * @private\n     * @function Highcharts.Legend#positionItem\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The item to position\n     */\n    positionItem: function (item) {\n        var legend = this,\n            options = legend.options,\n            symbolPadding = options.symbolPadding,\n            ltr = !options.rtl,\n            legendItemPos = item._legendItemPos,\n            itemX = legendItemPos[0],\n            itemY = legendItemPos[1],\n            checkbox = item.checkbox,\n            legendGroup = item.legendGroup;\n\n        if (legendGroup && legendGroup.element) {\n            legendGroup[defined(legendGroup.translateY) ? 'animate' : 'attr']({\n                translateX: ltr ?\n                    itemX :\n                    legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                translateY: itemY\n            });\n        }\n\n        if (checkbox) {\n            checkbox.x = itemX;\n            checkbox.y = itemY;\n        }\n    },\n\n    /**\n     * Destroy a single legend item, used internally on removing series items.\n     *\n     * @private\n     * @function Highcharts.Legend#destroyItem\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The item to remove\n     */\n    destroyItem: function (item) {\n        var checkbox = item.checkbox;\n\n        // destroy SVG elements\n        each(\n            ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],\n            function (key) {\n                if (item[key]) {\n                    item[key] = item[key].destroy();\n                }\n            }\n        );\n\n        if (checkbox) {\n            discardElement(item.checkbox);\n        }\n    },\n\n    /**\n     * Destroy the legend. Used internally. To reflow objects, `chart.redraw`\n     * must be called after destruction.\n     *\n     * @private\n     * @function Highcharts.Legend#destroy\n     */\n    destroy: function () {\n        function destroyItems(key) {\n            if (this[key]) {\n                this[key] = this[key].destroy();\n            }\n        }\n\n        // Destroy items\n        each(this.getAllItems(), function (item) {\n            each(['legendItem', 'legendGroup'], destroyItems, item);\n        });\n\n        // Destroy legend elements\n        each([\n            'clipRect',\n            'up',\n            'down',\n            'pager',\n            'nav',\n            'box',\n            'title',\n            'group'\n        ], destroyItems, this);\n        this.display = null; // Reset in .render on update.\n    },\n\n    /**\n     * Position the checkboxes after the width is determined.\n     *\n     * @private\n     * @function Highcharts.Legend#positionCheckboxes\n     */\n    positionCheckboxes: function () {\n        var alignAttr = this.group && this.group.alignAttr,\n            translateY,\n            clipHeight = this.clipHeight || this.legendHeight,\n            titleHeight = this.titleHeight;\n\n        if (alignAttr) {\n            translateY = alignAttr.translateY;\n            each(this.allItems, function (item) {\n                var checkbox = item.checkbox,\n                    top;\n\n                if (checkbox) {\n                    top = translateY + titleHeight + checkbox.y +\n                        (this.scrollOffset || 0) + 3;\n                    css(checkbox, {\n                        left: (alignAttr.translateX + item.checkboxOffset +\n                            checkbox.x - 20) + 'px',\n                        top: top + 'px',\n                        display: top > translateY - 6 && top < translateY +\n                            clipHeight - 6 ? '' : 'none'\n                    });\n                }\n            }, this);\n        }\n    },\n\n    /**\n     * Render the legend title on top of the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#renderTitle\n     */\n    renderTitle: function () {\n        var options = this.options,\n            padding = this.padding,\n            titleOptions = options.title,\n            titleHeight = 0,\n            bBox;\n\n        if (titleOptions.text) {\n            if (!this.title) {\n                /**\n                 * SVG element of the legend title.\n                 *\n                 * @readonly\n                 * @name Highcharts.Legend#title\n                 * @type {Highcharts.SVGElement}\n                 */\n                this.title = this.chart.renderer.label(\n                        titleOptions.text,\n                        padding - 3,\n                        padding - 4,\n                        null,\n                        null,\n                        null,\n                        options.useHTML,\n                        null,\n                        'legend-title'\n                    )\n                    .attr({ zIndex: 1 })\n                    \n                    .add(this.group);\n            }\n            bBox = this.title.getBBox();\n            titleHeight = bBox.height;\n            this.offsetWidth = bBox.width; // #1717\n            this.contentGroup.attr({ translateY: titleHeight });\n        }\n        this.titleHeight = titleHeight;\n    },\n\n    /**\n     * Set the legend item text.\n     *\n     * @function Highcharts.Legend#setText\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The item for which to update the text in the legend.\n     */\n    setText: function (item) {\n        var options = this.options;\n        item.legendItem.attr({\n            text: options.labelFormat ?\n                H.format(options.labelFormat, item, this.chart.time) :\n                options.labelFormatter.call(item)\n        });\n    },\n\n    /**\n     * Render a single specific legend item. Called internally from the `render`\n     * function.\n     *\n     * @private\n     * @function Highcharts.Legend#renderItem\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The item to render.\n     */\n    renderItem: function (item) {\n        var legend = this,\n            chart = legend.chart,\n            renderer = chart.renderer,\n            options = legend.options,\n            horizontal = options.layout === 'horizontal',\n            symbolWidth = legend.symbolWidth,\n            symbolPadding = options.symbolPadding,\n            \n            itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n            ltr = !options.rtl,\n            bBox,\n            li = item.legendItem,\n            isSeries = !item.series,\n            series = !isSeries && item.series.drawLegendSymbol ?\n                item.series :\n                item,\n            seriesOptions = series.options,\n            showCheckbox = legend.createCheckboxForItem &&\n                seriesOptions &&\n                seriesOptions.showCheckbox,\n            // full width minus text width\n            itemExtraWidth = symbolWidth + symbolPadding + itemDistance +\n                (showCheckbox ? 20 : 0),\n            useHTML = options.useHTML,\n            fontSize = 12,\n            itemClassName = item.options.className;\n\n        if (!li) { // generate it once, later move it\n\n            // Generate the group box, a group to hold the symbol and text. Text\n            // is to be appended in Legend class.\n            item.legendGroup = renderer.g('legend-item')\n                .addClass(\n                    'highcharts-' + series.type + '-series ' +\n                    'highcharts-color-' + item.colorIndex +\n                    (itemClassName ? ' ' + itemClassName : '') +\n                    (isSeries ? ' highcharts-series-' + item.index : '')\n                )\n                .attr({ zIndex: 1 })\n                .add(legend.scrollGroup);\n\n            // Generate the list item text and add it to the group\n            item.legendItem = li = renderer.text(\n                    '',\n                    ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                    legend.baseline || 0,\n                    useHTML\n                )\n                \n                .attr({\n                    align: ltr ? 'left' : 'right',\n                    zIndex: 2\n                })\n                .add(item.legendGroup);\n\n            // Get the baseline for the first item - the font size is equal for\n            // all\n            if (!legend.baseline) {\n                \n                legend.fontMetrics = renderer.fontMetrics(\n                    fontSize,\n                    li\n                );\n                legend.baseline =\n                    legend.fontMetrics.f + 3 + legend.itemMarginTop;\n                li.attr('y', legend.baseline);\n            }\n\n            // Draw the legend symbol inside the group box\n            legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;\n            series.drawLegendSymbol(legend, item);\n\n            if (legend.setItemEvents) {\n                legend.setItemEvents(item, li, useHTML);\n            }\n\n            // add the HTML checkbox on top\n            if (showCheckbox) {\n                legend.createCheckboxForItem(item);\n            }\n        }\n\n        // Colorize the items\n        legend.colorizeItem(item, item.visible);\n\n        // Take care of max width and text overflow (#6659)\n        \n            li.css({\n                width: (\n                    options.itemWidth ||\n                    options.width ||\n                    chart.spacingBox.width\n                ) - itemExtraWidth\n            });\n        \n\n        // Always update the text\n        legend.setText(item);\n\n        // calculate the positions for the next line\n        bBox = li.getBBox();\n\n        item.itemWidth = item.checkboxOffset =\n            options.itemWidth ||\n            item.legendItemWidth ||\n            bBox.width + itemExtraWidth;\n        legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);\n        legend.totalItemWidth += item.itemWidth;\n        legend.itemHeight = item.itemHeight = Math.round(\n            item.legendItemHeight || bBox.height || legend.symbolHeight\n        );\n    },\n\n    /**\n     * Get the position of the item in the layout. We now know the\n     * maxItemWidth from the previous loop.\n     *\n     * @private\n     * @function Highcharts.Legend#layoutItem\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     */\n    layoutItem: function (item) {\n\n        var options = this.options,\n            padding = this.padding,\n            horizontal = options.layout === 'horizontal',\n            itemHeight = item.itemHeight,\n            itemMarginBottom = options.itemMarginBottom || 0,\n            itemMarginTop = this.itemMarginTop,\n            itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n            widthOption = options.width,\n            maxLegendWidth = widthOption || (\n                this.chart.spacingBox.width - 2 * padding - options.x\n            ),\n            itemWidth = (\n                    options.alignColumns &&\n                    this.totalItemWidth > maxLegendWidth\n                ) ?\n                this.maxItemWidth :\n                item.itemWidth;\n\n        // If the item exceeds the width, start a new line\n        if (\n            horizontal &&\n            this.itemX - padding + itemWidth > maxLegendWidth\n        ) {\n            this.itemX = padding;\n            this.itemY += itemMarginTop + this.lastLineHeight +\n                itemMarginBottom;\n            this.lastLineHeight = 0; // reset for next line (#915, #3976)\n        }\n\n        // Set the edge positions\n        this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;\n        this.lastLineHeight = Math.max( // #915\n            itemHeight,\n            this.lastLineHeight\n        );\n\n        // cache the position of the newly generated or reordered items\n        item._legendItemPos = [this.itemX, this.itemY];\n\n        // advance\n        if (horizontal) {\n            this.itemX += itemWidth;\n\n        } else {\n            this.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n            this.lastLineHeight = itemHeight;\n        }\n\n        // the width of the widest item\n        this.offsetWidth = widthOption || Math.max(\n            (\n                horizontal ? this.itemX - padding - (item.checkbox ?\n                    // decrease by itemDistance only when no checkbox #4853\n                    0 :\n                    itemDistance\n                ) : itemWidth\n            ) + padding,\n            this.offsetWidth\n        );\n    },\n\n    /**\n     * Get all items, which is one item per series for most series and one\n     * item per point for pie series and its derivatives.\n     *\n     * @private\n     * @function Highcharts.Legend#getAllItems\n     *\n     * @return {Array<Highcharts.Point|Highcharts.Series>}\n     *         The current items in the legend.\n     *\n     * @fires Highcharts.Legend#event:afterGetAllItems\n     *\n     * @todo\n     * Make events official: Fires the event `afterGetAllItems`.\n     */\n    getAllItems: function () {\n        var allItems = [];\n        each(this.chart.series, function (series) {\n            var seriesOptions = series && series.options;\n\n            // Handle showInLegend. If the series is linked to another series,\n            // defaults to false.\n            if (series && pick(\n                seriesOptions.showInLegend,\n                !defined(seriesOptions.linkedTo) ? undefined : false, true\n            )) {\n\n                // Use points or series for the legend item depending on\n                // legendType\n                allItems = allItems.concat(\n                    series.legendItems ||\n                    (\n                        seriesOptions.legendType === 'point' ?\n                            series.data :\n                            series\n                    )\n                );\n            }\n        });\n\n        fireEvent(this, 'afterGetAllItems', { allItems: allItems });\n\n        return allItems;\n    },\n\n    /**\n     * Get a short, three letter string reflecting the alignment and layout.\n     *\n     * @private\n     * @function Highcharts.Legend#getAlignment\n     *\n     * @return {string}\n     *         The alignment, empty string if floating\n     */\n    getAlignment: function () {\n        var options = this.options;\n\n        // Use the first letter of each alignment option in order to detect\n        // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n        if (this.proximate) {\n            return options.align.charAt(0) + 'tv';\n        }\n        return options.floating ? '' : (\n            options.align.charAt(0) +\n            options.verticalAlign.charAt(0) +\n            options.layout.charAt(0)\n        );\n    },\n\n    /**\n     * Adjust the chart margins by reserving space for the legend on only one\n     * side of the chart. If the position is set to a corner, top or bottom is\n     * reserved for horizontal legends and left or right for vertical ones.\n     *\n     * @private\n     * @function Highcharts.Legend#adjustMargins\n     *\n     * @param {Array<number>} margin\n     *\n     * @param {number} spacing\n     */\n    adjustMargins: function (margin, spacing) {\n        var chart = this.chart,\n            options = this.options,\n            alignment = this.getAlignment();\n\n        if (alignment) {\n\n            each([\n                /(lth|ct|rth)/,\n                /(rtv|rm|rbv)/,\n                /(rbh|cb|lbh)/,\n                /(lbv|lm|ltv)/\n            ], function (alignments, side) {\n                if (alignments.test(alignment) && !defined(margin[side])) {\n\n                    // Now we have detected on which side of the chart we should\n                    // reserve space for the legend\n                    chart[marginNames[side]] = Math.max(\n                        chart[marginNames[side]],\n                        (\n                            chart.legend[\n                                (side + 1) % 2 ? 'legendHeight' : 'legendWidth'\n                            ] +\n                            [1, -1, -1, 1][side] * options[\n                                (side % 2) ? 'x' : 'y'\n                            ] +\n                            pick(options.margin, 12) +\n                            spacing[side] +\n                            (\n                                side === 0 &&\n                                chart.options.title.margin !== undefined ?\n                                    chart.titleOffset +\n                                        chart.options.title.margin :\n                                    0\n                            ) // #7428, #7894\n                        )\n                    );\n                }\n            });\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Legend#proximatePositions\n     */\n    proximatePositions: function () {\n        var chart = this.chart,\n            boxes = [],\n            alignLeft = this.options.align === 'left';\n\n        each(this.allItems, function (item) {\n            var lastPoint,\n                height,\n                useFirstPoint = alignLeft;\n\n            if (item.xAxis && item.points) {\n\n                if (item.xAxis.options.reversed) {\n                    useFirstPoint = !useFirstPoint;\n                }\n                lastPoint = H.find(\n                    useFirstPoint ?\n                        item.points :\n                        item.points.slice(0).reverse(),\n                    function (item) {\n                        return H.isNumber(item.plotY);\n                    }\n                );\n                height = item.legendGroup.getBBox().height;\n                boxes.push({\n                    target: item.visible ?\n                        (lastPoint ? lastPoint.plotY : item.xAxis.height) -\n                            0.3 * height :\n                        chart.plotHeight,\n                    size: height,\n                    item: item\n                });\n            }\n        }, this);\n        H.distribute(boxes, chart.plotHeight);\n        each(boxes, function (box) {\n            box.item._legendItemPos[1] =\n                chart.plotTop - chart.spacing[0] + box.pos;\n        });\n\n    },\n\n    /**\n     * Render the legend. This method can be called both before and after\n     * `chart.render`. If called after, it will only rearrange items instead\n     * of creating new ones. Called internally on initial render and after\n     * redraws.\n     *\n     * @private\n     * @function Highcharts.Legend#render\n     */\n    render: function () {\n        var legend = this,\n            chart = legend.chart,\n            renderer = chart.renderer,\n            legendGroup = legend.group,\n            allItems,\n            display,\n            legendWidth,\n            legendHeight,\n            box = legend.box,\n            options = legend.options,\n            padding = legend.padding,\n            alignTo;\n\n        legend.itemX = padding;\n        legend.itemY = legend.initialItemY;\n        legend.offsetWidth = 0;\n        legend.lastItemY = 0;\n\n        if (!legendGroup) {\n            /**\n             * SVG group of the legend.\n             *\n             * @readonly\n             * @name Highcharts.Legend#group\n             * @type {Highcharts.SVGElement}\n             */\n            legend.group = legendGroup = renderer.g('legend')\n                .attr({ zIndex: 7 })\n                .add();\n            legend.contentGroup = renderer.g()\n                .attr({ zIndex: 1 }) // above background\n                .add(legendGroup);\n            legend.scrollGroup = renderer.g()\n                .add(legend.contentGroup);\n        }\n\n        legend.renderTitle();\n\n        // add each series or point\n        allItems = legend.getAllItems();\n\n        // sort by legendIndex\n        stableSort(allItems, function (a, b) {\n            return ((a.options && a.options.legendIndex) || 0) -\n                ((b.options && b.options.legendIndex) || 0);\n        });\n\n        // reversed legend\n        if (options.reversed) {\n            allItems.reverse();\n        }\n\n        /**\n         * All items for the legend, which is an array of series for most series\n         * and an array of points for pie series and its derivatives.\n         *\n         * @readonly\n         * @name Highcharts.Legend#allItems\n         * @type {Array<Highcharts.Point|Highcharts.Series>}\n         */\n        legend.allItems = allItems;\n        legend.display = display = !!allItems.length;\n\n        // Render the items. First we run a loop to set the text and properties\n        // and read all the bounding boxes. The next loop computes the item\n        // positions based on the bounding boxes.\n        legend.lastLineHeight = 0;\n        legend.maxItemWidth = 0;\n        legend.totalItemWidth = 0;\n        legend.itemHeight = 0;\n        each(allItems, legend.renderItem, legend);\n        each(allItems, legend.layoutItem, legend);\n\n        // Get the box\n        legendWidth = (options.width || legend.offsetWidth) + padding;\n        legendHeight = legend.lastItemY + legend.lastLineHeight +\n            legend.titleHeight;\n        legendHeight = legend.handleOverflow(legendHeight);\n        legendHeight += padding;\n\n        // Draw the border and/or background\n        if (!box) {\n            /**\n             * SVG element of the legend box.\n             *\n             * @readonly\n             * @name Highcharts.Legend#box\n             * @type {Highcharts.SVGElement}\n             */\n            legend.box = box = renderer.rect()\n                .addClass('highcharts-legend-box')\n                .attr({\n                    r: options.borderRadius\n                })\n                .add(legendGroup);\n            box.isNew = true;\n        }\n\n        \n\n        if (legendWidth > 0 && legendHeight > 0) {\n            box[box.isNew ? 'attr' : 'animate'](\n                box.crisp.call({}, { // #7260\n                    x: 0,\n                    y: 0,\n                    width: legendWidth,\n                    height: legendHeight\n                }, box.strokeWidth())\n            );\n            box.isNew = false;\n        }\n\n        // hide the border if no items\n        box[display ? 'show' : 'hide']();\n\n        \n        // Open for responsiveness\n        if (legendGroup.getStyle('display') === 'none') {\n            legendWidth = legendHeight = 0;\n        }\n        \n\n        legend.legendWidth = legendWidth;\n        legend.legendHeight = legendHeight;\n\n        if (display) {\n            // If aligning to the top and the layout is horizontal, adjust for\n            // the title (#7428)\n            alignTo = chart.spacingBox;\n            if (/(lth|ct|rth)/.test(legend.getAlignment())) {\n                alignTo = merge(alignTo, {\n                    y: alignTo.y + chart.titleOffset +\n                        chart.options.title.margin\n                });\n            }\n\n            legendGroup.align(merge(options, {\n                width: legendWidth,\n                height: legendHeight,\n                verticalAlign: this.proximate ? 'top' : options.verticalAlign\n            }), true, alignTo);\n        }\n\n        if (!this.proximate) {\n            this.positionItems();\n        }\n    },\n\n    /**\n     * Set up the overflow handling by adding navigation with up and down arrows\n     * below the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#handleOverflow\n     *\n     * @param {number} legendHeight\n     *\n     * @return {number}\n     */\n    handleOverflow: function (legendHeight) {\n        var legend = this,\n            chart = this.chart,\n            renderer = chart.renderer,\n            options = this.options,\n            optionsY = options.y,\n            alignTop = options.verticalAlign === 'top',\n            padding = this.padding,\n            spaceHeight = chart.spacingBox.height +\n                (alignTop ? -optionsY : optionsY) - padding,\n            maxHeight = options.maxHeight,\n            clipHeight,\n            clipRect = this.clipRect,\n            navOptions = options.navigation,\n            animation = pick(navOptions.animation, true),\n            arrowSize = navOptions.arrowSize || 12,\n            nav = this.nav,\n            pages = this.pages,\n            lastY,\n            allItems = this.allItems,\n            clipToHeight = function (height) {\n                if (typeof height === 'number') {\n                    clipRect.attr({\n                        height: height\n                    });\n                } else if (clipRect) { // Reset (#5912)\n                    legend.clipRect = clipRect.destroy();\n                    legend.contentGroup.clip();\n                }\n\n                // useHTML\n                if (legend.contentGroup.div) {\n                    legend.contentGroup.div.style.clip = height ?\n                        'rect(' + padding + 'px,9999px,' +\n                            (padding + height) + 'px,0)' :\n                        'auto';\n                }\n            };\n\n\n        // Adjust the height\n        if (\n            options.layout === 'horizontal' &&\n            options.verticalAlign !== 'middle' &&\n            !options.floating\n        ) {\n            spaceHeight /= 2;\n        }\n        if (maxHeight) {\n            spaceHeight = Math.min(spaceHeight, maxHeight);\n        }\n\n        // Reset the legend height and adjust the clipping rectangle\n        pages.length = 0;\n        if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n\n            this.clipHeight = clipHeight =\n                Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n            this.currentPage = pick(this.currentPage, 1);\n            this.fullHeight = legendHeight;\n\n            // Fill pages with Y positions so that the top of each a legend item\n            // defines the scroll top for each page (#2098)\n            each(allItems, function (item, i) {\n                var y = item._legendItemPos[1],\n                    h = Math.round(item.legendItem.getBBox().height),\n                    len = pages.length;\n\n                if (!len || (y - pages[len - 1] > clipHeight &&\n                        (lastY || y) !== pages[len - 1])) {\n                    pages.push(lastY || y);\n                    len++;\n                }\n\n                // Keep track of which page each item is on\n                item.pageIx = len - 1;\n                if (lastY) {\n                    allItems[i - 1].pageIx = len - 1;\n                }\n\n                if (i === allItems.length - 1 &&\n                        y + h - pages[len - 1] > clipHeight) {\n                    pages.push(y);\n                    item.pageIx = len;\n                }\n                if (y !== lastY) {\n                    lastY = y;\n                }\n            });\n\n            // Only apply clipping if needed. Clipping causes blurred legend in\n            // PDF export (#1787)\n            if (!clipRect) {\n                clipRect = legend.clipRect =\n                    renderer.clipRect(0, padding, 9999, 0);\n                legend.contentGroup.clip(clipRect);\n            }\n\n            clipToHeight(clipHeight);\n\n            // Add navigation elements\n            if (!nav) {\n                this.nav = nav = renderer.g()\n                    .attr({ zIndex: 1 })\n                    .add(this.group);\n\n                this.up = renderer\n                    .symbol(\n                        'triangle',\n                        0,\n                        0,\n                        arrowSize,\n                        arrowSize\n                    )\n                    .on('click', function () {\n                        legend.scroll(-1, animation);\n                    })\n                    .add(nav);\n\n                this.pager = renderer.text('', 15, 10)\n                    .addClass('highcharts-legend-navigation')\n                    \n                    .add(nav);\n\n                this.down = renderer\n                    .symbol(\n                        'triangle-down',\n                        0,\n                        0,\n                        arrowSize,\n                        arrowSize\n                    )\n                    .on('click', function () {\n                        legend.scroll(1, animation);\n                    })\n                    .add(nav);\n            }\n\n            // Set initial position\n            legend.scroll(0);\n\n            legendHeight = spaceHeight;\n\n        // Reset\n        } else if (nav) {\n            clipToHeight();\n            this.nav = nav.destroy(); // #6322\n            this.scrollGroup.attr({\n                translateY: 1\n            });\n            this.clipHeight = 0; // #1379\n        }\n\n        return legendHeight;\n    },\n\n    /**\n     * Scroll the legend by a number of pages.\n     *\n     * @private\n     * @function Highcharts.Legend#scroll\n     *\n     * @param {number} scrollBy\n     *        The number of pages to scroll.\n     *\n     * @param {Highcharts.AnimationOptionsObject} animation\n     *        Whether and how to apply animation.\n     */\n    scroll: function (scrollBy, animation) {\n        var pages = this.pages,\n            pageCount = pages.length,\n            currentPage = this.currentPage + scrollBy,\n            clipHeight = this.clipHeight,\n            navOptions = this.options.navigation,\n            pager = this.pager,\n            padding = this.padding;\n\n        // When resizing while looking at the last page\n        if (currentPage > pageCount) {\n            currentPage = pageCount;\n        }\n\n        if (currentPage > 0) {\n\n            if (animation !== undefined) {\n                setAnimation(animation, this.chart);\n            }\n\n            this.nav.attr({\n                translateX: padding,\n                translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                visibility: 'visible'\n            });\n            this.up.attr({\n                'class': currentPage === 1 ?\n                    'highcharts-legend-nav-inactive' :\n                    'highcharts-legend-nav-active'\n            });\n            pager.attr({\n                text: currentPage + '/' + pageCount\n            });\n            this.down.attr({\n                'x': 18 + this.pager.getBBox().width, // adjust to text width\n                'class': currentPage === pageCount ?\n                    'highcharts-legend-nav-inactive' :\n                    'highcharts-legend-nav-active'\n            });\n\n            \n\n            this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n            this.scrollGroup.animate({\n                translateY: this.scrollOffset\n            });\n\n            this.currentPage = currentPage;\n            this.positionCheckboxes();\n        }\n\n    }\n\n};\n\n/**\n * Legend symbol mixin.\n *\n * @private\n * @mixin Highcharts.LegendSymbolMixin\n */\nH.LegendSymbolMixin = {\n\n    /**\n     * Get the series' symbol in the legend\n     *\n     * @private\n     * @function Highcharts.LegendSymbolMixin.drawRectangle\n     *\n     * @param {Highcharts.Legend} legend\n     *        The legend object\n     *\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The series (this) or point\n     */\n    drawRectangle: function (legend, item) {\n        var options = legend.options,\n            symbolHeight = legend.symbolHeight,\n            square = options.squareSymbol,\n            symbolWidth = square ? symbolHeight : legend.symbolWidth;\n\n        item.legendSymbol = this.chart.renderer.rect(\n            square ? (legend.symbolWidth - symbolHeight) / 2 : 0,\n            legend.baseline - symbolHeight + 1, // #3988\n            symbolWidth,\n            symbolHeight,\n            pick(legend.options.symbolRadius, symbolHeight / 2)\n        )\n        .addClass('highcharts-point')\n        .attr({\n            zIndex: 3\n        }).add(item.legendGroup);\n\n    },\n\n    /**\n     * Get the series' symbol in the legend. This method should be overridable\n     * to create custom symbols through\n     * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n     *\n     * @private\n     * @function Highcharts.LegendSymbolMixin.drawLineMarker\n     *\n     * @param {Highcharts.Legend} legend\n     *        The legend object.\n     */\n    drawLineMarker: function (legend) {\n\n        var options = this.options,\n            markerOptions = options.marker,\n            radius,\n            legendSymbol,\n            symbolWidth = legend.symbolWidth,\n            symbolHeight = legend.symbolHeight,\n            generalRadius = symbolHeight / 2,\n            renderer = this.chart.renderer,\n            legendItemGroup = this.legendGroup,\n            verticalCenter = legend.baseline -\n                Math.round(legend.fontMetrics.b * 0.3),\n            attr = {};\n\n        // Draw the line\n        \n\n        this.legendLine = renderer.path([\n            'M',\n            0,\n            verticalCenter,\n            'L',\n            symbolWidth,\n            verticalCenter\n        ])\n        .addClass('highcharts-graph')\n        .attr(attr)\n        .add(legendItemGroup);\n\n        // Draw the marker\n        if (markerOptions && markerOptions.enabled !== false && symbolWidth) {\n\n            // Do not allow the marker to be larger than the symbolHeight\n            radius = Math.min(\n                pick(markerOptions.radius, generalRadius),\n                generalRadius\n            );\n\n            // Restrict symbol markers size\n            if (this.symbol.indexOf('url') === 0) {\n                markerOptions = merge(markerOptions, {\n                    width: symbolHeight,\n                    height: symbolHeight\n                });\n                radius = 0;\n            }\n\n            this.legendSymbol = legendSymbol = renderer.symbol(\n                this.symbol,\n                (symbolWidth / 2) - radius,\n                verticalCenter - radius,\n                2 * radius,\n                2 * radius,\n                markerOptions\n            )\n            .addClass('highcharts-point')\n            .add(legendItemGroup);\n            legendSymbol.isMarker = true;\n        }\n    }\n};\n\n// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n// and for #2580, a similar drawing flaw in Firefox 26.\n// Explore if there's a general cause for this. The problem may be related\n// to nested group elements, as the legend item texts are within 4 group\n// elements.\nif (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n    wrap(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Legend.prototype, 'positionItem', function (proceed, item) {\n        var legend = this,\n            // If chart destroyed in sync, this is undefined (#2030)\n            runPositionItem = function () {\n                if (item._legendItemPos) {\n                    proceed.call(legend, item);\n                }\n            };\n\n        // Do it now, for export and to get checkbox placement\n        runPositionItem();\n\n        // Do it after to work around the core issue\n        setTimeout(runPositionItem);\n    });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Legend.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/LogarithmicAxis.js":
/*!************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/LogarithmicAxis.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    getMagnitude = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMagnitude,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    normalizeTickInterval = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeTickInterval,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n/**\n * Methods defined on the Axis prototype\n */\n\n/**\n * Set the tick positions of a logarithmic axis\n *\n * @ignore\n */\nAxis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n    var axis = this,\n        options = axis.options,\n        axisLength = axis.len,\n        // Since we use this method for both major and minor ticks,\n        // use a local variable and return the result\n        positions = [];\n\n    // Reset\n    if (!minor) {\n        axis._minorAutoInterval = null;\n    }\n\n    // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n    if (interval >= 0.5) {\n        interval = Math.round(interval);\n        positions = axis.getLinearTickPositions(interval, min, max);\n\n    // Second case: We need intermediary ticks. For example\n    // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n    } else if (interval >= 0.08) {\n        var roundedMin = Math.floor(min),\n            intermediate,\n            i,\n            j,\n            len,\n            pos,\n            lastPos,\n            break2;\n\n        if (interval > 0.3) {\n            intermediate = [1, 2, 4];\n\n        // 0.2 equals five minor ticks per 1, 10, 100 etc\n        } else if (interval > 0.15) {\n            intermediate = [1, 2, 4, 6, 8];\n        } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n            intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        }\n\n        for (i = roundedMin; i < max + 1 && !break2; i++) {\n            len = intermediate.length;\n            for (j = 0; j < len && !break2; j++) {\n                pos = axis.log2lin(axis.lin2log(i) * intermediate[j]);\n                // #1670, lastPos is #3113\n                if (\n                    pos > min &&\n                    (!minor || lastPos <= max) &&\n                    lastPos !== undefined\n                ) {\n                    positions.push(lastPos);\n                }\n\n                if (lastPos > max) {\n                    break2 = true;\n                }\n                lastPos = pos;\n            }\n        }\n\n    // Third case: We are so deep in between whole logarithmic values that\n    // we might as well handle the tick positions like a linear axis. For\n    // example 1.01, 1.02, 1.03, 1.04.\n    } else {\n        var realMin = axis.lin2log(min),\n            realMax = axis.lin2log(max),\n            tickIntervalOption = minor ?\n                this.getMinorTickInterval() :\n                options.tickInterval,\n            filteredTickIntervalOption = tickIntervalOption === 'auto' ?\n                null :\n                tickIntervalOption,\n            tickPixelIntervalOption =\n                options.tickPixelInterval / (minor ? 5 : 1),\n            totalPixelLength = minor ?\n                axisLength / axis.tickPositions.length :\n                axisLength;\n\n        interval = pick(\n            filteredTickIntervalOption,\n            axis._minorAutoInterval,\n            (realMax - realMin) *\n                tickPixelIntervalOption / (totalPixelLength || 1)\n        );\n\n        interval = normalizeTickInterval(\n            interval,\n            null,\n            getMagnitude(interval)\n        );\n\n        positions = map(axis.getLinearTickPositions(\n            interval,\n            realMin,\n            realMax\n        ), axis.log2lin);\n\n        if (!minor) {\n            axis._minorAutoInterval = interval / 5;\n        }\n    }\n\n    // Set the axis-level tickInterval variable\n    if (!minor) {\n        axis.tickInterval = interval;\n    }\n    return positions;\n};\n\nAxis.prototype.log2lin = function (num) {\n    return Math.log(num) / Math.LN10;\n};\n\nAxis.prototype.lin2log = function (num) {\n    return Math.pow(10, num);\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/LogarithmicAxis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/MSPointer.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/MSPointer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer.js */ \"./node_modules/highcharts/js/es-modules/parts/Pointer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    charts = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    doc = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    hasTouch = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasTouch,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    Pointer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\nif (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {\n\n    // The touches object keeps track of the points being touched at all times\n    var touches = {},\n        hasPointerEvent = !!win.PointerEvent,\n        getWebkitTouches = function () {\n            var fake = [];\n            fake.item = function (i) {\n                return this[i];\n            };\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(touches, function (touch) {\n                fake.push({\n                    pageX: touch.pageX,\n                    pageY: touch.pageY,\n                    target: touch.target\n                });\n            });\n            return fake;\n        },\n        translateMSPointer = function (e, method, wktype, func) {\n            var p;\n            if (\n                (\n                    e.pointerType === 'touch' ||\n                    e.pointerType === e.MSPOINTER_TYPE_TOUCH\n                ) && charts[_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex]\n            ) {\n                func(e);\n                p = charts[_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex].pointer;\n                p[method]({\n                    type: wktype,\n                    target: e.currentTarget,\n                    preventDefault: noop,\n                    touches: getWebkitTouches()\n                });\n            }\n        };\n\n    // Extend the Pointer prototype with methods for each event handler and more\n    extend(Pointer.prototype, /** @lends Pointer.prototype */ {\n\n        /**\n         * @private\n         * @function Highcharts.Pointer#onContainerPointerDown\n         *\n         * @param {Highcharts.PointerEventObject} e\n         */\n        onContainerPointerDown: function (e) {\n            translateMSPointer(\n                e,\n                'onContainerTouchStart',\n                'touchstart',\n                function (e) {\n                    touches[e.pointerId] = {\n                        pageX: e.pageX,\n                        pageY: e.pageY,\n                        target: e.currentTarget\n                    };\n                }\n            );\n        },\n\n        /**\n         * @private\n         * @function Highcharts.Pointer#onContainerPointerMove\n         *\n         * @param {Highcharts.PointerEventObject} e\n         */\n        onContainerPointerMove: function (e) {\n            translateMSPointer(\n                e,\n                'onContainerTouchMove',\n                'touchmove',\n                function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n                    if (!touches[e.pointerId].target) {\n                        touches[e.pointerId].target = e.currentTarget;\n                    }\n                }\n            );\n        },\n\n        /**\n         * @private\n         * @function Highcharts.Pointer#onDocumentPointerUp\n         *\n         * @param {Highcharts.PointerEventObject} e\n         */\n        onDocumentPointerUp: function (e) {\n            translateMSPointer(\n                e,\n                'onDocumentTouchEnd',\n                'touchend',\n                function (e) {\n                    delete touches[e.pointerId];\n                }\n            );\n        },\n\n        /**\n         * Add or remove the MS Pointer specific events\n         *\n         * @private\n         * @function Highcharts.Pointer#batchMSEvents\n         *\n         * @param {Function} fn\n         */\n        batchMSEvents: function (fn) {\n            fn(\n                this.chart.container,\n                hasPointerEvent ? 'pointerdown' : 'MSPointerDown',\n                this.onContainerPointerDown\n            );\n            fn(\n                this.chart.container,\n                hasPointerEvent ? 'pointermove' : 'MSPointerMove',\n                this.onContainerPointerMove\n            );\n            fn(\n                doc,\n                hasPointerEvent ? 'pointerup' : 'MSPointerUp',\n                this.onDocumentPointerUp\n            );\n        }\n    });\n\n    // Disable default IE actions for pinch and such on chart element\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n        proceed.call(this, chart, options);\n        if (this.hasZoom) { // #4014\n            css(chart.container, {\n                '-ms-touch-action': 'none',\n                'touch-action': 'none'\n            });\n        }\n    });\n\n    // Add IE specific touch events to chart\n    wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n        proceed.apply(this);\n        if (this.hasZoom || this.followTouchMove) {\n            this.batchMSEvents(addEvent);\n        }\n    });\n    // Destroy MS events also\n    wrap(Pointer.prototype, 'destroy', function (proceed) {\n        this.batchMSEvents(removeEvent);\n        proceed.call(this);\n    });\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/MSPointer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Navigator.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Navigator.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Scrollbar_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Scrollbar.js */ \"./node_modules/highcharts/js/es-modules/parts/Scrollbar.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    defaultDataGroupingUnits = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultDataGroupingUnits,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    erase = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    error = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    hasTouch = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasTouch,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isTouchDevice = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isTouchDevice,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    Scrollbar = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Scrollbar,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n\n    units = [].concat(defaultDataGroupingUnits), // copy\n    defaultSeriesType,\n\n    // Finding the min or max of a set of variables where we don't know if they\n    // are defined, is a pattern that is repeated several places in Highcharts.\n    // Consider making this a global utility method.\n    numExt = function (extreme) {\n        var numbers = grep(arguments, isNumber);\n        if (numbers.length) {\n            return Math[extreme].apply(0, numbers);\n        }\n    };\n\n// add more resolution to units\nunits[4] = ['day', [1, 2, 3, 4]]; // allow more days\nunits[5] = ['week', [1, 2, 3]]; // allow more weeks\n\ndefaultSeriesType = seriesTypes.areaspline === undefined ?\n    'line' :\n    'areaspline';\n\nextend(defaultOptions, {\n\n    /**\n     * The navigator is a small series below the main series, displaying\n     * a view of the entire data set. It provides tools to zoom in and\n     * out on parts of the data as well as panning across the dataset.\n     *\n     * @product highstock\n     * @optionparent navigator\n     */\n    navigator: {\n\n        /**\n         * Whether the navigator and scrollbar should adapt to updated data\n         * in the base X axis. When loading data async, as in the demo below,\n         * this should be `false`. Otherwise new data will trigger navigator\n         * redraw, which will cause unwanted looping. In the demo below, the\n         * data in the navigator is set only once. On navigating, only the main\n         * chart content is updated.\n         *\n         * @sample {highstock} stock/demo/lazy-loading/\n         *         Set to false with async data loading\n         *\n         * @type       {boolean}\n         * @default    true\n         * @product    highstock\n         * @apioption  navigator.adaptToUpdatedData\n         */\n\n        /**\n         * An integer identifying the index to use for the base series, or a\n         * string representing the id of the series.\n         *\n         * **Note**: As of Highcharts 5.0, this is now a deprecated option.\n         * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).\n         *\n         * @see [series.showInNavigator](#plotOptions.series.showInNavigator)\n         *\n         * @deprecated\n         * @type       {*}\n         * @default    0\n         * @product    highstock\n         * @apioption  navigator.baseSeries\n         */\n\n        /**\n         * Enable or disable the navigator.\n         *\n         * @sample {highstock} stock/navigator/enabled/ Disable the navigator\n         *\n         * @type       {boolean}\n         * @default    true\n         * @product    highstock\n         * @apioption  navigator.enabled\n         */\n\n        /**\n         * When the chart is inverted, whether to draw the navigator on the\n         * opposite side.\n         *\n         * @type       {boolean}\n         * @default    false\n         * @since      5.0.8\n         * @product    highstock\n         * @apioption  navigator.opposite\n         */\n\n        /**\n         * The height of the navigator.\n         *\n         * @sample {highstock} stock/navigator/height/\n         *         A higher navigator\n         *\n         * @type       {number}\n         * @default    40\n         * @product    highstock\n         * @apioption  navigator.height\n         */\n        height: 40,\n\n        /**\n         * The distance from the nearest element, the X axis or X axis labels.\n         *\n         * @sample {highstock} stock/navigator/margin/\n         *         A margin of 2 draws the navigator closer to the X axis labels\n         *\n         * @type       {number}\n         * @default    25\n         * @product    highstock\n         * @apioption  navigator.margin\n         */\n        margin: 25,\n\n        /**\n         * Whether the mask should be inside the range marking the zoomed\n         * range, or outside. In Highstock 1.x it was always `false`.\n         *\n         * @sample {highstock} stock/navigator/maskinside-false/\n         *         False, mask outside\n         *\n         * @type       {boolean}\n         * @default    true\n         * @since      2.0\n         * @product    highstock\n         * @apioption  navigator.maskInside\n         */\n        maskInside: true,\n\n        /**\n         * Options for the handles for dragging the zoomed area.\n         *\n         * @sample {highstock} stock/navigator/handles/\n         *         Colored handles\n         *\n         * @type       {*}\n         * @product    highstock\n         * @apioption  navigator.handles\n         */\n        handles: {\n            /**\n             * Width for handles.\n             *\n             * @sample {highstock} stock/navigator/styled-handles/\n             *         Styled handles\n             *\n             * @type       {number}\n             * @default    7\n             * @since      6.0.0\n             * @product    highstock\n             * @apioption  navigator.handles.width\n             */\n            width: 7,\n\n            /**\n             * Height for handles.\n             *\n             * @sample {highstock} stock/navigator/styled-handles/\n             *         Styled handles\n             *\n             * @type       {number}\n             * @default    15\n             * @since      6.0.0\n             * @product    highstock\n             * @apioption  navigator.handles.height\n             */\n            height: 15,\n\n            /**\n             * Array to define shapes of handles. 0-index for left, 1-index for\n             * right.\n             *\n             * Additionally, the URL to a graphic can be given on this form:\n             * `url(graphic.png)`. Note that for the image to be applied to\n             * exported charts, its URL needs to be accessible by the export\n             * server.\n             *\n             * Custom callbacks for symbol path generation can also be added to\n             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n             * used by its method name, as shown in the demo.\n             *\n             * @sample {highstock} stock/navigator/styled-handles/\n             *         Styled handles\n             *\n             * @type       {Array<string>}\n             * @default    ['navigator-handle', 'navigator-handle']\n             * @since      6.0.0\n             * @product    highstock\n             * @apioption  navigator.handles.symbols\n             */\n            symbols: ['navigator-handle', 'navigator-handle'],\n\n            /**\n             * Allows to enable/disable handles.\n             *\n             * @type       {boolean}\n             * @default    true\n             * @since      6.0.0\n             * @product    highstock\n             * @apioption  navigator.handles.enabled\n             */\n            enabled: true\n\n            \n        },\n\n        \n\n        /**\n         * Options for the navigator series. Available options are the same\n         * as any series, documented at [plotOptions](#plotOptions.series)\n         * and [series](#series).\n         *\n         * Unless data is explicitly defined on navigator.series, the data\n         * is borrowed from the first series in the chart.\n         *\n         * Default series options for the navigator series are:\n         *\n         * <pre>series: {\n         *     type: 'areaspline',\n         *     fillOpacity: 0.05,\n         *     dataGrouping: {\n         *         smoothed: true\n         *     },\n         *     lineWidth: 1,\n         *     marker: {\n         *         enabled: false\n         *     }\n         * }</pre>\n         *\n         * @see In styled mode, the navigator series is styled with the\n         *      `.highcharts-navigator-series` class.\n         *\n         * @sample {highstock} stock/navigator/series-data/\n         *         Using a separate data set for the navigator\n         * @sample {highstock} stock/navigator/series/\n         *         A green navigator series\n         *\n         * @type       {*}\n         * @product    highstock\n         * @apioption  navigator.series\n         */\n        series: {\n\n            /**\n             * The type of the navigator series. Defaults to `areaspline` if\n             * defined, otherwise `line`.\n             *\n             * @type       {string}\n             * @default    areaspline\n             * @apioption  navigator.series.type\n             */\n            type: defaultSeriesType,\n            \n\n            /**\n             * @ignore-option\n             */\n            compare: null,\n\n            /**\n             * Data grouping options for the navigator series.\n             *\n             * @type       {*}\n             * @extends    plotOptions.series.dataGrouping\n             * @apioption  navigator.series.dataGrouping\n             */\n            dataGrouping: {\n                approximation: 'average',\n                enabled: true,\n                groupPixelWidth: 2,\n                smoothed: true,\n                units: units\n            },\n\n            /**\n             * Data label options for the navigator series. Data labels are\n             * disabled by default on the navigator series.\n             *\n             * @type       {*}\n             * @extends    plotOptions.series.dataLabels\n             * @apioption  navigator.series.dataLabels\n             */\n            dataLabels: {\n                enabled: false,\n                zIndex: 2 // #1839\n            },\n\n            id: 'highcharts-navigator-series',\n            className: 'highcharts-navigator-series',\n\n            /**\n             * Line color for the navigator series. Allows setting the color\n             * while disallowing the default candlestick setting.\n             *\n             * @type       {Highcharts.ColorString|null}\n             * @default    null\n             * @apioption  navigator.series.lineColor\n             */\n            lineColor: null, // #4602\n\n            marker: {\n                enabled: false\n            },\n\n            pointRange: 0,\n            /**\n             * The threshold option. Setting it to 0 will make the default\n             * navigator area series draw its area from the 0 value and up.\n             *\n             * @type       {number|null}\n             * @default    null\n             * @apioption  navigator.series.threshold\n             */\n            threshold: null\n        },\n\n        /**\n         * Options for the navigator X axis. Default series options\n         * for the navigator xAxis are:\n         *\n         * <pre>xAxis: {\n         *     tickWidth: 0,\n         *     lineWidth: 0,\n         *     gridLineWidth: 1,\n         *     tickPixelInterval: 200,\n         *     labels: {\n         *            align: 'left',\n         *         style: {\n         *             color: '#888'\n         *         },\n         *         x: 3,\n         *         y: -4\n         *     }\n         * }</pre>\n         *\n         * @type       {*}\n         * @extends    xAxis\n         * @excluding  linkedTo,maxZoom,minRange,opposite,range,scrollbar,\n         *             showEmpty,maxRange\n         * @product    highstock\n         * @apioption  navigator.xAxis\n         */\n        xAxis: {\n            /**\n             * Additional range on the right side of the xAxis. Works similar to\n             * xAxis.maxPadding, but value is set in milliseconds.\n             * Can be set for both, main xAxis and navigator's xAxis.\n             *\n             * @type       {number}\n             * @default    0\n             * @since      6.0.0\n             * @product    highstock\n             * @apioption  navigator.xAxis.overscroll\n             */\n            overscroll: 0,\n\n            className: 'highcharts-navigator-xaxis',\n            tickLength: 0,\n\n            \n\n            tickPixelInterval: 200,\n\n            labels: {\n                align: 'left',\n\n                \n\n                x: 3,\n                y: -4\n            },\n\n            crosshair: false\n        },\n\n        /**\n         * Options for the navigator Y axis. Default series options\n         * for the navigator yAxis are:\n         *\n         * <pre>yAxis: {\n         *     gridLineWidth: 0,\n         *     startOnTick: false,\n         *     endOnTick: false,\n         *     minPadding: 0.1,\n         *     maxPadding: 0.1,\n         *     labels: {\n         *         enabled: false\n         *     },\n         *     title: {\n         *         text: null\n         *     },\n         *     tickWidth: 0\n         * }</pre>\n         *\n         * @type       {*}\n         * @extends    yAxis\n         * @excluding  height,linkedTo,maxZoom,minRange,ordinal,range,showEmpty,\n         *             scrollbar,top,units,maxRange,minLength,maxLength,resize\n         * @product    highstock\n         * @apioption  navigator.yAxis\n         */\n        yAxis: {\n\n            className: 'highcharts-navigator-yaxis',\n\n            \n\n            startOnTick: false,\n            endOnTick: false,\n            minPadding: 0.1,\n            maxPadding: 0.1,\n            labels: {\n                enabled: false\n            },\n            crosshair: false,\n            title: {\n                text: null\n            },\n            tickLength: 0,\n            tickWidth: 0\n        }\n    }\n});\n\n/**\n * Draw one of the handles on the side of the zoomed range in the navigator\n *\n * @function Highcharts.Renderer#symbols.navigator-handle\n *\n * @param  {boolean} inverted\n *         flag for chart.inverted\n *\n * @return {Array<number|string>}\n *         Path to be used in a handle\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer.prototype.symbols[\"navigator-handle\"] = function (\n    x,\n    y,\n    w,\n    h,\n    options\n) {\n    var halfWidth = options.width / 2,\n        markerPosition = Math.round(halfWidth / 3) + 0.5,\n        height = options.height;\n\n    return [\n        'M',\n        -halfWidth - 1, 0.5,\n        'L',\n        halfWidth, 0.5,\n        'L',\n        halfWidth, height + 0.5,\n        'L',\n        -halfWidth - 1, height + 0.5,\n        'L',\n        -halfWidth - 1, 0.5,\n        'M',\n        -markerPosition, 4,\n        'L',\n        -markerPosition, height - 3,\n        'M',\n        markerPosition - 1, 4,\n        'L',\n        markerPosition - 1, height - 3\n    ];\n};\n\n/**\n * The Navigator class\n *\n * @class Highcharts.Navigator\n *\n * @param {Highcharts.Chart} chart\n *        Chart object\n */\nfunction Navigator(chart) {\n    this.init(chart);\n}\n\nNavigator.prototype = {\n    /**\n     * Draw one of the handles on the side of the zoomed range in the navigator\n     *\n     * @function Highcharts.Navigator#drawHandle\n     *\n     * @param  {number} x\n     *         The x center for the handle\n     *\n     * @param  {number} index\n     *         0 for left and 1 for right\n     * @param  {boolean} inverted\n     *         flag for chart.inverted\n     * @param  {string} verb\n     *         use 'animate' or 'attr'\n     *\n     * @return {void}\n     */\n    drawHandle: function (x, index, inverted, verb) {\n        var navigator = this,\n            height = navigator.navigatorOptions.handles.height;\n\n        // Place it\n        navigator.handles[index][verb](inverted ? {\n            translateX: Math.round(navigator.left + navigator.height / 2),\n            translateY: Math.round(\n                navigator.top + parseInt(x, 10) + 0.5 - height\n            )\n        } : {\n            translateX: Math.round(navigator.left + parseInt(x, 10)),\n            translateY: Math.round(\n                navigator.top + navigator.height / 2 - height / 2 - 1\n            )\n        });\n    },\n\n    /**\n     * Render outline around the zoomed range\n     *\n     * @function Highcharts.Navigator#drawOutline\n     *\n     * @param  {number} zoomedMin\n     *         in pixels position where zoomed range starts\n     *\n     * @param  {number} zoomedMax\n     *         in pixels position where zoomed range ends\n     *\n     * @param  {boolean} inverted\n     *         flag if chart is inverted\n     *\n     * @param  {string} verb\n     *         use 'animate' or 'attr'\n     *\n     * @return {void}\n     */\n    drawOutline: function (zoomedMin, zoomedMax, inverted, verb) {\n        var navigator = this,\n            maskInside = navigator.navigatorOptions.maskInside,\n            outlineWidth = navigator.outline.strokeWidth(),\n            halfOutline = outlineWidth / 2,\n            outlineCorrection = (outlineWidth % 2) / 2, // #5800\n            outlineHeight = navigator.outlineHeight,\n            scrollbarHeight = navigator.scrollbarHeight,\n            navigatorSize = navigator.size,\n            left = navigator.left - scrollbarHeight,\n            navigatorTop = navigator.top,\n            verticalMin,\n            path;\n\n        if (inverted) {\n            left -= halfOutline;\n            verticalMin = navigatorTop + zoomedMax + outlineCorrection;\n            zoomedMax = navigatorTop + zoomedMin + outlineCorrection;\n\n            path = [\n                'M',\n                left + outlineHeight,\n                navigatorTop - scrollbarHeight - outlineCorrection, // top edge\n                'L',\n                left + outlineHeight,\n                verticalMin, // top right of zoomed range\n                'L',\n                left,\n                verticalMin, // top left of z.r.\n                'L',\n                left,\n                zoomedMax, // bottom left of z.r.\n                'L',\n                left + outlineHeight,\n                zoomedMax, // bottom right of z.r.\n                'L',\n                left + outlineHeight,\n                navigatorTop + navigatorSize + scrollbarHeight // bottom edge\n            ].concat(maskInside ? [\n                'M',\n                left + outlineHeight,\n                verticalMin - halfOutline, // upper left of zoomed range\n                'L',\n                left + outlineHeight,\n                zoomedMax + halfOutline // upper right of z.r.\n            ] : []);\n        } else {\n            zoomedMin += left + scrollbarHeight - outlineCorrection;\n            zoomedMax += left + scrollbarHeight - outlineCorrection;\n            navigatorTop += halfOutline;\n\n            path = [\n                'M',\n                left,\n                navigatorTop, // left\n                'L',\n                zoomedMin,\n                navigatorTop, // upper left of zoomed range\n                'L',\n                zoomedMin,\n                navigatorTop + outlineHeight, // lower left of z.r.\n                'L',\n                zoomedMax,\n                navigatorTop + outlineHeight, // lower right of z.r.\n                'L',\n                zoomedMax,\n                navigatorTop, // upper right of z.r.\n                'L',\n                left + navigatorSize + scrollbarHeight * 2,\n                navigatorTop // right\n            ].concat(maskInside ? [\n                'M',\n                zoomedMin - halfOutline,\n                navigatorTop, // upper left of zoomed range\n                'L',\n                zoomedMax + halfOutline,\n                navigatorTop // upper right of z.r.\n            ] : []);\n        }\n        navigator.outline[verb]({\n            d: path\n        });\n    },\n\n    /**\n     * Render outline around the zoomed range\n     *\n     * @function Highcharts.Navigator#drawMasks\n     *\n     * @param  {number} zoomedMin\n     *         in pixels position where zoomed range starts\n     *\n     * @param  {number} zoomedMax\n     *         in pixels position where zoomed range ends\n     *\n     * @param  {boolean} inverted\n     *         flag if chart is inverted\n     *\n     * @param  {string} verb\n     *         use 'animate' or 'attr'\n     *\n     * @return {void}\n     */\n    drawMasks: function (zoomedMin, zoomedMax, inverted, verb) {\n        var navigator = this,\n            left = navigator.left,\n            top = navigator.top,\n            navigatorHeight = navigator.height,\n            height,\n            width,\n            x,\n            y;\n\n        // Determine rectangle position & size\n        // According to (non)inverted position:\n        if (inverted) {\n            x = [left, left, left];\n            y = [top, top + zoomedMin, top + zoomedMax];\n            width = [navigatorHeight, navigatorHeight, navigatorHeight];\n            height = [\n                zoomedMin,\n                zoomedMax - zoomedMin,\n                navigator.size - zoomedMax\n            ];\n        } else {\n            x = [left, left + zoomedMin, left + zoomedMax];\n            y = [top, top, top];\n            width = [\n                zoomedMin,\n                zoomedMax - zoomedMin,\n                navigator.size - zoomedMax\n            ];\n            height = [navigatorHeight, navigatorHeight, navigatorHeight];\n        }\n        each(navigator.shades, function (shade, i) {\n            shade[verb]({\n                x: x[i],\n                y: y[i],\n                width: width[i],\n                height: height[i]\n            });\n        });\n    },\n\n    /**\n     * Generate DOM elements for a navigator:\n     * - main navigator group\n     * - all shades\n     * - outline\n     * - handles\n     *\n     * @function Highcharts.Navigator#renderElements\n     *\n     * @return {void}\n     */\n    renderElements: function () {\n        var navigator = this,\n            navigatorOptions = navigator.navigatorOptions,\n            maskInside = navigatorOptions.maskInside,\n            chart = navigator.chart,\n            inverted = chart.inverted,\n            renderer = chart.renderer,\n            navigatorGroup;\n\n        // Create the main navigator group\n        navigator.navigatorGroup = navigatorGroup = renderer.g('navigator')\n            .attr({\n                zIndex: 8,\n                visibility: 'hidden'\n            })\n            .add();\n\n\n        \n\n        // Create masks, each mask will get events and fill:\n        each([!maskInside, maskInside, !maskInside], function (hasMask, index) {\n            navigator.shades[index] = renderer.rect()\n                .addClass('highcharts-navigator-mask' +\n                    (index === 1 ? '-inside' : '-outside'))\n                \n                .add(navigatorGroup);\n        });\n\n        // Create the outline:\n        navigator.outline = renderer.path()\n            .addClass('highcharts-navigator-outline')\n            \n            .add(navigatorGroup);\n\n        // Create the handlers:\n        if (navigatorOptions.handles.enabled) {\n            each([0, 1], function (index) {\n                navigatorOptions.handles.inverted = chart.inverted;\n                navigator.handles[index] = renderer.symbol(\n                    navigatorOptions.handles.symbols[index],\n                    -navigatorOptions.handles.width / 2 - 1,\n                    0,\n                    navigatorOptions.handles.width,\n                    navigatorOptions.handles.height,\n                    navigatorOptions.handles\n                );\n                // zIndex = 6 for right handle, 7 for left.\n                // Can't be 10, because of the tooltip in inverted chart #2908\n                navigator.handles[index].attr({ zIndex: 7 - index })\n                    .addClass(\n                        'highcharts-navigator-handle ' +\n                        'highcharts-navigator-handle-' +\n                        ['left', 'right'][index]\n                    ).add(navigatorGroup);\n\n                \n            });\n        }\n    },\n\n    /**\n     * Update navigator\n     *\n     * @function Highcharts.Navigator#update\n     *\n     * @param  {Highcharts.NavigatorOptions} options\n     *         Options to merge in when updating navigator\n     *\n     * @return {void}\n     */\n    update: function (options) {\n        // Remove references to old navigator series in base series\n        each(this.series || [], function (series) {\n            if (series.baseSeries) {\n                delete series.baseSeries.navigatorSeries;\n            }\n        });\n        // Destroy and rebuild navigator\n        this.destroy();\n        var chartOptions = this.chart.options;\n        merge(true, chartOptions.navigator, this.options, options);\n        this.init(this.chart);\n    },\n\n    /**\n     * Render the navigator\n     *\n     * @function Highcharts.Navigator#render\n     *\n     * @param  {number} min\n     *         X axis value minimum\n     *\n     * @param  {number} max\n     *         X axis value maximum\n     *\n     * @param  {number} pxMin\n     *         Pixel value minimum\n     *\n     * @param  {number} pxMax\n     *         Pixel value maximum\n     *\n     * @return {void}\n     */\n    render: function (min, max, pxMin, pxMax) {\n\n        var navigator = this,\n            chart = navigator.chart,\n            navigatorWidth,\n            scrollbarLeft,\n            scrollbarTop,\n            scrollbarHeight = navigator.scrollbarHeight,\n            navigatorSize,\n            xAxis = navigator.xAxis,\n            scrollbarXAxis = xAxis.fake ? chart.xAxis[0] : xAxis,\n            navigatorEnabled = navigator.navigatorEnabled,\n            zoomedMin,\n            zoomedMax,\n            rendered = navigator.rendered,\n            inverted = chart.inverted,\n            verb,\n            newMin,\n            newMax,\n            currentRange,\n            minRange = chart.xAxis[0].minRange,\n            maxRange = chart.xAxis[0].options.maxRange;\n\n        // Don't redraw while moving the handles (#4703).\n        if (this.hasDragged && !defined(pxMin)) {\n            return;\n        }\n\n        // Don't render the navigator until we have data (#486, #4202, #5172).\n        if (!isNumber(min) || !isNumber(max)) {\n            // However, if navigator was already rendered, we may need to resize\n            // it. For example hidden series, but visible navigator (#6022).\n            if (rendered) {\n                pxMin = 0;\n                pxMax = pick(xAxis.width, scrollbarXAxis.width);\n            } else {\n                return;\n            }\n        }\n\n        navigator.left = pick(\n            xAxis.left,\n            // in case of scrollbar only, without navigator\n            chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0)\n        );\n\n        navigator.size = zoomedMax = navigatorSize = pick(\n            xAxis.len,\n            (inverted ? chart.plotHeight : chart.plotWidth) -\n                2 * scrollbarHeight\n        );\n\n        if (inverted) {\n            navigatorWidth = scrollbarHeight;\n        } else {\n            navigatorWidth = navigatorSize + 2 * scrollbarHeight;\n        }\n\n        // Get the pixel position of the handles\n        pxMin = pick(pxMin, xAxis.toPixels(min, true));\n        pxMax = pick(pxMax, xAxis.toPixels(max, true));\n\n        // Verify (#1851, #2238)\n        if (!isNumber(pxMin) || Math.abs(pxMin) === Infinity) {\n            pxMin = 0;\n            pxMax = navigatorWidth;\n        }\n\n        // Are we below the minRange? (#2618, #6191)\n        newMin = xAxis.toValue(pxMin, true);\n        newMax = xAxis.toValue(pxMax, true);\n        currentRange = Math.abs(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat(newMax - newMin));\n        if (currentRange < minRange) {\n            if (this.grabbedLeft) {\n                pxMin = xAxis.toPixels(newMax - minRange, true);\n            } else if (this.grabbedRight) {\n                pxMax = xAxis.toPixels(newMin + minRange, true);\n            }\n        } else if (defined(maxRange) && currentRange > maxRange) {\n            /**\n             * Maximum range which can be set using the navigator's handles.\n             * Opposite of [xAxis.minRange](#xAxis.minRange).\n             *\n             * @type {Number}\n             * @default undefined\n             * @product highstock\n             * @sample {highstock} stock/navigator/maxrange/\n             *         Defined max and min range\n             * @since 6.0.0\n             * @apioption xAxis.maxRange\n             */\n            if (this.grabbedLeft) {\n                pxMin = xAxis.toPixels(newMax - maxRange, true);\n            } else if (this.grabbedRight) {\n                pxMax = xAxis.toPixels(newMin + maxRange, true);\n            }\n        }\n\n        // Handles are allowed to cross, but never exceed the plot area\n        navigator.zoomedMax = Math.min(Math.max(pxMin, pxMax, 0), zoomedMax);\n        navigator.zoomedMin = Math.min(\n            Math.max(\n                navigator.fixedWidth ?\n                    navigator.zoomedMax - navigator.fixedWidth :\n                    Math.min(pxMin, pxMax),\n                0\n            ),\n            zoomedMax\n        );\n\n        navigator.range = navigator.zoomedMax - navigator.zoomedMin;\n\n        zoomedMax = Math.round(navigator.zoomedMax);\n        zoomedMin = Math.round(navigator.zoomedMin);\n\n        if (navigatorEnabled) {\n            navigator.navigatorGroup.attr({\n                visibility: 'visible'\n            });\n            // Place elements\n            verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';\n\n            navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);\n            navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);\n\n            if (navigator.navigatorOptions.handles.enabled) {\n                navigator.drawHandle(zoomedMin, 0, inverted, verb);\n                navigator.drawHandle(zoomedMax, 1, inverted, verb);\n            }\n        }\n\n        if (navigator.scrollbar) {\n            if (inverted) {\n                scrollbarTop = navigator.top - scrollbarHeight;\n                scrollbarLeft = navigator.left - scrollbarHeight +\n                    (navigatorEnabled || !scrollbarXAxis.opposite ? 0 :\n                        // Multiple axes has offsets:\n                        (scrollbarXAxis.titleOffset || 0) +\n                        // Self margin from the axis.title\n                        scrollbarXAxis.axisTitleMargin\n                    );\n                scrollbarHeight = navigatorSize + 2 * scrollbarHeight;\n            } else {\n                scrollbarTop = navigator.top +\n                    (navigatorEnabled ? navigator.height : -scrollbarHeight);\n                scrollbarLeft = navigator.left - scrollbarHeight;\n            }\n            // Reposition scrollbar\n            navigator.scrollbar.position(\n                scrollbarLeft,\n                scrollbarTop,\n                navigatorWidth,\n                scrollbarHeight\n            );\n            // Keep scale 0-1\n            navigator.scrollbar.setRange(\n                // Use real value, not rounded because range can be very small\n                // (#1716)\n                navigator.zoomedMin / (navigatorSize || 1),\n                navigator.zoomedMax / (navigatorSize || 1)\n            );\n        }\n        navigator.rendered = true;\n    },\n\n    /**\n     * Set up the mouse and touch events for the navigator\n     *\n     * @function Highcharts.Navigator#addMouseEvents\n     *\n     * @return {void}\n     */\n    addMouseEvents: function () {\n        var navigator = this,\n            chart = navigator.chart,\n            container = chart.container,\n            eventsToUnbind = [],\n            mouseMoveHandler,\n            mouseUpHandler;\n\n        /**\n         * Create mouse events' handlers.\n         * Make them as separate functions to enable wrapping them:\n         */\n        navigator.mouseMoveHandler = mouseMoveHandler = function (e) {\n            navigator.onMouseMove(e);\n        };\n        navigator.mouseUpHandler = mouseUpHandler = function (e) {\n            navigator.onMouseUp(e);\n        };\n\n        // Add shades and handles mousedown events\n        eventsToUnbind = navigator.getPartsEvents('mousedown');\n        // Add mouse move and mouseup events. These are bind to doc/container,\n        // because Navigator.grabbedSomething flags are stored in mousedown\n        // events\n        eventsToUnbind.push(\n            addEvent(container, 'mousemove', mouseMoveHandler),\n            addEvent(container.ownerDocument, 'mouseup', mouseUpHandler)\n        );\n\n        // Touch events\n        if (hasTouch) {\n            eventsToUnbind.push(\n                addEvent(container, 'touchmove', mouseMoveHandler),\n                addEvent(container.ownerDocument, 'touchend', mouseUpHandler)\n            );\n            eventsToUnbind.concat(navigator.getPartsEvents('touchstart'));\n        }\n\n        navigator.eventsToUnbind = eventsToUnbind;\n\n        // Data events\n        if (navigator.series && navigator.series[0]) {\n            eventsToUnbind.push(\n                addEvent(\n                    navigator.series[0].xAxis,\n                    'foundExtremes',\n                    function () {\n                        chart.navigator.modifyNavigatorAxisExtremes();\n                    }\n                )\n            );\n        }\n    },\n\n    /**\n     * Generate events for handles and masks\n     *\n     * @function Highcharts.Navigator#getPartsEvents\n     *\n     * @param  {string} eventName\n     *         Event name handler, 'mousedown' or 'touchstart'\n     *\n     * @return {Array<*>}\n     *         An array of arrays: [DOMElement, eventName, callback].\n     */\n    getPartsEvents: function (eventName) {\n        var navigator = this,\n            events = [];\n        each(['shades', 'handles'], function (name) {\n            each(navigator[name], function (navigatorItem, index) {\n                events.push(\n                    addEvent(\n                        navigatorItem.element,\n                        eventName,\n                        function (e) {\n                            navigator[name + 'Mousedown'](e, index);\n                        }\n                    )\n                );\n            });\n        });\n        return events;\n    },\n\n    /**\n     * Mousedown on a shaded mask, either:\n     * - will be stored for future drag&drop\n     * - will directly shift to a new range\n     *\n     * @function Highcharts.Navigator#shadesMousedown\n     *\n     * @param  {*} e\n     *         Mouse event\n     *\n     * @param  {number} index\n     *         Index of a mask in Navigator.shades array\n     *\n     * @return {void}\n     */\n    shadesMousedown: function (e, index) {\n        e = this.chart.pointer.normalize(e);\n\n        var navigator = this,\n            chart = navigator.chart,\n            xAxis = navigator.xAxis,\n            zoomedMin = navigator.zoomedMin,\n            navigatorPosition = navigator.left,\n            navigatorSize = navigator.size,\n            range = navigator.range,\n            chartX = e.chartX,\n            fixedMax,\n            fixedMin,\n            ext,\n            left;\n\n        // For inverted chart, swap some options:\n        if (chart.inverted) {\n            chartX = e.chartY;\n            navigatorPosition = navigator.top;\n        }\n\n        if (index === 1) {\n            // Store information for drag&drop\n            navigator.grabbedCenter = chartX;\n            navigator.fixedWidth = range;\n            navigator.dragOffset = chartX - zoomedMin;\n        } else {\n            // Shift the range by clicking on shaded areas\n            left = chartX - navigatorPosition - range / 2;\n            if (index === 0) {\n                left = Math.max(0, left);\n            } else if (index === 2 && left + range >= navigatorSize) {\n                left = navigatorSize - range;\n                if (navigator.reversedExtremes) {\n                    // #7713\n                    left -= range;\n                    fixedMin = navigator.getUnionExtremes().dataMin;\n                } else {\n                    // #2293, #3543\n                    fixedMax = navigator.getUnionExtremes().dataMax;\n                }\n            }\n            if (left !== zoomedMin) { // it has actually moved\n                navigator.fixedWidth = range; // #1370\n\n                ext = xAxis.toFixedRange(\n                    left,\n                    left + range,\n                    fixedMin,\n                    fixedMax\n                );\n                if (defined(ext.min)) { // #7411\n                    chart.xAxis[0].setExtremes(\n                        Math.min(ext.min, ext.max),\n                        Math.max(ext.min, ext.max),\n                        true,\n                        null, // auto animation\n                        { trigger: 'navigator' }\n                    );\n                }\n            }\n        }\n    },\n\n    /**\n     * Mousedown on a handle mask.\n     * Will store necessary information for drag&drop.\n     *\n     * @function Highcharts.Navigator#handlesMousedown\n     *\n     * @param  {*} e\n     *         Mouse event\n     *\n     * @param  {number} index\n     *         Index of a handle in Navigator.handles array\n     *\n     * @return {void}\n     */\n    handlesMousedown: function (e, index) {\n        e = this.chart.pointer.normalize(e);\n\n        var navigator = this,\n            chart = navigator.chart,\n            baseXAxis = chart.xAxis[0],\n            // For reversed axes, min and max are changed,\n            // so the other extreme should be stored\n            reverse = navigator.reversedExtremes;\n\n        if (index === 0) {\n            // Grab the left handle\n            navigator.grabbedLeft = true;\n            navigator.otherHandlePos = navigator.zoomedMax;\n            navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;\n        } else {\n            // Grab the right handle\n            navigator.grabbedRight = true;\n            navigator.otherHandlePos = navigator.zoomedMin;\n            navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;\n        }\n\n        chart.fixedRange = null;\n    },\n    /**\n     * Mouse move event based on x/y mouse position.\n     *\n     * @function Highcharts.Navigator#onMouseMove\n     *\n     * @param  {*} e\n     *         Mouse event\n     *\n     * @return {void}\n     */\n    onMouseMove: function (e) {\n        var navigator = this,\n            chart = navigator.chart,\n            left = navigator.left,\n            navigatorSize = navigator.navigatorSize,\n            range = navigator.range,\n            dragOffset = navigator.dragOffset,\n            inverted = chart.inverted,\n            chartX;\n\n\n        // In iOS, a mousemove event with e.pageX === 0 is fired when holding\n        // the finger down in the center of the scrollbar. This should be\n        // ignored.\n        if (!e.touches || e.touches[0].pageX !== 0) { // #4696\n\n            e = chart.pointer.normalize(e);\n            chartX = e.chartX;\n\n            // Swap some options for inverted chart\n            if (inverted) {\n                left = navigator.top;\n                chartX = e.chartY;\n            }\n\n            // Drag left handle or top handle\n            if (navigator.grabbedLeft) {\n                navigator.hasDragged = true;\n                navigator.render(\n                    0,\n                    0,\n                    chartX - left,\n                    navigator.otherHandlePos\n                );\n            // Drag right handle or bottom handle\n            } else if (navigator.grabbedRight) {\n                navigator.hasDragged = true;\n                navigator.render(\n                    0,\n                    0,\n                    navigator.otherHandlePos,\n                    chartX - left\n                );\n            // Drag scrollbar or open area in navigator\n            } else if (navigator.grabbedCenter) {\n                navigator.hasDragged = true;\n                if (chartX < dragOffset) { // outside left\n                    chartX = dragOffset;\n                // outside right\n                } else if (chartX > navigatorSize + dragOffset - range) {\n                    chartX = navigatorSize + dragOffset - range;\n                }\n\n                navigator.render(\n                    0,\n                    0,\n                    chartX - dragOffset,\n                    chartX - dragOffset + range\n                );\n            }\n            if (\n                navigator.hasDragged &&\n                navigator.scrollbar &&\n                pick(\n                    navigator.scrollbar.options.liveRedraw,\n\n                    // By default, don't run live redraw on VML, on touch\n                    // devices or if the chart is in boost.\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg && !isTouchDevice && !this.chart.isBoosting\n                )\n            ) {\n                e.DOMType = e.type; // DOMType is for IE8\n                setTimeout(function () {\n                    navigator.onMouseUp(e);\n                }, 0);\n            }\n        }\n    },\n\n    /**\n     * Mouse up event based on x/y mouse position.\n     *\n     * @function Highcharts.Navigator#onMouseUp\n     *\n     * @param  {*} e\n     *         Mouse event\n     *\n     * @return {void}\n     */\n    onMouseUp: function (e) {\n        var navigator = this,\n            chart = navigator.chart,\n            xAxis = navigator.xAxis,\n            scrollbar = navigator.scrollbar,\n            unionExtremes,\n            fixedMin,\n            fixedMax,\n            ext,\n            DOMEvent = e.DOMEvent || e;\n\n        if (\n            // MouseUp is called for both, navigator and scrollbar (that order),\n            // which causes calling afterSetExtremes twice. Prevent first call\n            // by checking if scrollbar is going to set new extremes (#6334)\n            (navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged)) ||\n            e.trigger === 'scrollbar'\n        ) {\n            unionExtremes = navigator.getUnionExtremes();\n\n            // When dragging one handle, make sure the other one doesn't change\n            if (navigator.zoomedMin === navigator.otherHandlePos) {\n                fixedMin = navigator.fixedExtreme;\n            } else if (navigator.zoomedMax === navigator.otherHandlePos) {\n                fixedMax = navigator.fixedExtreme;\n            }\n            // Snap to right edge (#4076)\n            if (navigator.zoomedMax === navigator.size) {\n                fixedMax = navigator.reversedExtremes ?\n                    unionExtremes.dataMin : unionExtremes.dataMax;\n            }\n\n            // Snap to left edge (#7576)\n            if (navigator.zoomedMin === 0) {\n                fixedMin = navigator.reversedExtremes ?\n                    unionExtremes.dataMax : unionExtremes.dataMin;\n            }\n\n            ext = xAxis.toFixedRange(\n                navigator.zoomedMin,\n                navigator.zoomedMax,\n                fixedMin,\n                fixedMax\n            );\n\n            if (defined(ext.min)) {\n                chart.xAxis[0].setExtremes(\n                    Math.min(ext.min, ext.max),\n                    Math.max(ext.min, ext.max),\n                    true,\n                    // Run animation when clicking buttons, scrollbar track etc,\n                    // but not when dragging handles or scrollbar\n                    navigator.hasDragged ? false : null,\n                    {\n                        trigger: 'navigator',\n                        triggerOp: 'navigator-drag',\n                        DOMEvent: DOMEvent // #1838\n                    }\n                );\n            }\n        }\n\n        if (e.DOMType !== 'mousemove') {\n            navigator.grabbedLeft = navigator.grabbedRight =\n                navigator.grabbedCenter = navigator.fixedWidth =\n                navigator.fixedExtreme = navigator.otherHandlePos =\n                navigator.hasDragged = navigator.dragOffset = null;\n        }\n    },\n\n    /**\n     * Removes the event handlers attached previously with addEvents.\n     *\n     * @function Highcharts.Navigator#removeEvents\n     *\n     * @return {void}\n     */\n    removeEvents: function () {\n        if (this.eventsToUnbind) {\n            each(this.eventsToUnbind, function (unbind) {\n                unbind();\n            });\n            this.eventsToUnbind = undefined;\n        }\n        this.removeBaseSeriesEvents();\n    },\n\n    /**\n     * Remove data events.\n     *\n     * @function Highcharts.Navigator#removeBaseSeriesEvents\n     *\n     * @return {void}\n     */\n    removeBaseSeriesEvents: function () {\n        var baseSeries = this.baseSeries || [];\n        if (this.navigatorEnabled && baseSeries[0]) {\n            if (this.navigatorOptions.adaptToUpdatedData !== false) {\n                each(baseSeries, function (series) {\n                    removeEvent(series, 'updatedData', this.updatedDataHandler);\n                }, this);\n            }\n\n            // We only listen for extremes-events on the first baseSeries\n            if (baseSeries[0].xAxis) {\n                removeEvent(\n                    baseSeries[0].xAxis,\n                    'foundExtremes',\n                    this.modifyBaseAxisExtremes\n                );\n            }\n        }\n    },\n\n    /**\n     * Initiate the Navigator object\n     *\n     * @function Highcharts.Navigator#init\n     *\n     * @param  {Highcharts.Chart} chart\n     *\n     * @return {void}\n     */\n    init: function (chart) {\n        var chartOptions = chart.options,\n            navigatorOptions = chartOptions.navigator,\n            navigatorEnabled = navigatorOptions.enabled,\n            scrollbarOptions = chartOptions.scrollbar,\n            scrollbarEnabled = scrollbarOptions.enabled,\n            height = navigatorEnabled ? navigatorOptions.height : 0,\n            scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;\n\n        this.handles = [];\n        this.shades = [];\n\n        this.chart = chart;\n        this.setBaseSeries();\n\n        this.height = height;\n        this.scrollbarHeight = scrollbarHeight;\n        this.scrollbarEnabled = scrollbarEnabled;\n        this.navigatorEnabled = navigatorEnabled;\n        this.navigatorOptions = navigatorOptions;\n        this.scrollbarOptions = scrollbarOptions;\n        this.outlineHeight = height + scrollbarHeight;\n\n        this.opposite = pick(\n            navigatorOptions.opposite,\n            !navigatorEnabled && chart.inverted\n        ); // #6262\n\n        var navigator = this,\n            baseSeries = navigator.baseSeries,\n            xAxisIndex = chart.xAxis.length,\n            yAxisIndex = chart.yAxis.length,\n            baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis ||\n                chart.xAxis[0] || { options: {} };\n\n        chart.isDirtyBox = true;\n\n        if (navigator.navigatorEnabled) {\n            // an x axis is required for scrollbar also\n            navigator.xAxis = new Axis(chart, merge({\n                // inherit base xAxis' break and ordinal options\n                breaks: baseXaxis.options.breaks,\n                ordinal: baseXaxis.options.ordinal\n            }, navigatorOptions.xAxis, {\n                id: 'navigator-x-axis',\n                yAxis: 'navigator-y-axis',\n                isX: true,\n                type: 'datetime',\n                index: xAxisIndex,\n                isInternal: true,\n                offset: 0,\n                keepOrdinalPadding: true, // #2436\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0,\n                maxPadding: 0,\n                zoomEnabled: false\n            }, chart.inverted ? {\n                offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],\n                width: height\n            } : {\n                offsets: [0, -scrollbarHeight, 0, scrollbarHeight],\n                height: height\n            }));\n\n            navigator.yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {\n                id: 'navigator-y-axis',\n                alignTicks: false,\n                offset: 0,\n                index: yAxisIndex,\n                isInternal: true,\n                zoomEnabled: false\n            }, chart.inverted ? {\n                width: height\n            } : {\n                height: height\n            }));\n\n            // If we have a base series, initialize the navigator series\n            if (baseSeries || navigatorOptions.series.data) {\n                navigator.updateNavigatorSeries(false);\n\n            // If not, set up an event to listen for added series\n            } else if (chart.series.length === 0) {\n\n                navigator.unbindRedraw = addEvent(\n                    chart,\n                    'beforeRedraw',\n                    function () {\n                        // We've got one, now add it as base\n                        if (chart.series.length > 0 && !navigator.series) {\n                            navigator.setBaseSeries();\n                            navigator.unbindRedraw(); // reset\n                        }\n                    }\n                );\n            }\n\n            navigator.reversedExtremes = (\n                chart.inverted && !navigator.xAxis.reversed\n            ) || (\n                !chart.inverted && navigator.xAxis.reversed\n            );\n\n            // Render items, so we can bind events to them:\n            navigator.renderElements();\n            // Add mouse events\n            navigator.addMouseEvents();\n\n        // in case of scrollbar only, fake an x axis to get translation\n        } else {\n            navigator.xAxis = {\n                translate: function (value, reverse) {\n                    var axis = chart.xAxis[0],\n                        ext = axis.getExtremes(),\n                        scrollTrackWidth = axis.len - 2 * scrollbarHeight,\n                        min = numExt('min', axis.options.min, ext.dataMin),\n                        valueRange = numExt(\n                            'max',\n                            axis.options.max,\n                            ext.dataMax\n                        ) - min;\n\n                    return reverse ?\n                        // from pixel to value\n                        (value * valueRange / scrollTrackWidth) + min :\n                        // from value to pixel\n                        scrollTrackWidth * (value - min) / valueRange;\n                },\n                toPixels: function (value) {\n                    return this.translate(value);\n                },\n                toValue: function (value) {\n                    return this.translate(value, true);\n                },\n                toFixedRange: Axis.prototype.toFixedRange,\n                fake: true\n            };\n        }\n\n\n        // Initialize the scrollbar\n        if (chart.options.scrollbar.enabled) {\n            chart.scrollbar = navigator.scrollbar = new Scrollbar(\n                chart.renderer,\n                merge(chart.options.scrollbar, {\n                    margin: navigator.navigatorEnabled ? 0 : 10,\n                    vertical: chart.inverted\n                }),\n                chart\n            );\n            addEvent(navigator.scrollbar, 'changed', function (e) {\n                var range = navigator.size,\n                    to = range * this.to,\n                    from = range * this.from;\n\n                navigator.hasDragged = navigator.scrollbar.hasDragged;\n                navigator.render(0, 0, from, to);\n\n                if (\n                    chart.options.scrollbar.liveRedraw ||\n                    (\n                        e.DOMType !== 'mousemove' &&\n                        e.DOMType !== 'touchmove'\n                    )\n                ) {\n                    setTimeout(function () {\n                        navigator.onMouseUp(e);\n                    });\n                }\n            });\n        }\n\n        // Add data events\n        navigator.addBaseSeriesEvents();\n        // Add redraw events\n        navigator.addChartEvents();\n    },\n\n    /**\n     * Get the union data extremes of the chart - the outer data extremes of the\n     * base X axis and the navigator axis.\n     *\n     * @function Highcharts.Navigator#getUnionExtremes\n     *\n     * @param  {boolean} returnFalseOnNoBaseSeries\n     *         as the param says.\n     *\n     * @return {*}\n     */\n    getUnionExtremes: function (returnFalseOnNoBaseSeries) {\n        var baseAxis = this.chart.xAxis[0],\n            navAxis = this.xAxis,\n            navAxisOptions = navAxis.options,\n            baseAxisOptions = baseAxis.options,\n            ret;\n\n        if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {\n            ret = {\n                dataMin: pick( // #4053\n                    navAxisOptions && navAxisOptions.min,\n                    numExt(\n                        'min',\n                        baseAxisOptions.min,\n                        baseAxis.dataMin,\n                        navAxis.dataMin,\n                        navAxis.min\n                    )\n                ),\n                dataMax: pick(\n                    navAxisOptions && navAxisOptions.max,\n                    numExt(\n                        'max',\n                        baseAxisOptions.max,\n                        baseAxis.dataMax,\n                        navAxis.dataMax,\n                        navAxis.max\n                    )\n                )\n            };\n        }\n        return ret;\n    },\n\n    /**\n     * Set the base series and update the navigator series from this. With a bit\n     * of modification we should be able to make this an API method to be called\n     * from the outside\n     *\n     * @function Highcharts.Navigator#setBaseSeries\n     *\n     * @param  {*} baseSeriesOptions\n     *         Additional series options for a navigator\n     *\n     * @param  {boolean} [redraw]\n     *         Whether to redraw after update.\n     *\n     * @return {void}\n     */\n    setBaseSeries: function (baseSeriesOptions, redraw) {\n        var chart = this.chart,\n            baseSeries = this.baseSeries = [];\n\n        baseSeriesOptions = (\n            baseSeriesOptions ||\n            chart.options && chart.options.navigator.baseSeries ||\n            0\n        );\n\n        // Iterate through series and add the ones that should be shown in\n        // navigator.\n        each(chart.series || [], function (series, i) {\n            if (\n                // Don't include existing nav series\n                !series.options.isInternal &&\n                (\n                    series.options.showInNavigator ||\n                    (\n                        i === baseSeriesOptions ||\n                        series.options.id === baseSeriesOptions\n                    ) &&\n                    series.options.showInNavigator !== false\n                )\n            ) {\n                baseSeries.push(series);\n            }\n        });\n\n        // When run after render, this.xAxis already exists\n        if (this.xAxis && !this.xAxis.fake) {\n            this.updateNavigatorSeries(true, redraw);\n        }\n    },\n\n    /**\n     * Update series in the navigator from baseSeries, adding new if does not\n     * exist.\n     *\n     * @function Highcharts.Navigator.updateNavigatorSeries\n     *\n     * @param  {boolean} addEvents\n     *\n     * @param  {boolean} redraw\n     *\n     * @return {void}\n     */\n    updateNavigatorSeries: function (addEvents, redraw) {\n        var navigator = this,\n            chart = navigator.chart,\n            baseSeries = navigator.baseSeries,\n            baseOptions,\n            mergedNavSeriesOptions,\n            chartNavigatorSeriesOptions = navigator.navigatorOptions.series,\n            baseNavigatorOptions,\n            navSeriesMixin = {\n                enableMouseTracking: false,\n                index: null, // #6162\n                linkedTo: null, // #6734\n                group: 'nav', // for columns\n                padXAxis: false,\n                xAxis: 'navigator-x-axis',\n                yAxis: 'navigator-y-axis',\n                showInLegend: false,\n                stacking: false, // #4823\n                isInternal: true\n            },\n            // Remove navigator series that are no longer in the baseSeries\n            navigatorSeries = navigator.series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep(\n                navigator.series || [], function (navSeries) {\n                    var base = navSeries.baseSeries;\n                    if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray(base, baseSeries) < 0) { // Not in array\n                        // If there is still a base series connected to this\n                        // series, remove event handler and reference.\n                        if (base) {\n                            removeEvent(\n                                base,\n                                'updatedData',\n                                navigator.updatedDataHandler\n                            );\n                            delete base.navigatorSeries;\n                        }\n                        // Kill the nav series. It may already have been\n                        // destroyed (#8715).\n                        if (navSeries.chart) {\n                            navSeries.destroy();\n                        }\n                        return false;\n                    }\n                    return true;\n                }\n            );\n\n        // Go through each base series and merge the options to create new\n        // series\n        if (baseSeries && baseSeries.length) {\n            each(baseSeries, function eachBaseSeries(base) {\n                var linkedNavSeries = base.navigatorSeries,\n                    userNavOptions = extend(\n                        // Grab color and visibility from base as default\n                        {\n                            color: base.color,\n                            visible: base.visible\n                        },\n                        !isArray(chartNavigatorSeriesOptions) ?\n                            chartNavigatorSeriesOptions :\n                            defaultOptions.navigator.series\n                    );\n\n                // Don't update if the series exists in nav and we have disabled\n                // adaptToUpdatedData.\n                if (\n                    linkedNavSeries &&\n                    navigator.navigatorOptions.adaptToUpdatedData === false\n                ) {\n                    return;\n                }\n\n                navSeriesMixin.name = 'Navigator ' + baseSeries.length;\n\n                baseOptions = base.options || {};\n                baseNavigatorOptions = baseOptions.navigatorOptions || {};\n                mergedNavSeriesOptions = merge(\n                    baseOptions,\n                    navSeriesMixin,\n                    userNavOptions,\n                    baseNavigatorOptions\n                );\n\n                // Merge data separately. Do a slice to avoid mutating the\n                // navigator options from base series (#4923).\n                var navigatorSeriesData =\n                    baseNavigatorOptions.data || userNavOptions.data;\n                navigator.hasNavigatorData =\n                    navigator.hasNavigatorData || !!navigatorSeriesData;\n                mergedNavSeriesOptions.data =\n                    navigatorSeriesData ||\n                    baseOptions.data && baseOptions.data.slice(0);\n\n                // Update or add the series\n                if (linkedNavSeries && linkedNavSeries.options) {\n                    linkedNavSeries.update(mergedNavSeriesOptions, redraw);\n                } else {\n                    base.navigatorSeries = chart.initSeries(\n                        mergedNavSeriesOptions\n                    );\n                    base.navigatorSeries.baseSeries = base; // Store ref\n                    navigatorSeries.push(base.navigatorSeries);\n                }\n            });\n        }\n\n        // If user has defined data (and no base series) or explicitly defined\n        // navigator.series as an array, we create these series on top of any\n        // base series.\n        if (\n            chartNavigatorSeriesOptions.data &&\n            !(baseSeries && baseSeries.length) ||\n            isArray(chartNavigatorSeriesOptions)\n        ) {\n            navigator.hasNavigatorData = false;\n            // Allow navigator.series to be an array\n            chartNavigatorSeriesOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat(chartNavigatorSeriesOptions);\n            each(chartNavigatorSeriesOptions, function (userSeriesOptions, i) {\n                navSeriesMixin.name =\n                    'Navigator ' + (navigatorSeries.length + 1);\n                mergedNavSeriesOptions = merge(\n                    defaultOptions.navigator.series,\n                    {\n                        // Since we don't have a base series to pull color from,\n                        // try to fake it by using color from series with same\n                        // index. Otherwise pull from the colors array. We need\n                        // an explicit color as otherwise updates will increment\n                        // color counter and we'll get a new color for each\n                        // update of the nav series.\n                        color: chart.series[i] &&\n                            !chart.series[i].options.isInternal &&\n                            chart.series[i].color ||\n                            chart.options.colors[i] ||\n                            chart.options.colors[0]\n                    },\n                    navSeriesMixin,\n                    userSeriesOptions\n                );\n                mergedNavSeriesOptions.data = userSeriesOptions.data;\n                if (mergedNavSeriesOptions.data) {\n                    navigator.hasNavigatorData = true;\n                    navigatorSeries.push(\n                        chart.initSeries(mergedNavSeriesOptions)\n                    );\n                }\n            });\n        }\n\n        if (addEvents) {\n            this.addBaseSeriesEvents();\n        }\n    },\n\n    /**\n     * Add data events.\n     * For example when main series is updated we need to recalculate extremes\n     *\n     * @function Highcharts.Navigator#addBaseSeriesEvent\n     *\n     * @return {void}\n     */\n    addBaseSeriesEvents: function () {\n        var navigator = this,\n            baseSeries = navigator.baseSeries || [];\n\n        // Bind modified extremes event to first base's xAxis only.\n        // In event of > 1 base-xAxes, the navigator will ignore those.\n        // Adding this multiple times to the same axis is no problem, as\n        // duplicates should be discarded by the browser.\n        if (baseSeries[0] && baseSeries[0].xAxis) {\n            addEvent(\n                baseSeries[0].xAxis,\n                'foundExtremes',\n                this.modifyBaseAxisExtremes\n            );\n        }\n\n        each(baseSeries, function (base) {\n            // Link base series show/hide to navigator series visibility\n            addEvent(base, 'show', function () {\n                if (this.navigatorSeries) {\n                    this.navigatorSeries.setVisible(true, false);\n                }\n            });\n            addEvent(base, 'hide', function () {\n                if (this.navigatorSeries) {\n                    this.navigatorSeries.setVisible(false, false);\n                }\n            });\n\n            // Respond to updated data in the base series, unless explicitily\n            // not adapting to data changes.\n            if (this.navigatorOptions.adaptToUpdatedData !== false) {\n                if (base.xAxis) {\n                    addEvent(base, 'updatedData', this.updatedDataHandler);\n                }\n            }\n\n            // Handle series removal\n            addEvent(base, 'remove', function () {\n                if (this.navigatorSeries) {\n                    erase(navigator.series, this.navigatorSeries);\n                    if (defined(this.navigatorSeries.options)) {\n                        this.navigatorSeries.remove(false);\n                    }\n                    delete this.navigatorSeries;\n                }\n            });\n        }, this);\n    },\n\n    /**\n     * Set the navigator x axis extremes to reflect the total. The navigator\n     * extremes should always be the extremes of the union of all series in the\n     * chart as well as the navigator series.\n     *\n     * @function Highcharts.Navigator#modifyNavigatorAxisExtremes\n     *\n     * @return {void}\n     */\n    modifyNavigatorAxisExtremes: function () {\n        var xAxis = this.xAxis,\n            unionExtremes;\n\n        if (xAxis.getExtremes) {\n            unionExtremes = this.getUnionExtremes(true);\n            if (\n                unionExtremes &&\n                (\n                    unionExtremes.dataMin !== xAxis.min ||\n                    unionExtremes.dataMax !== xAxis.max\n                )\n            ) {\n                xAxis.min = unionExtremes.dataMin;\n                xAxis.max = unionExtremes.dataMax;\n            }\n        }\n    },\n\n    /**\n     * Hook to modify the base axis extremes with information from the Navigator\n     *\n     * @function Highcharts.Navigator#modifyBaseAxisExtremes\n     *\n     * @return {void}\n     */\n    modifyBaseAxisExtremes: function () {\n        var baseXAxis = this,\n            navigator = baseXAxis.chart.navigator,\n            baseExtremes = baseXAxis.getExtremes(),\n            baseMin = baseExtremes.min,\n            baseMax = baseExtremes.max,\n            baseDataMin = baseExtremes.dataMin,\n            baseDataMax = baseExtremes.dataMax,\n            range = baseMax - baseMin,\n            stickToMin = navigator.stickToMin,\n            stickToMax = navigator.stickToMax,\n            overscroll = pick(baseXAxis.options.overscroll, 0),\n            newMax,\n            newMin,\n            navigatorSeries = navigator.series && navigator.series[0],\n            hasSetExtremes = !!baseXAxis.setExtremes,\n\n            // When the extremes have been set by range selector button, don't\n            // stick to min or max. The range selector buttons will handle the\n            // extremes. (#5489)\n            unmutable = baseXAxis.eventArgs &&\n                baseXAxis.eventArgs.trigger === 'rangeSelectorButton';\n\n        if (!unmutable) {\n\n            // If the zoomed range is already at the min, move it to the right\n            // as new data comes in\n            if (stickToMin) {\n                newMin = baseDataMin;\n                newMax = newMin + range;\n            }\n\n            // If the zoomed range is already at the max, move it to the right\n            // as new data comes in\n            if (stickToMax) {\n                newMax = baseDataMax + overscroll;\n\n                // if stickToMin is true, the new min value is set above\n                if (!stickToMin) {\n                    newMin = Math.max(\n                        newMax - range,\n                        navigatorSeries && navigatorSeries.xData ?\n                            navigatorSeries.xData[0] : -Number.MAX_VALUE\n                    );\n                }\n            }\n\n            // Update the extremes\n            if (hasSetExtremes && (stickToMin || stickToMax)) {\n                if (isNumber(newMin)) {\n                    baseXAxis.min = baseXAxis.userMin = newMin;\n                    baseXAxis.max = baseXAxis.userMax = newMax;\n                }\n            }\n        }\n\n        // Reset\n        navigator.stickToMin = navigator.stickToMax = null;\n    },\n\n    /**\n     * Handler for updated data on the base series. When data is modified, the\n     * navigator series must reflect it. This is called from the Chart.redraw\n     * function before axis and series extremes are computed.\n     *\n     * @function Highcharts.Navigator#updateDataHandler\n     *\n     * @return {void}\n     */\n    updatedDataHandler: function () {\n        var navigator = this.chart.navigator,\n            baseSeries = this,\n            navigatorSeries = this.navigatorSeries;\n\n        // If the scrollbar is scrolled all the way to the right, keep right as\n        // new data  comes in.\n        navigator.stickToMax = navigator.reversedExtremes ?\n            Math.round(navigator.zoomedMin) === 0 :\n            Math.round(navigator.zoomedMax) >= Math.round(navigator.size);\n\n        // Detect whether the zoomed area should stick to the minimum or\n        // maximum. If the current axis minimum falls outside the new updated\n        // dataset, we must adjust.\n        navigator.stickToMin = isNumber(baseSeries.xAxis.min) &&\n            (baseSeries.xAxis.min <= baseSeries.xData[0]) &&\n            (!this.chart.fixedRange || !navigator.stickToMax);\n\n        // Set the navigator series data to the new data of the base series\n        if (navigatorSeries && !navigator.hasNavigatorData) {\n            navigatorSeries.options.pointStart = baseSeries.xData[0];\n            navigatorSeries.setData(\n                baseSeries.options.data,\n                false,\n                null,\n                false\n            ); // #5414\n        }\n    },\n\n    /**\n     * Add chart events, like redrawing navigator, when chart requires that.\n     *\n     * @function Highcharts.Navigator#addChartEvents\n     *\n     * @return {void}\n     */\n    addChartEvents: function () {\n        if (!this.eventsToUnbind) {\n            this.eventsToUnbind = [];\n        }\n\n        this.eventsToUnbind.push(\n            // Move the scrollbar after redraw, like after data updata even if\n            // axes don't redraw\n            addEvent(\n                this.chart,\n                'redraw',\n                function () {\n                    var navigator = this.navigator,\n                        xAxis = navigator && (\n                            navigator.baseSeries &&\n                            navigator.baseSeries[0] &&\n                            navigator.baseSeries[0].xAxis ||\n                            navigator.scrollbar && this.xAxis[0]\n                        ); // #5709\n\n                    if (xAxis) {\n                        navigator.render(xAxis.min, xAxis.max);\n                    }\n                }\n            ),\n            // Make room for the navigator, can be placed around the chart:\n            addEvent(\n                this.chart,\n                'getMargins',\n                function () {\n                    var chart = this,\n                        navigator = chart.navigator,\n                        marginName = navigator.opposite ?\n                            'plotTop' : 'marginBottom';\n                    if (chart.inverted) {\n                        marginName = navigator.opposite ?\n                            'marginRight' : 'plotLeft';\n                    }\n\n                    chart[marginName] = (chart[marginName] || 0) + (\n                        navigator.navigatorEnabled || !chart.inverted ?\n                            navigator.outlineHeight :\n                            0\n                    ) + navigator.navigatorOptions.margin;\n                }\n            )\n        );\n    },\n\n    /**\n     * Destroys allocated elements.\n     *\n     * @function Highcharts.Navigator#destroy\n     *\n     * @return {void}\n     */\n    destroy: function () {\n\n        // Disconnect events added in addEvents\n        this.removeEvents();\n\n        if (this.xAxis) {\n            erase(this.chart.xAxis, this.xAxis);\n            erase(this.chart.axes, this.xAxis);\n        }\n        if (this.yAxis) {\n            erase(this.chart.yAxis, this.yAxis);\n            erase(this.chart.axes, this.yAxis);\n        }\n        // Destroy series\n        each(this.series || [], function (s) {\n            if (s.destroy) {\n                s.destroy();\n            }\n        });\n\n        // Destroy properties\n        each([\n            'series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack',\n            'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup',\n            'rendered'\n        ], function (prop) {\n            if (this[prop] && this[prop].destroy) {\n                this[prop].destroy();\n            }\n            this[prop] = null;\n        }, this);\n\n        // Destroy elements in collection\n        each([this.handles], function (coll) {\n            destroyObjectProperties(coll);\n        }, this);\n    }\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Navigator = Navigator;\n\n/**\n * For Stock charts, override selection zooming with some special features\n * because X axis zooming is already allowed by the Navigator and Range\n * selector.\n */\nwrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {\n    var chart = this.chart,\n        chartOptions = chart.options,\n        zoomType = chartOptions.chart.zoomType,\n        pinchType = chartOptions.chart.pinchType,\n        previousZoom,\n        navigator = chartOptions.navigator,\n        rangeSelector = chartOptions.rangeSelector,\n        ret;\n\n    if (this.isXAxis && ((navigator && navigator.enabled) ||\n            (rangeSelector && rangeSelector.enabled))) {\n        // For x only zooming, fool the chart.zoom method not to create the zoom\n        // button because the property already exists\n        if (\n            (!isTouchDevice && zoomType === 'x') ||\n            (isTouchDevice && pinchType === 'x')\n        ) {\n            chart.resetZoomButton = 'blocked';\n\n        // For y only zooming, ignore the X axis completely\n        } else if (zoomType === 'y') {\n            ret = false;\n\n        // For xy zooming, record the state of the zoom before zoom selection,\n        // then when the reset button is pressed, revert to this state. This\n        // should apply only if the chart is initialized with a range (#6612),\n        // otherwise zoom all the way out.\n        } else if (\n            (\n                (!isTouchDevice && zoomType === 'xy') ||\n                (isTouchDevice && pinchType === 'xy')\n            ) &&\n            this.options.range\n        ) {\n\n            previousZoom = this.previousZoom;\n            if (defined(newMin)) {\n                this.previousZoom = [this.min, this.max];\n            } else if (previousZoom) {\n                newMin = previousZoom[0];\n                newMax = previousZoom[1];\n                delete this.previousZoom;\n            }\n        }\n\n    }\n    return ret !== undefined ? ret : proceed.call(this, newMin, newMax);\n});\n\n// Initialize navigator for stock charts\naddEvent(Chart, 'beforeRender', function () {\n    var options = this.options;\n    if (options.navigator.enabled || options.scrollbar.enabled) {\n        this.scroller = this.navigator = new Navigator(this);\n    }\n});\n\n/**\n * For stock charts, extend the Chart.setChartSize method so that we can set the\n * final top position of the navigator once the height of the chart, including\n * the legend, is determined. #367. We can't use Chart.getMargins, because\n * labels offsets are not calculated yet.\n */\naddEvent(Chart, 'afterSetChartSize', function () {\n\n    var legend = this.legend,\n        navigator = this.navigator,\n        scrollbarHeight,\n        legendOptions,\n        xAxis,\n        yAxis;\n\n    if (navigator) {\n        legendOptions = legend && legend.options;\n        xAxis = navigator.xAxis;\n        yAxis = navigator.yAxis;\n        scrollbarHeight = navigator.scrollbarHeight;\n\n        // Compute the top position\n        if (this.inverted) {\n            navigator.left = navigator.opposite ?\n                this.chartWidth - scrollbarHeight - navigator.height :\n                this.spacing[3] + scrollbarHeight;\n            navigator.top = this.plotTop + scrollbarHeight;\n        } else {\n            navigator.left = this.plotLeft + scrollbarHeight;\n            navigator.top = navigator.navigatorOptions.top ||\n                this.chartHeight -\n                navigator.height -\n                scrollbarHeight -\n                this.spacing[2] -\n                (\n                    this.rangeSelector && this.extraBottomMargin ?\n                        this.rangeSelector.getHeight() :\n                        0\n                ) -\n                (\n                    (\n                        legendOptions &&\n                        legendOptions.verticalAlign === 'bottom' &&\n                        legendOptions.enabled &&\n                        !legendOptions.floating\n                    ) ?\n                        legend.legendHeight + pick(legendOptions.margin, 10) :\n                        0\n                );\n        }\n\n        if (xAxis && yAxis) { // false if navigator is disabled (#904)\n\n            if (this.inverted) {\n                xAxis.options.left = yAxis.options.left = navigator.left;\n            } else {\n                xAxis.options.top = yAxis.options.top = navigator.top;\n            }\n\n            xAxis.setAxisSize();\n            yAxis.setAxisSize();\n        }\n    }\n});\n\n// Merge options, if no scrolling exists yet\naddEvent(Chart, 'update', function (e) {\n\n    var navigatorOptions = (e.options.navigator || {}),\n        scrollbarOptions = (e.options.scrollbar || {});\n\n    if (!this.navigator && !this.scroller &&\n        (navigatorOptions.enabled || scrollbarOptions.enabled)\n    ) {\n        merge(true, this.options.navigator, navigatorOptions);\n        merge(true, this.options.scrollbar, scrollbarOptions);\n        delete e.options.navigator;\n        delete e.options.scrollbar;\n    }\n\n});\n\n// Initiate navigator, if no scrolling exists yet\naddEvent(Chart, 'afterUpdate', function () {\n\n    if (!this.navigator && !this.scroller &&\n        (this.options.navigator.enabled || this.options.scrollbar.enabled)\n    ) {\n        this.scroller = this.navigator = new Navigator(this);\n    }\n\n});\n\n// Pick up badly formatted point options to addPoint\nwrap(Series.prototype, 'addPoint', function (\n    proceed,\n    options,\n    redraw,\n    shift,\n    animation\n) {\n    var turboThreshold = this.options.turboThreshold;\n    if (\n        turboThreshold &&\n        this.xData.length > turboThreshold &&\n        isObject(options, true) &&\n        this.chart.navigator\n    ) {\n        error(20, true);\n    }\n    proceed.call(this, options, redraw, shift, animation);\n});\n\n// Handle adding new series\naddEvent(Chart, 'afterAddSeries', function () {\n    if (this.navigator) {\n        // Recompute which series should be shown in navigator, and add them\n        this.navigator.setBaseSeries(null, false);\n    }\n});\n\n// Handle updating series\naddEvent(Series, 'afterUpdate', function () {\n    if (this.chart.navigator && !this.options.isInternal) {\n        this.chart.navigator.setBaseSeries(null, false);\n    }\n});\n\nChart.prototype.callbacks.push(function (chart) {\n    var extremes,\n        navigator = chart.navigator;\n\n    // Initiate the navigator\n    if (navigator && chart.xAxis[0]) {\n        extremes = chart.xAxis[0].getExtremes();\n        navigator.render(extremes.min, extremes.max);\n    }\n});\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Navigator.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/OHLCSeries.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/OHLCSeries.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n/**\n * The ohlc series type.\n *\n * @constructor seriesTypes.ohlc\n * @augments seriesTypes.column\n */\n/**\n * An OHLC chart is a style of financial chart used to describe price\n * movements over time. It displays open, high, low and close values per data\n * point.\n *\n * @sample stock/demo/ohlc/ OHLC chart\n * @extends plotOptions.column\n * @excluding borderColor,borderRadius,borderWidth,crisp,stacking,stack\n * @product highstock\n * @optionparent plotOptions.ohlc\n */\nseriesType('ohlc', 'column', {\n\n    /**\n     * The approximate pixel width of each group. If for example a series\n     * with 30 points is displayed over a 600 pixel wide plot area, no grouping\n     * is performed. If however the series contains so many points that\n     * the spacing is less than the groupPixelWidth, Highcharts will try\n     * to group it into appropriate groups so that each is more or less\n     * two pixels wide. Defaults to `5`.\n     *\n     * @type {Number}\n     * @default 5\n     * @product highstock\n     * @apioption plotOptions.ohlc.dataGrouping.groupPixelWidth\n     */\n\n    /**\n     * The pixel width of the line/border. Defaults to `1`.\n     *\n     * @type {Number}\n     * @sample {highstock} stock/plotoptions/ohlc-linewidth/\n     *         A greater line width\n     * @default 1\n     * @product highstock\n     */\n    lineWidth: 1,\n\n    tooltip: {\n        \n        pointFormat: '<span class=\"highcharts-color-{point.colorIndex}\">\\u25CF</span> <b> {series.name}</b><br/>' +\n            'Open: {point.open}<br/>' +\n            'High: {point.high}<br/>' +\n            'Low: {point.low}<br/>' +\n            'Close: {point.close}<br/>'\n        \n    },\n\n    threshold: null,\n    \n\n    stickyTracking: true\n\n}, /** @lends seriesTypes.ohlc */ {\n    directTouch: false,\n    pointArrayMap: ['open', 'high', 'low', 'close'],\n    toYData: function (point) { // return a plain array for speedy calculation\n        return [point.open, point.high, point.low, point.close];\n    },\n    pointValKey: 'close',\n\n    \n\n    /**\n     * Translate data points from raw values x and y to plotX and plotY\n     */\n    translate: function () {\n        var series = this,\n            yAxis = series.yAxis,\n            hasModifyValue = !!series.modifyValue,\n            translated = [\n                'plotOpen',\n                'plotHigh',\n                'plotLow',\n                'plotClose',\n                'yBottom'\n            ]; // translate OHLC for\n\n        seriesTypes.column.prototype.translate.apply(series);\n\n        // Do the translation\n        each(series.points, function (point) {\n            each(\n                [point.open, point.high, point.low, point.close, point.low],\n                function (value, i) {\n                    if (value !== null) {\n                        if (hasModifyValue) {\n                            value = series.modifyValue(value);\n                        }\n                        point[translated[i]] = yAxis.toPixels(value, true);\n                    }\n                }\n            );\n\n            // Align the tooltip to the high value to avoid covering the point\n            point.tooltipPos[1] =\n                point.plotHigh + yAxis.pos - series.chart.plotTop;\n        });\n    },\n\n    /**\n     * Draw the data points\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            chart = series.chart;\n\n\n        each(points, function (point) {\n            var plotOpen,\n                plotClose,\n                crispCorr,\n                halfWidth,\n                path,\n                graphic = point.graphic,\n                crispX,\n                isNew = !graphic;\n\n            if (point.plotY !== undefined) {\n\n                // Create and/or update the graphic\n                if (!graphic) {\n                    point.graphic = graphic = chart.renderer.path()\n                        .add(series.group);\n                }\n\n                \n\n                // crisp vector coordinates\n                crispCorr = (graphic.strokeWidth() % 2) / 2;\n                crispX = Math.round(point.plotX) - crispCorr;  // #2596\n                halfWidth = Math.round(point.shapeArgs.width / 2);\n\n                // the vertical stem\n                path = [\n                    'M',\n                    crispX, Math.round(point.yBottom),\n                    'L',\n                    crispX, Math.round(point.plotHigh)\n                ];\n\n                // open\n                if (point.open !== null) {\n                    plotOpen = Math.round(point.plotOpen) + crispCorr;\n                    path.push(\n                        'M',\n                        crispX,\n                        plotOpen,\n                        'L',\n                        crispX - halfWidth,\n                        plotOpen\n                    );\n                }\n\n                // close\n                if (point.close !== null) {\n                    plotClose = Math.round(point.plotClose) + crispCorr;\n                    path.push(\n                        'M',\n                        crispX,\n                        plotClose,\n                        'L',\n                        crispX + halfWidth,\n                        plotClose\n                    );\n                }\n\n                graphic[isNew ? 'attr' : 'animate']({ d: path })\n                    .addClass(point.getClassName(), true);\n\n            }\n\n\n        });\n\n    },\n\n    animate: null // Disable animation\n\n}, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {\n    /**\n      * Extend the parent method by adding up or down to the class name.\n      */\n    getClassName: function () {\n        return Point.prototype.getClassName.call(this) +\n            (\n                this.open < this.close ?\n                    ' highcharts-point-up' :\n                    ' highcharts-point-down'\n            );\n    }\n});\n\n/**\n * A `ohlc` series. If the [type](#series.ohlc.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.ohlc\n * @excluding dataParser,dataURL\n * @product highstock\n * @apioption series.ohlc\n */\n\n/**\n * An array of data points for the series. For the `ohlc` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of arrays with 5 or 4 values. In this case, the values\n * correspond to `x,open,high,low,close`. If the first value is a string,\n * it is applied as the name of the point, and the `x` value is inferred.\n * The `x` value can also be omitted, in which case the inner arrays\n * should be of length 4\\. Then the `x` value is automatically calculated,\n * either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options.\n *\n *  ```js\n *     data: [\n *         [0, 6, 5, 6, 7],\n *         [1, 9, 4, 8, 2],\n *         [2, 6, 3, 4, 10]\n *     ]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.ohlc.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         open: 3,\n *         high: 4,\n *         low: 5,\n *         close: 2,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         open: 4,\n *         high: 3,\n *         low: 6,\n *         close: 7,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type {Array<Object|Array>}\n * @extends series.arearange.data\n * @excluding y,marker\n * @product highstock\n * @apioption series.ohlc.data\n */\n\n/**\n * The closing value of each data point.\n *\n * @type {Number}\n * @product highstock\n * @apioption series.ohlc.data.close\n */\n\n/**\n * The opening value of each data point.\n *\n * @type {Number}\n * @product highstock\n * @apioption series.ohlc.data.open\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/OHLCSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Options.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Options.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Time_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Time.js */ \"./node_modules/highcharts/js/es-modules/parts/Time.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    isTouchDevice = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isTouchDevice,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    svg = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg;\n\n/* ****************************************************************************\n * Handle the options                                                         *\n *****************************************************************************/\n/**\n * Global default settings.\n *\n * @name Highcharts.defaultOptions\n * @type {Highcharts.Options}\n *//**\n * @optionparent\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions = {\n    \n\n\n    /**\n     * Styled mode only. Configuration object for adding SVG definitions for\n     * reusable elements. See [gradients, shadows and\n     * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)\n     * for more information and code examples.\n     *\n     * @type      {*}\n     * @since     5.0.0\n     * @apioption defs\n     */\n\n    /**\n     * @ignore-option\n     */\n    symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n\n    /**\n     * The language object is global and it can't be set on each chart\n     * initiation. Instead, use `Highcharts.setOptions` to set it before any\n     * chart is initialized.\n     *\n     * <pre>Highcharts.setOptions({\n     *     lang: {\n     *         months: [\n     *             'Janvier', 'Fvrier', 'Mars', 'Avril',\n     *             'Mai', 'Juin', 'Juillet', 'Aot',\n     *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'\n     *         ],\n     *         weekdays: [\n     *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',\n     *             'Jeudi', 'Vendredi', 'Samedi'\n     *         ]\n     *     }\n     * });</pre>\n     */\n    lang: {\n\n        /**\n         * The loading text that appears when the chart is set into the loading\n         * state following a call to `chart.showLoading`.\n         */\n        loading: 'Loading...',\n\n        /**\n         * An array containing the months names. Corresponds to the `%B` format\n         * in `Highcharts.dateFormat()`.\n         *\n         * @type    {Array<string>}\n         * @default [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n         *          \"July\", \"August\", \"September\", \"October\", \"November\",\n         *          \"December\"]\n         */\n        months: [\n            'January', 'February', 'March', 'April', 'May', 'June', 'July',\n            'August', 'September', 'October', 'November', 'December'\n        ],\n\n        /**\n         * An array containing the months names in abbreviated form. Corresponds\n         * to the `%b` format in `Highcharts.dateFormat()`.\n         *\n         * @type    {Array<string>}\n         * @default [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n         *          \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n         */\n        shortMonths: [\n            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n            'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n        ],\n\n        /**\n         * An array containing the weekday names.\n         *\n         * @type    {Array<string>}\n         * @default [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n         *          \"Friday\", \"Saturday\"]\n         */\n        weekdays: [\n            'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n            'Thursday', 'Friday', 'Saturday'\n        ],\n\n        /**\n         * Short week days, starting Sunday. If not specified, Highcharts uses\n         * the first three letters of the `lang.weekdays` option.\n         *\n         * @sample highcharts/lang/shortweekdays/\n         *         Finnish two-letter abbreviations\n         *\n         * @type      {Array<string>}\n         * @since     4.2.4\n         * @apioption lang.shortWeekdays\n         */\n\n        /**\n         * What to show in a date field for invalid dates. Defaults to an empty\n         * string.\n         *\n         * @type      {string}\n         * @since     4.1.8\n         * @product   highcharts highstock\n         * @apioption lang.invalidDate\n         */\n\n        /**\n         * The title appearing on hovering the zoom in button. The text itself\n         * defaults to \"+\" and can be changed in the button options.\n         *\n         * @type      {string}\n         * @default   Zoom in\n         * @product   highmaps\n         * @apioption lang.zoomIn\n         */\n\n        /**\n         * The title appearing on hovering the zoom out button. The text itself\n         * defaults to \"-\" and can be changed in the button options.\n         *\n         * @type      {string}\n         * @default   Zoom out\n         * @product   highmaps\n         * @apioption lang.zoomOut\n         */\n\n        /**\n         * The default decimal point used in the `Highcharts.numberFormat`\n         * method unless otherwise specified in the function arguments.\n         *\n         * @since 1.2.2\n         */\n        decimalPoint: '.',\n\n        /**\n         * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used\n         * to shorten high numbers in axis labels. Replacing any of the\n         * positions with `null` causes the full number to be written. Setting\n         * `numericSymbols` to `null` disables shortening altogether.\n         *\n         * @sample {highcharts} highcharts/lang/numericsymbols/\n         *         Replacing the symbols with text\n         * @sample {highstock} highcharts/lang/numericsymbols/\n         *         Replacing the symbols with text\n         *\n         * @type    {Array<string>}\n         * @default [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"]\n         * @since   2.3.0\n         */\n        numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],\n\n        /**\n         * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.\n         * Use 10000 for Japanese, Korean and various Chinese locales, which\n         * use symbols for 10^4, 10^8 and 10^12.\n         *\n         * @sample highcharts/lang/numericsymbolmagnitude/\n         *         10000 magnitude for Japanese\n         *\n         * @type      {number}\n         * @default   1000\n         * @since     5.0.3\n         * @apioption lang.numericSymbolMagnitude\n         */\n\n        /**\n         * The text for the label appearing when a chart is zoomed.\n         *\n         * @since 1.2.4\n         */\n        resetZoom: 'Reset zoom',\n\n        /**\n         * The tooltip title for the label appearing when a chart is zoomed.\n         *\n         * @since 1.2.4\n         */\n        resetZoomTitle: 'Reset zoom level 1:1',\n\n        /**\n         * The default thousands separator used in the `Highcharts.numberFormat`\n         * method unless otherwise specified in the function arguments. Since\n         * Highcharts 4.1 it defaults to a single space character, which is\n         * compatible with ISO and works across Anglo-American and continental\n         * European languages.\n         *\n         * The default is a single space.\n         *\n         * @default \\u0020\n         * @since   1.2.2\n         */\n        thousandsSep: ' '\n    },\n\n    /**\n     * Global options that don't apply to each chart. These options, like\n     * the `lang` options, must be set using the `Highcharts.setOptions`\n     * method.\n     *\n     * <pre>Highcharts.setOptions({\n     *     global: {\n     *         useUTC: false\n     *     }\n     * });</pre>\n     *\n     */\n\n    /**\n     * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\\.\n     * Use the [libURL](#exporting.libURL) option to configure exporting._\n     *\n     * The URL to the additional file to lazy load for Android 2.x devices.\n     * These devices don't support SVG, so we download a helper file that\n     * contains [canvg](http://code.google.com/p/canvg/), its dependency\n     * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to\n     * our site, you can install canvas-tools.js on your own server and\n     * change this option accordingly.\n     *\n     * @deprecated\n     *\n     * @type      {string}\n     * @default   http://code.highcharts.com/{version}/modules/canvas-tools.js\n     * @product   highcharts highmaps\n     * @apioption global.canvasToolsURL\n     */\n\n    /**\n     * This option is deprecated since v6.0.5. Instead, use\n     * [time.useUTC](#time.useUTC) that supports individual time settings\n     * per chart.\n     *\n     * @deprecated\n     *\n     * @type      {boolean}\n     * @apioption global.useUTC\n     */\n\n    /**\n     * This option is deprecated since v6.0.5. Instead, use\n     * [time.Date](#time.Date) that supports individual time settings\n     * per chart.\n     *\n     * @deprecated\n     *\n     * @type      {Function}\n     * @product   highcharts highstock\n     * @apioption global.Date\n     */\n\n    /**\n     * This option is deprecated since v6.0.5. Instead, use\n     * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports\n     * individual time settings per chart.\n     *\n     * @deprecated\n     *\n     * @type      {Function}\n     * @product   highcharts highstock\n     * @apioption global.getTimezoneOffset\n     */\n\n    /**\n     * This option is deprecated since v6.0.5. Instead, use\n     * [time.timezone](#time.timezone) that supports individual time\n     * settings per chart.\n     *\n     * @deprecated\n     *\n     * @type      {string}\n     * @product   highcharts highstock\n     * @apioption global.timezone\n     */\n\n    /**\n     * This option is deprecated since v6.0.5. Instead, use\n     * [time.timezoneOffset](#time.timezoneOffset) that supports individual\n     * time settings per chart.\n     *\n     * @deprecated\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption global.timezoneOffset\n     */\n\n    global: {},\n\n    time: _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Time.prototype.defaultOptions,\n\n    /**\n     * General options for the chart.\n     */\n    chart: {\n\n        /**\n         * Default `mapData` for all series. If set to a string, it functions\n         * as an index into the `Highcharts.maps` array. Otherwise it is\n         * interpreted s map data.\n         *\n         * @see [mapData](#series.map.mapData)\n         *\n         * @type      {string|Array<*>}\n         * @since     5.0.0\n         * @product   highmaps\n         * @apioption chart.map\n         */\n\n        /**\n         * Set lat/lon transformation definitions for the chart. If not defined,\n         * these are extracted from the map data.\n         *\n         * @type      {*}\n         * @since     5.0.0\n         * @product   highmaps\n         * @apioption chart.mapTransforms\n         */\n\n        /**\n         * When using multiple axis, the ticks of two or more opposite axes\n         * will automatically be aligned by adding ticks to the axis or axes\n         * with the least ticks, as if `tickAmount` were specified.\n         *\n         * This can be prevented by setting `alignTicks` to false. If the grid\n         * lines look messy, it's a good idea to hide them for the secondary\n         * axis by setting `gridLineWidth` to 0.\n         *\n         * If `startOnTick` or `endOnTick` in an Axis options are set to false,\n         * then the `alignTicks ` will be disabled for the Axis.\n         *\n         * Disabled for logarithmic axes.\n         *\n         * @sample {highcharts} highcharts/chart/alignticks-true/\n         *         True by default\n         * @sample {highcharts} highcharts/chart/alignticks-false/\n         *         False\n         * @sample {highstock} stock/chart/alignticks-true/\n         *         True by default\n         * @sample {highstock} stock/chart/alignticks-false/\n         *         False\n         *\n         * @type      {boolean}\n         * @default   true\n         * @product   highcharts highstock\n         * @apioption chart.alignTicks\n         */\n\n        /**\n         * Set the overall animation for all chart updating. Animation can be\n         * disabled throughout the chart by setting it to false here. It can\n         * be overridden for each individual API method as a function parameter.\n         * The only animation not affected by this option is the initial series\n         * animation, see [plotOptions.series.animation](\n         * #plotOptions.series.animation).\n         *\n         * The animation can either be set as a boolean or a configuration\n         * object. If `true`, it will use the 'swing' jQuery easing and a\n         * duration of 500 ms. If used as a configuration object, the following\n         * properties are supported:\n         *\n         * <dl>\n         *\n         * <dt>duration</dt>\n         *\n         * <dd>The duration of the animation in milliseconds.</dd>\n         *\n         * <dt>easing</dt>\n         *\n         * <dd>A string reference to an easing function set on the `Math`\n         * object. See [the easing\n         * demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).\n         * </dd>\n         *\n         * </dl>\n         *\n         * @sample {highcharts} highcharts/chart/animation-none/\n         *         Updating with no animation\n         * @sample {highcharts} highcharts/chart/animation-duration/\n         *         With a longer duration\n         * @sample {highcharts} highcharts/chart/animation-easing/\n         *         With a jQuery UI easing\n         * @sample {highmaps} maps/chart/animation-none/\n         *         Updating with no animation\n         * @sample {highmaps} maps/chart/animation-duration/\n         *         With a longer duration\n         *\n         * @type      {boolean|Highcharts.AnimationOptionsObject}\n         * @default   true\n         * @apioption chart.animation\n         */\n\n        /**\n         * A CSS class name to apply to the charts container `div`, allowing\n         * unique CSS styling for each chart.\n         *\n         * @type      {string}\n         * @apioption chart.className\n         */\n\n        /**\n         * Event listeners for the chart.\n         *\n         * @apioption chart.events\n         */\n\n        /**\n         * Fires when a series is added to the chart after load time, using\n         * the `addSeries` method. One parameter, `event`, is passed to the\n         * function, containing common event information.\n         * Through `event.options` you can access the series options that was\n         * passed to the `addSeries` method. Returning false prevents the series\n         * from being added.\n         *\n         * @sample {highcharts} highcharts/chart/events-addseries/\n         *         Alert on add series\n         * @sample {highstock} stock/chart/events-addseries/\n         *         Alert on add series\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Highcharts.Chart\n         * @apioption chart.events.addSeries\n         */\n\n        /**\n         * Fires when clicking on the plot background. One parameter, `event`,\n         * is passed to the function, containing common event information.\n         *\n         * Information on the clicked spot can be found through `event.xAxis`\n         * and `event.yAxis`, which are arrays containing the axes of each\n         * dimension and each axis' value at the clicked spot. The primary axes\n         * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a\n         * datetime axis is milliseconds since 1970-01-01 00:00:00.\n         *\n         * <pre>click: function(e) {\n         *     console.log(\n         *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),\n         *         e.yAxis[0].value\n         *     )\n         * }</pre>\n         *\n         * @sample {highcharts} highcharts/chart/events-click/\n         *         Alert coordinates on click\n         * @sample {highcharts} highcharts/chart/events-container/\n         *         Alternatively, attach event to container\n         * @sample {highstock} stock/chart/events-click/\n         *         Alert coordinates on click\n         * @sample {highstock} highcharts/chart/events-container/\n         *         Alternatively, attach event to container\n         * @sample {highmaps} maps/chart/events-click/\n         *         Record coordinates on click\n         * @sample {highmaps} highcharts/chart/events-container/\n         *         Alternatively, attach event to container\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Highcharts.Chart\n         * @apioption chart.events.click\n         */\n\n\n        /**\n         * Fires when the chart is finished loading. Since v4.2.2, it also waits\n         * for images to be loaded, for example from point markers. One\n         * parameter, `event`, is passed to the function, containing common\n         * event information.\n         *\n         * There is also a second parameter to the chart constructor where a\n         * callback function can be passed to be executed on chart.load.\n         *\n         * @sample {highcharts} highcharts/chart/events-load/\n         *         Alert on chart load\n         * @sample {highstock} stock/chart/events-load/\n         *         Alert on chart load\n         * @sample {highmaps} maps/chart/events-load/\n         *         Add series on chart load\n         *\n         * @type      {Function}\n         * @context   Highcharts.Chart\n         * @apioption chart.events.load\n         */\n\n        /**\n         * Fires when the chart is redrawn, either after a call to\n         * `chart.redraw()` or after an axis, series or point is modified with\n         * the `redraw` option set to true. One parameter, `event`, is passed to\n         * the function, containing common event information.\n         *\n         * @sample {highcharts} highcharts/chart/events-redraw/\n         *         Alert on chart redraw\n         * @sample {highstock} stock/chart/events-redraw/\n         *         Alert on chart redraw when adding a series or moving the\n         *         zoomed range\n         * @sample {highmaps} maps/chart/events-redraw/\n         *         Set subtitle on chart redraw\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Highcharts.Chart\n         * @apioption chart.events.redraw\n         */\n\n        /**\n         * Fires after initial load of the chart (directly after the `load`\n         * event), and after each redraw (directly after the `redraw` event).\n         *\n         * @type      {Function}\n         * @since     5.0.7\n         * @context   Highcharts.Chart\n         * @apioption chart.events.render\n         */\n\n        /**\n         * Fires when an area of the chart has been selected. Selection is\n         * enabled by setting the chart's zoomType. One parameter, `event`, is\n         * passed to the function, containing common event information. The\n         * default action for the selection event is to zoom the chart to the\n         * selected area. It can be prevented by calling\n         * `event.preventDefault()`.\n         *\n         * Information on the selected area can be found through `event.xAxis`\n         * and `event.yAxis`, which are arrays containing the axes of each\n         * dimension and each axis' min and max values. The primary axes are\n         * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a\n         * datetime axis is milliseconds since 1970-01-01 00:00:00.\n         *\n         * <pre>selection: function(event) {\n         *     // log the min and max of the primary, datetime x-axis\n         *     console.log(\n         *         Highcharts.dateFormat(\n         *             '%Y-%m-%d %H:%M:%S',\n         *             event.xAxis[0].min\n         *         ),\n         *         Highcharts.dateFormat(\n         *             '%Y-%m-%d %H:%M:%S',\n         *             event.xAxis[0].max\n         *         )\n         *     );\n         *     // log the min and max of the y axis\n         *     console.log(event.yAxis[0].min, event.yAxis[0].max);\n         * }</pre>\n         *\n         * @sample {highcharts} highcharts/chart/events-selection/\n         *         Report on selection and reset\n         * @sample {highcharts} highcharts/chart/events-selection-points/\n         *         Select a range of points through a drag selection\n         * @sample {highstock} stock/chart/events-selection/\n         *         Report on selection and reset\n         * @sample {highstock} highcharts/chart/events-selection-points/\n         *         Select a range of points through a drag selection\n         *         (Highcharts)\n         *\n         * @type      {Function}\n         * @apioption chart.events.selection\n         */\n\n        /**\n         * The margin between the outer edge of the chart and the plot area.\n         * The numbers in the array designate top, right, bottom and left\n         * respectively. Use the options `marginTop`, `marginRight`,\n         * `marginBottom` and `marginLeft` for shorthand setting of one option.\n         *\n         * By default there is no margin. The actual space is dynamically\n         * calculated from the offset of axis labels, axis title, title,\n         * subtitle and legend in addition to the `spacingTop`, `spacingRight`,\n         * `spacingBottom` and `spacingLeft` options.\n         *\n         * @sample {highcharts} highcharts/chart/margins-zero/\n         *         Zero margins\n         * @sample {highstock} stock/chart/margin-zero/\n         *         Zero margins\n         *\n         * @type      {number|Array<number>}\n         * @apioption chart.margin\n         */\n\n        /**\n         * The margin between the bottom outer edge of the chart and the plot\n         * area. Use this to set a fixed pixel value for the margin as opposed\n         * to the default dynamic margin. See also `spacingBottom`.\n         *\n         * @sample {highcharts} highcharts/chart/marginbottom/\n         *         100px bottom margin\n         * @sample {highstock} stock/chart/marginbottom/\n         *         100px bottom margin\n         * @sample {highmaps} maps/chart/margin/\n         *         100px margins\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption chart.marginBottom\n         */\n\n        /**\n         * The margin between the left outer edge of the chart and the plot\n         * area. Use this to set a fixed pixel value for the margin as opposed\n         * to the default dynamic margin. See also `spacingLeft`.\n         *\n         * @sample {highcharts} highcharts/chart/marginleft/\n         *         150px left margin\n         * @sample {highstock} stock/chart/marginleft/\n         *         150px left margin\n         * @sample {highmaps} maps/chart/margin/\n         *         100px margins\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption chart.marginLeft\n         */\n\n        /**\n         * The margin between the right outer edge of the chart and the plot\n         * area. Use this to set a fixed pixel value for the margin as opposed\n         * to the default dynamic margin. See also `spacingRight`.\n         *\n         * @sample {highcharts} highcharts/chart/marginright/\n         *         100px right margin\n         * @sample {highstock} stock/chart/marginright/\n         *         100px right margin\n         * @sample {highmaps} maps/chart/margin/\n         *         100px margins\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption chart.marginRight\n         */\n\n        /**\n         * The margin between the top outer edge of the chart and the plot area.\n         * Use this to set a fixed pixel value for the margin as opposed to\n         * the default dynamic margin. See also `spacingTop`.\n         *\n         * @sample {highcharts} highcharts/chart/margintop/ 100px top margin\n         * @sample {highstock} stock/chart/margintop/\n         *         100px top margin\n         * @sample {highmaps} maps/chart/margin/\n         *         100px margins\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption chart.marginTop\n         */\n\n        /**\n         * Allows setting a key to switch between zooming and panning. Can be\n         * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows\n         * key on Windows) or `shift`. The keys are mapped directly to the key\n         * properties of the click event argument (`event.altKey`,\n         * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).\n         *\n         * @type       {string}\n         * @since      4.0.3\n         * @product    highcharts\n         * @validvalue [\"alt\", \"ctrl\", \"meta\", \"shift\"]\n         * @apioption  chart.panKey\n         */\n\n        /**\n         * Allow panning in a chart. Best used with [panKey](#chart.panKey)\n         * to combine zooming and panning.\n         *\n         * On touch devices, when the [tooltip.followTouchMove](\n         * #tooltip.followTouchMove) option is `true` (default), panning\n         * requires two fingers. To allow panning with one finger, set\n         * `followTouchMove` to `false`.\n         *\n         * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning\n         *\n         * @type      {boolean}\n         * @default   {highcharts} false\n         * @default   {highstock} true\n         * @since     4.0.3\n         * @product   highcharts highstock\n         * @apioption chart.panning\n         */\n\n\n        /**\n         * Equivalent to [zoomType](#chart.zoomType), but for multitouch\n         * gestures only. By default, the `pinchType` is the same as the\n         * `zoomType` setting. However, pinching can be enabled separately in\n         * some cases, for example in stock charts where a mouse drag pans the\n         * chart, while pinching is enabled. When [tooltip.followTouchMove](\n         * #tooltip.followTouchMove) is true, pinchType only applies to\n         * two-finger touches.\n         *\n         * @type       {string}\n         * @default    {highcharts} undefined\n         * @default    {highstock} x\n         * @since      3.0\n         * @product    highcharts highstock\n         * @validvalue [\"x\", \"y\", \"xy\"]\n         * @apioption  chart.pinchType\n         */\n\n        /**\n         * The corner radius of the outer chart border.\n         *\n         * @sample {highcharts} highcharts/chart/borderradius/\n         *         20px radius\n         * @sample {highstock} stock/chart/border/\n         *         10px radius\n         * @sample {highmaps} maps/chart/border/\n         *         Border options\n         *\n         */\n        borderRadius: 0,\n\n        \n\n        /**\n         * In styled mode, this sets how many colors the class names\n         * should rotate between. With ten colors, series (or points) are\n         * given class names like `highcharts-color-0`, `highcharts-color-0`\n         * [...] `highcharts-color-9`. The equivalent in non-styled mode\n         * is to set colors using the [colors](#colors) setting.\n         *\n         * @since      5.0.0\n         */\n        colorCount: 10,\n\n        \n\n        /**\n         * Alias of `type`.\n         *\n         * @sample {highcharts} highcharts/chart/defaultseriestype/\n         *         Bar\n         *\n         * @deprecated\n         *\n         * @product highcharts\n         */\n        defaultSeriesType: 'line',\n\n        /**\n         * If true, the axes will scale to the remaining visible series once\n         * one series is hidden. If false, hiding and showing a series will\n         * not affect the axes or the other series. For stacks, once one series\n         * within the stack is hidden, the rest of the stack will close in\n         * around it even if the axis is not affected.\n         *\n         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/\n         *         True by default\n         * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/\n         *         False\n         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/\n         *         True with stack\n         * @sample {highstock} stock/chart/ignorehiddenseries-true/\n         *         True by default\n         * @sample {highstock} stock/chart/ignorehiddenseries-false/\n         *         False\n         *\n         * @since   1.2.0\n         * @product highcharts highstock\n         */\n        ignoreHiddenSeries: true,\n\n\n        /**\n         * Whether to invert the axes so that the x axis is vertical and y axis\n         * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)\n         * by default.\n         *\n         * @productdesc {highcharts}\n         * If a bar series is present in the chart, it will be inverted\n         * automatically. Inverting the chart doesn't have an effect if there\n         * are no cartesian series in the chart, or if the chart is\n         * [polar](#chart.polar).\n         *\n         * @sample {highcharts} highcharts/chart/inverted/\n         *         Inverted line\n         * @sample {highstock} stock/navigator/inverted/\n         *         Inverted stock chart\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   highcharts highstock\n         * @apioption chart.inverted\n         */\n\n        /**\n         * The distance between the outer edge of the chart and the content,\n         * like title or legend, or axis title and labels if present. The\n         * numbers in the array designate top, right, bottom and left\n         * respectively. Use the options spacingTop, spacingRight, spacingBottom\n         * and spacingLeft options for shorthand setting of one option.\n         *\n         * @type    {Array<number>}\n         * @see     [chart.margin](#chart.margin)\n         * @default [10, 10, 15, 10]\n         * @since   3.0.6\n         */\n        spacing: [10, 10, 15, 10],\n\n        /**\n         * The button that appears after a selection zoom, allowing the user\n         * to reset zoom.\n         */\n        resetZoomButton: {\n\n            /**\n             * What frame the button should be placed related to. Can be either\n             * `plot` or `chart`\n             *\n             * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/\n             *         Relative to the chart\n             * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/\n             *         Relative to the chart\n             *\n             * @type       {string}\n             * @default    plot\n             * @since      2.2\n             * @validvalue [\"plot\", \"chart\"]\n             * @apioption  chart.resetZoomButton.relativeTo\n             */\n\n            /**\n             * A collection of attributes for the button. The object takes SVG\n             * attributes like `fill`, `stroke`, `stroke-width` or `r`, the\n             * border radius. The theme also supports `style`, a collection of\n             * CSS properties for the text. Equivalent attributes for the hover\n             * state are given in `theme.states.hover`.\n             *\n             * @sample {highcharts} highcharts/chart/resetzoombutton-theme/\n             *         Theming the button\n             * @sample {highstock} highcharts/chart/resetzoombutton-theme/\n             *         Theming the button\n             *\n             * @since 2.2\n             */\n            theme: {\n\n                /**\n                 * The Z index for the reset zoom button. The default value\n                 * places it below the tooltip that has Z index 7.\n                 */\n                zIndex: 6\n            },\n\n            /**\n             * The position of the button.\n             *\n             * @sample {highcharts} highcharts/chart/resetzoombutton-position/\n             *         Above the plot area\n             * @sample {highstock} highcharts/chart/resetzoombutton-position/\n             *         Above the plot area\n             * @sample {highmaps} highcharts/chart/resetzoombutton-position/\n             *         Above the plot area\n             *\n             * @since 2.2\n             */\n            position: {\n\n                /**\n                 * The horizontal alignment of the button.\n                 */\n                align: 'right',\n\n                /**\n                 * The horizontal offset of the button.\n                 */\n                x: -10,\n\n                /**\n                 * The vertical alignment of the button.\n                 *\n                 * @type       {string}\n                 * @default    top\n                 * @validvalue [\"top\", \"middle\", \"bottom\"]\n                 * @apioption  chart.resetZoomButton.position.verticalAlign\n                 */\n\n                /**\n                 * The vertical offset of the button.\n                 */\n                y: 10\n            }\n        },\n\n        /**\n         * The pixel width of the plot area border.\n         *\n         * @sample {highcharts} highcharts/chart/plotborderwidth/\n         *         1px border\n         * @sample {highstock} stock/chart/plotborder/\n         *         2px border\n         * @sample {highmaps} maps/chart/plotborder/\n         *         Plot border options\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption chart.plotBorderWidth\n         */\n\n        /**\n         * Whether to apply a drop shadow to the plot area. Requires that\n         * plotBackgroundColor be set. The shadow can be an object configuration\n         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.\n         *\n         * @sample {highcharts} highcharts/chart/plotshadow/\n         *         Plot shadow\n         * @sample {highstock} stock/chart/plotshadow/\n         *         Plot shadow\n         * @sample {highmaps} maps/chart/plotborder/\n         *         Plot border options\n         *\n         * @type      {boolean|Highcharts.CSSObject}\n         * @default   false\n         * @apioption chart.plotShadow\n         */\n\n        /**\n         * When true, cartesian charts like line, spline, area and column are\n         * transformed into the polar coordinate system. Requires\n         * `highcharts-more.js`.\n         *\n         * @sample {highcharts} highcharts/demo/polar/\n         *         Polar chart\n         * @sample {highcharts} highcharts/demo/polar-wind-rose/\n         *         Wind rose, stacked polar column chart\n         * @sample {highcharts} highcharts/demo/polar-spider/\n         *         Spider web chart\n         * @sample {highcharts} highcharts/parallel-coordinates/polar/\n         *         Star plot, multivariate data in a polar chart\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption chart.polar\n         */\n\n        /**\n         * Whether to reflow the chart to fit the width of the container div\n         * on resizing the window.\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         True by default\n         * @sample {highcharts} highcharts/chart/reflow-false/\n         *         False\n         * @sample {highstock} stock/chart/reflow-true/\n         *         True by default\n         * @sample {highstock} stock/chart/reflow-false/\n         *         False\n         * @sample {highmaps} maps/chart/reflow-true/\n         *         True by default\n         * @sample {highmaps} maps/chart/reflow-false/\n         *         False\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     2.1\n         * @apioption chart.reflow\n         */\n\n        /**\n         * The HTML element where the chart will be rendered. If it is a string,\n         * the element by that id is used. The HTML element can also be passed\n         * by direct reference, or as the first argument of the chart\n         * constructor, in which case the option is not needed.\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         String\n         * @sample {highcharts} highcharts/chart/renderto-object/\n         *         Object reference\n         * @sample {highcharts} highcharts/chart/renderto-jquery/\n         *         Object reference through jQuery\n         * @sample {highstock} stock/chart/renderto-string/\n         *         String\n         * @sample {highstock} stock/chart/renderto-object/\n         *         Object reference\n         * @sample {highstock} stock/chart/renderto-jquery/\n         *         Object reference through jQuery\n         *\n         * @type      {string|Highcharts.SVGDOMElement}\n         * @apioption chart.renderTo\n         */\n\n        /**\n         * The background color of the marker square when selecting (zooming\n         * in on) an area of the chart.\n         *\n         * @see In styled mode, the selection marker fill is set with the\n         *      `.highcharts-selection-marker` class.\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   rgba(51,92,173,0.25)\n         * @since     2.1.7\n         * @apioption chart.selectionMarkerFill\n         */\n\n        /**\n         * Whether to apply a drop shadow to the outer chart area. Requires\n         * that backgroundColor be set. The shadow can be an object\n         * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and\n         * `width`.\n         *\n         * @sample {highcharts} highcharts/chart/shadow/\n         *         Shadow\n         * @sample {highstock} stock/chart/shadow/\n         *         Shadow\n         * @sample {highmaps} maps/chart/border/\n         *         Chart border and shadow\n         *\n         * @type      {boolean|Highcharts.CSSObject}\n         * @default   false\n         * @apioption chart.shadow\n         */\n\n        /**\n         * Whether to show the axes initially. This only applies to empty charts\n         * where series are added dynamically, as axes are automatically added\n         * to cartesian series.\n         *\n         * @sample {highcharts} highcharts/chart/showaxes-false/\n         *         False by default\n         * @sample {highcharts} highcharts/chart/showaxes-true/\n         *         True\n         *\n         * @type      {boolean}\n         * @since     1.2.5\n         * @product   highcharts\n         * @apioption chart.showAxes\n         */\n\n        /**\n         * The space between the bottom edge of the chart and the content (plot\n         * area, axis title and labels, title, subtitle or legend in top\n         * position).\n         *\n         * @sample {highcharts} highcharts/chart/spacingbottom/\n         *         Spacing bottom set to 100\n         * @sample {highstock} stock/chart/spacingbottom/\n         *         Spacing bottom set to 100\n         * @sample {highmaps} maps/chart/spacing/\n         *         Spacing 100 all around\n         *\n         * @type      {number}\n         * @default   15\n         * @since     2.1\n         * @apioption chart.spacingBottom\n         */\n\n        /**\n         * The space between the left edge of the chart and the content (plot\n         * area, axis title and labels, title, subtitle or legend in top\n         * position).\n         *\n         * @sample {highcharts} highcharts/chart/spacingleft/\n         *         Spacing left set to 100\n         * @sample {highstock} stock/chart/spacingleft/\n         *         Spacing left set to 100\n         * @sample {highmaps} maps/chart/spacing/\n         *         Spacing 100 all around\n         *\n         * @type      {number}\n         * @default   10\n         * @since     2.1\n         * @apioption chart.spacingLeft\n         */\n\n        /**\n         * The space between the right edge of the chart and the content (plot\n         * area, axis title and labels, title, subtitle or legend in top\n         * position).\n         *\n         * @sample {highcharts} highcharts/chart/spacingright-100/\n         *         Spacing set to 100\n         * @sample {highcharts} highcharts/chart/spacingright-legend/\n         *         Legend in right position with default spacing\n         * @sample {highstock} stock/chart/spacingright/\n         *         Spacing set to 100\n         * @sample {highmaps} maps/chart/spacing/\n         *         Spacing 100 all around\n         *\n         * @type      {number}\n         * @default   10\n         * @since     2.1\n         * @apioption chart.spacingRight\n         */\n\n        /**\n         * The space between the top edge of the chart and the content (plot\n         * area, axis title and labels, title, subtitle or legend in top\n         * position).\n         *\n         * @sample {highcharts} highcharts/chart/spacingtop-100/\n         *         A top spacing of 100\n         * @sample {highcharts} highcharts/chart/spacingtop-10/\n         *         Floating chart title makes the plot area align to the default\n         *         spacingTop of 10.\n         * @sample {highstock} stock/chart/spacingtop/\n         *         A top spacing of 100\n         * @sample {highmaps} maps/chart/spacing/\n         *         Spacing 100 all around\n         *\n         * @type      {number}\n         * @default   10\n         * @since     2.1\n         * @apioption chart.spacingTop\n         */\n\n        /**\n         * Additional CSS styles to apply inline to the container `div`. Note\n         * that since the default font styles are applied in the renderer, it\n         * is ignorant of the individual chart options and must be set globally.\n         *\n         * @see    In styled mode, general chart styles can be set with the\n         *         `.highcharts-root` class.\n         * @sample {highcharts} highcharts/chart/style-serif-font/\n         *         Using a serif type font\n         * @sample {highcharts} highcharts/css/em/\n         *         Styled mode with relative font sizes\n         * @sample {highstock} stock/chart/style/\n         *         Using a serif type font\n         * @sample {highmaps} maps/chart/style-serif-font/\n         *         Using a serif type font\n         *\n         * @type      {Highcharts.CSSObject}\n         * @default   {\"fontFamily\": \"\\\"Lucida Grande\\\", \\\"Lucida Sans Unicode\\\", Verdana, Arial, Helvetica, sans-serif\",\"fontSize\":\"12px\"}\n         * @apioption chart.style\n         */\n\n        /**\n         * The default series type for the chart. Can be any of the chart types\n         * listed under [plotOptions](#plotOptions).\n         *\n         * @sample {highcharts} highcharts/chart/type-bar/\n         *         Bar\n         * @sample {highstock} stock/chart/type/\n         *         Areaspline\n         * @sample {highmaps} maps/chart/type-mapline/\n         *         Mapline\n         *\n         * @type       {string}\n         * @default    {highcharts} line\n         * @default    {highstock} line\n         * @default    {highmaps} map\n         * @since      2.1.0\n         * @validvalue [\"line\", \"spline\", \"column\", \"bar\", \"area\", \"areaspline\",\n         *             \"pie\", \"arearange\", \"areasplinerange\", \"boxplot\",\n         *             \"bubble\", \"columnrange\", \"errorbar\", \"funnel\", \"gauge\",\n         *             \"heatmap\", \"polygon\", \"pyramid\", \"scatter\", \"solidgauge\",\n         *             \"treemap\", \"waterfall\"]\n         * @apioption  chart.type\n         */\n\n        /**\n         * Decides in what dimensions the user can zoom by dragging the mouse.\n         * Can be one of `x`, `y` or `xy`.\n         *\n         * @see [panKey](#chart.panKey)\n         *\n         * @sample {highcharts} highcharts/chart/zoomtype-none/\n         *         None by default\n         * @sample {highcharts} highcharts/chart/zoomtype-x/\n         *         X\n         * @sample {highcharts} highcharts/chart/zoomtype-y/\n         *         Y\n         * @sample {highcharts} highcharts/chart/zoomtype-xy/\n         *         Xy\n         * @sample {highstock} stock/demo/basic-line/\n         *         None by default\n         * @sample {highstock} stock/chart/zoomtype-x/\n         *         X\n         * @sample {highstock} stock/chart/zoomtype-y/\n         *         Y\n         * @sample {highstock} stock/chart/zoomtype-xy/\n         *         Xy\n         *\n         * @type       {string}\n         * @product    highcharts highstock\n         * @validvalue [\"x\", \"y\", \"xy\"]\n         * @apioption  chart.zoomType\n         */\n\n        /**\n         * An explicit width for the chart. By default (when `null`) the width\n         * is calculated from the offset width of the containing element.\n         *\n         * @sample {highcharts} highcharts/chart/width/\n         *         800px wide\n         * @sample {highstock} stock/chart/width/\n         *         800px wide\n         * @sample {highmaps} maps/chart/size/\n         *         Chart with explicit size\n         *\n         * @type {number|null}\n         */\n        width: null,\n\n        /**\n         * An explicit height for the chart. If a _number_, the height is\n         * given in pixels. If given a _percentage string_ (for example\n         * `'56%'`), the height is given as the percentage of the actual chart\n         * width. This allows for preserving the aspect ratio across responsive\n         * sizes.\n         *\n         * By default (when `null`) the height is calculated from the offset\n         * height of the containing element, or 400 pixels if the containing\n         * element's height is 0.\n         *\n         * @sample {highcharts} highcharts/chart/height/\n         *         500px height\n         * @sample {highstock} stock/chart/height/\n         *         300px height\n         * @sample {highmaps} maps/chart/size/\n         *         Chart with explicit size\n         * @sample highcharts/chart/height-percent/\n         *         Highcharts with percentage height\n         *\n         * @type {number|string|null}\n         */\n        height: null\n\n        \n\n    },\n\n    /**\n     * The chart's main title.\n     *\n     * @sample {highmaps} maps/title/title/\n     *         Title options demonstrated\n     */\n    title: {\n\n        /**\n         * When the title is floating, the plot area will not move to make space\n         * for it.\n         *\n         * @sample {highcharts} highcharts/chart/zoomtype-none/\n         *         False by default\n         * @sample {highcharts} highcharts/title/floating/\n         *         True - title on top of the plot area\n         * @sample {highstock} stock/chart/title-floating/\n         *         True - title on top of the plot area\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.1\n         * @apioption title.floating\n         */\n\n        /**\n         * CSS styles for the title. Use this for font styling, but use `align`,\n         * `x` and `y` for text alignment.\n         *\n         * In styled mode, the title style is given in the `.highcharts-title`\n         * class.\n         *\n         * @sample {highcharts} highcharts/title/style/\n         *         Custom color and weight\n         * @sample {highstock} stock/chart/title-style/\n         *         Custom color and weight\n         * @sample highcharts/css/titles/\n         *         Styled mode\n         *\n         * @type      {Highcharts.CSSObject}\n         * @default   {highcharts|highmaps} { \"color\": \"#333333\", \"fontSize\": \"18px\" }\n         * @default   {highstock} { \"color\": \"#333333\", \"fontSize\": \"16px\" }\n         * @apioption title.style\n         */\n\n        /**\n         * Whether to\n         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)\n         * to render the text.\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption title.useHTML\n         */\n\n        /**\n         * The vertical alignment of the title. Can be one of `\"top\"`,\n         * `\"middle\"` and `\"bottom\"`. When a value is given, the title behaves\n         * as if [floating](#title.floating) were `true`.\n         *\n         * @sample {highcharts} highcharts/title/verticalalign/\n         *         Chart title in bottom right corner\n         * @sample {highstock} stock/chart/title-verticalalign/\n         *         Chart title in bottom right corner\n         *\n         * @type       {string}\n         * @since      2.1\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @apioption  title.verticalAlign\n         */\n\n        /**\n         * The x position of the title relative to the alignment within\n         * `chart.spacingLeft` and `chart.spacingRight`.\n         *\n         * @sample {highcharts} highcharts/title/align/\n         *         Aligned to the plot area (x = 70px = margin left - spacing\n         *         left)\n         * @sample {highstock} stock/chart/title-align/\n         *         Aligned to the plot area (x = 50px = margin left - spacing\n         *         left)\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.0\n         * @apioption title.x\n         */\n\n        /**\n         * The y position of the title relative to the alignment within\n         * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](\n         * #chart.spacingBottom). By default it depends on the font size.\n         *\n         * @sample {highcharts} highcharts/title/y/\n         *         Title inside the plot area\n         * @sample {highstock} stock/chart/title-verticalalign/\n         *         Chart title in bottom right corner\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption title.y\n         */\n\n        /**\n         * The title of the chart. To disable the title, set the `text` to\n         * `undefined`.\n         *\n         * @sample {highcharts} highcharts/title/text/\n         *         Custom title\n         * @sample {highstock} stock/chart/title-text/\n         *         Custom title\n         *\n         * @default {highcharts|highmaps} Chart title\n         * @default {highstock} undefined\n         */\n        text: 'Chart title',\n\n        /**\n         * The horizontal alignment of the title. Can be one of \"left\", \"center\"\n         * and \"right\".\n         *\n         * @sample {highcharts} highcharts/title/align/\n         *         Aligned to the plot area (x = 70px = margin left - spacing\n         *         left)\n         * @sample {highstock} stock/chart/title-align/\n         *         Aligned to the plot area (x = 50px = margin left - spacing\n         *         left)\n         *\n         * @since      2.0\n         * @validvalue [\"left\", \"center\", \"right\"]\n         */\n        align: 'center',\n\n        /**\n         * The margin between the title and the plot area, or if a subtitle\n         * is present, the margin between the subtitle and the plot area.\n         *\n         * @sample {highcharts} highcharts/title/margin-50/\n         *         A chart title margin of 50\n         * @sample {highcharts} highcharts/title/margin-subtitle/\n         *         The same margin applied with a subtitle\n         * @sample {highstock} stock/chart/title-margin/\n         *         A chart title margin of 50\n         *\n         * @since 2.1\n         */\n        margin: 15,\n\n        /**\n         * Adjustment made to the title width, normally to reserve space for\n         * the exporting burger menu.\n         *\n         * @sample highcharts/title/widthadjust/\n         *         Wider menu, greater padding\n         *\n         * @since 4.2.5\n         */\n        widthAdjust: -44\n\n    },\n\n    /**\n     * The chart's subtitle. This can be used both to display a subtitle below\n     * the main title, and to display random text anywhere in the chart. The\n     * subtitle can be updated after chart initialization through the\n     * `Chart.setTitle` method.\n     *\n     * @sample {highmaps} maps/title/subtitle/\n     *         Subtitle options demonstrated\n     */\n    subtitle: {\n\n        /**\n         * When the subtitle is floating, the plot area will not move to make\n         * space for it.\n         *\n         * @sample {highcharts} highcharts/subtitle/floating/\n         *         Floating title and subtitle\n         * @sample {highstock} stock/chart/subtitle-footnote\n         *         Footnote floating at bottom right of plot area\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.1\n         * @apioption subtitle.floating\n         */\n\n        /**\n         * CSS styles for the title.\n         *\n         * In styled mode, the subtitle style is given in the\n         * `.highcharts-subtitle` class.\n         *\n         * @sample {highcharts} highcharts/subtitle/style/\n         *         Custom color and weight\n         * @sample {highcharts} highcharts/css/titles/\n         *         Styled mode\n         * @sample {highstock} stock/chart/subtitle-style\n         *         Custom color and weight\n         * @sample {highstock} highcharts/css/titles/\n         *         Styled mode\n         * @sample {highmaps} highcharts/css/titles/\n         *         Styled mode\n         *\n         * @type      {Highcharts.CSSObject}\n         * @default   {\"color\": \"#666666\"}\n         * @apioption subtitle.style\n         */\n\n        /**\n         * Whether to\n         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)\n         * to render the text.\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption subtitle.useHTML\n         */\n\n        /**\n         * The vertical alignment of the title. Can be one of \"top\", \"middle\"\n         * and \"bottom\". When a value is given, the title behaves as floating.\n         *\n         * @sample {highcharts} highcharts/subtitle/verticalalign/\n         *         Footnote at the bottom right of plot area\n         * @sample {highstock} stock/chart/subtitle-footnote\n         *         Footnote at the bottom right of plot area\n         *\n         * @type       {string}\n         * @since      2.1\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @apioption  subtitle.verticalAlign\n         */\n\n        /**\n         * The x position of the subtitle relative to the alignment within\n         * `chart.spacingLeft` and `chart.spacingRight`.\n         *\n         * @sample {highcharts} highcharts/subtitle/align/\n         *         Footnote at right of plot area\n         * @sample {highstock} stock/chart/subtitle-footnote\n         *         Footnote at the bottom right of plot area\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.0\n         * @apioption subtitle.x\n         */\n\n        /**\n         * The y position of the subtitle relative to the alignment within\n         * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle\n         * is laid out below the title unless the title is floating.\n         *\n         * @sample {highcharts} highcharts/subtitle/verticalalign/\n         *         Footnote at the bottom right of plot area\n         * @sample {highstock} stock/chart/subtitle-footnote\n         *         Footnote at the bottom right of plot area\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption subtitle.y\n         */\n\n        /**\n         * The subtitle of the chart.\n         *\n         * @sample {highcharts|highstock} highcharts/subtitle/text/\n         *         Custom subtitle\n         * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/\n         *         Formatted and linked text.\n         */\n        text: '',\n\n        /**\n         * The horizontal alignment of the subtitle. Can be one of \"left\",\n         *  \"center\" and \"right\".\n         *\n         * @sample {highcharts} highcharts/subtitle/align/\n         *         Footnote at right of plot area\n         * @sample {highstock} stock/chart/subtitle-footnote\n         *         Footnote at bottom right of plot area\n         *\n         * @since      2.0\n         * @validvalue [\"left\", \"center\", \"right\"]\n         */\n        align: 'center',\n\n        /**\n         * Adjustment made to the subtitle width, normally to reserve space\n         * for the exporting burger menu.\n         *\n         * @see [title.widthAdjust](#title.widthAdjust)\n         *\n         * @sample highcharts/title/widthadjust/\n         *         Wider menu, greater padding\n         *\n         * @since 4.2.5\n         */\n        widthAdjust: -44\n    },\n\n    /**\n     * The plotOptions is a wrapper object for config objects for each series\n     * type. The config objects for each series can also be overridden for\n     * each series item as given in the series array.\n     *\n     * Configuration options for the series are given in three levels. Options\n     * for all series in a chart are given in the [plotOptions.series](\n     * #plotOptions.series) object. Then options for all series of a specific\n     * type are given in the plotOptions of that type, for example\n     * `plotOptions.line`. Next, options for one single series are given in\n     * [the series array](#series).\n     */\n    plotOptions: {},\n\n    /**\n     * HTML labels that can be positioned anywhere in the chart area.\n     */\n    labels: {\n\n        /**\n         * An HTML label that can be positioned anywhere in the chart area.\n         *\n         * @type      {Array<*>}\n         * @apioption labels.items\n         */\n\n        /**\n         * Inner HTML or text for the label.\n         *\n         * @type      {string}\n         * @apioption labels.items.html\n         */\n\n        /**\n         * CSS styles for each label. To position the label, use left and top\n         * like this:\n         *\n         * <pre>style: {\n         *     left: '100px',\n         *     top: '100px'\n         * }</pre>\n         *\n         * @type      {Highcharts.CSSObject}\n         * @apioption labels.items.style\n         */\n\n        /**\n         * Shared CSS styles for all labels.\n         *\n         * @type    {Highcharts.CSSObject}\n         * @default {\"color\": \"#333333\", \"position\": \"absolute\"}\n         */\n        style: {\n            /**\n             * @ignore\n             */\n            position: 'absolute',\n            /**\n             * @ignore\n             */\n            color: '#333333'\n        }\n    },\n\n    /**\n     * The legend is a box containing a symbol and name for each series\n     * item or point item in the chart. Each series (or points in case\n     * of pie charts) is represented by a symbol and its name in the legend.\n     *\n     * It is possible to override the symbol creator function and create\n     * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).\n     *\n     * @productdesc {highmaps}\n     * A Highmaps legend by default contains one legend item per series, but if\n     * a `colorAxis` is defined, the axis will be displayed in the legend.\n     * Either as a gradient, or as multiple legend items for `dataClasses`.\n     */\n    legend: {\n\n        /**\n         * The background color of the legend.\n         *\n         * @see In styled mode, the legend background fill can be applied with\n         *      the `.highcharts-legend-box` class.\n         *\n         * @sample {highcharts} highcharts/legend/backgroundcolor/\n         *         Yellowish background\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/border-background/\n         *         Border and background options\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption legend.backgroundColor\n         */\n\n        /**\n         * The width of the drawn border around the legend.\n         *\n         * @see In styled mode, the legend border stroke width can be applied\n         *      with the `.highcharts-legend-box` class.\n         *\n         * @sample {highcharts} highcharts/legend/borderwidth/\n         *         2px border width\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/border-background/\n         *         Border and background options\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption legend.borderWidth\n         */\n\n        /**\n         * Enable or disable the legend. There is also a series-specific option,\n         * [showInLegend](#plotOptions.series.showInLegend), that can hide the\n         * series from the legend. In some series types this is `false` by\n         * default, so it must set to `true` in order to show the legend for the\n         * series.\n         *\n         * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled\n         * @sample {highstock} stock/legend/align/ Various legend options\n         * @sample {highmaps} maps/legend/enabled-false/ Legend disabled\n         *\n         * @default {highstock} false\n         * @default {highmaps} true\n         */\n        enabled: true,\n\n        /**\n         * The horizontal alignment of the legend box within the chart area.\n         * Valid values are `left`, `center` and `right`.\n         *\n         * In the case that the legend is aligned in a corner position, the\n         * `layout` option will determine whether to place it above/below\n         * or on the side of the plot area.\n         *\n         * @sample {highcharts} highcharts/legend/align/\n         *         Legend at the right of the chart\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/alignment/\n         *         Legend alignment\n         *\n         * @since      2.0\n         * @validvalue [\"left\", \"center\", \"right\"]\n         */\n        align: 'center',\n\n        /**\n         * If the [layout](legend.layout) is `horizontal` and the legend items\n         * span over two lines or more, whether to align the items into vertical\n         * columns. Setting this to `false` makes room for more items, but will\n         * look more messy.\n         *\n         * @since 6.1.0\n         */\n        alignColumns: true,\n\n        /**\n         * When the legend is floating, the plot area ignores it and is allowed\n         * to be placed below it.\n         *\n         * @sample {highcharts} highcharts/legend/floating-false/\n         *         False by default\n         * @sample {highcharts} highcharts/legend/floating-true/\n         *         True\n         * @sample {highmaps} maps/legend/alignment/\n         *         Floating legend\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.1\n         * @apioption legend.floating\n         */\n\n        /**\n         * The layout of the legend items. Can be one of `horizontal` or\n         * `vertical` or `proximate`. When `proximate`, the legend items will be\n         * placed as close as possible to the graphs they're representing,\n         * except in inverted charts or when the legend position doesn't allow\n         * it.\n         *\n         * @sample {highcharts} highcharts/legend/layout-horizontal/\n         *         Horizontal by default\n         * @sample {highcharts} highcharts/legend/layout-vertical/\n         *         Vertical\n         * @sample highcharts/legend/layout-proximate\n         *         Labels proximate to the data\n         * @sample {highstock} stock/legend/layout-horizontal/\n         *         Horizontal by default\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         Vertical with data classes\n         * @sample {highmaps} maps/legend/layout-vertical/\n         *         Vertical with color axis gradient\n         *\n         * @validvalue [\"horizontal\", \"vertical\", \"proximate\"]\n         */\n        layout: 'horizontal',\n\n        /**\n         * In a legend with horizontal layout, the itemDistance defines the\n         * pixel distance between each item.\n         *\n         * @sample {highcharts} highcharts/legend/layout-horizontal/\n         *         50px item distance\n         * @sample {highstock} highcharts/legend/layout-horizontal/\n         *         50px item distance\n         *\n         * @type      {number}\n         * @default   {highcharts} 20\n         * @default   {highstock} 20\n         * @default   {highmaps} 8\n         * @since     3.0.3\n         * @apioption legend.itemDistance\n         */\n\n        /**\n         * The pixel bottom margin for each legend item.\n         *\n         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.2.0\n         * @apioption legend.itemMarginBottom\n         */\n\n        /**\n         * The pixel top margin for each legend item.\n         *\n         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.2.0\n         * @apioption legend.itemMarginTop\n         */\n\n        /**\n         * The width for each legend item. By default the items are laid out\n         * successively. In a [horizontal layout](legend.layout), if the items\n         * are laid out across two rows or more, they will be vertically aligned\n         * depending on the [legend.alignColumns](legend.alignColumns) option.\n         *\n         * @sample {highcharts} highcharts/legend/itemwidth-default/\n         *         Undefined by default\n         * @sample {highcharts} highcharts/legend/itemwidth-80/\n         *         80 for aligned legend items\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption legend.itemWidth\n         */\n\n        /**\n         * A [format string](https://www.highcharts.com/docs/chart-concepts/\n         * labels-and-string-formatting) for each legend label. Available\n         * variables relates to properties on the series, or the point in case\n         * of pies.\n         *\n         * @type      {string}\n         * @default   {name}\n         * @since     1.3\n         * @apioption legend.labelFormat\n         */\n\n        /**\n         * Callback function to format each of the series' labels. The `this`\n         * keyword refers to the series object, or the point object in case\n         * of pie charts. By default the series or point name is printed.\n         *\n         * @productdesc {highmaps}\n         * In Highmaps the context can also be a data class in case of a\n         * `colorAxis`.\n         *\n         * @sample {highcharts} highcharts/legend/labelformatter/\n         *         Add text\n         * @sample {highmaps} maps/legend/labelformatter/\n         *         Data classes with label formatter\n         *\n         * @context {Highcharts.Series|Highcharts.Point}\n         */\n        labelFormatter: function () {\n            return this.name;\n        },\n\n        /**\n         * Line height for the legend items. Deprecated as of 2.1\\. Instead,\n         * the line height for each item can be set using itemStyle.lineHeight,\n         * and the padding between items using `itemMarginTop` and\n         * `itemMarginBottom`.\n         *\n         * @sample {highcharts} highcharts/legend/lineheight/\n         *         Setting padding\n         *\n         * @deprecated\n         *\n         * @type      {number}\n         * @default   16\n         * @since     2.0\n         * @product   highcharts\n         * @apioption legend.lineHeight\n         */\n\n        /**\n         * If the plot area sized is calculated automatically and the legend\n         * is not floating, the legend margin is the space between the legend\n         * and the axis labels or plot area.\n         *\n         * @sample {highcharts} highcharts/legend/margin-default/\n         *         12 pixels by default\n         * @sample {highcharts} highcharts/legend/margin-30/\n         *         30 pixels\n         *\n         * @type      {number}\n         * @default   12\n         * @since     2.1\n         * @apioption legend.margin\n         */\n\n        /**\n         * Maximum pixel height for the legend. When the maximum height is\n         * extended, navigation will show.\n         *\n         * @type      {number}\n         * @since     2.3.0\n         * @apioption legend.maxHeight\n         */\n\n        /**\n         * The color of the drawn border around the legend.\n         *\n         * @see In styled mode, the legend border stroke can be applied with the\n         *      `.highcharts-legend-box` class.\n         *\n         * @sample {highcharts} highcharts/legend/bordercolor/\n         *         Brown border\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/border-background/\n         *         Border and background options\n         *\n         * @type {Highcharts.ColorString}\n         */\n        borderColor: '#999999',\n\n        /**\n         * The border corner radius of the legend.\n         *\n         * @sample {highcharts} highcharts/legend/borderradius-default/\n         *         Square by default\n         * @sample {highcharts} highcharts/legend/borderradius-round/\n         *         5px rounded\n         * @sample {highmaps} maps/legend/border-background/\n         *         Border and background options\n         */\n        borderRadius: 0,\n\n        /**\n         * Options for the paging or navigation appearing when the legend\n         * is overflown. Navigation works well on screen, but not in static\n         * exported images. One way of working around that is to\n         * [increase the chart height in\n         * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).\n         */\n        navigation: {\n\n            /**\n             * How to animate the pages when navigating up or down. A value of\n             * `true` applies the default navigation given in the\n             * `chart.animation` option. Additional options can be given as an\n             * object containing values for easing and duration.\n             *\n             * @sample {highcharts} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             * @sample {highstock} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             *\n             * @type      {boolean|Highcharts.AnimationObject}\n             * @default   true\n             * @since     2.2.4\n             * @apioption legend.navigation.animation\n             */\n\n            /**\n             * The pixel size of the up and down arrows in the legend paging\n             * navigation.\n             *\n             * @sample {highcharts} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             * @sample {highstock} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             *\n             * @type      {number}\n             * @default   12\n             * @since     2.2.4\n             * @apioption legend.navigation.arrowSize\n             */\n\n            /**\n             * Whether to enable the legend navigation. In most cases, disabling\n             * the navigation results in an unwanted overflow.\n             *\n             * See also the [adapt chart to legend](\n             * https://www.highcharts.com/products/plugin-registry/single/8/Adapt-Chart-To-Legend)\n             * plugin for a solution to extend the chart height to make room for\n             * the legend, optionally in exported charts only.\n             *\n             * @type      {boolean}\n             * @default   true\n             * @since     4.2.4\n             * @apioption legend.navigation.enabled\n             */\n\n            /**\n             * Text styles for the legend page navigation.\n             *\n             * @see In styled mode, the navigation items are styled with the\n             *      `.highcharts-legend-navigation` class.\n             *\n             * @sample {highcharts} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             * @sample {highstock} highcharts/legend/navigation/\n             *         Legend page navigation demonstrated\n             *\n             * @type      {Highcharts.CSSObject}\n             * @since     2.2.4\n             * @apioption legend.navigation.style\n             */\n\n            \n        },\n\n        /**\n         * The inner padding of the legend box.\n         *\n         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         *\n         * @type      {number}\n         * @default   8\n         * @since     2.2.0\n         * @apioption legend.padding\n         */\n\n        /**\n         * Whether to reverse the order of the legend items compared to the\n         * order of the series or points as defined in the configuration object.\n         *\n         * @see [yAxis.reversedStacks](#yAxis.reversedStacks),\n         *      [series.legendIndex](#series.legendIndex)\n         *\n         * @sample {highcharts} highcharts/legend/reversed/\n         *         Stacked bar with reversed legend\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     1.2.5\n         * @apioption legend.reversed\n         */\n\n        /**\n         * Whether to show the symbol on the right side of the text rather than\n         * the left side. This is common in Arabic and Hebraic.\n         *\n         * @sample {highcharts} highcharts/legend/rtl/\n         *         Symbol to the right\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.2\n         * @apioption legend.rtl\n         */\n\n        /**\n         * CSS styles for the legend area. In the 1.x versions the position\n         * of the legend area was determined by CSS. In 2.x, the position is\n         * determined by properties like `align`, `verticalAlign`, `x` and `y`,\n         * but the styles are still parsed for backwards compatibility.\n         *\n         * @deprecated\n         *\n         * @type      {Highcharts.CSSObject}\n         * @product   highcharts highstock\n         * @apioption legend.style\n         */\n\n        \n\n        /**\n         * Default styling for the checkbox next to a legend item when\n         * `showCheckbox` is true.\n         *\n         * @type {Highcharts.CSSObject}\n         * @default {\"width\": \"13px\", \"height\": \"13px\", \"position\":\"absolute\"}\n         */\n        itemCheckboxStyle: {\n            /**\n             * @ignore\n             */\n            position: 'absolute',\n            /**\n             * @ignore\n             */\n            width: '13px', // for IE precision\n            /**\n             * @ignore\n             */\n            height: '13px'\n        },\n        // itemWidth: undefined,\n\n        /**\n         * When this is true, the legend symbol width will be the same as\n         * the symbol height, which in turn defaults to the font size of the\n         * legend items.\n         *\n         * @since 5.0.0\n         */\n        squareSymbol: true,\n\n        /**\n         * The pixel height of the symbol for series types that use a rectangle\n         * in the legend. Defaults to the font size of legend items.\n         *\n         * @productdesc {highmaps}\n         * In Highmaps, when the symbol is the gradient of a vertical color\n         * axis, the height defaults to 200.\n         *\n         * @sample {highmaps} maps/legend/layout-vertical-sized/\n         *         Sized vertical gradient\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         No distance between data classes\n         *\n         * @type      {number}\n         * @since     3.0.8\n         * @apioption legend.symbolHeight\n         */\n\n        /**\n         * The border radius of the symbol for series types that use a rectangle\n         * in the legend. Defaults to half the `symbolHeight`.\n         *\n         * @sample {highcharts} highcharts/legend/symbolradius/\n         *         Round symbols\n         * @sample {highstock} highcharts/legend/symbolradius/\n         *         Round symbols\n         * @sample {highmaps} highcharts/legend/symbolradius/\n         *         Round symbols\n         *\n         * @type      {number}\n         * @since     3.0.8\n         * @apioption legend.symbolRadius\n         */\n\n        /**\n         * The pixel width of the legend item symbol. When the `squareSymbol`\n         * option is set, this defaults to the `symbolHeight`, otherwise 16.\n         *\n         * @productdesc {highmaps}\n         * In Highmaps, when the symbol is the gradient of a horizontal color\n         * axis, the width defaults to 200.\n         *\n         * @sample {highcharts} highcharts/legend/symbolwidth/\n         *         Greater symbol width and padding\n         * @sample {highmaps} maps/legend/padding-itemmargin/\n         *         Padding and item margins demonstrated\n         * @sample {highmaps} maps/legend/layout-vertical-sized/\n         *         Sized vertical gradient\n         *\n         * @type      {number}\n         * @apioption legend.symbolWidth\n         */\n\n        /**\n         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/\n         * labels-and-string-formatting#html) to render the legend item texts.\n         *\n         * Prior to 4.1.7, when using HTML, [legend.navigation](\n         * #legend.navigation) was disabled.\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption legend.useHTML\n         */\n\n        /**\n         * The width of the legend box.\n         *\n         * @sample {highcharts} highcharts/legend/width/\n         *         Aligned to the plot area\n         *\n         * @type      {number}\n         * @since     2.0\n         * @apioption legend.width\n         */\n\n        /**\n         * The pixel padding between the legend item symbol and the legend\n         * item text.\n         *\n         * @sample {highcharts} highcharts/legend/symbolpadding/\n         *         Greater symbol width and padding\n         */\n        symbolPadding: 5,\n\n        /**\n         * The vertical alignment of the legend box. Can be one of `top`,\n         * `middle` or `bottom`. Vertical position can be further determined\n         * by the `y` option.\n         *\n         * In the case that the legend is aligned in a corner position, the\n         * `layout` option will determine whether to place it above/below\n         * or on the side of the plot area.\n         *\n         * When the [layout](#legend.layout) option is `proximate`, the\n         * `verticalAlign` option doesn't apply.\n         *\n         * @sample {highcharts} highcharts/legend/verticalalign/\n         *         Legend 100px from the top of the chart\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/alignment/\n         *         Legend alignment\n         *\n         * @since      2.0\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         */\n        verticalAlign: 'bottom',\n\n        // width: undefined,\n\n        /**\n         * The x offset of the legend relative to its horizontal alignment\n         * `align` within chart.spacingLeft and chart.spacingRight. Negative\n         * x moves it to the left, positive x moves it to the right.\n         *\n         * @sample {highcharts} highcharts/legend/width/\n         *         Aligned to the plot area\n         *\n         * @since 2.0\n         */\n        x: 0,\n\n        /**\n         * The vertical offset of the legend relative to it's vertical alignment\n         * `verticalAlign` within chart.spacingTop and chart.spacingBottom.\n         *  Negative y moves it up, positive y moves it down.\n         *\n         * @sample {highcharts} highcharts/legend/verticalalign/\n         *         Legend 100px from the top of the chart\n         * @sample {highstock} stock/legend/align/\n         *         Various legend options\n         * @sample {highmaps} maps/legend/alignment/\n         *         Legend alignment\n         *\n         * @since 2.0\n         */\n        y: 0,\n\n        /**\n         * A title to be added on top of the legend.\n         *\n         * @sample {highcharts} highcharts/legend/title/\n         *         Legend title\n         * @sample {highmaps} maps/legend/alignment/\n         *         Legend with title\n         *\n         * @since 3.0\n         */\n        title: {\n            /**\n             * A text or HTML string for the title.\n             *\n             * @type      {string}\n             * @since     3.0\n             * @apioption legend.title.text\n             */\n\n            \n\n        }\n    },\n\n\n    /**\n     * The loading options control the appearance of the loading screen\n     * that covers the plot area on chart operations. This screen only\n     * appears after an explicit call to `chart.showLoading()`. It is a\n     * utility for developers to communicate to the end user that something\n     * is going on, for example while retrieving new data via an XHR connection.\n     * The \"Loading...\" text itself is not part of this configuration\n     * object, but part of the `lang` object.\n     */\n    loading: {\n\n        /**\n         * The duration in milliseconds of the fade out effect.\n         *\n         * @sample highcharts/loading/hideduration/\n         *         Fade in and out over a second\n         *\n         * @type      {number}\n         * @default   100\n         * @since     1.2.0\n         * @apioption loading.hideDuration\n         */\n\n        /**\n         * The duration in milliseconds of the fade in effect.\n         *\n         * @sample highcharts/loading/hideduration/\n         *         Fade in and out over a second\n         *\n         * @type      {number}\n         * @default   100\n         * @since     1.2.0\n         * @apioption loading.showDuration\n         */\n\n        \n    },\n\n\n    /**\n     * Options for the tooltip that appears when the user hovers over a\n     * series or point.\n     */\n    tooltip: {\n\n\n        /**\n         * The color of the tooltip border. When `undefined`, the border takes\n         * the color of the corresponding series or point.\n         *\n         * @sample {highcharts} highcharts/tooltip/bordercolor-default/\n         *         Follow series by default\n         * @sample {highcharts} highcharts/tooltip/bordercolor-black/\n         *         Black border\n         * @sample {highstock} stock/tooltip/general/\n         *         Styled tooltip\n         * @sample {highmaps} maps/tooltip/background-border/\n         *         Background and border demo\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption tooltip.borderColor\n         */\n\n        /**\n         * Since 4.1, the crosshair definitions are moved to the Axis object\n         * in order for a better separation from the tooltip. See\n         * [xAxis.crosshair](#xAxis.crosshair)<a>.</a>\n         *\n         * @sample {highcharts} highcharts/tooltip/crosshairs-x/\n         *         Enable a crosshair for the x value\n         *\n         * @deprecated\n         *\n         * @type      {*}\n         * @default   true\n         * @apioption tooltip.crosshairs\n         */\n\n        /**\n         * Whether the tooltip should follow the mouse as it moves across\n         * columns, pie slices and other point types with an extent. By default\n         * it behaves this way for scatter, bubble and pie series by override\n         * in the `plotOptions` for those series types.\n         *\n         * For touch moves to behave the same way, [followTouchMove](\n         * #tooltip.followTouchMove) must be `true` also.\n         *\n         * @type      {boolean}\n         * @default   {highcharts} false\n         * @default   {highstock} false\n         * @default   {highmaps} true\n         * @since     3.0\n         * @apioption tooltip.followPointer\n         */\n\n        /**\n         * Whether the tooltip should update as the finger moves on a touch\n         * device. If this is `true` and [chart.panning](#chart.panning) is\n         * set,`followTouchMove` will take over one-finger touches, so the user\n         * needs to use two fingers for zooming and panning.\n         *\n         * Note the difference to [followPointer](#tooltip.followPointer) that\n         * only defines the _position_ of the tooltip. If `followPointer` is\n         * false in for example a column series, the tooltip will show above or\n         * below the column, but as `followTouchMove` is true, the tooltip will\n         * jump from column to column as the user swipes across the plot area.\n         *\n         * @type      {boolean}\n         * @default   {highcharts} true\n         * @default   {highstock} true\n         * @default   {highmaps} false\n         * @since     3.0.1\n         * @apioption tooltip.followTouchMove\n         */\n\n        /**\n         * Callback function to format the text of the tooltip from scratch.\n         * Return `false` to disable tooltip for a specific point on series.\n         *\n         * A subset of HTML is supported. Unless `useHTML` is true, the HTML of\n         * the tooltip is parsed and converted to SVG, therefore this isn't a\n         * complete HTML renderer. The following tags are supported: `<b>`,\n         * `<strong>`, `<i>`, `<em>`, `<br/>`, `<span>`. Spans can be styled\n         * with a `style` attribute, but only text-related CSS that is shared\n         * with SVG is handled.\n         *\n         * Since version 2.1 the tooltip can be shared between multiple series\n         * through the `shared` option. The available data in the formatter\n         * differ a bit depending on whether the tooltip is shared or not. In\n         * a shared tooltip, all properties except `x`, which is common for\n         * all points, are kept in an array, `this.points`.\n         *\n         * Available data are:\n         *\n         * <dl>\n         *\n         * <dt>this.percentage (not shared) / this.points[i].percentage (shared)\n         * </dt>\n         *\n         * <dd>Stacked series and pies only. The point's percentage of the\n         * total.\n         * </dd>\n         *\n         * <dt>this.point (not shared) / this.points[i].point (shared)</dt>\n         *\n         * <dd>The point object. The point name, if defined, is available\n         * through `this.point.name`.</dd>\n         *\n         * <dt>this.points</dt>\n         *\n         * <dd>In a shared tooltip, this is an array containing all other\n         * properties for each point.</dd>\n         *\n         * <dt>this.series (not shared) / this.points[i].series (shared)</dt>\n         *\n         * <dd>The series object. The series name is available through\n         * `this.series.name`.</dd>\n         *\n         * <dt>this.total (not shared) / this.points[i].total (shared)</dt>\n         *\n         * <dd>Stacked series only. The total value at this point's x value.\n         * </dd>\n         *\n         * <dt>this.x</dt>\n         *\n         * <dd>The x value. This property is the same regardless of the tooltip\n         * being shared or not.</dd>\n         *\n         * <dt>this.y (not shared) / this.points[i].y (shared)</dt>\n         *\n         * <dd>The y value.</dd>\n         *\n         * </dl>\n         *\n         * @sample {highcharts} highcharts/tooltip/formatter-simple/\n         *         Simple string formatting\n         * @sample {highcharts} highcharts/tooltip/formatter-shared/\n         *         Formatting with shared tooltip\n         * @sample {highstock} stock/tooltip/formatter/\n         *         Formatting with shared tooltip\n         * @sample {highmaps} maps/tooltip/formatter/\n         *         String formatting\n         *\n         * @type      {Function}\n         * @apioption tooltip.formatter\n         */\n\n        /**\n         * The number of milliseconds to wait until the tooltip is hidden when\n         * mouse out from a point or chart.\n         *\n         * @type      {number}\n         * @default   500\n         * @since     3.0\n         * @apioption tooltip.hideDelay\n         */\n\n        /**\n         * Whether to allow the tooltip to render outside the chart's SVG\n         * element box. By default (`false`), the tooltip is rendered within the\n         * chart's SVG element, which results in the tooltip being aligned\n         * inside the chart area. For small charts, this may result in clipping\n         * or overlapping. When `true`, a separate SVG element is created and\n         * overlaid on the page, allowing the tooltip to be aligned inside the\n         * page itself.\n         *\n         * @sample highcharts/tooltip/outside\n         *         Small charts with tooltips outside\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     6.1.1\n         * @apioption tooltip.outside\n         */\n\n        /**\n         * A callback function for formatting the HTML output for a single point\n         * in the tooltip. Like the `pointFormat` string, but with more\n         * flexibility.\n         *\n         * @type      {Function}\n         * @since     4.1.0\n         * @context   Highcharts.Point\n         * @apioption tooltip.pointFormatter\n         */\n\n        /**\n         * A callback function to place the tooltip in a default position. The\n         * callback receives three parameters: `labelWidth`, `labelHeight` and\n         * `point`, where point contains values for `plotX` and `plotY` telling\n         * where the reference point is in the plot area. Add `chart.plotLeft`\n         * and `chart.plotTop` to get the full coordinates.\n         *\n         * The return should be an object containing x and y values, for example\n         * `{ x: 100, y: 100 }`.\n         *\n         * @sample {highcharts} highcharts/tooltip/positioner/\n         *         A fixed tooltip position\n         * @sample {highstock} stock/tooltip/positioner/\n         *         A fixed tooltip position on top of the chart\n         * @sample {highmaps} maps/tooltip/positioner/\n         *         A fixed tooltip position\n         *\n         * @type      {Function}\n         * @since     2.2.4\n         * @apioption tooltip.positioner\n         */\n\n        /**\n         * The name of a symbol to use for the border around the tooltip. Can\n         * be one of: `\"callout\"`, `\"circle\"` or `\"square\"`.\n         *\n         * Custom callbacks for symbol path generation can also be added to\n         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for\n         * [series.marker.symbol](plotOptions.line.marker.symbol).\n         *\n         * @type       {string}\n         * @default    callout\n         * @since      4.0\n         * @validvalue [\"callout\", \"square\"]\n         * @apioption  tooltip.shape\n         */\n\n        /**\n         * When the tooltip is shared, the entire plot area will capture mouse\n         * movement or touch events. Tooltip texts for series types with ordered\n         * data (not pie, scatter, flags etc) will be shown in a single bubble.\n         * This is recommended for single series charts and for tablet/mobile\n         * optimized charts.\n         *\n         * See also [tooltip.split](#tooltip.split), that is better suited for\n         * charts with many series, especially line-type series. The\n         * `tooltip.split` option takes precedence over `tooltip.shared`.\n         *\n         * @sample {highcharts} highcharts/tooltip/shared-false/\n         *         False by default\n         * @sample {highcharts} highcharts/tooltip/shared-true/\n         *         True\n         * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/\n         *         True with x axis crosshair\n         * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/\n         *         True with mixed series types\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.1\n         * @product   highcharts highstock\n         * @apioption tooltip.shared\n         */\n\n        /**\n         * Split the tooltip into one label per series, with the header close\n         * to the axis. This is recommended over [shared](#tooltip.shared)\n         * tooltips for charts with multiple line series, generally making them\n         * easier to read. This option takes precedence over `tooltip.shared`.\n         *\n         * @productdesc {highstock} In Highstock, tooltips are split by default\n         * since v6.0.0. Stock charts typically contain multi-dimension points\n         * and multiple panes, making split tooltips the preferred layout over\n         * the previous `shared` tooltip.\n         *\n         * @sample highcharts/tooltip/split/\n         *         Split tooltip\n         *\n         * @type      {boolean}\n         * @default   {highcharts} false\n         * @default   {highstock} true\n         * @since     5.0.0\n         * @product   highcharts highstock\n         * @apioption tooltip.split\n         */\n\n        /**\n         * Use HTML to render the contents of the tooltip instead of SVG. Using\n         * HTML allows advanced formatting like tables and images in the\n         * tooltip. It is also recommended for rtl languages as it works around\n         * rtl bugs in early Firefox.\n         *\n         * @sample {highcharts|highstock} highcharts/tooltip/footerformat/\n         *         A table for value alignment\n         * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/\n         *         Full HTML tooltip\n         * @sample {highmaps} maps/tooltip/usehtml/\n         *         Pure HTML tooltip\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     2.2\n         * @apioption tooltip.useHTML\n         */\n\n        /**\n         * How many decimals to show in each series' y value. This is\n         * overridable in each series' tooltip options object. The default is to\n         * preserve all decimals.\n         *\n         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         * @sample {highmaps} maps/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         *\n         * @type      {number}\n         * @since     2.2\n         * @apioption tooltip.valueDecimals\n         */\n\n        /**\n         * A string to prepend to each series' y value. Overridable in each\n         * series' tooltip options object.\n         *\n         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         * @sample {highmaps} maps/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         *\n         * @type      {string}\n         * @since     2.2\n         * @apioption tooltip.valuePrefix\n         */\n\n        /**\n         * A string to append to each series' y value. Overridable in each\n         * series' tooltip options object.\n         *\n         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         * @sample {highmaps} maps/tooltip/valuedecimals/\n         *         Set decimals, prefix and suffix for the value\n         *\n         * @type      {string}\n         * @since     2.2\n         * @apioption tooltip.valueSuffix\n         */\n\n        /**\n         * The format for the date in the tooltip header if the X axis is a\n         * datetime axis. The default is a best guess based on the smallest\n         * distance between points in the chart.\n         *\n         * @sample {highcharts} highcharts/tooltip/xdateformat/\n         *         A different format\n         *\n         * @type      {string}\n         * @product   highcharts highstock\n         * @apioption tooltip.xDateFormat\n         */\n\n        /**\n         * How many decimals to show for the `point.change` value when the\n         * `series.compare` option is set. This is overridable in each series'\n         * tooltip options object. The default is to preserve all decimals.\n         *\n         * @type      {number}\n         * @since     1.0.1\n         * @product   highstock\n         * @apioption tooltip.changeDecimals\n         */\n\n        /**\n         * Enable or disable the tooltip.\n         *\n         * @sample {highcharts} highcharts/tooltip/enabled/\n         *         Disabled\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n         *         Disable tooltip and show values on chart instead\n         */\n        enabled: true,\n\n        /**\n         * Enable or disable animation of the tooltip.\n         *\n         * @type       {boolean}\n         * @default    true\n         * @since      2.3.0\n         */\n        animation: svg,\n\n        /**\n         * The radius of the rounded border corners.\n         *\n         * @sample {highcharts} highcharts/tooltip/bordercolor-default/\n         *         5px by default\n         * @sample {highcharts} highcharts/tooltip/borderradius-0/\n         *         Square borders\n         * @sample {highmaps} maps/tooltip/background-border/\n         *         Background and border demo\n         */\n        borderRadius: 3,\n\n        /**\n         * For series on a datetime axes, the date format in the tooltip's\n         * header will by default be guessed based on the closest data points.\n         * This member gives the default string representations used for\n         * each unit. For an overview of the replacement codes, see\n         * [dateFormat](/class-reference/Highcharts#dateFormat).\n         *\n         * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)\n         *\n         * @type    {Highcharts.Dictionary<string>}\n         * @product highcharts highstock\n         */\n        dateTimeLabelFormats: {\n            millisecond: '%A, %b %e, %H:%M:%S.%L',\n            second: '%A, %b %e, %H:%M:%S',\n            minute: '%A, %b %e, %H:%M',\n            hour: '%A, %b %e, %H:%M',\n            day: '%A, %b %e, %Y',\n            week: 'Week from %A, %b %e, %Y',\n            month: '%B %Y',\n            year: '%Y'\n        },\n\n        /**\n         * A string to append to the tooltip format.\n         *\n         * @sample {highcharts} highcharts/tooltip/footerformat/\n         *         A table for value alignment\n         * @sample {highmaps} maps/tooltip/format/\n         *         Format demo\n         *\n         * @since 2.2\n         */\n        footerFormat: '',\n\n        /**\n         * Padding inside the tooltip, in pixels.\n         *\n         * @since      5.0.0\n         */\n        padding: 8,\n\n        /**\n         * Proximity snap for graphs or single points. It defaults to 10 for\n         * mouse-powered devices and 25 for touch devices.\n         *\n         * Note that in most cases the whole plot area captures the mouse\n         * movement, and in these cases `tooltip.snap` doesn't make sense. This\n         * applies when [stickyTracking](#plotOptions.series.stickyTracking)\n         * is `true` (default) and when the tooltip is [shared](#tooltip.shared)\n         * or [split](#tooltip.split).\n         *\n         * @sample {highcharts} highcharts/tooltip/bordercolor-default/\n         *         10 px by default\n         * @sample {highcharts} highcharts/tooltip/snap-50/\n         *         50 px on graph\n         *\n         * @type    {number}\n         * @default 10/25\n         * @since   1.2.0\n         * @product highcharts highstock\n         */\n        snap: isTouchDevice ? 25 : 10,\n\n        \n\n        headerFormat: '<span class=\"highcharts-header\">{point.key}</span><br/>',\n\n        pointFormat: '<span class=\"highcharts-color-{point.colorIndex}\">' +\n            '\\u25CF</span> {series.name}: <span class=\"highcharts-strong\">' +\n            '{point.y}</span><br/>'\n\n        \n    },\n\n\n    /**\n     * Highchart by default puts a credits label in the lower right corner\n     * of the chart. This can be changed using these options.\n     */\n    credits: {\n\n        /**\n         * Credits for map source to be concatenated with conventional credit\n         * text. By default this is a format string that collects copyright\n         * information from the map if available.\n         *\n         * @see [mapTextFull](#credits.mapTextFull)\n         * @see [text](#credits.text)\n         *\n         * @type      {string}\n         * @default   \\u00a9 <a href=\"{geojson.copyrightUrl}\">{geojson.copyrightShort}</a>\n         * @since     4.2.2\n         * @product   highmaps\n         * @apioption credits.mapText\n         */\n\n        /**\n         * Detailed credits for map source to be displayed on hover of credits\n         * text. By default this is a format string that collects copyright\n         * information from the map if available.\n         *\n         * @see [mapText](#credits.mapText)\n         * @see [text](#credits.text)\n         *\n         * @type      {string}\n         * @default   {geojson.copyright}\n         * @since     4.2.2\n         * @product   highmaps\n         * @apioption credits.mapTextFull\n         */\n\n        /**\n         * Whether to show the credits text.\n         *\n         * @sample {highcharts} highcharts/credits/enabled-false/\n         *         Credits disabled\n         * @sample {highstock} stock/credits/enabled/\n         *         Credits disabled\n         * @sample {highmaps} maps/credits/enabled-false/\n         *         Credits disabled\n         */\n        enabled: true,\n\n        /**\n         * The URL for the credits label.\n         *\n         * @sample {highcharts} highcharts/credits/href/\n         *         Custom URL and text\n         * @sample {highmaps} maps/credits/customized/\n         *         Custom URL and text\n         */\n        href: 'https://www.highcharts.com',\n\n        /**\n         * Position configuration for the credits label.\n         *\n         * @sample {highcharts} highcharts/credits/position-left/\n         *         Left aligned\n         * @sample {highcharts} highcharts/credits/position-left/\n         *         Left aligned\n         * @sample {highmaps} maps/credits/customized/\n         *         Left aligned\n         * @sample {highmaps} maps/credits/customized/\n         *         Left aligned\n         *\n         * @since 2.1\n         */\n        position: {\n\n            /**\n             * Horizontal alignment of the credits.\n             *\n             * @validvalue [\"left\", \"center\", \"right\"]\n             */\n            align: 'right',\n\n            /**\n             * Horizontal pixel offset of the credits.\n             */\n            x: -10,\n\n            /**\n             * Vertical alignment of the credits.\n             *\n             * @validvalue [\"top\", \"middle\", \"bottom\"]\n             */\n            verticalAlign: 'bottom',\n\n            /**\n             * Vertical pixel offset of the credits.\n             */\n            y: -5\n\n        },\n\n        \n\n        /**\n         * The text for the credits label.\n         *\n         * @productdesc {highmaps}\n         * If a map is loaded as GeoJSON, the text defaults to\n         * `Highcharts @ {map-credits}`. Otherwise, it defaults to\n         * `Highcharts.com`.\n         *\n         * @sample {highcharts} highcharts/credits/href/\n         *         Custom URL and text\n         * @sample {highmaps} maps/credits/customized/\n         *         Custom URL and text\n         */\n        text: 'Highcharts.com'\n\n    }\n};\n\n/**\n * Merge the default options with custom options and return the new options\n * structure. Commonly used for defining reusable templates.\n *\n * @sample highcharts/global/useutc-false Setting a global option\n * @sample highcharts/members/setoptions Applying a global theme\n *\n * @function Highcharts.setOptions\n *\n * @param {Highcharts.Options} options\n *        The new custom chart options.\n *\n * @return {Highcharts.Options}\n *         Updated options.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setOptions = function (options) {\n\n    // Copy in the default options\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions = merge(true, _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions, options);\n\n    // Update the time object\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time.update(\n        merge(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.global, _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.time),\n        false\n    );\n\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions;\n};\n\n/**\n * Get the updated default options. Until 3.0.7, merely exposing defaultOptions\n * for outside modules wasn't enough because the setOptions method created a new\n * object.\n *\n * @function Highcharts.getOptions\n *\n * @return {Highcharts.Options}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getOptions = function () {\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions;\n};\n\n\n// Series defaults\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.plotOptions;\n\n\n/**\n * Global `Time` object with default options. Since v6.0.5, time settings can be\n * applied individually for each chart. If no individual settings apply, this\n * `Time` object is shared by all instances.\n *\n * @name Highcharts.time\n * @type {Highcharts.Time}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Time(merge(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.global, _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.time));\n\n/**\n * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a\n * human readable date string. The format is a subset of the formats for PHP's\n * [strftime]{@link\n * http://www.php.net/manual/en/function.strftime.php} function. Additional\n * formats can be given in the {@link Highcharts.dateFormats} hook.\n *\n * Since v6.0.5, all internal dates are formatted through the\n * [Chart.time](Chart#time) instance to respect chart-level time settings. The\n * `Highcharts.dateFormat` function only reflects global time settings set with\n * `setOptions`.\n *\n * @function Highcharts.dateFormat\n *\n * @param {string} format\n *        The desired format where various time representations are prefixed\n *        with `%`.\n *\n * @param {number} timestamp\n *        The JavaScript timestamp.\n *\n * @param {boolean} [capitalize=false]\n *        Upper case first letter in the return.\n *\n * @return {string}\n *         The formatted date.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dateFormat = function (format, timestamp, capitalize) {\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time.dateFormat(format, timestamp, capitalize);\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Options.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/OrdinalAxis.js":
/*!********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/OrdinalAxis.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n/* eslint max-len: 0 */\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    timeUnits = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timeUnits,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n/* ****************************************************************************\n * Start ordinal axis logic                                                   *\n *****************************************************************************/\n\n\nwrap(Series.prototype, 'init', function (proceed) {\n    var series = this,\n        xAxis;\n\n    // call the original function\n    proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n    xAxis = series.xAxis;\n\n    // Destroy the extended ordinal index on updated data\n    if (xAxis && xAxis.options.ordinal) {\n        addEvent(series, 'updatedData', function () {\n            delete xAxis.ordinalIndex;\n        });\n    }\n});\n\n/**\n * In an ordinal axis, there might be areas with dense consentrations of points, then large\n * gaps between some. Creating equally distributed ticks over this entire range\n * may lead to a huge number of ticks that will later be removed. So instead, break the\n * positions up in segments, find the tick positions for each segment then concatenize them.\n * This method is used from both data grouping logic and X axis tick position logic.\n */\nwrap(Axis.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {\n\n    var start = 0,\n        end,\n        segmentPositions,\n        higherRanks = {},\n        hasCrossedHigherRank,\n        info,\n        posLength,\n        outsideMax,\n        groupPositions = [],\n        lastGroupPosition = -Number.MAX_VALUE,\n        tickPixelIntervalOption = this.options.tickPixelInterval,\n        time = this.chart.time;\n\n    // The positions are not always defined, for example for ordinal positions\n    // when data has regular interval (#1557, #2090)\n    if (\n        (!this.options.ordinal && !this.options.breaks) ||\n        !positions ||\n        positions.length < 3 ||\n        min === undefined\n    ) {\n        return proceed.call(this, normalizedInterval, min, max, startOfWeek);\n    }\n\n    // Analyze the positions array to split it into segments on gaps larger than 5 times\n    // the closest distance. The closest distance is already found at this point, so\n    // we reuse that instead of computing it again.\n    posLength = positions.length;\n\n    for (end = 0; end < posLength; end++) {\n\n        outsideMax = end && positions[end - 1] > max;\n\n        if (positions[end] < min) { // Set the last position before min\n            start = end;\n        }\n\n        if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {\n\n            // For each segment, calculate the tick positions from the getTimeTicks utility\n            // function. The interval will be the same regardless of how long the segment is.\n            if (positions[end] > lastGroupPosition) { // #1475\n\n                segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);\n\n                // Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)\n                while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {\n                    segmentPositions.shift();\n                }\n                if (segmentPositions.length) {\n                    lastGroupPosition = segmentPositions[segmentPositions.length - 1];\n                }\n\n                groupPositions = groupPositions.concat(segmentPositions);\n            }\n            // Set start of next segment\n            start = end + 1;\n        }\n\n        if (outsideMax) {\n            break;\n        }\n    }\n\n    // Get the grouping info from the last of the segments. The info is the same for\n    // all segments.\n    info = segmentPositions.info;\n\n    // Optionally identify ticks with higher rank, for example when the ticks\n    // have crossed midnight.\n    if (findHigherRanks && info.unitRange <= timeUnits.hour) {\n        end = groupPositions.length - 1;\n\n        // Compare points two by two\n        for (start = 1; start < end; start++) {\n            if (\n                time.dateFormat('%d', groupPositions[start]) !==\n                time.dateFormat('%d', groupPositions[start - 1])\n            ) {\n                higherRanks[groupPositions[start]] = 'day';\n                hasCrossedHigherRank = true;\n            }\n        }\n\n        // If the complete array has crossed midnight, we want to mark the first\n        // positions also as higher rank\n        if (hasCrossedHigherRank) {\n            higherRanks[groupPositions[0]] = 'day';\n        }\n        info.higherRanks = higherRanks;\n    }\n\n    // Save the info\n    groupPositions.info = info;\n\n\n\n    // Don't show ticks within a gap in the ordinal axis, where the space between\n    // two points is greater than a portion of the tick pixel interval\n    if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks\n\n        var length = groupPositions.length,\n            i = length,\n            itemToRemove,\n            translated,\n            translatedArr = [],\n            lastTranslated,\n            medianDistance,\n            distance,\n            distances = [];\n\n        // Find median pixel distance in order to keep a reasonably even distance between\n        // ticks (#748)\n        while (i--) {\n            translated = this.translate(groupPositions[i]);\n            if (lastTranslated) {\n                distances[i] = lastTranslated - translated;\n            }\n            translatedArr[i] = lastTranslated = translated;\n        }\n        distances.sort();\n        medianDistance = distances[Math.floor(distances.length / 2)];\n        if (medianDistance < tickPixelIntervalOption * 0.6) {\n            medianDistance = null;\n        }\n\n        // Now loop over again and remove ticks where needed\n        i = groupPositions[length - 1] > max ? length - 1 : length; // #817\n        lastTranslated = undefined;\n        while (i--) {\n            translated = translatedArr[i];\n            distance = Math.abs(lastTranslated - translated);\n            // #4175 - when axis is reversed, the distance, is negative but\n            // tickPixelIntervalOption positive, so we need to compare the same values\n\n            // Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,\n            // but not if it is close to the median distance (#748).\n            if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&\n                    (medianDistance === null || distance < medianDistance * 0.8)) {\n\n                // Is this a higher ranked position with a normal position to the right?\n                if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {\n\n                    // Yes: remove the lower ranked neighbour to the right\n                    itemToRemove = i + 1;\n                    lastTranslated = translated; // #709\n\n                } else {\n\n                    // No: remove this one\n                    itemToRemove = i;\n                }\n\n                groupPositions.splice(itemToRemove, 1);\n\n            } else {\n                lastTranslated = translated;\n            }\n        }\n    }\n    return groupPositions;\n});\n\n// Extend the Axis prototype\nextend(Axis.prototype, /** @lends Axis.prototype */ {\n\n    /**\n     * Calculate the ordinal positions before tick positions are calculated.\n     */\n    beforeSetTickPositions: function () {\n        var axis = this,\n            len,\n            ordinalPositions = [],\n            uniqueOrdinalPositions,\n            useOrdinal = false,\n            dist,\n            extremes = axis.getExtremes(),\n            min = extremes.min,\n            max = extremes.max,\n            minIndex,\n            maxIndex,\n            slope,\n            hasBreaks = axis.isXAxis && !!axis.options.breaks,\n            isOrdinal = axis.options.ordinal,\n            overscrollPointsRange = Number.MAX_VALUE,\n            ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,\n            isNavigatorAxis = axis.options.className === 'highcharts-navigator-xaxis',\n            i,\n            hasBoostedSeries;\n\n        if (\n            axis.options.overscroll &&\n            axis.max === axis.dataMax &&\n            (\n                // Panning is an execption,\n                // We don't want to apply overscroll when panning over the dataMax\n                !axis.chart.mouseIsDown ||\n                isNavigatorAxis\n            ) && (\n                // Scrollbar buttons are the other execption:\n                !axis.eventArgs ||\n                axis.eventArgs && axis.eventArgs.trigger !== 'navigator'\n            )\n        ) {\n            axis.max += axis.options.overscroll;\n\n            // Live data and buttons require translation for the min:\n            if (!isNavigatorAxis && defined(axis.userMin)) {\n                axis.min += axis.options.overscroll;\n            }\n        }\n\n        // Apply the ordinal logic\n        if (isOrdinal || hasBreaks) { // #4167 YAxis is never ordinal ?\n\n            each(axis.series, function (series, i) {\n                uniqueOrdinalPositions = [];\n\n                if (\n                    (!ignoreHiddenSeries || series.visible !== false) &&\n                    (series.takeOrdinalPosition !== false || hasBreaks)\n                ) {\n\n                    // concatenate the processed X data into the existing positions, or the empty array\n                    ordinalPositions = ordinalPositions.concat(series.processedXData);\n                    len = ordinalPositions.length;\n\n                    // remove duplicates (#1588)\n                    ordinalPositions.sort(function (a, b) {\n                        return a - b; // without a custom function it is sorted as strings\n                    });\n\n                    overscrollPointsRange = Math.min(\n                        overscrollPointsRange,\n                        pick(\n                            // Check for a single-point series:\n                            series.closestPointRange,\n                            overscrollPointsRange\n                        )\n                    );\n\n                    if (len) {\n\n                        i = 0;\n                        while (i < len - 1) {\n                            if (\n                                ordinalPositions[i] !== ordinalPositions[i + 1]\n                            ) {\n                                uniqueOrdinalPositions.push(\n                                    ordinalPositions[i + 1]\n                                );\n                            }\n                            i++;\n                        }\n\n                        // Check first item:\n                        if (\n                            uniqueOrdinalPositions[0] !== ordinalPositions[0]\n                        ) {\n                            uniqueOrdinalPositions.unshift(\n                                ordinalPositions[0]\n                            );\n                        }\n\n                        ordinalPositions = uniqueOrdinalPositions;\n                    }\n                }\n\n                if (series.isSeriesBoosting) {\n                    hasBoostedSeries = true;\n                }\n\n            });\n\n            if (hasBoostedSeries) {\n                ordinalPositions.length = 0;\n            }\n\n            // cache the length\n            len = ordinalPositions.length;\n\n            // Check if we really need the overhead of mapping axis data against the ordinal positions.\n            // If the series consist of evenly spaced data any way, we don't need any ordinal logic.\n            if (len > 2) { // two points have equal distance by default\n                dist = ordinalPositions[1] - ordinalPositions[0];\n                i = len - 1;\n                while (i-- && !useOrdinal) {\n                    if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {\n                        useOrdinal = true;\n                    }\n                }\n\n                // When zooming in on a week, prevent axis padding for weekends even though the data within\n                // the week is evenly spaced.\n                if (\n                    !axis.options.keepOrdinalPadding &&\n                    (\n                        ordinalPositions[0] - min > dist ||\n                        max - ordinalPositions[ordinalPositions.length - 1] > dist\n                    )\n                ) {\n                    useOrdinal = true;\n                }\n            } else if (axis.options.overscroll) {\n                if (len === 2) {\n                    // Exactly two points, distance for overscroll is fixed:\n                    overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];\n                } else if (len === 1) {\n                    // We have just one point, closest distance is unknown.\n                    // Assume then it is last point and overscrolled range:\n                    overscrollPointsRange = axis.options.overscroll;\n                    ordinalPositions = [ordinalPositions[0], ordinalPositions[0] + overscrollPointsRange];\n                } else {\n                    // In case of zooming in on overscrolled range, stick to the old range:\n                    overscrollPointsRange = axis.overscrollPointsRange;\n                }\n            }\n\n            // Record the slope and offset to compute the linear values from the array index.\n            // Since the ordinal positions may exceed the current range, get the start and\n            // end positions within it (#719, #665b)\n            if (useOrdinal) {\n\n                if (axis.options.overscroll) {\n                    axis.overscrollPointsRange = overscrollPointsRange;\n                    ordinalPositions = ordinalPositions.concat(axis.getOverscrollPositions());\n                }\n\n                // Register\n                axis.ordinalPositions = ordinalPositions;\n\n                // This relies on the ordinalPositions being set. Use Math.max\n                // and Math.min to prevent padding on either sides of the data.\n                minIndex = axis.ordinal2lin( // #5979\n                    Math.max(\n                        min,\n                        ordinalPositions[0]\n                    ),\n                    true\n                );\n                maxIndex = Math.max(axis.ordinal2lin(\n                    Math.min(\n                        max,\n                        ordinalPositions[ordinalPositions.length - 1]\n                    ),\n                    true\n                ), 1); // #3339\n\n                // Set the slope and offset of the values compared to the indices in the ordinal positions\n                axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);\n                axis.ordinalOffset = min - (minIndex * slope);\n\n            } else {\n                axis.overscrollPointsRange = pick(axis.closestPointRange, axis.overscrollPointsRange);\n                axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = undefined;\n            }\n        }\n\n        axis.isOrdinal = isOrdinal && useOrdinal; // #3818, #4196, #4926\n        axis.groupIntervalFactor = null; // reset for next run\n    },\n    /**\n     * Translate from a linear axis value to the corresponding ordinal axis position. If there\n     * are no gaps in the ordinal axis this will be the same. The translated value is the value\n     * that the point would have if the axis were linear, using the same min and max.\n     *\n     * @param Number val The axis value\n     * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value\n     */\n    val2lin: function (val, toIndex) {\n        var axis = this,\n            ordinalPositions = axis.ordinalPositions,\n            ret;\n\n        if (!ordinalPositions) {\n            ret = val;\n\n        } else {\n\n            var ordinalLength = ordinalPositions.length,\n                i,\n                distance,\n                ordinalIndex;\n\n            // first look for an exact match in the ordinalpositions array\n            i = ordinalLength;\n            while (i--) {\n                if (ordinalPositions[i] === val) {\n                    ordinalIndex = i;\n                    break;\n                }\n            }\n\n            // if that failed, find the intermediate position between the two nearest values\n            i = ordinalLength - 1;\n            while (i--) {\n                if (val > ordinalPositions[i] || i === 0) { // interpolate\n                    distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1\n                    ordinalIndex = i + distance;\n                    break;\n                }\n            }\n            ret = toIndex ?\n                ordinalIndex :\n                axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;\n        }\n        return ret;\n    },\n    /**\n     * Translate from linear (internal) to axis value\n     *\n     * @param Number val The linear abstracted value\n     * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value\n     */\n    lin2val: function (val, fromIndex) {\n        var axis = this,\n            ordinalPositions = axis.ordinalPositions,\n            ret;\n\n        if (!ordinalPositions) { // the visible range contains only equally spaced values\n            ret = val;\n\n        } else {\n\n            var ordinalSlope = axis.ordinalSlope,\n                ordinalOffset = axis.ordinalOffset,\n                i = ordinalPositions.length - 1,\n                linearEquivalentLeft,\n                linearEquivalentRight,\n                distance;\n\n\n            // Handle the case where we translate from the index directly, used only\n            // when panning an ordinal axis\n            if (fromIndex) {\n\n                if (val < 0) { // out of range, in effect panning to the left\n                    val = ordinalPositions[0];\n                } else if (val > i) { // out of range, panning to the right\n                    val = ordinalPositions[i];\n                } else { // split it up\n                    i = Math.floor(val);\n                    distance = val - i; // the decimal\n                }\n\n            // Loop down along the ordinal positions. When the linear equivalent of i matches\n            // an ordinal position, interpolate between the left and right values.\n            } else {\n                while (i--) {\n                    linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;\n                    if (val >= linearEquivalentLeft) {\n                        linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;\n                        distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1\n                        break;\n                    }\n                }\n            }\n\n            // If the index is within the range of the ordinal positions, return the associated\n            // or interpolated value. If not, just return the value\n            return distance !== undefined && ordinalPositions[i] !== undefined ?\n                ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :\n                val;\n        }\n        return ret;\n    },\n    /**\n     * Get the ordinal positions for the entire data set. This is necessary in chart panning\n     * because we need to find out what points or data groups are available outside the\n     * visible range. When a panning operation starts, if an index for the given grouping\n     * does not exists, it is created and cached. This index is deleted on updated data, so\n     * it will be regenerated the next time a panning operation starts.\n     */\n    getExtendedPositions: function () {\n        var axis = this,\n            chart = axis.chart,\n            grouping = axis.series[0].currentDataGrouping,\n            ordinalIndex = axis.ordinalIndex,\n            key = grouping ? grouping.count + grouping.unitName : 'raw',\n            overscroll = axis.options.overscroll,\n            extremes = axis.getExtremes(),\n            fakeAxis,\n            fakeSeries;\n\n        // If this is the first time, or the ordinal index is deleted by updatedData,\n        // create it.\n        if (!ordinalIndex) {\n            ordinalIndex = axis.ordinalIndex = {};\n        }\n\n\n        if (!ordinalIndex[key]) {\n\n            // Create a fake axis object where the extended ordinal positions are emulated\n            fakeAxis = {\n                series: [],\n                chart: chart,\n                getExtremes: function () {\n                    return {\n                        min: extremes.dataMin,\n                        max: extremes.dataMax + overscroll\n                    };\n                },\n                options: {\n                    ordinal: true\n                },\n                val2lin: Axis.prototype.val2lin, // #2590\n                ordinal2lin: Axis.prototype.ordinal2lin // #6276\n            };\n\n            // Add the fake series to hold the full data, then apply processData to it\n            each(axis.series, function (series) {\n                fakeSeries = {\n                    xAxis: fakeAxis,\n                    xData: series.xData.slice(),\n                    chart: chart,\n                    destroyGroupedData: noop\n                };\n\n                fakeSeries.xData = fakeSeries.xData.concat(axis.getOverscrollPositions());\n\n                fakeSeries.options = {\n                    dataGrouping: grouping ? {\n                        enabled: true,\n                        forced: true,\n                        approximation: 'open', // doesn't matter which, use the fastest\n                        units: [[grouping.unitName, [grouping.count]]]\n                    } : {\n                        enabled: false\n                    }\n                };\n                series.processData.apply(fakeSeries);\n\n\n                fakeAxis.series.push(fakeSeries);\n            });\n\n            // Run beforeSetTickPositions to compute the ordinalPositions\n            axis.beforeSetTickPositions.apply(fakeAxis);\n\n            // Cache it\n            ordinalIndex[key] = fakeAxis.ordinalPositions;\n        }\n        return ordinalIndex[key];\n    },\n\n    /**\n     * Get ticks for an ordinal axis within a range where points don't exist.\n     * It is required when overscroll is enabled. We can't base on points,\n     * because we may not have any, so we use approximated pointRange and\n     * generate these ticks between <Axis.dataMax, Axis.dataMax + Axis.overscroll>\n     * evenly spaced. Used in panning and navigator scrolling.\n     *\n     * @returns positions {Array} Generated ticks\n     * @private\n     */\n    getOverscrollPositions: function () {\n        var axis = this,\n            extraRange = axis.options.overscroll,\n            distance = axis.overscrollPointsRange,\n            positions = [],\n            max = axis.dataMax;\n\n        if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(distance)) {\n            // Max + pointRange because we need to scroll to the last\n\n            positions.push(max);\n\n            while (max <= axis.dataMax + extraRange) {\n                max += distance;\n                positions.push(max);\n            }\n\n        }\n\n        return positions;\n    },\n\n    /**\n     * Find the factor to estimate how wide the plot area would have been if ordinal\n     * gaps were included. This value is used to compute an imagined plot width in order\n     * to establish the data grouping interval.\n     *\n     * A real world case is the intraday-candlestick\n     * example. Without this logic, it would show the correct data grouping when viewing\n     * a range within each day, but once moving the range to include the gap between two\n     * days, the interval would include the cut-away night hours and the data grouping\n     * would be wrong. So the below method tries to compensate by identifying the most\n     * common point interval, in this case days.\n     *\n     * An opposite case is presented in issue #718. We have a long array of daily data,\n     * then one point is appended one hour after the last point. We expect the data grouping\n     * not to change.\n     *\n     * In the future, if we find cases where this estimation doesn't work optimally, we\n     * might need to add a second pass to the data grouping logic, where we do another run\n     * with a greater interval if the number of data groups is more than a certain fraction\n     * of the desired group count.\n     */\n    getGroupIntervalFactor: function (xMin, xMax, series) {\n        var i,\n            processedXData = series.processedXData,\n            len = processedXData.length,\n            distances = [],\n            median,\n            groupIntervalFactor = this.groupIntervalFactor;\n\n        // Only do this computation for the first series, let the other inherit it (#2416)\n        if (!groupIntervalFactor) {\n\n            // Register all the distances in an array\n            for (i = 0; i < len - 1; i++) {\n                distances[i] = processedXData[i + 1] - processedXData[i];\n            }\n\n            // Sort them and find the median\n            distances.sort(function (a, b) {\n                return a - b;\n            });\n            median = distances[Math.floor(len / 2)];\n\n            // Compensate for series that don't extend through the entire axis extent. #1675.\n            xMin = Math.max(xMin, processedXData[0]);\n            xMax = Math.min(xMax, processedXData[len - 1]);\n\n            this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);\n        }\n\n        // Return the factor needed for data grouping\n        return groupIntervalFactor;\n    },\n\n    /**\n     * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster\n     */\n    postProcessTickInterval: function (tickInterval) {\n        // Problem: https://jsfiddle.net/highcharts/FQm4E/1/\n        // This is a case where this algorithm doesn't work optimally. In this case, the\n        // tick labels are spread out per week, but all the gaps reside within weeks. So\n        // we have a situation where the labels are courser than the ordinal gaps, and\n        // thus the tick interval should not be altered\n        var ordinalSlope = this.ordinalSlope,\n            ret;\n\n\n        if (ordinalSlope) {\n            if (!this.options.breaks) {\n                ret = tickInterval / (ordinalSlope / this.closestPointRange);\n            } else {\n                ret = this.closestPointRange || tickInterval; // #7275\n            }\n        } else {\n            ret = tickInterval;\n        }\n        return ret;\n    }\n});\n\n// Record this to prevent overwriting by broken-axis module (#5979)\nAxis.prototype.ordinal2lin = Axis.prototype.val2lin;\n\n// Extending the Chart.pan method for ordinal axes\nwrap(Chart.prototype, 'pan', function (proceed, e) {\n    var chart = this,\n        xAxis = chart.xAxis[0],\n        overscroll = xAxis.options.overscroll,\n        chartX = e.chartX,\n        runBase = false;\n\n    if (xAxis.options.ordinal && xAxis.series.length) {\n\n        var mouseDownX = chart.mouseDownX,\n            extremes = xAxis.getExtremes(),\n            dataMax = extremes.dataMax,\n            min = extremes.min,\n            max = extremes.max,\n            trimmedRange,\n            hoverPoints = chart.hoverPoints,\n            closestPointRange = xAxis.closestPointRange || xAxis.overscrollPointsRange,\n            pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),\n            movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?\n            extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points\n            ordinalPositions,\n            searchAxisLeft,\n            lin2val = xAxis.lin2val,\n            val2lin = xAxis.val2lin,\n            searchAxisRight;\n\n        if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced\n            runBase = true;\n\n        } else if (Math.abs(movedUnits) > 1) {\n\n            // Remove active points for shared tooltip\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            if (movedUnits < 0) {\n                searchAxisLeft = extendedAxis;\n                searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;\n            } else {\n                searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;\n                searchAxisRight = extendedAxis;\n            }\n\n            // In grouped data series, the last ordinal position represents the grouped data, which is\n            // to the left of the real data max. If we don't compensate for this, we will be allowed\n            // to pan grouped data series passed the right of the plot area.\n            ordinalPositions = searchAxisRight.ordinalPositions;\n            if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {\n                ordinalPositions.push(dataMax);\n            }\n\n            // Get the new min and max values by getting the ordinal index for the current extreme,\n            // then add the moved units and translate back to values. This happens on the\n            // extended ordinal positions if the new position is out of range, else it happens\n            // on the current x axis which is smaller and faster.\n            chart.fixedRange = max - min;\n            trimmedRange = xAxis.toFixedRange(null, null,\n                lin2val.apply(searchAxisLeft, [\n                    val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index\n                    true // translate from index\n                ]),\n                lin2val.apply(searchAxisRight, [\n                    val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index\n                    true // translate from index\n                ])\n            );\n\n            // Apply it if it is within the available data range\n            if (\n                trimmedRange.min >= Math.min(extremes.dataMin, min) &&\n                trimmedRange.max <= Math.max(dataMax, max) + overscroll\n            ) {\n                xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: 'pan' });\n            }\n\n            chart.mouseDownX = chartX; // set new reference for next run\n            css(chart.container, { cursor: 'move' });\n        }\n\n    } else {\n        runBase = true;\n    }\n\n    // revert to the linear chart.pan version\n    if (runBase) {\n        if (overscroll) {\n            xAxis.max = xAxis.dataMax + overscroll;\n        }\n        // call the original function\n        proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n});\n\n/* ****************************************************************************\n * End ordinal axis logic                                                   *\n *****************************************************************************/\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/OrdinalAxis.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/PieSeries.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/PieSeries.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _ColumnSeries_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColumnSeries.js */ \"./node_modules/highcharts/js/es-modules/parts/ColumnSeries.js\");\n/* harmony import */ var _mixins_centered_series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixins/centered-series.js */ \"./node_modules/highcharts/js/es-modules/mixins/centered-series.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    CenteredSeriesMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CenteredSeriesMixin,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    getStartAndEndRadians = CenteredSeriesMixin.getStartAndEndRadians,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    LegendSymbolMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType,\n    seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes,\n    setAnimation = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setAnimation;\n\n/**\n * The pie series type.\n *\n * @constructor seriesTypes.pie\n * @augments Series\n */\n\n/**\n * A pie chart is a circular graphic which is divided into slices to illustrate\n * numerical proportion.\n *\n * @sample highcharts/demo/pie-basic/ Pie chart\n *\n * @extends plotOptions.line\n * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,\n *          cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,\n *          lineWidth,marker,negativeColor,pointInterval,pointIntervalUnit,\n *          pointPlacement,pointStart,softThreshold,stacking,step,threshold,\n *          turboThreshold,zoneAxis,zones\n * @product highcharts\n * @optionparent plotOptions.pie\n */\nseriesType('pie', 'line', {\n\n    /**\n     * The center of the pie chart relative to the plot area. Can be percentages\n     * or pixel values. The default behaviour (as of 3.0) is to center\n     * the pie so that all slices and data labels are within the plot area.\n     * As a consequence, the pie may actually jump around in a chart with\n     * dynamic values, as the data labels move. In that case, the center\n     * should be explicitly set, for example to `[\"50%\", \"50%\"]`.\n     *\n     * @type {Array<String|Number>}\n     * @sample {highcharts} highcharts/plotoptions/pie-center/\n     *         Centered at 100, 100\n     * @default [null, null]\n     * @product highcharts\n     */\n    center: [null, null],\n\n    clip: false,\n\n    /**\n     * @ignore\n     */\n    colorByPoint: true, // always true for pies\n\n    /**\n     * A series specific or series type specific color set to use instead\n     * of the global [colors](#colors).\n     *\n     * @type {Array<Color>}\n     * @sample {highcharts} highcharts/demo/pie-monochrome/\n     *         Set default colors for all pies\n     * @since 3.0\n     * @product highcharts\n     * @apioption plotOptions.pie.colors\n     */\n\n    /**\n     * @extends plotOptions.series.dataLabels\n     * @excluding align,allowOverlap,staggerLines,step\n     * @product highcharts\n     */\n    dataLabels: {\n        allowOverlap: true,\n        /**\n         * The color of the line connecting the data label to the pie slice.\n         * The default color is the same as the point's color.\n         *\n         * In styled mode, the connector stroke is given in the\n         * `.highcharts-data-label-connector` class.\n         *\n         * @type {String}\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-connectorcolor/\n         *         Blue connectors\n         * @sample {highcharts} highcharts/css/pie-point/ Styled connectors\n         * @default {point.color}\n         * @since 2.1\n         * @product highcharts\n         * @apioption plotOptions.pie.dataLabels.connectorColor\n         */\n\n        /**\n         * The distance from the data label to the connector.\n         *\n         * @type {Number}\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-connectorpadding/\n         *         No padding\n         * @default 5\n         * @since 2.1\n         * @product highcharts\n         * @apioption plotOptions.pie.dataLabels.connectorPadding\n         */\n\n        /**\n         * The width of the line connecting the data label to the pie slice.\n         *\n         *\n         * In styled mode, the connector stroke width is given in the\n         * `.highcharts-data-label-connector` class.\n         *\n         * @type {Number}\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/\n         *         Disable the connector\n         * @sample {highcharts}\n         *         highcharts/css/pie-point/\n         *         Styled connectors\n         * @default 1\n         * @since 2.1\n         * @product highcharts\n         * @apioption plotOptions.pie.dataLabels.connectorWidth\n         */\n\n        /**\n         *\n         * @sample {highcharts}\n         *         highcharts/plotOptions/pie-datalabels-overflow\n         *         Long labels truncated with an ellipsis\n         * @sample {highcharts}\n         *         highcharts/plotOptions/pie-datalabels-overflow-wrap\n         *         Long labels are wrapped\n         * @apioption plotOptions.pie.dataLabels.style\n         */\n\n        /**\n         * The distance of the data label from the pie's edge. Negative numbers\n         * put the data label on top of the pie slices. Connectors are only\n         * shown for data labels outside the pie.\n         *\n         * @type {Number}\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-distance/\n         *         Data labels on top of the pie\n         * @default 30\n         * @since 2.1\n         * @product highcharts\n         */\n        distance: 30,\n\n        /**\n         * Enable or disable the data labels.\n         *\n         * @type {Boolean}\n         * @since 2.1\n         * @product highcharts\n         */\n        enabled: true,\n\n        formatter: function () { // #2945\n            return this.point.isNull ? undefined : this.point.name;\n        },\n\n        /**\n         * Whether to render the connector as a soft arc or a line with sharp\n         * break.\n         *\n         * @type {Number}\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-softconnector-true/\n         *         Soft\n         * @sample {highcharts}\n         *         highcharts/plotoptions/pie-datalabels-softconnector-false/\n         *         Non soft\n         * @since 2.1.7\n         * @product highcharts\n         * @apioption plotOptions.pie.dataLabels.softConnector\n         */\n\n        x: 0\n    },\n\n    /**\n     * The end angle of the pie in degrees where 0 is top and 90 is right.\n     * Defaults to `startAngle` plus 360.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/demo/pie-semi-circle/ Semi-circle donut\n     * @default null\n     * @since 1.3.6\n     * @product highcharts\n     * @apioption plotOptions.pie.endAngle\n     */\n\n    /**\n     * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),\n     * this option tells whether the series shall be redrawn as if the\n     * hidden point were `null`.\n     *\n     * The default value changed from `false` to `true` with Highcharts\n     * 3.0.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/\n     *         True, the hiddden point is ignored\n     * @default true\n     * @since 2.3.0\n     * @product highcharts\n     */\n    ignoreHiddenPoint: true,\n\n    /**\n     * The size of the inner diameter for the pie. A size greater than 0\n     * renders a donut chart. Can be a percentage or pixel value. Percentages\n     * are relative to the pie size. Pixel values are given as integers.\n     *\n     *\n     * Note: in Highcharts < 4.1.2, the percentage was relative to the plot\n     * area, not the pie size.\n     *\n     * @type {String|Number}\n     * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/\n     *         80px inner size\n     * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/\n     *         50% of the plot area\n     * @sample {highcharts} highcharts/demo/3d-pie-donut/ 3D donut\n     * @default 0\n     * @since 2.0\n     * @product highcharts\n     * @apioption plotOptions.pie.innerSize\n     */\n\n    /**\n     * @ignore-option\n     */\n    legendType: 'point',\n\n    /**    @ignore */\n    marker: null, // point options are specified in the base options\n\n    /**\n     * The minimum size for a pie in response to auto margins. The pie will\n     * try to shrink to make room for data labels in side the plot area,\n     *  but only to this size.\n     *\n     * @type {Number}\n     * @default 80\n     * @since 3.0\n     * @product highcharts\n     * @apioption plotOptions.pie.minSize\n     */\n\n    /**\n     * The diameter of the pie relative to the plot area. Can be a percentage\n     * or pixel value. Pixel values are given as integers. The default\n     * behaviour (as of 3.0) is to scale to the plot area and give room\n     * for data labels within the plot area.\n     * [slicedOffset](#plotOptions.pie.slicedOffset) is also included\n     * in the default size calculation. As a consequence, the size\n     * of the pie may vary when points are updated and data labels more\n     * around. In that case it is best to set a fixed value, for example\n     * `\"75%\"`.\n     *\n     * @type    {String|Number}\n     * @sample  {highcharts} highcharts/plotoptions/pie-size/\n     *          Smaller pie\n     * @product highcharts\n     */\n    size: null,\n\n    /**\n     * Whether to display this particular series or series type in the\n     * legend. Since 2.1, pies are not shown in the legend by default.\n     *\n     * @type {Boolean}\n     * @sample {highcharts} highcharts/plotoptions/series-showinlegend/\n     *         One series in the legend, one hidden\n     * @product highcharts\n     */\n    showInLegend: false,\n\n    /**\n     * If a point is sliced, moved out from the center, how many pixels\n     * should it be moved?.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/\n     *         20px offset\n     * @default 10\n     * @product highcharts\n     */\n    slicedOffset: 10,\n\n    /**\n     * The start angle of the pie slices in degrees where 0 is top and 90\n     * right.\n     *\n     * @type {Number}\n     * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/\n     *         Start from right\n     * @default 0\n     * @since 2.3.4\n     * @product highcharts\n     * @apioption plotOptions.pie.startAngle\n     */\n\n    /**\n     * Sticky tracking of mouse events. When true, the `mouseOut` event\n     * on a series isn't triggered until the mouse moves over another series,\n     * or out of the plot area. When false, the `mouseOut` event on a\n     * series is triggered when the mouse leaves the area around the series'\n     * graph or markers. This also implies the tooltip. When `stickyTracking`\n     * is false and `tooltip.shared` is false, the tooltip will be hidden\n     * when moving the mouse between series.\n     *\n     * @product highcharts\n     */\n    stickyTracking: false,\n\n    tooltip: {\n        followPointer: true\n    }\n    \n\n}, /** @lends seriesTypes.pie.prototype */ {\n    isCartesian: false,\n    requireSorting: false,\n    directTouch: true,\n    noSharedTooltip: true,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    axisTypes: [],\n    pointAttribs: seriesTypes.column.prototype.pointAttribs,\n    /**\n     * Animate the pies in\n     */\n    animate: function (init) {\n        var series = this,\n            points = series.points,\n            startAngleRad = series.startAngleRad;\n\n        if (!init) {\n            each(points, function (point) {\n                var graphic = point.graphic,\n                    args = point.shapeArgs;\n\n                if (graphic) {\n                    // start values\n                    graphic.attr({\n                        // animate from inner radius (#779)\n                        r: point.startR || (series.center[3] / 2),\n                        start: startAngleRad,\n                        end: startAngleRad\n                    });\n\n                    // animate\n                    graphic.animate({\n                        r: args.r,\n                        start: args.start,\n                        end: args.end\n                    }, series.options.animation);\n                }\n            });\n\n            // delete this function to allow it only once\n            series.animate = null;\n        }\n    },\n\n    /**\n     * Recompute total chart sum and update percentages of points.\n     */\n    updateTotals: function () {\n        var i,\n            total = 0,\n            points = this.points,\n            len = points.length,\n            point,\n            ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n        // Get the total sum\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            total += (ignoreHiddenPoint && !point.visible) ?\n                0 :\n                point.isNull ? 0 : point.y;\n        }\n        this.total = total;\n\n        // Set each point's properties\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            point.percentage =\n                (total > 0 && (point.visible || !ignoreHiddenPoint)) ?\n                    point.y / total * 100 :\n                    0;\n            point.total = total;\n        }\n    },\n\n    /**\n     * Extend the generatePoints method by adding total and percentage\n     * properties to each point\n     */\n    generatePoints: function () {\n        Series.prototype.generatePoints.call(this);\n        this.updateTotals();\n    },\n\n    /**\n     * Do translation for pie slices\n     */\n    translate: function (positions) {\n        this.generatePoints();\n\n        var series = this,\n            cumulative = 0,\n            precision = 1000, // issue #172\n            options = series.options,\n            slicedOffset = options.slicedOffset,\n            connectorOffset = slicedOffset + (options.borderWidth || 0),\n            finalConnectorOffset,\n            start,\n            end,\n            angle,\n            radians = getStartAndEndRadians(\n                options.startAngle,\n                options.endAngle\n            ),\n            startAngleRad = series.startAngleRad = radians.start,\n            endAngleRad = series.endAngleRad = radians.end,\n            circ = endAngleRad - startAngleRad, // 2 * Math.PI,\n            points = series.points,\n            radiusX, // the x component of the radius vector for a given point\n            radiusY,\n            labelDistance = options.dataLabels.distance,\n            ignoreHiddenPoint = options.ignoreHiddenPoint,\n            i,\n            len = points.length,\n            point;\n\n        // Get positions - either an integer or a percentage string must be\n        // given. If positions are passed as a parameter, we're in a recursive\n        // loop for adjusting space for data labels.\n        if (!positions) {\n            series.center = positions = series.getCenter();\n        }\n\n        // Utility for getting the x value from a given y, used for\n        // anticollision logic in data labels. Added point for using specific\n        // points' label distance.\n        series.getX = function (y, left, point) {\n            angle = Math.asin(\n                Math.min(\n                    (\n                        (y - positions[1]) /\n                        (positions[2] / 2 + point.labelDistance)\n                    ),\n                    1\n                )\n            );\n            return positions[0] +\n                (left ? -1 : 1) *\n                (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));\n        };\n\n        // Calculate the geometry for each point\n        for (i = 0; i < len; i++) {\n\n            point = points[i];\n\n            // Used for distance calculation for specific point.\n            point.labelDistance = pick(\n                point.options.dataLabels && point.options.dataLabels.distance,\n                labelDistance\n            );\n\n            // Saved for later dataLabels distance calculation.\n            series.maxLabelDistance = Math.max(\n                series.maxLabelDistance || 0,\n                point.labelDistance\n            );\n\n            // set start and end angle\n            start = startAngleRad + (cumulative * circ);\n            if (!ignoreHiddenPoint || point.visible) {\n                cumulative += point.percentage / 100;\n            }\n            end = startAngleRad + (cumulative * circ);\n\n            // set the shape\n            point.shapeType = 'arc';\n            point.shapeArgs = {\n                x: positions[0],\n                y: positions[1],\n                r: positions[2] / 2,\n                innerR: positions[3] / 2,\n                start: Math.round(start * precision) / precision,\n                end: Math.round(end * precision) / precision\n            };\n\n            // The angle must stay within -90 and 270 (#2645)\n            angle = (end + start) / 2;\n            if (angle > 1.5 * Math.PI) {\n                angle -= 2 * Math.PI;\n            } else if (angle < -Math.PI / 2) {\n                angle += 2 * Math.PI;\n            }\n\n            // Center for the sliced out slice\n            point.slicedTranslation = {\n                translateX: Math.round(Math.cos(angle) * slicedOffset),\n                translateY: Math.round(Math.sin(angle) * slicedOffset)\n            };\n\n            // set the anchor point for tooltips\n            radiusX = Math.cos(angle) * positions[2] / 2;\n            radiusY = Math.sin(angle) * positions[2] / 2;\n            point.tooltipPos = [\n                positions[0] + radiusX * 0.7,\n                positions[1] + radiusY * 0.7\n            ];\n\n            point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;\n            point.angle = angle;\n\n            // Set the anchor point for data labels. Use point.labelDistance\n            // instead of labelDistance // #1174\n            // finalConnectorOffset - not override connectorOffset value.\n            finalConnectorOffset = Math.min(\n                connectorOffset,\n                point.labelDistance / 5\n            ); // #1678\n            point.labelPos = [\n                // first break of connector\n                positions[0] + radiusX +\n                    Math.cos(angle) * point.labelDistance,\n                positions[1] + radiusY +\n                    Math.sin(angle) * point.labelDistance,\n                // second break, right outside pie\n                positions[0] + radiusX +\n                    Math.cos(angle) * finalConnectorOffset,\n                positions[1] + radiusY +\n                    Math.sin(angle) * finalConnectorOffset, // a/a\n                positions[0] + radiusX, // landing point for connector\n                positions[1] + radiusY, // a/a\n                point.labelDistance < 0 ? // alignment\n                    'center' :\n                    point.half ? 'right' : 'left', // alignment\n                angle // center angle\n            ];\n\n        }\n    },\n\n    drawGraph: null,\n\n    /**\n     * Draw the data points\n     */\n    drawPoints: function () {\n        var series = this,\n            chart = series.chart,\n            renderer = chart.renderer,\n            groupTranslation,\n            graphic,\n            pointAttr,\n            shapeArgs;\n\n        \n\n        // draw the slices\n        each(series.points, function (point) {\n            graphic = point.graphic;\n            if (!point.isNull) {\n                shapeArgs = point.shapeArgs;\n\n\n                // If the point is sliced, use special translation, else use\n                // plot area traslation\n                groupTranslation = point.getTranslate();\n\n                \n\n                // Draw the slice\n                if (graphic) {\n                    graphic\n                        .setRadialReference(series.center)\n                        \n                        .animate(extend(shapeArgs, groupTranslation));\n                } else {\n\n                    point.graphic = graphic = renderer[point.shapeType](\n                            shapeArgs\n                        )\n                        .setRadialReference(series.center)\n                        .attr(groupTranslation)\n                        .add(series.group);\n\n                    \n                }\n\n                graphic.attr({\n                    visibility: point.visible ? 'inherit' : 'hidden'\n                });\n\n                graphic.addClass(point.getClassName());\n\n            } else if (graphic) {\n                point.graphic = graphic.destroy();\n            }\n        });\n\n    },\n\n\n    searchPoint: noop,\n\n    /**\n     * Utility for sorting data labels\n     */\n    sortByAngle: function (points, sign) {\n        points.sort(function (a, b) {\n            return a.angle !== undefined && (b.angle - a.angle) * sign;\n        });\n    },\n\n    /**\n     * Use a simple symbol from LegendSymbolMixin\n     */\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n    /**\n     * Use the getCenter method from drawLegendSymbol\n     */\n    getCenter: CenteredSeriesMixin.getCenter,\n\n    /**\n     * Pies don't have point marker symbols\n     */\n    getSymbol: noop\n\n\n}, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {\n    /**\n     * Initiate the pie slice\n     */\n    init: function () {\n\n        Point.prototype.init.apply(this, arguments);\n\n        var point = this,\n            toggleSlice;\n\n        point.name = pick(point.name, 'Slice');\n\n        // add event listener for select\n        toggleSlice = function (e) {\n            point.slice(e.type === 'select');\n        };\n        addEvent(point, 'select', toggleSlice);\n        addEvent(point, 'unselect', toggleSlice);\n\n        return point;\n    },\n\n    /**\n     * Negative points are not valid (#1530, #3623, #5322)\n     */\n    isValid: function () {\n        return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(this.y, true) && this.y >= 0;\n    },\n\n    /**\n     * Toggle the visibility of the pie slice\n     * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n     *    visibility is toggled\n     */\n    setVisible: function (vis, redraw) {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n        redraw = pick(redraw, ignoreHiddenPoint);\n\n        if (vis !== point.visible) {\n\n            // If called without an argument, toggle visibility\n            point.visible = point.options.visible = vis =\n                vis === undefined ? !point.visible : vis;\n            // update userOptions.data\n            series.options.data[inArray(point, series.data)] = point.options;\n\n            // Show and hide associated elements. This is performed regardless\n            // of redraw or not, because chart.redraw only handles full series.\n            each(\n                ['graphic', 'dataLabel', 'connector', 'shadowGroup'],\n                function (key) {\n                    if (point[key]) {\n                        point[key][vis ? 'show' : 'hide'](true);\n                    }\n                }\n            );\n\n            if (point.legendItem) {\n                chart.legend.colorizeItem(point, vis);\n            }\n\n            // #4170, hide halo after hiding point\n            if (!vis && point.state === 'hover') {\n                point.setState('');\n            }\n\n            // Handle ignore hidden slices\n            if (ignoreHiddenPoint) {\n                series.isDirty = true;\n            }\n\n            if (redraw) {\n                chart.redraw();\n            }\n        }\n    },\n\n    /**\n     * Set or toggle whether the slice is cut out from the pie\n     * @param {Boolean} sliced When undefined, the slice state is toggled\n     * @param {Boolean} redraw Whether to redraw the chart. True by default.\n     */\n    slice: function (sliced, redraw, animation) {\n        var point = this,\n            series = point.series,\n            chart = series.chart;\n\n        setAnimation(animation, chart);\n\n        // redraw is true by default\n        redraw = pick(redraw, true);\n\n        // if called without an argument, toggle\n        point.sliced = point.options.sliced = sliced =\n            defined(sliced) ? sliced : !point.sliced;\n        // update userOptions.data\n        series.options.data[inArray(point, series.data)] = point.options;\n\n        point.graphic.animate(this.getTranslate());\n\n        \n    },\n\n    getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : {\n            translateX: 0,\n            translateY: 0\n        };\n    },\n\n    haloPath: function (size) {\n        var shapeArgs = this.shapeArgs;\n\n        return this.sliced || !this.visible ?\n            [] :\n            this.series.chart.renderer.symbols.arc(\n                shapeArgs.x,\n                shapeArgs.y,\n                shapeArgs.r + size,\n                shapeArgs.r + size, {\n                    // Substract 1px to ensure the background is not bleeding\n                    // through between the halo and the slice (#7495).\n                    innerR: this.shapeArgs.r - 1,\n                    start: shapeArgs.start,\n                    end: shapeArgs.end\n                }\n            );\n    }\n});\n\n/**\n * A `pie` series. If the [type](#series.pie.type) option is not specified,\n * it is inherited from [chart.type](#chart.type).\n *\n * @type {Object}\n * @extends series,plotOptions.pie\n * @excluding dataParser,dataURL,stack,xAxis,yAxis\n * @product highcharts\n * @apioption series.pie\n */\n\n/**\n * An array of data points for the series. For the `pie` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.pie.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *     y: 1,\n *     name: \"Point2\",\n *     color: \"#00FF00\"\n * }, {\n *     y: 7,\n *     name: \"Point1\",\n *     color: \"#FF00FF\"\n * }]</pre>\n *\n * @type {Array<Object|Number>}\n * @extends series.line.data\n * @excluding marker,x\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n * @product highcharts\n * @apioption series.pie.data\n */\n\n/**\n * The sequential index of the data point in the legend.\n *\n * @type {Number}\n * @product highcharts\n * @apioption series.pie.data.legendIndex\n */\n\n/**\n * Whether to display a slice offset from the center.\n *\n * @type {Boolean}\n * @sample {highcharts} highcharts/point/sliced/ One sliced point\n * @product highcharts\n * @apioption series.pie.data.sliced\n */\n\n/**\n * Fires when the checkbox next to the point name in the legend is clicked.\n * One parameter, event, is passed to the function. The state of the\n * checkbox is found by event.checked. The checked item is found by\n * event.item. Return false to prevent the default action which is to\n * toggle the select state of the series.\n *\n * @type {Function}\n * @context Point\n * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/\n *         Alert checkbox status\n * @since 1.2.0\n * @product highcharts\n * @apioption plotOptions.pie.events.checkboxClick\n */\n\n/**\n * Not applicable to pies, as the legend item is per point. See point.\n * events.\n *\n * @type {Function}\n * @since 1.2.0\n * @product highcharts\n * @apioption plotOptions.pie.events.legendItemClick\n */\n\n/**\n * Fires when the legend item belonging to the pie point (slice) is\n * clicked. The `this` keyword refers to the point itself. One parameter,\n * `event`, is passed to the function, containing common event information. The\n * default action is to toggle the visibility of the point. This can be\n * prevented by calling `event.preventDefault()`.\n *\n * @type {Function}\n * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/\n *         Confirm toggle visibility\n * @since 1.2.0\n * @product highcharts\n * @apioption plotOptions.pie.point.events.legendItemClick\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/PieSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/PlotLineOrBand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/PlotLineOrBand.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options for plot bands on axes.\n *\n * @typedef {Highcharts.XAxisPlotBandsOptions|Highcharts.YAxisPlotBandsOptions|Highcharts.ZAxisPlotBandsOptions} Highcharts.AxisPlotBandsOptions\n */\n\n/**\n * Options for plot band labels on axes.\n *\n * @typedef {Highcharts.XAxisPlotBandsLabelOptions|Highcharts.YAxisPlotBandsLabelOptions|Highcharts.ZAxisPlotBandsLabelOptions} Highcharts.AxisPlotBandsLabelOptions\n */\n\n/**\n * Options for plot lines on axes.\n *\n * @typedef {Highcharts.XAxisPlotLinesOptions|Highcharts.YAxisPlotLinesOptions|Highcharts.ZAxisPlotLinesOptions} Highcharts.AxisPlotLinesOptions\n */\n\n/**\n * Options for plot line labels on axes.\n *\n * @typedef {Highcharts.XAxisPlotLinesLabelOptions|Highcharts.YAxisPlotLinesLabelOptions|Highcharts.ZAxisPlotLinesLabelOptions} Highcharts.AxisPlotLinesLabelOptions\n */\n\n\n\n\n\n\n\nvar arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    erase = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick;\n\n/**\n * The object wrapper for plot lines and plot bands\n *\n * @class\n * @name Highcharts.PlotLineOrBand\n *\n * @param {Highcharts.Axis} axis\n *\n * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PlotLineOrBand = function (axis, options) {\n    this.axis = axis;\n\n    if (options) {\n        this.options = options;\n        this.id = options.id;\n    }\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PlotLineOrBand.prototype = {\n\n    /**\n     * Render the plot line or plot band. If it is already existing,\n     * move it.\n     *\n     * @private\n     * @function Highcharts.PlotLineOrBand#render\n     *\n     * @return {Highcharts.PlotLineOrBand|undefined}\n     */\n    render: function () {\n        var plotLine = this,\n            axis = plotLine.axis,\n            horiz = axis.horiz,\n            options = plotLine.options,\n            optionsLabel = options.label,\n            label = plotLine.label,\n            to = options.to,\n            from = options.from,\n            value = options.value,\n            isBand = defined(from) && defined(to),\n            isLine = defined(value),\n            svgElem = plotLine.svgElem,\n            isNew = !svgElem,\n            path = [],\n            color = options.color,\n            zIndex = pick(options.zIndex, 0),\n            events = options.events,\n            attribs = {\n                'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') +\n                    (options.className || '')\n            },\n            groupAttribs = {},\n            renderer = axis.chart.renderer,\n            groupName = isBand ? 'bands' : 'lines',\n            group;\n\n        // logarithmic conversion\n        if (axis.isLog) {\n            from = axis.log2lin(from);\n            to = axis.log2lin(to);\n            value = axis.log2lin(value);\n        }\n\n        \n\n        // Grouping and zIndex\n        groupAttribs.zIndex = zIndex;\n        groupName += '-' + zIndex;\n\n        group = axis.plotLinesAndBandsGroups[groupName];\n        if (!group) {\n            axis.plotLinesAndBandsGroups[groupName] = group =\n                renderer.g('plot-' + groupName)\n                    .attr(groupAttribs).add();\n        }\n\n        // Create the path\n        if (isNew) {\n            /**\n             * SVG element of the plot line or band.\n             *\n             * @name Highcharts.PlotLineOrBand#svgElement\n             * @type {Highcharts.SVGElement}\n             */\n            plotLine.svgElem = svgElem =\n                renderer\n                    .path()\n                    .attr(attribs).add(group);\n        }\n\n\n        // Set the path or return\n        if (isLine) {\n            path = axis.getPlotLinePath(value, svgElem.strokeWidth());\n        } else if (isBand) { // plot band\n            path = axis.getPlotBandPath(from, to, options);\n        } else {\n            return;\n        }\n\n\n        // common for lines and bands\n        if (isNew && path && path.length) {\n            svgElem.attr({ d: path });\n\n            // events\n            if (events) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(events, function (event, eventType) {\n                    svgElem.on(eventType, function (e) {\n                        events[eventType].apply(plotLine, [e]);\n                    });\n                });\n            }\n        } else if (svgElem) {\n            if (path) {\n                svgElem.show();\n                svgElem.animate({ d: path });\n            } else {\n                svgElem.hide();\n                if (label) {\n                    plotLine.label = label = label.destroy();\n                }\n            }\n        }\n\n        // the plot band/line label\n        if (\n            optionsLabel &&\n            defined(optionsLabel.text) &&\n            path &&\n            path.length &&\n            axis.width > 0 &&\n            axis.height > 0 &&\n            !path.isFlat\n        ) {\n            // apply defaults\n            optionsLabel = merge({\n                align: horiz && isBand && 'center',\n                x: horiz ? !isBand && 4 : 10,\n                verticalAlign: !horiz && isBand && 'middle',\n                y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                rotation: horiz && !isBand && 90\n            }, optionsLabel);\n\n            this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n        } else if (label) { // move out of sight\n            label.hide();\n        }\n\n        // chainable\n        return plotLine;\n    },\n\n    /**\n     * Render and align label for plot line or band.\n     *\n     * @private\n     * @function Highcharts.PlotLineOrBand#renderLabel\n     *\n     * @param {Highcharts.AxisPlotLinesLabelOptions|Highcharts.AxisPlotBandsLabelOptions} optionsLabel\n     *\n     * @param {Highcharts.SVGPathArray} path\n     *\n     * @param {boolean} [isBand]\n     *\n     * @param {number} [zIndex]\n     */\n    renderLabel: function (optionsLabel, path, isBand, zIndex) {\n        var plotLine = this,\n            label = plotLine.label,\n            renderer = plotLine.axis.chart.renderer,\n            attribs,\n            xBounds,\n            yBounds,\n            x,\n            y;\n\n        // add the SVG element\n        if (!label) {\n            attribs = {\n                align: optionsLabel.textAlign || optionsLabel.align,\n                rotation: optionsLabel.rotation,\n                'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') +\n                    '-label ' + (optionsLabel.className || '')\n            };\n\n            attribs.zIndex = zIndex;\n\n            /**\n             * SVG element of the label.\n             *\n             * @name Highcharts.PlotLineOrBand#label\n             * @type {Highcharts.SVGElement}\n             */\n            plotLine.label = label = renderer.text(\n                    optionsLabel.text,\n                    0,\n                    0,\n                    optionsLabel.useHTML\n                )\n                .attr(attribs)\n                .add();\n\n            \n        }\n\n        // get the bounding box and align the label\n        // #3000 changed to better handle choice between plotband or plotline\n        xBounds = path.xBounds ||\n            [path[1], path[4], (isBand ? path[6] : path[1])];\n        yBounds = path.yBounds ||\n            [path[2], path[5], (isBand ? path[7] : path[2])];\n\n        x = arrayMin(xBounds);\n        y = arrayMin(yBounds);\n\n        label.align(optionsLabel, false, {\n            x: x,\n            y: y,\n            width: arrayMax(xBounds) - x,\n            height: arrayMax(yBounds) - y\n        });\n        label.show();\n    },\n\n    /**\n     * Remove the plot line or band.\n     *\n     * @function Highcharts.PlotLineOrBand#destroy\n     */\n    destroy: function () {\n        // remove it from the lookup\n        erase(this.axis.plotLinesAndBands, this);\n\n        delete this.axis;\n        destroyObjectProperties(this);\n    }\n};\n\n// Object with members for extending the Axis prototype\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(_Axis_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype, /** @lends Highcharts.Axis.prototype */ {\n\n    /**\n     * An array of colored bands stretching across the plot area marking an\n     * interval on the axis.\n     *\n     * In styled mode, the plot bands are styled by the `.highcharts-plot-band`\n     * class in addition to the `className` option.\n     *\n     * @productdesc {highcharts}\n     * In a gauge, a plot band on the Y axis (value axis) will stretch along the\n     * perimeter of the gauge.\n     *\n     * @type      {Array<*>}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands\n     */\n\n    /**\n     * Border color for the plot band. Also requires `borderWidth` to be set.\n     *\n     * @type      {Highcharts.ColorString}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.borderColor\n     */\n\n    /**\n     * Border width for the plot band. Also requires `borderColor` to be set.\n     *\n     * @type      {number}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.borderWidth\n     */\n\n    /**\n     * A custom class name, in addition to the default `highcharts-plot-band`,\n     * to apply to each individual band.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.plotBands.className\n     */\n\n    /**\n     * The color of the plot band.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-color/\n     *         Color band\n     * @sample {highstock} stock/xaxis/plotbands/\n     *         Plot band on Y axis\n     *\n     * @type      {Highcharts.ColorString}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.color\n     */\n\n    /**\n     * An object defining mouse events for the plot band. Supported properties\n     * are `click`, `mouseover`, `mouseout`, `mousemove`.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-events/\n     *         Mouse events demonstrated\n     *\n     * @since     1.2\n     * @product   highcharts highstock\n     * @context   PlotLineOrBand\n     * @apioption xAxis.plotBands.events\n     */\n\n    /**\n     * The start position of the plot band in axis units.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-color/\n     *         Datetime axis\n     * @sample {highcharts} highcharts/xaxis/plotbands-from/\n     *         Categorized axis\n     * @sample {highstock} stock/xaxis/plotbands/\n     *         Plot band on Y axis\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.from\n     */\n\n    /**\n     * An id used for identifying the plot band in Axis.removePlotBand.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-id/\n     *         Remove plot band by id\n     * @sample {highstock} highcharts/xaxis/plotbands-id/\n     *         Remove plot band by id\n     *\n     * @type      {string}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.id\n     */\n\n    /**\n     * The end position of the plot band in axis units.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-color/\n     *         Datetime axis\n     * @sample {highcharts} highcharts/xaxis/plotbands-from/\n     *         Categorized axis\n     * @sample {highstock} stock/xaxis/plotbands/\n     *         Plot band on Y axis\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.to\n     */\n\n    /**\n     * The z index of the plot band within the chart, relative to other\n     * elements. Using the same z index as another element may give\n     * unpredictable results, as the last rendered element will be on top.\n     * Values from 0 to 20 make sense.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-color/\n     *         Behind plot lines by default\n     * @sample {highcharts} highcharts/xaxis/plotbands-zindex/\n     *         Above plot lines\n     * @sample {highcharts} highcharts/xaxis/plotbands-zindex-above-series/\n     *         Above plot lines and series\n     *\n     * @type      {number}\n     * @since     1.2\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.zIndex\n     */\n\n    /**\n     * Text labels for the plot bands\n     *\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label\n     */\n\n    /**\n     * Horizontal alignment of the label. Can be one of \"left\", \"center\" or\n     * \"right\".\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-align/\n     *         Aligned to the right\n     * @sample {highstock} stock/xaxis/plotbands-label/\n     *         Plot band with labels\n     *\n     * @type      {string}\n     * @default   center\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.align\n     */\n\n    /**\n     * Rotation of the text label in degrees .\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/\n     *         Vertical text\n     *\n     * @type      {number}\n     * @default   0\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.rotation\n     */\n\n    /**\n     * CSS styles for the text label.\n     *\n     * In styled mode, the labels are styled by the\n     * `.highcharts-plot-band-label` class.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-style/\n     *         Blue and bold label\n     *\n     * @type      {Highcharts.CSSObject}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.style\n     */\n\n    /**\n     * The string text itself. A subset of HTML is supported.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highcharts\n     * @apioption xAxis.plotBands.label.text\n     */\n\n    /**\n     * The text alignment for the label. While `align` determines where the\n     * texts anchor point is placed within the plot band, `textAlign` determines\n     * how the text is aligned against its anchor point. Possible values are\n     * \"left\", \"center\" and \"right\". Defaults to the same as the `align` option.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-rotation/\n     *         Vertical text in center position but text-aligned left\n     *\n     * @type       {string}\n     * @since      2.1\n     * @product    highcharts highstock\n     * @validvalue [\"center\", \"left\", \"right\"]\n     * @apioption  xAxis.plotBands.label.textAlign\n     */\n\n    /**\n     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts\n     * /labels-and-string-formatting#html) to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     3.0.3\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.useHTML\n     */\n\n    /**\n     * Vertical alignment of the label relative to the plot band. Can be one of\n     * \"top\", \"middle\" or \"bottom\".\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-verticalalign/\n     *         Vertically centered label\n     * @sample {highstock} stock/xaxis/plotbands-label/\n     *         Plot band with labels\n     *\n     * @type       {string}\n     * @default    top\n     * @since      2.1\n     * @product    highcharts highstock\n     * @validvalue [\"bottom\", \"middle\",  \"top\"]\n     * @apioption  xAxis.plotBands.label.verticalAlign\n     */\n\n    /**\n     * Horizontal position relative the alignment. Default varies by\n     * orientation.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-align/\n     *         Aligned 10px from the right edge\n     * @sample {highstock} stock/xaxis/plotbands-label/\n     *         Plot band with labels\n     *\n     * @type      {number}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.x\n     */\n\n    /**\n     * Vertical position of the text baseline relative to the alignment. Default\n     * varies by orientation.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-label-y/\n     *         Label on x axis\n     * @sample {highstock} stock/xaxis/plotbands-label/\n     *         Plot band with labels\n     *\n     * @type      {number}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotBands.label.y\n     */\n\n    /**\n     * An array of lines stretching across the plot area, marking a specific\n     * value on one of the axes.\n     *\n     * In styled mode, the plot lines are styled by the\n     * `.highcharts-plot-line` class in addition to the `className` option.\n     *\n     * @type      {Array<*>}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines\n     */\n\n    /**\n     * A custom class name, in addition to the default `highcharts-plot-line`,\n     * to apply to each individual line.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption xAxis.plotLines.className\n     */\n\n    /**\n     * The color of the line.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-color/\n     *         A red line from X axis\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type      {Highcharts.ColorString}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.color\n     */\n\n    /**\n     * The dashing or dot style for the plot line. For possible values see\n     * [this overview](https://jsfiddle.net/gh/get/library/pure/highcharts\n     * /highcharts/tree/master/samples/highcharts/plotoptions/series-\n     * dashstyle-all/).\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-dashstyle/\n     *         Dash and dot pattern\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      1.2\n     * @product    highcharts highstock\n     * @validvalue [\"Solid\", \"ShortDash\", \"ShortDot\", \"ShortDashDot\",\n     *             \"ShortDashDotDot\", \"Dot\", \"Dash\" ,\"LongDash\", \"DashDot\",\n     *             \"LongDashDot\", \"LongDashDotDot\"]\n     * @apioption  xAxis.plotLines.dashStyle\n     */\n\n    /**\n     * An object defining mouse events for the plot line. Supported\n     * properties are `click`, `mouseover`, `mouseout`, `mousemove`.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-events/\n     *         Mouse events demonstrated\n     *\n     * @type      {*}\n     * @since     1.2\n     * @product   highcharts highstock\n     * @context   PlotLineOrBand\n     * @apioption xAxis.plotLines.events\n     */\n\n    /**\n     * An id used for identifying the plot line in Axis.removePlotLine.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-id/\n     *         Remove plot line by id\n     *\n     * @type      {string}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.id\n     */\n\n    /**\n     * The position of the line in axis units.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-color/\n     *         Between two categories on X axis\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.value\n     */\n\n    /**\n     * The width or thickness of the plot line.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-color/\n     *         2px wide line from X axis\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.width\n     */\n\n    /**\n     * The z index of the plot line within the chart.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-behind/\n     *         Behind plot lines by default\n     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above/\n     *         Above plot lines\n     * @sample {highcharts} highcharts/xaxis/plotlines-zindex-above-all/\n     *         Above plot lines and series\n     *\n     * @type      {number}\n     * @since     1.2\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.zIndex\n     */\n\n    /**\n     * Text labels for the plot bands\n     *\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label\n     */\n\n    /**\n     * Horizontal alignment of the label. Can be one of \"left\", \"center\" or\n     * \"right\".\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/\n     *         Aligned to the right\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type       {string}\n     * @default    left\n     * @since      2.1\n     * @product    highcharts highstock\n     * @validvalue [\"center\", \"left\", \"right\"]\n     * @apioption  xAxis.plotLines.label.align\n     */\n\n    /**\n     * Rotation of the text label in degrees. Defaults to 0 for horizontal plot\n     * lines and 90 for vertical lines.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/\n     *         Slanted text\n     *\n     * @type      {number}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.rotation\n     */\n\n    /**\n     * CSS styles for the text label.\n     *\n     * In styled mode, the labels are styled by the\n     * `.highcharts-plot-line-label` class.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-style/\n     *         Blue and bold label\n     *\n     * @type      {Highcharts.CSSObject}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.style\n     */\n\n    /**\n     * The text itself. A subset of HTML is supported.\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highcharts\n     * @apioption xAxis.plotLines.label.text\n     */\n\n    /**\n     * The text alignment for the label. While `align` determines where the\n     * texts anchor point is placed within the plot band, `textAlign` determines\n     * how the text is aligned against its anchor point. Possible values are\n     * \"left\", \"center\" and \"right\". Defaults to the same as the `align` option.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-textalign/\n     *         Text label in bottom position\n     *\n     * @type      {string}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.textAlign\n     */\n\n    /**\n     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts\n     * /labels-and-string-formatting#html) to render the labels.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     3.0.3\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.useHTML\n     */\n\n    /**\n     * Vertical alignment of the label relative to the plot line. Can be\n     * one of \"top\", \"middle\" or \"bottom\".\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-verticalalign-middle/\n     *         Vertically centered label\n     *\n     * @type       {string}\n     * @default    {highcharts} top\n     * @default    {highstock} top\n     * @since      2.1\n     * @product    highcharts highstock\n     * @validvalue [\"top\", \"middle\", \"bottom\"]\n     * @apioption  xAxis.plotLines.label.verticalAlign\n     */\n\n    /**\n     * Horizontal position relative the alignment. Default varies by\n     * orientation.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-align-right/\n     *         Aligned 10px from the right edge\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type      {number}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.x\n     */\n\n    /**\n     * Vertical position of the text baseline relative to the alignment. Default\n     * varies by orientation.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotlines-label-y/\n     *         Label below the plot line\n     * @sample {highstock} stock/xaxis/plotlines/\n     *         Plot line on Y axis\n     *\n     * @type      {number}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption xAxis.plotLines.label.y\n     */\n\n    /**\n     * An array of objects defining plot bands on the Y axis.\n     *\n     * @type      {Array<*>}\n     * @extends   xAxis.plotBands\n     * @product   highcharts highstock\n     * @apioption yAxis.plotBands\n     */\n\n    /**\n     * In a gauge chart, this option determines the inner radius of the\n     * plot band that stretches along the perimeter. It can be given as\n     * a percentage string, like `\"100%\"`, or as a pixel number, like `100`.\n     * By default, the inner radius is controlled by the [thickness](\n     * #yAxis.plotBands.thickness) option.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-gauge\n     *         Gauge plot band\n     *\n     * @type      {number|string}\n     * @since     2.3\n     * @product   highcharts\n     * @apioption yAxis.plotBands.innerRadius\n     */\n\n    /**\n     * In a gauge chart, this option determines the outer radius of the\n     * plot band that stretches along the perimeter. It can be given as\n     * a percentage string, like `\"100%\"`, or as a pixel number, like `100`.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-gauge\n     *         Gauge plot band\n     *\n     * @type      {number|string}\n     * @default   100%\n     * @since     2.3\n     * @product   highcharts\n     * @apioption yAxis.plotBands.outerRadius\n     */\n\n    /**\n     * In a gauge chart, this option sets the width of the plot band\n     * stretching along the perimeter. It can be given as a percentage\n     * string, like `\"10%\"`, or as a pixel number, like `10`. The default\n     * value 10 is the same as the default [tickLength](#yAxis.tickLength),\n     * thus making the plot band act as a background for the tick markers.\n     *\n     * @sample {highcharts} highcharts/xaxis/plotbands-gauge\n     *         Gauge plot band\n     *\n     * @type      {number|string}\n     * @default   10\n     * @since     2.3\n     * @product   highcharts\n     * @apioption yAxis.plotBands.thickness\n     */\n\n    /**\n     * An array of objects representing plot lines on the X axis\n     *\n     * @type      {Array<*>}\n     * @extends   xAxis.plotLines\n     * @product   highcharts highstock\n     * @apioption yAxis.plotLines\n     */\n\n    /**\n     * Internal function to create the SVG path definition for a plot band.\n     *\n     * @function Highcharts.Axis#getPlotBandPath\n     *\n     * @param {number} from\n     *        The axis value to start from.\n     *\n     * @param {number} to\n     *        The axis value to end on.\n     *\n     * @return {Highcharts.SVGPathArray}\n     *         The SVG path definition in array form.\n     */\n    getPlotBandPath: function (from, to) {\n        var toPath = this.getPlotLinePath(to, null, null, true),\n            path = this.getPlotLinePath(from, null, null, true),\n            result = [],\n            i,\n            // #4964 check if chart is inverted or plotband is on yAxis\n            horiz = this.horiz,\n            plus = 1,\n            isFlat,\n            outside =\n                (from < this.min && to < this.min) ||\n                (from > this.max && to > this.max);\n\n        if (path && toPath) {\n\n            // Flat paths don't need labels (#3836)\n            if (outside) {\n                isFlat = path.toString() === toPath.toString();\n                plus = 0;\n            }\n\n            // Go over each subpath - for panes in Highstock\n            for (i = 0; i < path.length; i += 6) {\n\n                // Add 1 pixel when coordinates are the same\n                if (horiz && toPath[i + 1] === path[i + 1]) {\n                    toPath[i + 1] += plus;\n                    toPath[i + 4] += plus;\n                } else if (!horiz && toPath[i + 2] === path[i + 2]) {\n                    toPath[i + 2] += plus;\n                    toPath[i + 5] += plus;\n                }\n\n                result.push(\n                    'M',\n                    path[i + 1],\n                    path[i + 2],\n                    'L',\n                    path[i + 4],\n                    path[i + 5],\n                    toPath[i + 4],\n                    toPath[i + 5],\n                    toPath[i + 1],\n                    toPath[i + 2],\n                    'z'\n                );\n                result.isFlat = isFlat;\n            }\n\n        } else { // outside the axis area\n            path = null;\n        }\n\n        return result;\n    },\n\n    /**\n     * Add a plot band after render time.\n     *\n     * @sample highcharts/members/axis-addplotband/\n     *         Toggle the plot band from a button\n     *\n     * @function Highcharts.Axis#addPlotBand\n     *\n     * @param {Highcharts.AxisPlotBandsOptions} options\n     *        A configuration object for the plot band, as defined in\n     *        {@link  https://api.highcharts.com/highcharts/xAxis.plotBands|xAxis.plotBands}.\n     *\n     * @return {Highcharts.PlotLineOrBand|undefined}\n     *         The added plot band.\n     */\n    addPlotBand: function (options) {\n        return this.addPlotBandOrLine(options, 'plotBands');\n    },\n\n    /**\n     * Add a plot line after render time.\n     *\n     * @sample highcharts/members/axis-addplotline/\n     *         Toggle the plot line from a button\n     *\n     * @function Highcharts.Axis#addPlotLine\n     *\n     * @param {Highcharts.AxisPlotLinesOptions} options\n     *        A configuration object for the plot line, as defined in\n     *        {@link https://api.highcharts.com/highcharts/xAxis.plotLines|xAxis.plotLines}.\n     *\n     * @return {Highcharts.PlotLineOrBand|undefined}\n     *         The added plot line.\n     */\n    addPlotLine: function (options) {\n        return this.addPlotBandOrLine(options, 'plotLines');\n    },\n\n    /**\n     * Add a plot band or plot line after render time. Called from addPlotBand\n     * and addPlotLine internally.\n     *\n     * @private\n     * @function Highcharts.Axis#addPlotBandOrLine\n     *\n     * @param {Highcharts.AxisPlotLinesOptions|Highcharts.AxisPlotBandsOptions} options\n     *        The plotBand or plotLine configuration object.\n     *\n     * @param {\"plotBands\"|\"plotLines\"} [coll]\n     *\n     * @return {Highcharts.PlotLineOrBand|undefined}\n     */\n    addPlotBandOrLine: function (options, coll) {\n        var obj = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].PlotLineOrBand(this, options).render(),\n            userOptions = this.userOptions;\n\n        if (obj) { // #2189\n            // Add it to the user options for exporting and Axis.update\n            if (coll) {\n                userOptions[coll] = userOptions[coll] || [];\n                userOptions[coll].push(options);\n            }\n            this.plotLinesAndBands.push(obj);\n        }\n\n        return obj;\n    },\n\n    /**\n     * Remove a plot band or plot line from the chart by id. Called internally\n     * from `removePlotBand` and `removePlotLine`.\n     *\n     * @private\n     * @function Highcharts.Axis#removePlotBandOrLine\n     *\n     * @param {string} id\n     */\n    removePlotBandOrLine: function (id) {\n        var plotLinesAndBands = this.plotLinesAndBands,\n            options = this.options,\n            userOptions = this.userOptions,\n            i = plotLinesAndBands.length;\n        while (i--) {\n            if (plotLinesAndBands[i].id === id) {\n                plotLinesAndBands[i].destroy();\n            }\n        }\n        each([\n            options.plotLines || [],\n            userOptions.plotLines || [],\n            options.plotBands || [],\n            userOptions.plotBands || []\n        ], function (arr) {\n            i = arr.length;\n            while (i--) {\n                if (arr[i].id === id) {\n                    erase(arr, arr[i]);\n                }\n            }\n        });\n    },\n\n    /**\n     * Remove a plot band by its id.\n     *\n     * @sample highcharts/members/axis-removeplotband/\n     *         Remove plot band by id\n     * @sample highcharts/members/axis-addplotband/\n     *         Toggle the plot band from a button\n     *\n     * @function Highcharts.Axis#removePlotBand\n     *\n     * @param {string} id\n     *        The plot band's `id` as given in the original configuration\n     *        object or in the `addPlotBand` option.\n     */\n    removePlotBand: function (id) {\n        this.removePlotBandOrLine(id);\n    },\n\n    /**\n     * Remove a plot line by its id.\n     *\n     * @sample highcharts/xaxis/plotlines-id/\n     *         Remove plot line by id\n     * @sample highcharts/members/axis-addplotline/\n     *         Toggle the plot line from a button\n     *\n     * @function Highcharts.Axis#removePlotLine\n     *\n     * @param {string} id\n     *        The plot line's `id` as given in the original configuration\n     *        object or in the `addPlotLine` option.\n     */\n    removePlotLine: function (id) {\n        this.removePlotBandOrLine(id);\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/PlotLineOrBand.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Point.js":
/*!**************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Point.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Configuration hash for the data label and tooltip formatters.\n *\n * @typedef Highcharts.PointLabelObject\n *\n * @property {number|string} x\n *           For categorized axes this property holds the category name for the\n *           point. For other axes it holds the X value.\n *\n * @property {number} [y]\n *           The y value of the point.\n *\n * @property {Highcharts.ColorString} color\n *           The point's current color.\n *\n * @property {number} colorIndex\n *           The point's current color index, used in styled mode instead of\n *           `color`. The color index is inserted in class names used for\n *           styling.\n *\n * @property {number|string} key\n *           The name of the related point.\n *\n * @property {Highcharts.Series} series\n *           The related series.\n *\n * @property {Highcharts.Point} point\n *           The related point.\n *\n * @property {number} percentage\n *           The percentage for related points in a stacked series or pies.\n *\n * @property {number} total\n *           The total of values in either a stack for stacked series, or a pie\n *           in a pie series.\n */\n\n\n\n\n\n\nvar Point,\n    H = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n\n    each = H.each,\n    extend = H.extend,\n    erase = H.erase,\n    fireEvent = H.fireEvent,\n    format = H.format,\n    isArray = H.isArray,\n    isNumber = H.isNumber,\n    pick = H.pick,\n    removeEvent = H.removeEvent;\n\n/**\n * The Point object. The point objects are generated from the `series.data`\n * configuration objects or raw numbers. They can be accessed from the\n * `Series.points` array. Other ways to instantiate points are through {@link\n * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n *\n * @class\n * @name Highcharts.Point\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point = Point = function () {};\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point.prototype = {\n\n    /**\n     * Initialize the point. Called internally based on the `series.data`\n     * option.\n     *\n     * @function Highcharts.Point#init\n     *\n     * @param {Highcharts.Series} series\n     *        The series object containing this point.\n     *\n     * @param {number|Array<number>|*} options\n     *        The data in either number, array or object format.\n     *\n     * @param {number} x\n     *        Optionally, the X value of the point.\n     *\n     * @return {Highcharts.Point}\n     *         The Point instance.\n     *\n     * @fires Highcharts.Point#event:afterInit\n     */\n    init: function (series, options, x) {\n\n        var point = this,\n            colors,\n            colorCount = series.chart.options.chart.colorCount,\n            colorIndex;\n\n        /**\n         * The series object associated with the point.\n         *\n         * @name Highcharts.Point#series\n         * @type {Highcharts.Series}\n         */\n        point.series = series;\n\n        \n\n        point.applyOptions(options, x);\n\n        if (series.options.colorByPoint) {\n\n            \n\n            colorIndex = series.colorCounter;\n            series.colorCounter++;\n            // loop back to zero\n            if (series.colorCounter === colorCount) {\n                series.colorCounter = 0;\n            }\n        } else {\n            colorIndex = series.colorIndex;\n        }\n\n        /**\n         * The point's current color index, used in styled mode instead of\n         * `color`. The color index is inserted in class names used for styling.\n         *\n         * @name Highcharts.Point#colorIndex\n         * @type {number}\n         */\n        point.colorIndex = pick(point.colorIndex, colorIndex);\n\n        series.chart.pointCount++;\n\n        fireEvent(point, 'afterInit');\n\n        return point;\n    },\n    /**\n     * Apply the options containing the x and y data and possible some extra\n     * properties. Called on point init or from point.update.\n     *\n     * @private\n     * @function Highcharts.Point#applyOptions\n     *\n     * @param {*} options\n     *        The point options as defined in series.data.\n     *\n     * @param {number} x\n     *        Optionally, the x value.\n     *\n     * @return {Highcharts.Point}\n     *         The Point instance.\n     */\n    applyOptions: function (options, x) {\n        var point = this,\n            series = point.series,\n            pointValKey = series.options.pointValKey || series.pointValKey;\n\n        options = Point.prototype.optionsToObject.call(this, options);\n\n        // copy options directly to point\n        extend(point, options);\n\n        /**\n         * The point's options as applied in the initial configuration, or\n         * extended through `Point.update`.\n         *\n         * @name Highcharts.Point#options\n         * @type {*}\n         */\n        point.options = point.options ?\n            extend(point.options, options) :\n            options;\n\n        // Since options are copied into the Point instance, some accidental\n        // options must be shielded (#5681)\n        if (options.group) {\n            delete point.group;\n        }\n\n        /**\n         * The y value of the point.\n         *\n         * @name Highcharts.Point#y\n         * @type {number|undefined}\n         */\n        // For higher dimension series types. For instance, for ranges, point.y\n        // is mapped to point.low.\n        if (pointValKey) {\n            point.y = point[pointValKey];\n        }\n        point.isNull = pick(\n            point.isValid && !point.isValid(),\n            point.x === null || !isNumber(point.y, true)\n        ); // #3571, check for NaN\n\n        // The point is initially selected by options (#5777)\n        if (point.selected) {\n            point.state = 'select';\n        }\n\n        /**\n         * The x value of the point.\n         *\n         * @name Highcharts.Point#x\n         * @type {number}\n         */\n        // If no x is set by now, get auto incremented value. All points must\n        // have an x value, however the y value can be null to create a gap in\n        // the series\n        if (\n            'name' in point &&\n            x === undefined &&\n            series.xAxis &&\n            series.xAxis.hasNames\n        ) {\n            point.x = series.xAxis.nameToX(point);\n        }\n        if (point.x === undefined && series) {\n            if (x === undefined) {\n                point.x = series.autoIncrement(point);\n            } else {\n                point.x = x;\n            }\n        }\n\n        return point;\n    },\n\n    /**\n     * Set a value in an object, on the property defined by key. The key\n     * supports nested properties using dot notation. The function modifies the\n     * input object and does not make a copy.\n     *\n     * @function Highcharts.Point#setNestedProperty\n     *\n     * @param {*} object\n     *        The object to set the value on.\n     *\n     * @param {*} value\n     *        The value to set.\n     *\n     * @param {string} key\n     *        Key to the property to set.\n     *\n     * @return {*}\n     *         The modified object.\n     */\n    setNestedProperty: function (object, value, key) {\n        var nestedKeys = key.split('.');\n        H.reduce(nestedKeys, function (result, key, i, arr) {\n            var isLastKey = arr.length - 1 === i;\n            result[key] = (\n                isLastKey ?\n                value :\n                (H.isObject(result[key], true) ? result[key] : {})\n            );\n            return result[key];\n        }, object);\n        return object;\n    },\n\n    /**\n     * Transform number or array configs into objects. Used internally to unify\n     * the different configuration formats for points. For example, a simple\n     * number `10` in a line series will be transformed to `{ y: 10 }`, and an\n     * array config like `[1, 10]` in a scatter series will be transformed to\n     * `{ x: 1, y: 10 }`.\n     *\n     * @function Highcharts.Point#optionsToObject\n     *\n     * @param {number|Array<number>|*} options\n     *        The input option.\n     *\n     * @return {*}\n     *         Transformed options.\n     */\n    optionsToObject: function (options) {\n        var ret = {},\n            series = this.series,\n            keys = series.options.keys,\n            pointArrayMap = keys || series.pointArrayMap || ['y'],\n            valueCount = pointArrayMap.length,\n            firstItemType,\n            i = 0,\n            j = 0;\n\n        if (isNumber(options) || options === null) {\n            ret[pointArrayMap[0]] = options;\n\n        } else if (isArray(options)) {\n            // with leading x value\n            if (!keys && options.length > valueCount) {\n                firstItemType = typeof options[0];\n                if (firstItemType === 'string') {\n                    ret.name = options[0];\n                } else if (firstItemType === 'number') {\n                    ret.x = options[0];\n                }\n                i++;\n            }\n            while (j < valueCount) {\n                // Skip undefined positions for keys\n                if (!keys || options[i] !== undefined) {\n                    if (pointArrayMap[j].indexOf('.') > 0) {\n                        // Handle nested keys, e.g. ['color.pattern.image']\n                        // Avoid function call unless necessary.\n                        H.Point.prototype.setNestedProperty(\n                            ret, options[i], pointArrayMap[j]\n                        );\n                    } else {\n                        ret[pointArrayMap[j]] = options[i];\n                    }\n                }\n                i++;\n                j++;\n            }\n        } else if (typeof options === 'object') {\n            ret = options;\n\n            // This is the fastest way to detect if there are individual point\n            // dataLabels that need to be considered in drawDataLabels. These\n            // can only occur in object configs.\n            if (options.dataLabels) {\n                series._hasPointLabels = true;\n            }\n\n            // Same approach as above for markers\n            if (options.marker) {\n                series._hasPointMarkers = true;\n            }\n        }\n        return ret;\n    },\n\n    /**\n     * Get the CSS class names for individual points. Used internally where the\n     * returned value is set on every point.\n     *\n     * @function Highcharts.Point#getClassName\n     *\n     * @return {string}\n     *         The class names.\n     */\n    getClassName: function () {\n        return 'highcharts-point' +\n            (this.selected ? ' highcharts-point-select' : '') +\n            (this.negative ? ' highcharts-negative' : '') +\n            (this.isNull ? ' highcharts-null-point' : '') +\n            (this.colorIndex !== undefined ? ' highcharts-color-' +\n                this.colorIndex : '') +\n            (this.options.className ? ' ' + this.options.className : '') +\n            (this.zone && this.zone.className ? ' ' +\n                this.zone.className.replace('highcharts-negative', '') : '');\n    },\n\n    /**\n     * In a series with `zones`, return the zone that the point belongs to.\n     *\n     * @function Highcharts.Point#getZone\n     *\n     * @return {Highcharts.PlotSeriesZonesOptions}\n     *         The zone item.\n     */\n    getZone: function () {\n        var series = this.series,\n            zones = series.zones,\n            zoneAxis = series.zoneAxis || 'y',\n            i = 0,\n            zone;\n\n        zone = zones[i];\n        while (this[zoneAxis] >= zone.value) {\n            zone = zones[++i];\n        }\n\n        // For resetting or reusing the point (#8100)\n        if (!this.nonZonedColor) {\n            this.nonZonedColor = this.color;\n        }\n\n        if (zone && zone.color && !this.options.color) {\n            this.color = zone.color;\n        } else {\n            this.color = this.nonZonedColor;\n        }\n\n        return zone;\n    },\n\n    /**\n     * Destroy a point to clear memory. Its reference still stays in\n     * `series.data`.\n     *\n     * @private\n     * @function Highcharts.Point#destroy\n     */\n    destroy: function () {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            hoverPoints = chart.hoverPoints,\n            prop;\n\n        chart.pointCount--;\n\n        if (hoverPoints) {\n            point.setState();\n            erase(hoverPoints, point);\n            if (!hoverPoints.length) {\n                chart.hoverPoints = null;\n            }\n\n        }\n        if (point === chart.hoverPoint) {\n            point.onMouseOut();\n        }\n\n        // Remove all events\n        if (point.graphic || point.dataLabel) {\n            removeEvent(point);\n            point.destroyElements();\n        }\n\n        if (point.legendItem) { // pies have legend items\n            chart.legend.destroyItem(point);\n        }\n\n        for (prop in point) {\n            point[prop] = null;\n        }\n    },\n\n    /**\n     * Destroy SVG elements associated with the point.\n     *\n     * @private\n     * @function Highcharts.Point#destroyElements\n     */\n    destroyElements: function () {\n        var point = this,\n            props = [\n                'graphic',\n                'dataLabel',\n                'dataLabelUpper',\n                'connector',\n                'shadowGroup'\n            ],\n            prop,\n            i = 6;\n        while (i--) {\n            prop = props[i];\n            if (point[prop]) {\n                point[prop] = point[prop].destroy();\n            }\n        }\n    },\n\n    /**\n     * Return the configuration hash needed for the data label and tooltip\n     * formatters.\n     *\n     * @function Highcharts.Point#getLabelConfig\n     *\n     * @return {Highcharts.PointLabelObject}\n     *         Abstract object used in formatters and formats.\n     */\n    getLabelConfig: function () {\n        return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            colorIndex: this.colorIndex,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n        };\n    },\n\n    /**\n     * Extendable method for formatting each point's tooltip line.\n     *\n     * @function Highcharts.Point#tooltipFormatter\n     *\n     * @param {string} pointFormat\n     *        The point format.\n     *\n     * @return {string}\n     *         A string to be concatenated in to the common tooltip text.\n     */\n    tooltipFormatter: function (pointFormat) {\n\n        // Insert options for valueDecimals, valuePrefix, and valueSuffix\n        var series = this.series,\n            seriesTooltipOptions = series.tooltipOptions,\n            valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n            valuePrefix = seriesTooltipOptions.valuePrefix || '',\n            valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n        // Loop over the point array map and replace unformatted values with\n        // sprintf formatting markup\n        each(series.pointArrayMap || ['y'], function (key) {\n            key = '{point.' + key; // without the closing bracket\n            if (valuePrefix || valueSuffix) {\n                pointFormat = pointFormat.replace(\n                    RegExp(key + '}', 'g'),\n                    valuePrefix + key + '}' + valueSuffix\n                );\n            }\n            pointFormat = pointFormat.replace(\n                RegExp(key + '}', 'g'),\n                key + ':,.' + valueDecimals + 'f}'\n            );\n        });\n\n        return format(pointFormat, {\n            point: this,\n            series: this.series\n        }, series.chart.time);\n    },\n\n    /**\n     * Fire an event on the Point object.\n     *\n     * @private\n     * @function Highcharts.Point#firePointEvent\n     *\n     * @param {string} eventType\n     *        Type of the event.\n     *\n     * @param {*} eventArgs\n     *        Additional event arguments.\n     *\n     * @param {Function} defaultFunction\n     *        Default event handler.\n     *\n     * @fires Highcharts.Point#event:*\n     */\n    firePointEvent: function (eventType, eventArgs, defaultFunction) {\n        var point = this,\n            series = this.series,\n            seriesOptions = series.options;\n\n        // load event handlers on demand to save time on mouseover/out\n        if (\n            seriesOptions.point.events[eventType] ||\n            (\n                point.options &&\n                point.options.events &&\n                point.options.events[eventType]\n            )\n        ) {\n            this.importEvents();\n        }\n\n        // add default handler if in selection mode\n        if (eventType === 'click' && seriesOptions.allowPointSelect) {\n            defaultFunction = function (event) {\n                // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n                // for Opera.\n                if (point.select) { // #2911\n                    point.select(\n                        null,\n                        event.ctrlKey || event.metaKey || event.shiftKey\n                    );\n                }\n            };\n        }\n\n        fireEvent(this, eventType, eventArgs, defaultFunction);\n    },\n\n    /**\n     * For certain series types, like pie charts, where individual points can\n     * be shown or hidden.\n     *\n     * @name Highcharts.Point#visible\n     * @type {boolean}\n     */\n    visible: true\n};\n\n/**\n * For categorized axes this property holds the category name for the\n * point. For other axes it holds the X value.\n *\n * @name Highcharts.Point#category\n * @type {number|string}\n */\n\n/**\n * The name of the point. The name can be given as the first position of the\n * point configuration array, or as a `name` property in the configuration:\n *\n * @example\n * // Array config\n * data: [\n *     ['John', 1],\n *     ['Jane', 2]\n * ]\n *\n * // Object config\n * data: [{\n *        name: 'John',\n *        y: 1\n * }, {\n *     name: 'Jane',\n *     y: 2\n * }]\n *\n * @name Highcharts.Point#name\n * @type {string}\n */\n\n\n/**\n * The percentage for points in a stacked series or pies.\n *\n * @name Highcharts.Point#percentage\n * @type {number}\n */\n\n/**\n * The total of values in either a stack for stacked series, or a pie in a pie\n * series.\n *\n * @name Highcharts.Point#total\n * @type {number}\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Point.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Pointer.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Pointer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tooltip.js */ \"./node_modules/highcharts/js/es-modules/parts/Tooltip.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * One position in relation to an axis.\n *\n * @typedef Highcharts.PointerAxisCoordinateObject\n *\n * @property {Highcharts.Axis} axis\n *           Related axis.\n *\n * @property {number} value\n *           Axis value.\n */\n\n/**\n * Positions in terms of axis values.\n *\n * @typedef Highcharts.PointerAxisCoordinatesObject\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} xAxis\n *           Positions on the x-axis.\n *\n * @property {Array<Highcharts.PointerAxisCoordinateObject>} yAxis\n *           Positions on the y-axis.\n */\n\n/**\n * Pointer coordinates.\n *\n * @typedef Highcharts.PointerCoordinatesObject\n *\n * @property {number} chartX\n *\n * @property {number} chartY\n */\n\n/**\n * A native browser mouse or touch event, extended with position information\n * relative to the {@link Chart.container}.\n *\n * @typedef {global.PointerEvent} Highcharts.PointerEventObject\n *\n * @property {number} chartX\n *           The X coordinate of the pointer interaction relative to the\n *           chart.\n *\n * @property {number} chartY\n *           The Y coordinate of the pointer interaction relative to the\n *           chart.\n */\n\n/**\n * Axis-specific data of a selection.\n *\n * @typedef Highcharts.SelectDataObject\n *\n * @property {Highcharts.Axis} axis\n *\n * @property {number} min\n *\n * @property {number} max\n */\n\n/**\n * Object for select events.\n *\n * @typedef Highcharts.SelectEventObject\n *\n * @property {global.Event} originalEvent\n *\n * @property {Array<Highcharts.SelectDataObject>} xAxis\n *\n * @property {Array<Highcharts.SelectDataObject>} yAxis\n */\n\n\n\n\n\n\n\n\nvar H = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    addEvent = H.addEvent,\n    attr = H.attr,\n    charts = H.charts,\n    color = H.color,\n    css = H.css,\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    find = H.find,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    isObject = H.isObject,\n    offset = H.offset,\n    pick = H.pick,\n    splat = H.splat,\n    Tooltip = H.Tooltip;\n\n/**\n * The mouse and touch tracker object. Each {@link Chart} item has one\n * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}\n * property.\n *\n * @class\n * @name Highcharts.Pointer\n *\n * @param {Highcharts.Chart} chart\n *        The Chart instance.\n *\n * @param {Highcharts.Options} options\n *        The root options object. The pointer uses options from the chart and\n *        tooltip structures.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer = function (chart, options) {\n    this.init(chart, options);\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer.prototype = {\n    /**\n     * Initialize the Pointer.\n     *\n     * @private\n     * @function Highcharts.Pointer#init\n     *\n     * @param {Highcharts.Chart} chart\n     *        The Chart instance.\n     *\n     * @param {Highcharts.Options} options\n     *        The root options object. The pointer uses options from the chart\n     *        and tooltip structures.\n     */\n    init: function (chart, options) {\n\n        // Store references\n        this.options = options;\n        this.chart = chart;\n\n        // Do we need to handle click on a touch device?\n        this.runChartClick =\n            options.chart.events && !!options.chart.events.click;\n\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n\n        if (Tooltip) {\n            /**\n             * Tooltip object for points of series.\n             *\n             * @name Highcharts.Chart#tooltip\n             * @type {Highcharts.Tooltip}\n             */\n            chart.tooltip = new Tooltip(chart, options.tooltip);\n            this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n        }\n\n        this.setDOMEvents();\n    },\n\n    /**\n     * Resolve the zoomType option, this is reset on all touch start and mouse\n     * down events.\n     *\n     * @private\n     * @function Highcharts.Pointer#zoomOption\n     *\n     * @param {global.Event} e\n     *        Event object.\n     */\n    zoomOption: function (e) {\n        var chart = this.chart,\n            options = chart.options.chart,\n            zoomType = options.zoomType || '',\n            inverted = chart.inverted,\n            zoomX,\n            zoomY;\n\n        // Look for the pinchType option\n        if (/touch/.test(e.type)) {\n            zoomType = pick(options.pinchType, zoomType);\n        }\n\n        this.zoomX = zoomX = /x/.test(zoomType);\n        this.zoomY = zoomY = /y/.test(zoomType);\n        this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n        this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n        this.hasZoom = zoomX || zoomY;\n    },\n\n    /**\n     * Takes a browser event object and extends it with custom Highcharts\n     * properties `chartX` and `chartY` in order to work on the internal\n     * coordinate system.\n     *\n     * @function Highcharts.Pointer#normalize\n     *\n     * @param {global.Event} e\n     *        Event object in standard browsers.\n     *\n     * @return {Highcharts.PointerEventObject}\n     *         A browser event with extended properties `chartX` and `chartY`.\n     */\n    normalize: function (e, chartPosition) {\n        var ePos;\n\n        // iOS (#2757)\n        ePos = e.touches ?\n            (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) :\n            e;\n\n        // Get mouse position\n        if (!chartPosition) {\n            this.chartPosition = chartPosition = offset(this.chart.container);\n        }\n\n        return extend(e, {\n            chartX: Math.round(ePos.pageX - chartPosition.left),\n            chartY: Math.round(ePos.pageY - chartPosition.top)\n        });\n    },\n\n    /**\n     * Get the click position in terms of axis values.\n     *\n     * @function Highcharts.Pointer#getCoordinates\n     *\n     * @param {Highcharts.PointerEventObject} e\n     *        Pointer event, extended with `chartX` and `chartY` properties.\n     *\n     * @return {Highcharts.PointerAxisCoordinatesObject}\n     */\n    getCoordinates: function (e) {\n\n        var coordinates = {\n            xAxis: [],\n            yAxis: []\n        };\n\n        each(this.chart.axes, function (axis) {\n            coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                axis: axis,\n                value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n            });\n        });\n\n        return coordinates;\n    },\n\n    /**\n     * Finds the closest point to a set of coordinates, using the k-d-tree\n     * algorithm.\n     *\n     * @function Highcharts.Pointer#findNearestKDPoints\n     *\n     * @param {Array<Highcharts.Series>} series\n     *        All the series to search in.\n     *\n     * @param {boolean} shared\n     *        Whether it is a shared tooltip or not.\n     *\n     * @param {Highcharts.PointerCoordinatesObject} coordinates\n     *        Chart coordinates of the pointer.\n     *\n     * @return {Point|undefined}\n     *         The point closest to given coordinates.\n     */\n    findNearestKDPoint: function (series, shared, coordinates) {\n        var closest,\n            sort = function (p1, p2) {\n                var isCloserX = p1.distX - p2.distX,\n                    isCloser = p1.dist - p2.dist,\n                    isAbove =\n                        (p2.series.group && p2.series.group.zIndex) -\n                        (p1.series.group && p1.series.group.zIndex),\n                    result;\n\n                // We have two points which are not in the same place on xAxis\n                // and shared tooltip:\n                if (isCloserX !== 0 && shared) { // #5721\n                    result = isCloserX;\n                // Points are not exactly in the same place on x/yAxis:\n                } else if (isCloser !== 0) {\n                    result = isCloser;\n                // The same xAxis and yAxis position, sort by z-index:\n                } else if (isAbove !== 0) {\n                    result = isAbove;\n                // The same zIndex, sort by array index:\n                } else {\n                    result = p1.series.index > p2.series.index ? -1 : 1;\n                }\n                return result;\n            };\n        each(series, function (s) {\n            var noSharedTooltip = s.noSharedTooltip && shared,\n                compareX = (\n                    !noSharedTooltip &&\n                    s.options.findNearestPointBy.indexOf('y') < 0\n                ),\n                point = s.searchPoint(\n                    coordinates,\n                    compareX\n                );\n            if (\n                // Check that we actually found a point on the series.\n                isObject(point, true) &&\n                // Use the new point if it is closer.\n                (!isObject(closest, true) || (sort(closest, point) > 0))\n            ) {\n                closest = point;\n            }\n        });\n        return closest;\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#getPointFromEvent\n     *\n     * @param {global.Event} e\n     *\n     * @return {Highcharts.Point|undefined}\n     */\n    getPointFromEvent: function (e) {\n        var target = e.target,\n            point;\n\n        while (target && !point) {\n            point = target.point;\n            target = target.parentNode;\n        }\n        return point;\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#getChartCoordinatesFromPoint\n     *\n     * @param {Highcharts.Point} point\n     *\n     * @param {boolean} inverted\n     *\n     * @return {Highcharts.PointerCoordinatesObject}\n     */\n    getChartCoordinatesFromPoint: function (point, inverted) {\n        var series = point.series,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            plotX = pick(point.clientX, point.plotX),\n            shapeArgs = point.shapeArgs;\n\n        if (xAxis && yAxis) {\n            return inverted ? {\n                chartX: xAxis.len + xAxis.pos - plotX,\n                chartY: yAxis.len + yAxis.pos - point.plotY\n            } : {\n                chartX: plotX + xAxis.pos,\n                chartY: point.plotY + yAxis.pos\n            };\n        } else if (shapeArgs && shapeArgs.x && shapeArgs.y) {\n            // E.g. pies do not have axes\n            return {\n                chartX: shapeArgs.x,\n                chartY: shapeArgs.y\n            };\n        }\n    },\n\n    /**\n     * Calculates what is the current hovered point/points and series.\n     *\n     * @private\n     * @function Highcharts.Pointer#getHoverData\n     *\n     * @param {Highcharts.Point|undefined} existingHoverPoint\n     *        The point currrently beeing hovered.\n     *\n     * @param {Highcharts.Series|undefined} existingHoverSeries\n     *        The series currently beeing hovered.\n     *\n     * @param {Array<Highcharts.Series>} series\n     *        All the series in the chart.\n     *\n     * @param {boolean} isDirectTouch\n     *        Is the pointer directly hovering the point.\n     *\n     * @param {boolean} shared\n     *        Whether it is a shared tooltip or not.\n     *\n     * @param {Highcharts.PointerCoordinatesObject} coordinates\n     *        Chart coordinates of the pointer.\n     *\n     * @return {*}\n     *         Object containing resulting hover data: hoverPoint, hoverSeries,\n     *         and hoverPoints.\n     */\n    getHoverData: function (\n        existingHoverPoint,\n        existingHoverSeries,\n        series,\n        isDirectTouch,\n        shared,\n        coordinates,\n        params\n    ) {\n        var hoverPoint,\n            hoverPoints = [],\n            hoverSeries = existingHoverSeries,\n            isBoosting = params && params.isBoosting,\n            useExisting = !!(isDirectTouch && existingHoverPoint),\n            notSticky = hoverSeries && !hoverSeries.stickyTracking,\n            filter = function (s) {\n                return (\n                    s.visible &&\n                    !(!shared && s.directTouch) && // #3821\n                    pick(s.options.enableMouseTracking, true)\n                );\n            },\n            // Which series to look in for the hover point\n            searchSeries = notSticky ?\n                // Only search on hovered series if it has stickyTracking false\n                [hoverSeries] :\n                // Filter what series to look in.\n                H.grep(series, function (s) {\n                    return filter(s) && s.stickyTracking;\n                });\n\n        // Use existing hovered point or find the one closest to coordinates.\n        hoverPoint = useExisting ?\n            existingHoverPoint :\n            this.findNearestKDPoint(searchSeries, shared, coordinates);\n\n        // Assign hover series\n        hoverSeries = hoverPoint && hoverPoint.series;\n\n        // If we have a hoverPoint, assign hoverPoints.\n        if (hoverPoint) {\n            // When tooltip is shared, it displays more than one point\n            if (shared && !hoverSeries.noSharedTooltip) {\n                searchSeries = H.grep(series, function (s) {\n                    return filter(s) && !s.noSharedTooltip;\n                });\n\n                // Get all points with the same x value as the hoverPoint\n                each(searchSeries, function (s) {\n                    var point = find(s.points, function (p) {\n                        return p.x === hoverPoint.x && !p.isNull;\n                    });\n                    if (isObject(point)) {\n                        /*\n                        * Boost returns a minimal point. Convert it to a usable\n                        * point for tooltip and states.\n                        */\n                        if (isBoosting) {\n                            point = s.getPoint(point);\n                        }\n                        hoverPoints.push(point);\n                    }\n                });\n            } else {\n                hoverPoints.push(hoverPoint);\n            }\n        }\n        return {\n            hoverPoint: hoverPoint,\n            hoverSeries: hoverSeries,\n            hoverPoints: hoverPoints\n        };\n    },\n\n    /**\n     * With line type charts with a single tracker, get the point closest to the\n     * mouse. Run Point.onMouseOver and display tooltip for the point or points.\n     *\n     * @private\n     * @function Highcharts.Pointer#runPointActions\n     *\n     * @param {global.Event} e\n     *\n     * @param {Highcharts.Point} p\n     *\n     * @fires Highcharts.Point#event:mouseOut\n     * @fires Highcharts.Point#event:mouseOver\n     */\n    runPointActions: function (e, p) {\n        var pointer = this,\n            chart = pointer.chart,\n            series = chart.series,\n            tooltip = chart.tooltip && chart.tooltip.options.enabled ?\n                chart.tooltip :\n                undefined,\n            shared = tooltip ? tooltip.shared : false,\n            hoverPoint = p || chart.hoverPoint,\n            hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,\n            // onMouseOver or already hovering a series with directTouch\n            isDirectTouch = e.type !== 'touchmove' && (\n                !!p || (\n                    (hoverSeries && hoverSeries.directTouch) &&\n                    pointer.isDirectTouch\n                )\n            ),\n            hoverData = this.getHoverData(\n                hoverPoint,\n                hoverSeries,\n                series,\n                isDirectTouch,\n                shared,\n                e,\n                { isBoosting: chart.isBoosting }\n            ),\n            useSharedTooltip,\n            followPointer,\n            anchor,\n            points;\n\n        // Update variables from hoverData.\n        hoverPoint = hoverData.hoverPoint;\n        points = hoverData.hoverPoints;\n        hoverSeries = hoverData.hoverSeries;\n        followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n        useSharedTooltip = (\n            shared &&\n            hoverSeries &&\n            !hoverSeries.noSharedTooltip\n        );\n\n        // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n        // #3926, #4200\n        if (\n            hoverPoint &&\n            // !(hoverSeries && hoverSeries.directTouch) &&\n            (hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))\n        ) {\n            each(chart.hoverPoints || [], function (p) {\n                if (H.inArray(p, points) === -1) {\n                    p.setState();\n                }\n            });\n            // Do mouseover on all points (#3919, #3985, #4410, #5622)\n            each(points || [], function (p) {\n                p.setState('hover');\n            });\n            // set normal state to previous series\n            if (chart.hoverSeries !== hoverSeries) {\n                hoverSeries.onMouseOver();\n            }\n\n            // If tracking is on series in stead of on each point,\n            // fire mouseOver on hover point. // #4448\n            if (chart.hoverPoint) {\n                chart.hoverPoint.firePointEvent('mouseOut');\n            }\n\n            // Hover point may have been destroyed in the event handlers (#7127)\n            if (!hoverPoint.series) {\n                return;\n            }\n\n            hoverPoint.firePointEvent('mouseOver');\n            chart.hoverPoints = points;\n            chart.hoverPoint = hoverPoint;\n            // Draw tooltip if necessary\n            if (tooltip) {\n                tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n            }\n        // Update positions (regardless of kdpoint or hoverPoint)\n        } else if (followPointer && tooltip && !tooltip.isHidden) {\n            anchor = tooltip.getAnchor([{}], e);\n            tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n        }\n\n        // Start the event listener to pick up the tooltip and crosshairs\n        if (!pointer.unDocMouseMove) {\n            pointer.unDocMouseMove = addEvent(\n                chart.container.ownerDocument,\n                'mousemove',\n                function (e) {\n                    var chart = charts[H.hoverChartIndex];\n                    if (chart) {\n                        chart.pointer.onDocumentMouseMove(e);\n                    }\n                }\n            );\n        }\n\n        // Issues related to crosshair #4927, #5269 #5066, #5658\n        each(chart.axes, function drawAxisCrosshair(axis) {\n            var snap = pick(axis.crosshair.snap, true),\n                point = !snap ?\n                    undefined :\n                    H.find(points, function (p) {\n                        return p.series[axis.coll] === axis;\n                    });\n\n            // Axis has snapping crosshairs, and one of the hover points belongs\n            // to axis. Always call drawCrosshair when it is not snap.\n            if (point || !snap) {\n                axis.drawCrosshair(e, point);\n            // Axis has snapping crosshairs, but no hover point belongs to axis\n            } else {\n                axis.hideCrosshair();\n            }\n        });\n    },\n\n    /**\n     * Reset the tracking by hiding the tooltip, the hover series state and the\n     * hover point\n     *\n     * @function Highcharts.Pointer#reset\n     *\n     * @param {boolean} allowMove\n     *        Instead of destroying the tooltip altogether, allow moving it if\n     *        possible.\n     *\n     * @param {number} delay\n     */\n    reset: function (allowMove, delay) {\n        var pointer = this,\n            chart = pointer.chart,\n            hoverSeries = chart.hoverSeries,\n            hoverPoint = chart.hoverPoint,\n            hoverPoints = chart.hoverPoints,\n            tooltip = chart.tooltip,\n            tooltipPoints = tooltip && tooltip.shared ?\n                hoverPoints :\n                hoverPoint;\n\n        // Check if the points have moved outside the plot area (#1003, #4736,\n        // #5101)\n        if (allowMove && tooltipPoints) {\n            each(splat(tooltipPoints), function (point) {\n                if (point.series.isCartesian && point.plotX === undefined) {\n                    allowMove = false;\n                }\n            });\n        }\n\n        // Just move the tooltip, #349\n        if (allowMove) {\n            if (tooltip && tooltipPoints) {\n                tooltip.refresh(tooltipPoints);\n                if (tooltip.shared && hoverPoints) { // #8284\n                    each(hoverPoints, function (point) {\n                        point.setState(point.state, true);\n                        if (point.series.xAxis.crosshair) {\n                            point.series.xAxis.drawCrosshair(null, point);\n                        }\n                        if (point.series.yAxis.crosshair) {\n                            point.series.yAxis.drawCrosshair(null, point);\n                        }\n                    });\n                } else if (hoverPoint) { // #2500\n                    hoverPoint.setState(hoverPoint.state, true);\n                    each(chart.axes, function (axis) {\n                        if (axis.crosshair) {\n                            axis.drawCrosshair(null, hoverPoint);\n                        }\n                    });\n                }\n            }\n\n        // Full reset\n        } else {\n\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            if (hoverSeries) {\n                hoverSeries.onMouseOut();\n            }\n\n            if (tooltip) {\n                tooltip.hide(delay);\n            }\n\n            if (pointer.unDocMouseMove) {\n                pointer.unDocMouseMove = pointer.unDocMouseMove();\n            }\n\n            // Remove crosshairs\n            each(chart.axes, function (axis) {\n                axis.hideCrosshair();\n            });\n\n            pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n        }\n    },\n\n    /**\n     * Scale series groups to a certain scale and translation.\n     *\n     * @private\n     * @function Highcharts.Pointer#scaleGroups\n     *\n     * @param {Highcharts.SeriesPlotBoxObject} attribs\n     *\n     * @param {boolean} clip\n     */\n    scaleGroups: function (attribs, clip) {\n\n        var chart = this.chart,\n            seriesAttribs;\n\n        // Scale each series\n        each(chart.series, function (series) {\n            seriesAttribs = attribs || series.getPlotBox(); // #1701\n            if (series.xAxis && series.xAxis.zoomEnabled && series.group) {\n                series.group.attr(seriesAttribs);\n                if (series.markerGroup) {\n                    series.markerGroup.attr(seriesAttribs);\n                    series.markerGroup.clip(clip ? chart.clipRect : null);\n                }\n                if (series.dataLabelsGroup) {\n                    series.dataLabelsGroup.attr(seriesAttribs);\n                }\n            }\n        });\n\n        // Clip\n        chart.clipRect.attr(clip || chart.clipBox);\n    },\n\n    /**\n     * Start a drag operation.\n     *\n     * @private\n     * @function Highcharts.Pointer#dragStart\n     *\n     * @param {Highcharts.PointerEventObject} e\n     */\n    dragStart: function (e) {\n        var chart = this.chart;\n\n        // Record the start position\n        chart.mouseIsDown = e.type;\n        chart.cancelClick = false;\n        chart.mouseDownX = this.mouseDownX = e.chartX;\n        chart.mouseDownY = this.mouseDownY = e.chartY;\n    },\n\n    /**\n     * Perform a drag operation in response to a mousemove event while the mouse\n     * is down.\n     *\n     * @private\n     * @function Highcharts.Pointer#drag\n     *\n     * @param {Highcharts.PointerEventObject} e\n     */\n    drag: function (e) {\n\n        var chart = this.chart,\n            chartOptions = chart.options.chart,\n            chartX = e.chartX,\n            chartY = e.chartY,\n            zoomHor = this.zoomHor,\n            zoomVert = this.zoomVert,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop,\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            clickedInside,\n            size,\n            selectionMarker = this.selectionMarker,\n            mouseDownX = this.mouseDownX,\n            mouseDownY = this.mouseDownY,\n            panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n        // If the device supports both touch and mouse (like IE11), and we are\n        // touch-dragging inside the plot area, don't handle the mouse event.\n        // #4339.\n        if (selectionMarker && selectionMarker.touch) {\n            return;\n        }\n\n        // If the mouse is outside the plot area, adjust to cooordinates\n        // inside to prevent the selection marker from going outside\n        if (chartX < plotLeft) {\n            chartX = plotLeft;\n        } else if (chartX > plotLeft + plotWidth) {\n            chartX = plotLeft + plotWidth;\n        }\n\n        if (chartY < plotTop) {\n            chartY = plotTop;\n        } else if (chartY > plotTop + plotHeight) {\n            chartY = plotTop + plotHeight;\n        }\n\n        // determine if the mouse has moved more than 10px\n        this.hasDragged = Math.sqrt(\n            Math.pow(mouseDownX - chartX, 2) +\n            Math.pow(mouseDownY - chartY, 2)\n        );\n\n        if (this.hasDragged > 10) {\n            clickedInside = chart.isInsidePlot(\n                mouseDownX - plotLeft,\n                mouseDownY - plotTop\n            );\n\n            // make a selection\n            if (\n                chart.hasCartesianSeries &&\n                (this.zoomX || this.zoomY) &&\n                clickedInside &&\n                !panKey\n            ) {\n                if (!selectionMarker) {\n                    this.selectionMarker = selectionMarker =\n                        chart.renderer.rect(\n                            plotLeft,\n                            plotTop,\n                            zoomHor ? 1 : plotWidth,\n                            zoomVert ? 1 : plotHeight,\n                            0\n                        )\n                        .attr({\n                            \n                            'class': 'highcharts-selection-marker',\n                            'zIndex': 7\n                        })\n                        .add();\n                }\n            }\n\n            // adjust the width of the selection marker\n            if (selectionMarker && zoomHor) {\n                size = chartX - mouseDownX;\n                selectionMarker.attr({\n                    width: Math.abs(size),\n                    x: (size > 0 ? 0 : size) + mouseDownX\n                });\n            }\n            // adjust the height of the selection marker\n            if (selectionMarker && zoomVert) {\n                size = chartY - mouseDownY;\n                selectionMarker.attr({\n                    height: Math.abs(size),\n                    y: (size > 0 ? 0 : size) + mouseDownY\n                });\n            }\n\n            // panning\n            if (clickedInside && !selectionMarker && chartOptions.panning) {\n                chart.pan(e, chartOptions.panning);\n            }\n        }\n    },\n\n    /**\n     * On mouse up or touch end across the entire document, drop the selection.\n     *\n     * @private\n     * @function Highcharts.Pointer#drop\n     *\n     * @param {global.Event} e\n     */\n    drop: function (e) {\n        var pointer = this,\n            chart = this.chart,\n            hasPinched = this.hasPinched;\n\n        if (this.selectionMarker) {\n            var selectionData = {\n                    originalEvent: e, // #4890\n                    xAxis: [],\n                    yAxis: []\n                },\n                selectionBox = this.selectionMarker,\n                selectionLeft = selectionBox.attr ?\n                    selectionBox.attr('x') :\n                    selectionBox.x,\n                selectionTop = selectionBox.attr ?\n                    selectionBox.attr('y') :\n                    selectionBox.y,\n                selectionWidth = selectionBox.attr ?\n                    selectionBox.attr('width') :\n                    selectionBox.width,\n                selectionHeight = selectionBox.attr ?\n                    selectionBox.attr('height') :\n                    selectionBox.height,\n                runZoom;\n\n            // a selection has been made\n            if (this.hasDragged || hasPinched) {\n\n                // record each axis' min and max\n                each(chart.axes, function (axis) {\n                    if (\n                        axis.zoomEnabled &&\n                        defined(axis.min) &&\n                        (\n                            hasPinched ||\n                            pointer[{\n                                xAxis: 'zoomX',\n                                yAxis: 'zoomY'\n                            }[axis.coll]]\n                        )\n                    ) { // #859, #3569\n                        var horiz = axis.horiz,\n                            minPixelPadding = e.type === 'touchend' ?\n                                axis.minPixelPadding :\n                                0, // #1207, #3075\n                            selectionMin = axis.toValue(\n                                (horiz ? selectionLeft : selectionTop) +\n                                minPixelPadding\n                            ),\n                            selectionMax = axis.toValue(\n                                (\n                                    horiz ?\n                                        selectionLeft + selectionWidth :\n                                        selectionTop + selectionHeight\n                                ) - minPixelPadding\n                                );\n\n                        selectionData[axis.coll].push({\n                            axis: axis,\n                            // Min/max for reversed axes\n                            min: Math.min(selectionMin, selectionMax),\n                            max: Math.max(selectionMin, selectionMax)\n                        });\n                        runZoom = true;\n                    }\n                });\n                if (runZoom) {\n                    fireEvent(\n                        chart,\n                        'selection',\n                        selectionData,\n                        function (args) {\n                            chart.zoom(\n                                extend(\n                                    args,\n                                    hasPinched ? { animation: false } : null\n                                )\n                            );\n                        }\n                    );\n                }\n\n            }\n\n            if (isNumber(chart.index)) {\n                this.selectionMarker = this.selectionMarker.destroy();\n            }\n\n            // Reset scaling preview\n            if (hasPinched) {\n                this.scaleGroups();\n            }\n        }\n\n        // Reset all. Check isNumber because it may be destroyed on mouse up\n        // (#877)\n        if (chart && isNumber(chart.index)) {\n            css(chart.container, { cursor: chart._cursor });\n            chart.cancelClick = this.hasDragged > 10; // #370\n            chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n            this.pinchDown = [];\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseDown\n     *\n     * @param {global.Event} e\n     */\n    onContainerMouseDown: function (e) {\n        // Normalize before the 'if' for the legacy IE (#7850)\n        e = this.normalize(e);\n\n        if (e.button !== 2) {\n\n            this.zoomOption(e);\n\n            // issue #295, dragging not always working in Firefox\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            this.dragStart(e);\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onDocumentMouseUp\n     *\n     * @param {global.Event} e\n     */\n    onDocumentMouseUp: function (e) {\n        if (charts[H.hoverChartIndex]) {\n            charts[H.hoverChartIndex].pointer.drop(e);\n        }\n    },\n\n    /**\n     * Special handler for mouse move that will hide the tooltip when the mouse\n     * leaves the plotarea. Issue #149 workaround. The mouseleave event does not\n     * always fire.\n     *\n     * @private\n     * @function Highcharts.Pointer#onDocumentMouseMove\n     *\n     * @param {Highcharts.PointerEventObject} e\n     */\n    onDocumentMouseMove: function (e) {\n        var chart = this.chart,\n            chartPosition = this.chartPosition;\n\n        e = this.normalize(e, chartPosition);\n\n        // If we're outside, hide the tooltip\n        if (\n            chartPosition &&\n            !this.inClass(e.target, 'highcharts-tracker') &&\n            !chart.isInsidePlot(\n                e.chartX - chart.plotLeft,\n                e.chartY - chart.plotTop\n            )\n        ) {\n            this.reset();\n        }\n    },\n\n    /**\n     * When mouse leaves the container, hide the tooltip.\n     *\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseLeave\n     *\n     * @param {global.Event} e\n     */\n    onContainerMouseLeave: function (e) {\n        var chart = charts[H.hoverChartIndex];\n        // #4886, MS Touch end fires mouseleave but with no related target\n        if (chart && (e.relatedTarget || e.toElement)) {\n            chart.pointer.reset();\n            // Also reset the chart position, used in #149 fix\n            chart.pointer.chartPosition = null;\n        }\n    },\n\n    /**\n     * The mousemove, touchmove and touchstart event handler\n     *\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseMove\n     *\n     * @param {Highcharts.PointerEventObject} e\n     */\n    onContainerMouseMove: function (e) {\n\n        var chart = this.chart;\n\n        if (\n            !defined(H.hoverChartIndex) ||\n            !charts[H.hoverChartIndex] ||\n            !charts[H.hoverChartIndex].mouseIsDown\n        ) {\n            H.hoverChartIndex = chart.index;\n        }\n\n        e = this.normalize(e);\n        e.returnValue = false; // #2251, #3224\n\n        if (chart.mouseIsDown === 'mousedown') {\n            this.drag(e);\n        }\n\n        // Show the tooltip and run mouse over events (#977)\n        if (\n            (\n                this.inClass(e.target, 'highcharts-tracker') ||\n                chart.isInsidePlot(\n                    e.chartX - chart.plotLeft,\n                    e.chartY - chart.plotTop\n                )\n            ) &&\n            !chart.openMenu\n        ) {\n            this.runPointActions(e);\n        }\n    },\n\n    /**\n     * Utility to detect whether an element has, or has a parent with, a\n     * specificclass name. Used on detection of tracker objects and on deciding\n     * whether hovering the tooltip should cause the active series to mouse out.\n     *\n     * @function Highcharts.Pointer#inClass\n     *\n     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n     *        The element to investigate.\n     *\n     * @param {string} className\n     *        The class name to look for.\n     *\n     * @return {boolean}\n     *         True if either the element or one of its parents has the given\n     *         class name.\n     */\n    inClass: function (element, className) {\n        var elemClassName;\n        while (element) {\n            elemClassName = attr(element, 'class');\n            if (elemClassName) {\n                if (elemClassName.indexOf(className) !== -1) {\n                    return true;\n                }\n                if (elemClassName.indexOf('highcharts-container') !== -1) {\n                    return false;\n                }\n            }\n            element = element.parentNode;\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onTrackerMouseOut\n     *\n     * @param {global.Event} e\n     */\n    onTrackerMouseOut: function (e) {\n        var series = this.chart.hoverSeries,\n            relatedTarget = e.relatedTarget || e.toElement;\n\n        this.isDirectTouch = false;\n\n        if (\n            series &&\n            relatedTarget &&\n            !series.stickyTracking &&\n            !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n            (\n                !this.inClass(\n                    relatedTarget,\n                    'highcharts-series-' + series.index\n                ) || // #2499, #4465\n                !this.inClass(relatedTarget, 'highcharts-tracker') // #5553\n            )\n        ) {\n            series.onMouseOut();\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerClick\n     *\n     * @param {Highcharts.PointerEventObject} e\n     */\n    onContainerClick: function (e) {\n        var chart = this.chart,\n            hoverPoint = chart.hoverPoint,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop;\n\n        e = this.normalize(e);\n\n        if (!chart.cancelClick) {\n\n            // On tracker click, fire the series and point events. #783, #1583\n            if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n\n                // the series click event\n                fireEvent(hoverPoint.series, 'click', extend(e, {\n                    point: hoverPoint\n                }));\n\n                // the point click event\n                if (chart.hoverPoint) { // it may be destroyed (#1844)\n                    hoverPoint.firePointEvent('click', e);\n                }\n\n            // When clicking outside a tracker, fire a chart event\n            } else {\n                extend(e, this.getCoordinates(e));\n\n                // fire a click event in the chart\n                if (\n                    chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)\n                ) {\n                    fireEvent(chart, 'click', e);\n                }\n            }\n\n\n        }\n    },\n\n    /**\n     * Set the JS DOM events on the container and document. This method should\n     * contain a one-to-one assignment between methods and their handlers. Any\n     * advanced logic should be moved to the handler reflecting the event's\n     * name.\n     *\n     * @private\n     * @function Highcharts.Pointer#setDOMEvents\n     */\n    setDOMEvents: function () {\n\n        var pointer = this,\n            container = pointer.chart.container,\n            ownerDoc = container.ownerDocument;\n\n        container.onmousedown = function (e) {\n            pointer.onContainerMouseDown(e);\n        };\n        container.onmousemove = function (e) {\n            pointer.onContainerMouseMove(e);\n        };\n        container.onclick = function (e) {\n            pointer.onContainerClick(e);\n        };\n        this.unbindContainerMouseLeave = addEvent(\n            container,\n            'mouseleave',\n            pointer.onContainerMouseLeave\n        );\n        if (!H.unbindDocumentMouseUp) {\n            H.unbindDocumentMouseUp = addEvent(\n                ownerDoc,\n                'mouseup',\n                pointer.onDocumentMouseUp\n            );\n        }\n        if (H.hasTouch) {\n            container.ontouchstart = function (e) {\n                pointer.onContainerTouchStart(e);\n            };\n            container.ontouchmove = function (e) {\n                pointer.onContainerTouchMove(e);\n            };\n            if (!H.unbindDocumentTouchEnd) {\n                H.unbindDocumentTouchEnd = addEvent(\n                    ownerDoc,\n                    'touchend',\n                    pointer.onDocumentTouchEnd\n                );\n            }\n        }\n\n    },\n\n    /**\n     * Destroys the Pointer object and disconnects DOM events.\n     *\n     * @function Highcharts.Pointer#destroy\n     */\n    destroy: function () {\n        var pointer = this;\n\n        if (pointer.unDocMouseMove) {\n            pointer.unDocMouseMove();\n        }\n\n        this.unbindContainerMouseLeave();\n\n        if (!H.chartCount) {\n            if (H.unbindDocumentMouseUp) {\n                H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();\n            }\n            if (H.unbindDocumentTouchEnd) {\n                H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();\n            }\n        }\n\n        // memory and CPU leak\n        clearInterval(pointer.tooltipTimeout);\n\n        H.objectEach(pointer, function (val, prop) {\n            pointer[prop] = null;\n        });\n    }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Pointer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/RangeSelector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/RangeSelector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    discardElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].discardElement,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap;\n\n/* ****************************************************************************\n * Start Range Selector code                                                  *\n *****************************************************************************/\nextend(defaultOptions, {\n\n    /**\n     * The range selector is a tool for selecting ranges to display within\n     * the chart. It provides buttons to select preconfigured ranges in\n     * the chart, like 1 day, 1 week, 1 month etc. It also provides input\n     * boxes where min and max dates can be manually input.\n     *\n     * @product highstock\n     * @optionparent rangeSelector\n     */\n    rangeSelector: {\n\n        /**\n         * Whether to enable all buttons from the start. By default buttons are\n         * only enabled if the corresponding time range exists on the X axis,\n         * but enabling all buttons allows for dynamically loading different\n         * time ranges.\n         *\n         * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/\n         *         All buttons enabled\n         *\n         * @type       {boolean}\n         * @default    false\n         * @since      2.0.3\n         * @product    highstock\n         * @apioption  rangeSelector.allButtonsEnabled\n         */\n\n        /**\n         * An array of configuration objects for the buttons.\n         *\n         * Defaults to\n         *\n         * <pre>buttons: [{\n         *     type: 'month',\n         *     count: 1,\n         *     text: '1m'\n         * }, {\n         *     type: 'month',\n         *     count: 3,\n         *     text: '3m'\n         * }, {\n         *     type: 'month',\n         *     count: 6,\n         *     text: '6m'\n         * }, {\n         *     type: 'ytd',\n         *     text: 'YTD'\n         * }, {\n         *     type: 'year',\n         *     count: 1,\n         *     text: '1y'\n         * }, {\n         *     type: 'all',\n         *     text: 'All'\n         * }]</pre>\n         *\n         * @sample {highstock} stock/rangeselector/datagrouping/\n         *         Data grouping by buttons\n         *\n         * @type       {Array<*>}\n         * @product    highstock\n         * @apioption  rangeSelector.buttons\n         */\n\n        /**\n         * How many units of the defined type the button should span. If `type`\n         * is \"month\" and `count` is 3, the button spans three months.\n         *\n         * @type       {number}\n         * @default    1\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.count\n         */\n\n        /**\n         * Fires when clicking on the rangeSelector button. One parameter,\n         * event, is passed to the function, containing common event\n         * information.\n         *\n         * <pre>\n         * click: function(e) {\n         *   console.log(this);\n         * }\n         * </pre>\n         *\n         * Return false to stop default button's click action.\n         *\n         * @sample {highstock} stock/rangeselector/button-click/\n         *         Click event on the button\n         *\n         * @type       {Function}\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.events.click\n         */\n\n        /**\n         * Additional range (in milliseconds) added to the end of the calculated\n         * time span.\n         *\n         * @sample {highstock} stock/rangeselector/min-max-offsets/\n         *         Button offsets\n         *\n         * @type       {number}\n         * @default    0\n         * @since      6.0.0\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.offsetMax\n         */\n\n        /**\n         * Additional range (in milliseconds) added to the start of the\n         * calculated time span.\n         *\n         * @sample {highstock} stock/rangeselector/min-max-offsets/\n         *         Button offsets\n         *\n         * @type       {number}\n         * @default    0\n         * @since      6.0.0\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.offsetMin\n         */\n\n        /**\n         * When buttons apply dataGrouping on a series, by default zooming\n         * in/out will deselect buttons and unset dataGrouping. Enable this\n         * option to keep buttons selected when extremes change.\n         *\n         * @sample {highstock} stock/rangeselector/preserve-datagrouping/\n         *         Different preserveDataGrouping settings\n         *\n         * @type       {boolean}\n         * @since      6.1.2\n         * @default    false\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.preserveDataGrouping\n         */\n\n        /**\n         * A custom data grouping object for each button.\n         *\n         * @see [series.dataGrouping](#plotOptions.series.dataGrouping)\n         *\n         * @sample {highstock} stock/rangeselector/datagrouping/\n         *         Data grouping by range selector buttons\n         *\n         * @type       {*}\n         * @extends    plotOptions.series.dataGrouping\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.dataGrouping\n         */\n\n        /**\n         * The text for the button itself.\n         *\n         * @type       {string}\n         * @product    highstock\n         * @apioption  rangeSelector.buttons.text\n         */\n\n        /**\n         * Defined the time span for the button. Can be one of `millisecond`,\n         * `second`, `minute`, `hour`, `day`, `week`, `month`, `ytd`, `all`.\n         *\n         * @type       {string}\n         * @product    highstock\n         * @validvalue [\"millisecond\", \"second\", \"minute\", \"day\", \"week\", \"month\", \"ytd\", \"all\"]\n         * @apioption  rangeSelector.buttons.type\n         */\n\n        /**\n         * The space in pixels between the buttons in the range selector.\n         *\n         * @type       {number}\n         * @default    0\n         * @product    highstock\n         * @apioption  rangeSelector.buttonSpacing\n         */\n\n        /**\n         * Enable or disable the range selector.\n         *\n         * @sample {highstock} stock/rangeselector/enabled/\n         *         Disable the range selector\n         *\n         * @type       {boolean}\n         * @default    true\n         * @product    highstock\n         * @apioption  rangeSelector.enabled\n         */\n\n        /**\n         * The vertical alignment of the rangeselector box. Allowed properties\n         * are `top`, `middle`, `bottom`.\n         *\n         * @sample {highstock} stock/rangeselector/vertical-align-middle/\n         *         Middle\n         * @sample {highstock} stock/rangeselector/vertical-align-bottom/\n         *         Bottom\n         *\n         * @type       {string}\n         * @default    top\n         * @since      6.0.0\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         * @apioption  rangeSelector.verticalAlign\n         */\n        verticalAlign: 'top',\n\n        /**\n         * A collection of attributes for the buttons. The object takes SVG\n         * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,\n         * a collection of CSS properties for the text.\n         *\n         * The object can also be extended with states, so you can set\n         * presentational options for `hover`, `select` or `disabled` button\n         * states.\n         *\n         * CSS styles for the text label.\n         *\n         * In styled mode, the buttons are styled by the\n         * `.highcharts-range-selector-buttons .highcharts-button` rule with its\n         * different states.\n         *\n         * @sample {highstock} stock/rangeselector/styling/\n         *         Styling the buttons and inputs\n         *\n         * @type       {Highcharts.CSSObject}\n         * @product    highstock\n         * @apioption  rangeSelector.buttonTheme\n         */\n        buttonTheme: {\n            \n            width: 28,\n            height: 18,\n            padding: 2,\n            zIndex: 7 // #484, #852\n        },\n\n        /**\n         * When the rangeselector is floating, the plot area does not reserve\n         * space for it. This opens for positioning anywhere on the chart.\n         *\n         * @sample {highstock} stock/rangeselector/floating/\n         *         Placing the range selector between the plot area and the\n         *         navigator\n         *\n         * @type       {boolean}\n         * @default    false\n         * @since      6.0.0\n         * @product    highstock\n         * @apioption  rangeSelector.floating\n         */\n        floating: false,\n\n        /**\n         * The x offset of the range selector relative to its horizontal\n         * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n         *\n         * @type       {number}\n         * @default    0\n         * @since      6.0.0\n         * @product    highstock\n         * @apioption  rangeSelector.x\n         */\n        x: 0,\n\n        /**\n         * The y offset of the range selector relative to its horizontal\n         * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n         *\n         * @type       {number}\n         * @default    0\n         * @since      6.0.0\n         * @product    highstock\n         * @apioption  rangeSelector.y\n         */\n        y: 0,\n\n        /**\n         * Deprecated. The height of the range selector. Currently it is\n         * calculated dynamically.\n         *\n         * @deprecated\n         * @type       {number}\n         * @default    undefined\n         * @since      2.1.9\n         * @product    highstock\n         * @apioption  rangeSelector.height\n         */\n        height: undefined, // reserved space for buttons and input\n\n        /**\n         * The border color of the date input boxes.\n         *\n         * @sample {highstock} stock/rangeselector/styling/\n         *         Styling the buttons and inputs\n         *\n         * @type       {Highcharts.ColorString}\n         * @default    #cccccc\n         * @since      1.3.7\n         * @product    highstock\n         * @apioption  rangeSelector.inputBoxBorderColor\n         */\n\n        /**\n         * The pixel height of the date input boxes.\n         *\n         * @sample {highstock} stock/rangeselector/styling/\n         *         Styling the buttons and inputs\n         *\n         * @type       {number}\n         * @default    17\n         * @since      1.3.7\n         * @product    highstock\n         * @apioption  rangeSelector.inputBoxHeight\n         */\n\n        /**\n         * CSS for the container DIV holding the input boxes. Deprecated as\n         * of 1.2.5\\. Use [inputPosition](#rangeSelector.inputPosition) instead.\n         *\n         * @sample {highstock} stock/rangeselector/styling/\n         *         Styling the buttons and inputs\n         *\n         * @deprecated\n         * @type       {Highcharts.CSSObject}\n         * @product    highstock\n         * @apioption  rangeSelector.inputBoxStyle\n         */\n\n        /**\n         * The pixel width of the date input boxes.\n         *\n         * @sample {highstock} stock/rangeselector/styling/\n         *         Styling the buttons and inputs\n         *\n         * @type       {number}\n         * @default    90\n         * @since      1.3.7\n         * @product    highstock\n         * @apioption  rangeSelector.inputBoxWidth\n         */\n\n        /**\n         * The date format in the input boxes when not selected for editing.\n         * Defaults to `%b %e, %Y`.\n         *\n         * @sample {highstock} stock/rangeselector/input-format/\n         *         Milliseconds in the range selector\n         *\n         * @type       {string}\n         * @default    %b %e %Y,\n         * @product    highstock\n         * @apioption  rangeSelector.inputDateFormat\n         */\n\n        /**\n         * A custom callback function to parse values entered in the input boxes\n         * and return a valid JavaScript time as milliseconds since 1970.\n         *\n         * @sample {highstock} stock/rangeselector/input-format/\n         *         Milliseconds in the range selector\n         *\n         * @type       {Function}\n         * @since      1.3.3\n         * @product    highstock\n         * @apioption  rangeSelector.inputDateParser\n         */\n\n        /**\n         * The date format in the input boxes when they are selected for\n         * editing. This must be a format that is recognized by JavaScript\n         * Date.parse.\n         *\n         * @sample {highstock} stock/rangeselector/input-format/\n         *         Milliseconds in the range selector\n         *\n         * @type       {string}\n         * @default    %Y-%m-%d\n         * @product    highstock\n         * @apioption  rangeSelector.inputEditDateFormat\n         */\n\n        /**\n         * Enable or disable the date input boxes. Defaults to enabled when\n         * there is enough space, disabled if not (typically mobile).\n         *\n         * @sample {highstock} stock/rangeselector/input-datepicker/\n         *         Extending the input with a jQuery UI datepicker\n         *\n         * @type       {boolean}\n         * @default    true\n         * @product    highstock\n         * @apioption  rangeSelector.inputEnabled\n         */\n\n        /**\n         * Positioning for the input boxes. Allowed properties are `align`,\n         *  `x` and `y`.\n         *\n         * @type       {*}\n         * @since      1.2.4\n         * @product    highstock\n         * @apioption  rangeSelector.inputPosition\n         */\n        inputPosition: {\n            /**\n             * The alignment of the input box. Allowed properties are `left`,\n             * `center`, `right`.\n             *\n             * @sample {highstock} stock/rangeselector/input-button-position/\n             *         Alignment\n             *\n             * @type       {string}\n             * @default    right\n             * @since      6.0.0\n             * @validvalue [\"left\", \"center\", \"right\"]\n             * @apioption  rangeSelector.inputPosition.align\n             */\n            align: 'right',\n\n            /**\n             * X offset of the input row.\n             *\n             * @type       {number}\n             * @default    0\n             * @apioption  rangeSelector.inputPosition.x\n             */\n            x: 0,\n\n            /**\n             * Y offset of the input row.\n             *\n             * @type       {number}\n             * @default    0\n             * @apioption  rangeSelector.inputPosition.y\n             */\n            y: 0\n        },\n\n        /**\n         * The index of the button to appear pre-selected.\n         *\n         * @type       {number}\n         * @product    highstock\n         * @apioption  rangeSelector.selected\n         */\n\n        /**\n         * Positioning for the button row.\n         *\n         * @type       {*}\n         * @since      1.2.4\n         * @product    highstock\n         * @apioption  rangeSelector.buttonPosition\n         */\n        buttonPosition: {\n\n            /**\n             * The alignment of the input box. Allowed properties are `left`,\n             * `center`, `right`.\n             *\n             * @sample {highstock} stock/rangeselector/input-button-position/\n             *         Alignment\n             *\n             * @type       {string}\n             * @default    left\n             * @since      6.0.0\n             * @validvalue [\"left\", \"center\", \"right\"]\n             * @apioption  rangeSelector.buttonPosition.align\n             */\n            align: 'left',\n\n            /**\n             * X offset of the button row.\n             *\n             * @type       {number}\n             * @default    0\n             * @apioption  rangeSelector.buttonPosition.x\n             */\n            x: 0,\n\n            /**\n             * Y offset of the button row.\n             *\n             * @type       {number}\n             * @default    0\n             * @apioption  rangeSelector.buttonPosition.y\n             */\n            y: 0\n        }\n\n        \n    }\n});\n\ndefaultOptions.lang = merge(\n    defaultOptions.lang,\n    /**\n     * Language object. The language object is global and it can't be set\n     * on each chart initiation. Instead, use `Highcharts.setOptions` to\n     * set it before any chart is initialized.\n     *\n     * <pre>Highcharts.setOptions({\n     *     lang: {\n     *         months: [\n     *             'Janvier', 'Fvrier', 'Mars', 'Avril',\n     *             'Mai', 'Juin', 'Juillet', 'Aot',\n     *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'\n     *         ],\n     *         weekdays: [\n     *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',\n     *             'Jeudi', 'Vendredi', 'Samedi'\n     *         ]\n     *     }\n     * });</pre>\n     *\n     * @optionparent lang\n     * @product highstock\n     */\n    {\n\n        /**\n         * The text for the label for the range selector buttons.\n         *\n         * @type       {string}\n         * @default    Zoom\n         * @product    highstock\n         * @apioption  lang.rangeSelectorZoom\n         */\n        rangeSelectorZoom: 'Zoom',\n\n        /**\n         * The text for the label for the \"from\" input box in the range\n         * selector.\n         *\n         * @type       {string}\n         * @default    From\n         * @product    highstock\n         * @apioption  lang.rangeSelectorFrom\n         */\n        rangeSelectorFrom: 'From',\n\n        /**\n         * The text for the label for the \"to\" input box in the range selector.\n         *\n         * @type       {string}\n         * @default    To\n         * @product    highstock\n         * @apioption  lang.rangeSelectorTo\n         */\n        rangeSelectorTo: 'To'\n    }\n);\n\n/**\n * The range selector.\n *\n * @class Highcharts.RangeSelector\n *\n * @param {Highcharts.Chart} chart\n */\nfunction RangeSelector(chart) {\n\n    // Run RangeSelector\n    this.init(chart);\n}\n\nRangeSelector.prototype = {\n    /**\n     * The method to run when one of the buttons in the range selectors is\n     * clicked\n     *\n     * @function Highcharts.RangeSelector#clickButton\n     *\n     * @param  {number} i\n     *         The index of the button\n     *\n     * @param  {boolean} redraw\n     *\n     * @return {void}\n     */\n    clickButton: function (i, redraw) {\n        var rangeSelector = this,\n            chart = rangeSelector.chart,\n            rangeOptions = rangeSelector.buttonOptions[i],\n            baseAxis = chart.xAxis[0],\n            unionExtremes = (\n                    chart.scroller && chart.scroller.getUnionExtremes()\n                ) || baseAxis || {},\n            dataMin = unionExtremes.dataMin,\n            dataMax = unionExtremes.dataMax,\n            newMin,\n            newMax = baseAxis && Math.round(\n                Math.min(baseAxis.max, pick(dataMax, baseAxis.max))\n            ), // #1568\n            type = rangeOptions.type,\n            baseXAxisOptions,\n            range = rangeOptions._range,\n            rangeMin,\n            minSetting,\n            rangeSetting,\n            ctx,\n            ytdExtremes,\n            dataGrouping = rangeOptions.dataGrouping;\n\n        // chart has no data, base series is removed\n        if (dataMin === null || dataMax === null) {\n            return;\n        }\n\n        // Set the fixed range before range is altered\n        chart.fixedRange = range;\n\n        // Apply dataGrouping associated to button\n        if (dataGrouping) {\n            this.forcedDataGrouping = true;\n            Axis.prototype.setDataGrouping.call(\n                baseAxis || { chart: this.chart },\n                dataGrouping,\n                false\n            );\n\n            this.frozenStates = rangeOptions.preserveDataGrouping;\n        }\n\n        // Apply range\n        if (type === 'month' || type === 'year') {\n            if (!baseAxis) {\n                // This is set to the user options and picked up later when the\n                // axis is instantiated so that we know the min and max.\n                range = rangeOptions;\n            } else {\n                ctx = {\n                    range: rangeOptions,\n                    max: newMax,\n                    chart: chart,\n                    dataMin: dataMin,\n                    dataMax: dataMax\n                };\n                newMin = baseAxis.minFromRange.call(ctx);\n                if (isNumber(ctx.newMax)) {\n                    newMax = ctx.newMax;\n                }\n            }\n\n        // Fixed times like minutes, hours, days\n        } else if (range) {\n            newMin = Math.max(newMax - range, dataMin);\n            newMax = Math.min(newMin + range, dataMax);\n\n        } else if (type === 'ytd') {\n\n            // On user clicks on the buttons, or a delayed action running from\n            // the beforeRender event (below), the baseAxis is defined.\n            if (baseAxis) {\n                // When \"ytd\" is the pre-selected button for the initial view,\n                // its calculation is delayed and rerun in the beforeRender\n                // event (below). When the series are initialized, but before\n                // the chart is rendered, we have access to the xData array\n                // (#942).\n                if (dataMax === undefined) {\n                    dataMin = Number.MAX_VALUE;\n                    dataMax = Number.MIN_VALUE;\n                    each(chart.series, function (series) {\n                        // reassign it to the last item\n                        var xData = series.xData;\n                        dataMin = Math.min(xData[0], dataMin);\n                        dataMax = Math.max(xData[xData.length - 1], dataMax);\n                    });\n                    redraw = false;\n                }\n                ytdExtremes = rangeSelector.getYTDExtremes(\n                    dataMax,\n                    dataMin,\n                    chart.time.useUTC\n                );\n                newMin = rangeMin = ytdExtremes.min;\n                newMax = ytdExtremes.max;\n\n            // \"ytd\" is pre-selected. We don't yet have access to processed\n            // point and extremes data (things like pointStart and pointInterval\n            // are missing), so we delay the process (#942)\n            } else {\n                addEvent(chart, 'beforeRender', function () {\n                    rangeSelector.clickButton(i);\n                });\n                return;\n            }\n        } else if (type === 'all' && baseAxis) {\n            newMin = dataMin;\n            newMax = dataMax;\n        }\n\n        newMin += rangeOptions._offsetMin;\n        newMax += rangeOptions._offsetMax;\n\n        rangeSelector.setSelected(i);\n\n        // Update the chart\n        if (!baseAxis) {\n            // Axis not yet instanciated. Temporarily set min and range\n            // options and remove them on chart load (#4317).\n            baseXAxisOptions = splat(chart.options.xAxis)[0];\n            rangeSetting = baseXAxisOptions.range;\n            baseXAxisOptions.range = range;\n            minSetting = baseXAxisOptions.min;\n            baseXAxisOptions.min = rangeMin;\n            addEvent(chart, 'load', function resetMinAndRange() {\n                baseXAxisOptions.range = rangeSetting;\n                baseXAxisOptions.min = minSetting;\n            });\n        } else {\n            // Existing axis object. Set extremes after render time.\n            baseAxis.setExtremes(\n                newMin,\n                newMax,\n                pick(redraw, 1),\n                null, // auto animation\n                {\n                    trigger: 'rangeSelectorButton',\n                    rangeSelectorButton: rangeOptions\n                }\n            );\n        }\n    },\n\n    /**\n     * Set the selected option. This method only sets the internal flag, it\n     * doesn't update the buttons or the actual zoomed range.\n     *\n     * @function Highcharts.RangeSelector#setSelected\n     *\n     * @param  {boolean} selected\n     *\n     * @return {void}\n     */\n    setSelected: function (selected) {\n        this.selected = this.options.selected = selected;\n    },\n\n    /**\n     * The default buttons for pre-selecting time frames\n     */\n    defaultButtons: [{\n        type: 'month',\n        count: 1,\n        text: '1m'\n    }, {\n        type: 'month',\n        count: 3,\n        text: '3m'\n    }, {\n        type: 'month',\n        count: 6,\n        text: '6m'\n    }, {\n        type: 'ytd',\n        text: 'YTD'\n    }, {\n        type: 'year',\n        count: 1,\n        text: '1y'\n    }, {\n        type: 'all',\n        text: 'All'\n    }],\n\n    /**\n     * Initialize the range selector\n     *\n     * @function Highcharts.RangeSelector#init\n     *\n     * @param  {Highcharts.Chart} chart\n     *\n     * @return {void}\n     */\n    init: function (chart) {\n        var rangeSelector = this,\n            options = chart.options.rangeSelector,\n            buttonOptions = options.buttons ||\n                [].concat(rangeSelector.defaultButtons),\n            selectedOption = options.selected,\n            blurInputs = function () {\n                var minInput = rangeSelector.minInput,\n                    maxInput = rangeSelector.maxInput;\n\n                // #3274 in some case blur is not defined\n                if (minInput && minInput.blur) {\n                    fireEvent(minInput, 'blur');\n                }\n                if (maxInput && maxInput.blur) {\n                    fireEvent(maxInput, 'blur');\n                }\n            };\n\n        rangeSelector.chart = chart;\n        rangeSelector.options = options;\n        rangeSelector.buttons = [];\n\n        chart.extraTopMargin = options.height;\n        rangeSelector.buttonOptions = buttonOptions;\n\n        this.unMouseDown = addEvent(chart.container, 'mousedown', blurInputs);\n        this.unResize = addEvent(chart, 'resize', blurInputs);\n\n        // Extend the buttonOptions with actual range\n        each(buttonOptions, rangeSelector.computeButtonRange);\n\n        // zoomed range based on a pre-selected button index\n        if (selectedOption !== undefined && buttonOptions[selectedOption]) {\n            this.clickButton(selectedOption, false);\n        }\n\n\n        addEvent(chart, 'load', function () {\n            // If a data grouping is applied to the current button, release it\n            // when extremes change\n            if (chart.xAxis && chart.xAxis[0]) {\n                addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                    if (\n                        this.max - this.min !== chart.fixedRange &&\n                        e.trigger !== 'rangeSelectorButton' &&\n                        e.trigger !== 'updatedData' &&\n                        rangeSelector.forcedDataGrouping &&\n                        !rangeSelector.frozenStates\n                    ) {\n                        this.setDataGrouping(false, false);\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Dynamically update the range selector buttons after a new range has been\n     * set\n     *\n     * @function Highcharts.RangeSelector#updateButtonStates\n     *\n     * @return {void}\n     */\n    updateButtonStates: function () {\n        var rangeSelector = this,\n            chart = this.chart,\n            baseAxis = chart.xAxis[0],\n            actualRange = Math.round(baseAxis.max - baseAxis.min),\n            hasNoData = !baseAxis.hasVisibleSeries,\n            day = 24 * 36e5, // A single day in milliseconds\n            unionExtremes = (\n                chart.scroller &&\n                chart.scroller.getUnionExtremes()\n            ) || baseAxis,\n            dataMin = unionExtremes.dataMin,\n            dataMax = unionExtremes.dataMax,\n            ytdExtremes = rangeSelector.getYTDExtremes(\n                dataMax,\n                dataMin,\n                chart.time.useUTC\n            ),\n            ytdMin = ytdExtremes.min,\n            ytdMax = ytdExtremes.max,\n            selected = rangeSelector.selected,\n            selectedExists = isNumber(selected),\n            allButtonsEnabled = rangeSelector.options.allButtonsEnabled,\n            buttons = rangeSelector.buttons;\n\n        each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n            var range = rangeOptions._range,\n                type = rangeOptions.type,\n                count = rangeOptions.count || 1,\n                button = buttons[i],\n                state = 0,\n                disable,\n                select,\n                offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin,\n                isSelected = i === selected,\n                // Disable buttons where the range exceeds what is allowed in\n                // the current view\n                isTooGreatRange = range > dataMax - dataMin,\n                // Disable buttons where the range is smaller than the minimum\n                // range\n                isTooSmallRange = range < baseAxis.minRange,\n                // Do not select the YTD button if not explicitly told so\n                isYTDButNotSelected = false,\n                // Disable the All button if we're already showing all\n                isAllButAlreadyShowingAll = false,\n                isSameRange = range === actualRange;\n            // Months and years have a variable range so we check the extremes\n            if (\n                (type === 'month' || type === 'year') &&\n                (\n                    actualRange + 36e5 >=\n                    { month: 28, year: 365 }[type] * day * count - offsetRange\n                ) &&\n                (\n                    actualRange - 36e5 <=\n                    { month: 31, year: 366 }[type] * day * count + offsetRange\n                )\n            ) {\n                isSameRange = true;\n            } else if (type === 'ytd') {\n                isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;\n                isYTDButNotSelected = !isSelected;\n            } else if (type === 'all') {\n                isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;\n                isAllButAlreadyShowingAll = (\n                    !isSelected &&\n                    selectedExists &&\n                    isSameRange\n                );\n            }\n\n            // The new zoom area happens to match the range for a button - mark\n            // it selected. This happens when scrolling across an ordinal gap.\n            // It can be seen in the intraday demos when selecting 1h and scroll\n            // across the night gap.\n            disable = (\n                !allButtonsEnabled &&\n                (\n                    isTooGreatRange ||\n                    isTooSmallRange ||\n                    isAllButAlreadyShowingAll ||\n                    hasNoData\n                )\n            );\n            select = (\n                (isSelected && isSameRange) ||\n                (isSameRange && !selectedExists && !isYTDButNotSelected) ||\n                (isSelected && rangeSelector.frozenStates)\n            );\n\n            if (disable) {\n                state = 3;\n            } else if (select) {\n                selectedExists = true; // Only one button can be selected\n                state = 2;\n            }\n\n            // If state has changed, update the button\n            if (button.state !== state) {\n                button.setState(state);\n            }\n        });\n    },\n\n    /**\n     * Compute and cache the range for an individual button\n     *\n     * @function Highcharts.RangeSelector#computeButtonRange\n     *\n     * @param  {Highcharts.RangeSelectorOptions} rangeOptions\n     *\n     * @return {void}\n     */\n    computeButtonRange: function (rangeOptions) {\n        var type = rangeOptions.type,\n            count = rangeOptions.count || 1,\n\n            // these time intervals have a fixed number of milliseconds, as\n            // opposed to month, ytd and year\n            fixedTimes = {\n                millisecond: 1,\n                second: 1000,\n                minute: 60 * 1000,\n                hour: 3600 * 1000,\n                day: 24 * 3600 * 1000,\n                week: 7 * 24 * 3600 * 1000\n            };\n\n        // Store the range on the button object\n        if (fixedTimes[type]) {\n            rangeOptions._range = fixedTimes[type] * count;\n        } else if (type === 'month' || type === 'year') {\n            rangeOptions._range =\n                { month: 30, year: 365 }[type] * 24 * 36e5 * count;\n        }\n\n        rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);\n        rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);\n        rangeOptions._range +=\n            rangeOptions._offsetMax - rangeOptions._offsetMin;\n    },\n\n    /**\n     * Set the internal and displayed value of a HTML input for the dates\n     *\n     * @function Highcharts.RangeSelector#setInputValue\n     *\n     * @param  {string} name\n     *\n     * @param  {number} inputTime\n     *\n     * @return {void}\n     */\n    setInputValue: function (name, inputTime) {\n        var options = this.chart.options.rangeSelector,\n            time = this.chart.time,\n            input = this[name + 'Input'];\n\n        if (defined(inputTime)) {\n            input.previousValue = input.HCTime;\n            input.HCTime = inputTime;\n        }\n\n        input.value = time.dateFormat(\n            options.inputEditDateFormat || '%Y-%m-%d',\n            input.HCTime\n        );\n        this[name + 'DateBox'].attr({\n            text: time.dateFormat(\n                options.inputDateFormat || '%b %e, %Y',\n                input.HCTime\n            )\n        });\n    },\n\n    /**\n     * @function Highcharts.RangeSelector#showInput\n     *\n     * @param  {string} name\n     *\n     * @return {void}\n     */\n    showInput: function (name) {\n        var inputGroup = this.inputGroup,\n            dateBox = this[name + 'DateBox'];\n\n        css(this[name + 'Input'], {\n            left: (inputGroup.translateX + dateBox.x) + 'px',\n            top: inputGroup.translateY + 'px',\n            width: (dateBox.width - 2) + 'px',\n            height: (dateBox.height - 2) + 'px',\n            border: '2px solid silver'\n        });\n    },\n\n    /**\n     * @function Highcharts.RangeSelector#hideInput\n     *\n     * @param  {string} name\n     *\n     * @return {void}\n     */\n    hideInput: function (name) {\n        css(this[name + 'Input'], {\n            border: 0,\n            width: '1px',\n            height: '1px'\n        });\n        this.setInputValue(name);\n    },\n\n    /**\n     * Draw either the 'from' or the 'to' HTML input box of the range selector\n     *\n     * @function Highcharts.RangeSelector#drawInput\n     *\n     * @param  {string} name\n     *\n     * @return {void}\n     */\n    drawInput: function (name) {\n        var rangeSelector = this,\n            chart = rangeSelector.chart,\n            chartStyle = chart.renderer.style || {},\n            renderer = chart.renderer,\n            options = chart.options.rangeSelector,\n            lang = defaultOptions.lang,\n            div = rangeSelector.div,\n            isMin = name === 'min',\n            input,\n            label,\n            dateBox,\n            inputGroup = this.inputGroup;\n\n        function updateExtremes() {\n            var inputValue = input.value,\n                value = (options.inputDateParser || Date.parse)(inputValue),\n                chartAxis = chart.xAxis[0],\n                dataAxis = chart.scroller && chart.scroller.xAxis ?\n                    chart.scroller.xAxis :\n                    chartAxis,\n                dataMin = dataAxis.dataMin,\n                dataMax = dataAxis.dataMax;\n            if (value !== input.previousValue) {\n                input.previousValue = value;\n                // If the value isn't parsed directly to a value by the\n                // browser's Date.parse method, like YYYY-MM-DD in IE, try\n                // parsing it a different way\n                if (!isNumber(value)) {\n                    value = inputValue.split('-');\n                    value = Date.UTC(\n                        pInt(value[0]),\n                        pInt(value[1]) - 1,\n                        pInt(value[2])\n                    );\n                }\n\n                if (isNumber(value)) {\n\n                    // Correct for timezone offset (#433)\n                    if (!chart.time.useUTC) {\n                        value =\n                            value + new Date().getTimezoneOffset() * 60 * 1000;\n                    }\n\n                    // Validate the extremes. If it goes beyound the data min or\n                    // max, use the actual data extreme (#2438).\n                    if (isMin) {\n                        if (value > rangeSelector.maxInput.HCTime) {\n                            value = undefined;\n                        } else if (value < dataMin) {\n                            value = dataMin;\n                        }\n                    } else {\n                        if (value < rangeSelector.minInput.HCTime) {\n                            value = undefined;\n                        } else if (value > dataMax) {\n                            value = dataMax;\n                        }\n                    }\n\n                    // Set the extremes\n                    if (value !== undefined) {\n                        chartAxis.setExtremes(\n                            isMin ? value : chartAxis.min,\n                            isMin ? chartAxis.max : value,\n                            undefined,\n                            undefined,\n                            { trigger: 'rangeSelectorInput' }\n                        );\n                    }\n                }\n            }\n        }\n\n        // Create the text label\n        this[name + 'Label'] = label = renderer.label(\n                lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'],\n                this.inputGroup.offset\n            )\n            .addClass('highcharts-range-label')\n            .attr({\n                padding: 2\n            })\n            .add(inputGroup);\n        inputGroup.offset += label.width + 5;\n\n        // Create an SVG label that shows updated date ranges and and records\n        // click events that bring in the HTML input.\n        this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)\n            .addClass('highcharts-range-input')\n            .attr({\n                padding: 2,\n                width: options.inputBoxWidth || 90,\n                height: options.inputBoxHeight || 17,\n                'text-align': 'center'\n                \n            })\n            .on('click', function () {\n                // If it is already focused, the onfocus event doesn't fire\n                // (#3713)\n                rangeSelector.showInput(name);\n                rangeSelector[name + 'Input'].focus();\n            })\n            .add(inputGroup);\n        inputGroup.offset += dateBox.width + (isMin ? 10 : 0);\n\n\n        // Create the HTML input element. This is rendered as 1x1 pixel then set\n        // to the right size when focused.\n        this[name + 'Input'] = input = createElement('input', {\n            name: name,\n            className: 'highcharts-range-selector',\n            type: 'text'\n        }, {\n            top: chart.plotTop + 'px' // prevent jump on focus in Firefox\n        }, div);\n\n        \n\n        // Blow up the input box\n        input.onfocus = function () {\n            rangeSelector.showInput(name);\n        };\n        // Hide away the input box\n        input.onblur = function () {\n            rangeSelector.hideInput(name);\n        };\n\n        // handle changes in the input boxes\n        input.onchange = updateExtremes;\n\n        input.onkeypress = function (event) {\n            // IE does not fire onchange on enter\n            if (event.keyCode === 13) {\n                updateExtremes();\n            }\n        };\n    },\n\n    /**\n     * Get the position of the range selector buttons and inputs. This can be\n     * overridden from outside for custom positioning.\n     *\n     * @function Highcharts.RangeSelector#getPosition\n     *\n     * @return {Highcharts.Dictionary<number>}\n     */\n    getPosition: function () {\n        var chart = this.chart,\n            options = chart.options.rangeSelector,\n            top = options.verticalAlign === 'top' ?\n                chart.plotTop - chart.axisOffset[0] :\n                0; // set offset only for varticalAlign top\n\n        return {\n            buttonTop: top + options.buttonPosition.y,\n            inputTop: top + options.inputPosition.y - 10\n        };\n    },\n    /**\n     * Get the extremes of YTD. Will choose dataMax if its value is lower than\n     * the current timestamp. Will choose dataMin if its value is higher than\n     * the timestamp for the start of current year.\n     *\n     * @function Highcharts.RangeSelector#getYTDExtremes\n     *\n     * @param  {number} dataMax\n     *\n     * @param  {number} dataMin\n     *\n     * @return {*}\n     *         Returns min and max for the YTD\n     */\n    getYTDExtremes: function (dataMax, dataMin, useUTC) {\n        var time = this.chart.time,\n            min,\n            now = new time.Date(dataMax),\n            year = time.get('FullYear', now),\n            startOfYear = useUTC ?\n                time.Date.UTC(year, 0, 1) : // eslint-disable-line new-cap\n                +new time.Date(year, 0, 1);\n        min = Math.max(dataMin || 0, startOfYear);\n        now = now.getTime();\n        return {\n            max: Math.min(dataMax || now, now),\n            min: min\n        };\n    },\n\n    /**\n     * Render the range selector including the buttons and the inputs. The first\n     * time render is called, the elements are created and positioned. On\n     * subsequent calls, they are moved and updated.\n     *\n     * @function Highcharts.RangeSelector#render\n     *\n     * @param  {number} min\n     *         X axis minimum\n     *\n     * @param  {number} max\n     *         X axis maximum\n     *\n     * @return {void}\n     */\n    render: function (min, max) {\n\n        var rangeSelector = this,\n            chart = rangeSelector.chart,\n            renderer = chart.renderer,\n            container = chart.container,\n            chartOptions = chart.options,\n            navButtonOptions = (\n                chartOptions.exporting &&\n                chartOptions.exporting.enabled !== false &&\n                chartOptions.navigation &&\n                chartOptions.navigation.buttonOptions\n            ),\n            lang = defaultOptions.lang,\n            div = rangeSelector.div,\n            options = chartOptions.rangeSelector,\n            // Place inputs above the container\n            inputsZIndex = pick(\n                chartOptions.chart.style &&\n                chartOptions.chart.style.zIndex,\n                0\n            ) + 1,\n            floating = options.floating,\n            buttons = rangeSelector.buttons,\n            inputGroup = rangeSelector.inputGroup,\n            buttonTheme = options.buttonTheme,\n            buttonPosition = options.buttonPosition,\n            inputPosition = options.inputPosition,\n            inputEnabled = options.inputEnabled,\n            states = buttonTheme && buttonTheme.states,\n            plotLeft = chart.plotLeft,\n            buttonLeft,\n            buttonGroup = rangeSelector.buttonGroup,\n            group,\n            groupHeight,\n            rendered = rangeSelector.rendered,\n            verticalAlign = rangeSelector.options.verticalAlign,\n            legend = chart.legend,\n            legendOptions = legend && legend.options,\n            buttonPositionY = buttonPosition.y,\n            inputPositionY = inputPosition.y,\n            animate = rendered || false,\n            verb = animate ? 'animate' : 'attr',\n            exportingX = 0,\n            alignTranslateY,\n            legendHeight,\n            minPosition,\n            translateY = 0,\n            translateX;\n\n        if (options.enabled === false) {\n            return;\n        }\n\n        // create the elements\n        if (!rendered) {\n\n            rangeSelector.group = group = renderer.g('range-selector-group')\n                .attr({\n                    zIndex: 7\n                })\n                .add();\n\n            rangeSelector.buttonGroup = buttonGroup =\n                renderer.g('range-selector-buttons').add(group);\n\n            rangeSelector.zoomText = renderer.text(\n                    lang.rangeSelectorZoom,\n                    0,\n                    15\n                )\n                .css(options.labelStyle)\n                .add(buttonGroup);\n\n            each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n\n                buttons[i] = renderer.button(\n                        rangeOptions.text,\n                        0,\n                        0,\n                        function () {\n\n                            // extract events from button object and call\n                            var buttonEvents = (\n                                    rangeOptions.events &&\n                                    rangeOptions.events.click\n                                ),\n                                callDefaultEvent;\n\n                            if (buttonEvents) {\n                                callDefaultEvent =\n                                    buttonEvents.call(rangeOptions);\n                            }\n\n                            if (callDefaultEvent !== false) {\n                                rangeSelector.clickButton(i);\n                            }\n\n                            rangeSelector.isActive = true;\n                        },\n                        buttonTheme,\n                        states && states.hover,\n                        states && states.select,\n                        states && states.disabled\n                    )\n                    .attr({\n                        'text-align': 'center'\n                    })\n                    .add(buttonGroup);\n            });\n\n            // first create a wrapper outside the container in order to make\n            // the inputs work and make export correct\n            if (inputEnabled !== false) {\n                rangeSelector.div = div = createElement('div', null, {\n                    position: 'relative',\n                    height: 0,\n                    zIndex: inputsZIndex\n                });\n\n                container.parentNode.insertBefore(div, container);\n\n                // Create the group to keep the inputs\n                rangeSelector.inputGroup = inputGroup =\n                    renderer.g('input-group').add(group);\n                inputGroup.offset = 0;\n\n                rangeSelector.drawInput('min');\n                rangeSelector.drawInput('max');\n            }\n        }\n\n        // #8769, allow dynamically updating margins\n        rangeSelector.zoomText[verb]({\n            x: pick(plotLeft + buttonPosition.x, plotLeft)\n        });\n        // button start position\n        buttonLeft = pick(plotLeft + buttonPosition.x, plotLeft) +\n            rangeSelector.zoomText.getBBox().width + 5;\n        each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n\n            buttons[i][verb]({ x: buttonLeft });\n\n            // increase button position for the next button\n            buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);\n        });\n\n\n        plotLeft = chart.plotLeft - chart.spacing[3];\n        rangeSelector.updateButtonStates();\n\n        // detect collisiton with exporting\n        if\n            (\n                navButtonOptions &&\n                this.titleCollision(chart) &&\n                verticalAlign === 'top' &&\n                buttonPosition.align === 'right' &&\n                (\n                    (buttonPosition.y + buttonGroup.getBBox().height - 12) <\n                    ((navButtonOptions.y || 0) + navButtonOptions.height)\n                )\n            ) {\n            exportingX = -40;\n        }\n\n        if (buttonPosition.align === 'left') {\n            translateX = buttonPosition.x - chart.spacing[3];\n        } else if (buttonPosition.align === 'right') {\n            translateX = buttonPosition.x + exportingX - chart.spacing[1];\n        }\n\n        // align button group\n        buttonGroup.align({\n            y: buttonPosition.y,\n            width: buttonGroup.getBBox().width,\n            align: buttonPosition.align,\n            x: translateX\n        }, true, chart.spacingBox);\n\n        // skip animation\n        rangeSelector.group.placed = animate;\n        rangeSelector.buttonGroup.placed = animate;\n\n        if (inputEnabled !== false) {\n\n            var inputGroupX,\n                inputGroupWidth,\n                buttonGroupX,\n                buttonGroupWidth;\n\n            // detect collision with exporting\n            if\n                (\n                    navButtonOptions &&\n                    this.titleCollision(chart) &&\n                    verticalAlign === 'top' &&\n                    inputPosition.align === 'right' &&\n                    (\n                        (inputPosition.y - inputGroup.getBBox().height - 12) <\n                        (\n                            (navButtonOptions.y || 0) +\n                            navButtonOptions.height +\n                            chart.spacing[0]\n                        )\n                    )\n                ) {\n                exportingX = -40;\n            } else {\n                exportingX = 0;\n            }\n\n            if (inputPosition.align === 'left') {\n                translateX = plotLeft;\n            } else if (inputPosition.align === 'right') {\n                translateX = -Math.max(chart.axisOffset[1], -exportingX);\n            }\n\n            // Update the alignment to the updated spacing box\n            inputGroup.align({\n                y: inputPosition.y,\n                width: inputGroup.getBBox().width,\n                align: inputPosition.align,\n                // fix wrong getBBox() value on right align\n                x: inputPosition.x + translateX - 2\n            }, true, chart.spacingBox);\n\n            // detect collision\n            inputGroupX = (\n                inputGroup.alignAttr.translateX +\n                inputGroup.alignOptions.x -\n                exportingX +\n                // getBBox for detecing left margin\n                inputGroup.getBBox().x +\n                // 2px padding to not overlap input and label\n                2\n            );\n\n            inputGroupWidth = inputGroup.alignOptions.width;\n\n            buttonGroupX = buttonGroup.alignAttr.translateX +\n                buttonGroup.getBBox().x;\n            // 20 is minimal spacing between elements\n            buttonGroupWidth = buttonGroup.getBBox().width + 20;\n\n            if (\n                    (inputPosition.align === buttonPosition.align) ||\n                    (\n                        (buttonGroupX + buttonGroupWidth > inputGroupX) &&\n                        (inputGroupX + inputGroupWidth > buttonGroupX) &&\n                        (\n                            buttonPositionY <\n                            (inputPositionY + inputGroup.getBBox().height)\n                        )\n                    )\n                ) {\n\n                inputGroup.attr({\n                    translateX: inputGroup.alignAttr.translateX +\n                        (chart.axisOffset[1] >= -exportingX ? 0 : -exportingX),\n                    translateY: inputGroup.alignAttr.translateY +\n                        buttonGroup.getBBox().height + 10\n                });\n\n            }\n\n            // Set or reset the input values\n            rangeSelector.setInputValue('min', min);\n            rangeSelector.setInputValue('max', max);\n\n            // skip animation\n            rangeSelector.inputGroup.placed = animate;\n        }\n\n        // vertical align\n        rangeSelector.group.align({\n            verticalAlign: verticalAlign\n        }, true, chart.spacingBox);\n\n        // set position\n        groupHeight = rangeSelector.group.getBBox().height + 20; // # 20 padding\n        alignTranslateY = rangeSelector.group.alignAttr.translateY;\n\n        // calculate bottom position\n        if (verticalAlign === 'bottom') {\n            legendHeight = (\n                legendOptions &&\n                legendOptions.verticalAlign === 'bottom' &&\n                legendOptions.enabled &&\n                !legendOptions.floating ?\n                    legend.legendHeight + pick(legendOptions.margin, 10) :\n                    0\n            );\n\n            groupHeight = groupHeight + legendHeight - 20;\n            translateY = (\n                alignTranslateY -\n                groupHeight -\n                (floating ? 0 : options.y) -\n                10 // 10 spacing\n            );\n\n        }\n\n        if (verticalAlign === 'top') {\n            if (floating) {\n                translateY = 0;\n            }\n\n            if (chart.titleOffset) {\n                translateY = chart.titleOffset + chart.options.title.margin;\n            }\n\n            translateY += ((chart.margin[0] - chart.spacing[0]) || 0);\n\n        } else if (verticalAlign === 'middle') {\n            if (inputPositionY === buttonPositionY) {\n                if (inputPositionY < 0) {\n                    translateY = alignTranslateY + minPosition;\n                } else {\n                    translateY = alignTranslateY;\n                }\n            } else if (inputPositionY || buttonPositionY) {\n                if (inputPositionY < 0 || buttonPositionY < 0) {\n                    translateY -= Math.min(inputPositionY, buttonPositionY);\n                } else {\n                    translateY = alignTranslateY - groupHeight + minPosition;\n                }\n            }\n        }\n\n        rangeSelector.group.translate(\n            options.x,\n            options.y + Math.floor(translateY)\n        );\n\n        // translate HTML inputs\n        if (inputEnabled !== false) {\n            rangeSelector.minInput.style.marginTop =\n                rangeSelector.group.translateY + 'px';\n            rangeSelector.maxInput.style.marginTop =\n                rangeSelector.group.translateY + 'px';\n        }\n\n        rangeSelector.rendered = true;\n    },\n\n    /**\n     * Extracts height of range selector\n     *\n     * @function Highcharts.RangeSelector#getHeight\n     *\n     * @return {number}\n     *         Returns rangeSelector height\n     */\n    getHeight: function () {\n        var rangeSelector = this,\n            options = rangeSelector.options,\n            rangeSelectorGroup = rangeSelector.group,\n            inputPosition = options.inputPosition,\n            buttonPosition = options.buttonPosition,\n            yPosition = options.y,\n            buttonPositionY = buttonPosition.y,\n            inputPositionY = inputPosition.y,\n            rangeSelectorHeight = 0,\n            minPosition;\n\n        rangeSelectorHeight = rangeSelectorGroup ?\n            // 13px to keep back compatibility\n            (rangeSelectorGroup.getBBox(true).height) + 13 + yPosition :\n            0;\n\n        minPosition = Math.min(inputPositionY, buttonPositionY);\n\n        if (\n            (inputPositionY < 0 && buttonPositionY < 0) ||\n            (inputPositionY > 0 && buttonPositionY > 0)\n        ) {\n            rangeSelectorHeight += Math.abs(minPosition);\n        }\n\n        return rangeSelectorHeight;\n    },\n\n    /**\n     * Detect collision with title or subtitle\n     *\n     * @function Highcharts.RangeSelector#titleCollision\n     *\n     * @param  {Highcharts.Chart} chart\n     *\n     * @return {boolean}\n     *         Returns collision status\n     */\n    titleCollision: function (chart) {\n        return !(chart.options.title.text || chart.options.subtitle.text);\n    },\n\n    /**\n     * Update the range selector with new options\n     *\n     * @function Highcharts.RangeSelector#update\n     *\n     * @param  {Highcharts.RangeSelectorOptions} options\n     *\n     * @return {void}\n     */\n    update: function (options) {\n        var chart = this.chart;\n\n        merge(true, chart.options.rangeSelector, options);\n        this.destroy();\n        this.init(chart);\n        chart.rangeSelector.render();\n    },\n\n    /**\n     * Destroys allocated elements.\n     *\n     * @function Highcharts.RangeSelector#destroy\n     *\n     * @return {void}\n     */\n    destroy: function () {\n        var rSelector = this,\n            minInput = rSelector.minInput,\n            maxInput = rSelector.maxInput;\n\n        rSelector.unMouseDown();\n        rSelector.unResize();\n\n        // Destroy elements in collections\n        destroyObjectProperties(rSelector.buttons);\n\n        // Clear input element events\n        if (minInput) {\n            minInput.onfocus = minInput.onblur = minInput.onchange = null;\n        }\n        if (maxInput) {\n            maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n        }\n\n        // Destroy HTML and SVG elements\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(rSelector, function (val, key) {\n            if (val && key !== 'chart') {\n                if (val.destroy) { // SVGElement\n                    val.destroy();\n                } else if (val.nodeType) { // HTML element\n                    discardElement(this[key]);\n                }\n            }\n            if (val !== RangeSelector.prototype[key]) {\n                rSelector[key] = null;\n            }\n        }, this);\n    }\n};\n\n/**\n * Add logic to normalize the zoomed range in order to preserve the pressed\n * state of range selector buttons\n *\n * @function Highcharts.Axis#toFixedRange\n *\n * @param  {number} pxMin\n *\n * @param  {number} pxMax\n *\n * @param  {number} fixedMin\n *\n * @param  {number} fixedMax\n *\n * @return {*}\n */\nAxis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {\n    var fixedRange = this.chart && this.chart.fixedRange,\n        newMin = pick(fixedMin, this.translate(pxMin, true, !this.horiz)),\n        newMax = pick(fixedMax, this.translate(pxMax, true, !this.horiz)),\n        changeRatio = fixedRange && (newMax - newMin) / fixedRange;\n\n    // If the difference between the fixed range and the actual requested range\n    // is too great, the user is dragging across an ordinal gap, and we need to\n    // release the range selector button.\n    if (changeRatio > 0.7 && changeRatio < 1.3) {\n        if (fixedMax) {\n            newMin = newMax - fixedRange;\n        } else {\n            newMax = newMin + fixedRange;\n        }\n    }\n    if (!isNumber(newMin) || !isNumber(newMax)) { // #1195, #7411\n        newMin = newMax = undefined;\n    }\n\n    return {\n        min: newMin,\n        max: newMax\n    };\n};\n\n/**\n * Get the axis min value based on the range option and the current max. For\n * stock charts this is extended via the {@link RangeSelector} so that if the\n * selected range is a multiple of months or years, it is compensated for\n * various month lengths.\n *\n * @function Highcharts.Axis#minFromRange\n *\n * @return {number}\n *         The new minimum value.\n */\nAxis.prototype.minFromRange = function () {\n    var rangeOptions = this.range,\n        type = rangeOptions.type,\n        timeName = { month: 'Month', year: 'FullYear' }[type],\n        min,\n        max = this.max,\n        dataMin,\n        range,\n        // Get the true range from a start date\n        getTrueRange = function (base, count) {\n            var date = new Date(base),\n                basePeriod = date['get' + timeName]();\n\n            date['set' + timeName](basePeriod + count);\n\n            if (basePeriod === date['get' + timeName]()) {\n                date.setDate(0); // #6537\n            }\n\n            return date.getTime() - base;\n        };\n\n    if (isNumber(rangeOptions)) {\n        min = max - rangeOptions;\n        range = rangeOptions;\n    } else {\n        min = max + getTrueRange(max, -rangeOptions.count);\n\n        // Let the fixedRange reflect initial settings (#5930)\n        if (this.chart) {\n            this.chart.fixedRange = max - min;\n        }\n    }\n\n    dataMin = pick(this.dataMin, Number.MIN_VALUE);\n    if (!isNumber(min)) {\n        min = dataMin;\n    }\n    if (min <= dataMin) {\n        min = dataMin;\n        if (range === undefined) { // #4501\n            range = getTrueRange(min, rangeOptions.count);\n        }\n        this.newMax = Math.min(min + range, this.dataMax);\n    }\n    if (!isNumber(max)) {\n        min = undefined;\n    }\n    return min;\n\n};\n\n// Initialize rangeselector for stock charts\naddEvent(Chart, 'afterGetContainer', function () {\n    if (this.options.rangeSelector.enabled) {\n        this.rangeSelector = new RangeSelector(this);\n    }\n});\n\nwrap(Chart.prototype, 'render', function (proceed, options, callback) {\n\n    var chart = this,\n        axes = chart.axes,\n        rangeSelector = chart.rangeSelector,\n        verticalAlign;\n\n    if (rangeSelector) {\n\n        each(axes, function (axis) {\n            axis.updateNames();\n            axis.setScale();\n        });\n\n        chart.getAxisMargins();\n\n        rangeSelector.render();\n        verticalAlign = rangeSelector.options.verticalAlign;\n\n        if (!rangeSelector.options.floating) {\n            if (verticalAlign === 'bottom') {\n                this.extraBottomMargin = true;\n            } else if (verticalAlign !== 'middle') {\n                this.extraTopMargin = true;\n            }\n        }\n    }\n\n    proceed.call(this, options, callback);\n\n});\n\naddEvent(Chart, 'update', function (e) {\n\n    var chart = this,\n        options = e.options,\n        optionsRangeSelector = options.rangeSelector,\n        rangeSelector = chart.rangeSelector,\n        verticalAlign,\n        extraBottomMarginWas = this.extraBottomMargin,\n        extraTopMarginWas = this.extraTopMargin;\n\n    if (\n        optionsRangeSelector &&\n        optionsRangeSelector.enabled &&\n        !defined(rangeSelector)\n    ) {\n        this.options.rangeSelector.enabled = true;\n        this.rangeSelector = new RangeSelector(this);\n    }\n\n\n    this.extraBottomMargin = false;\n    this.extraTopMargin = false;\n\n    if (rangeSelector) {\n\n        rangeSelector.render();\n\n        verticalAlign = (\n            optionsRangeSelector &&\n            optionsRangeSelector.verticalAlign\n        ) || (\n            rangeSelector.options && rangeSelector.options.verticalAlign\n        );\n\n        if (!rangeSelector.options.floating) {\n            if (verticalAlign === 'bottom') {\n                this.extraBottomMargin = true;\n            } else if (verticalAlign !== 'middle') {\n                this.extraTopMargin = true;\n            }\n        }\n\n        if (\n            this.extraBottomMargin !== extraBottomMarginWas ||\n            this.extraTopMargin !== extraTopMarginWas\n        ) {\n            this.isDirtyBox = true;\n        }\n\n    }\n\n});\n\nwrap(Chart.prototype, 'redraw', function (proceed, options, callback) {\n    var chart = this,\n        rangeSelector = chart.rangeSelector,\n        verticalAlign;\n\n    if (rangeSelector && !rangeSelector.options.floating) {\n\n        rangeSelector.render();\n        verticalAlign = rangeSelector.options.verticalAlign;\n\n        if (verticalAlign === 'bottom') {\n            this.extraBottomMargin = true;\n        } else if (verticalAlign !== 'middle') {\n            this.extraTopMargin = true;\n        }\n    }\n\n    proceed.call(this, options, callback);\n});\n\naddEvent(Chart, 'getMargins', function () {\n    var rangeSelector = this.rangeSelector,\n        rangeSelectorHeight;\n\n    if (rangeSelector) {\n        rangeSelectorHeight = rangeSelector.getHeight();\n\n        if (this.extraTopMargin) {\n            this.plotTop += rangeSelectorHeight;\n        }\n\n        if (this.extraBottomMargin) {\n            this.marginBottom += rangeSelectorHeight;\n        }\n    }\n});\n\nChart.prototype.callbacks.push(function (chart) {\n    var extremes,\n        rangeSelector = chart.rangeSelector,\n        unbindRender,\n        unbindSetExtremes;\n\n    function renderRangeSelector() {\n        extremes = chart.xAxis[0].getExtremes();\n        if (isNumber(extremes.min)) {\n            rangeSelector.render(extremes.min, extremes.max);\n        }\n    }\n\n    if (rangeSelector) {\n        // redraw the scroller on setExtremes\n        unbindSetExtremes = addEvent(\n            chart.xAxis[0],\n            'afterSetExtremes',\n            function (e) {\n                rangeSelector.render(e.min, e.max);\n            }\n        );\n\n        // redraw the scroller chart resize\n        unbindRender = addEvent(chart, 'redraw', renderRangeSelector);\n\n        // do it now\n        renderRangeSelector();\n    }\n\n    // Remove resize/afterSetExtremes at chart destroy\n    addEvent(chart, 'destroy', function destroyEvents() {\n        if (rangeSelector) {\n            unbindRender();\n            unbindSetExtremes();\n        }\n    });\n});\n\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].RangeSelector = RangeSelector;\n\n/* ****************************************************************************\n * End Range Selector code                                                     *\n *****************************************************************************/\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/RangeSelector.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Responsive.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Responsive.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\nvar Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat;\n\n\n/**\n * Allows setting a set of rules to apply for different screen or chart\n * sizes. Each rule specifies additional chart options.\n *\n * @sample {highstock} stock/demo/responsive/ Stock chart\n * @sample highcharts/responsive/axis/ Axis\n * @sample highcharts/responsive/legend/ Legend\n * @sample highcharts/responsive/classname/ Class name\n * @since 5.0.0\n * @apioption responsive\n */\n\n/**\n * A set of rules for responsive settings. The rules are executed from\n * the top down.\n *\n * @type {Array<Object>}\n * @sample {highcharts} highcharts/responsive/axis/ Axis changes\n * @sample {highstock} highcharts/responsive/axis/ Axis changes\n * @sample {highmaps} highcharts/responsive/axis/ Axis changes\n * @since 5.0.0\n * @apioption responsive.rules\n */\n\n/**\n * A full set of chart options to apply as overrides to the general\n * chart options. The chart options are applied when the given rule\n * is active.\n *\n * A special case is configuration objects that take arrays, for example\n * [xAxis](#xAxis), [yAxis](#yAxis) or [series](#series). For these\n * collections, an `id` option is used to map the new option set to\n * an existing object. If an existing object of the same id is not found,\n * the item of the same indexupdated. So for example, setting `chartOptions`\n * with two series items without an `id`, will cause the existing chart's\n * two series to be updated with respective options.\n *\n * @type {Object}\n * @sample {highstock} stock/demo/responsive/ Stock chart\n * @sample highcharts/responsive/axis/ Axis\n * @sample highcharts/responsive/legend/ Legend\n * @sample highcharts/responsive/classname/ Class name\n * @since 5.0.0\n * @apioption responsive.rules.chartOptions\n */\n\n/**\n * Under which conditions the rule applies.\n *\n * @type {Object}\n * @since 5.0.0\n * @apioption responsive.rules.condition\n */\n\n/**\n * A callback function to gain complete control on when the responsive\n * rule applies. Return `true` if it applies. This opens for checking\n * against other metrics than the chart size, or example the document\n * size or other elements.\n *\n * @type {Function}\n * @context Chart\n * @since 5.0.0\n * @apioption responsive.rules.condition.callback\n */\n\n/**\n * The responsive rule applies if the chart height is less than this.\n *\n * @type {Number}\n * @since 5.0.0\n * @apioption responsive.rules.condition.maxHeight\n */\n\n/**\n * The responsive rule applies if the chart width is less than this.\n *\n * @type {Number}\n * @sample highcharts/responsive/axis/ Max width is 500\n * @since 5.0.0\n * @apioption responsive.rules.condition.maxWidth\n */\n\n/**\n * The responsive rule applies if the chart height is greater than this.\n *\n * @type {Number}\n * @default 0\n * @since 5.0.0\n * @apioption responsive.rules.condition.minHeight\n */\n\n/**\n * The responsive rule applies if the chart width is greater than this.\n *\n * @type {Number}\n * @default 0\n * @since 5.0.0\n * @apioption responsive.rules.condition.minWidth\n */\n\n/**\n * Update the chart based on the current chart/document size and options for\n * responsiveness.\n */\nChart.prototype.setResponsive = function (redraw) {\n    var options = this.options.responsive,\n        ruleIds = [],\n        currentResponsive = this.currentResponsive,\n        currentRuleIds;\n\n    if (options && options.rules) {\n        each(options.rules, function (rule) {\n            if (rule._id === undefined) {\n                rule._id = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey();\n            }\n\n            this.matchResponsiveRule(rule, ruleIds, redraw);\n        }, this);\n    }\n\n    // Merge matching rules\n    var mergedOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge.apply(0, _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map(ruleIds, function (ruleId) {\n        return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(options.rules, function (rule) {\n            return rule._id === ruleId;\n        }).chartOptions;\n    }));\n\n    // Stringified key for the rules that currently apply.\n    ruleIds = ruleIds.toString() || undefined;\n    currentRuleIds = currentResponsive && currentResponsive.ruleIds;\n\n\n    // Changes in what rules apply\n    if (ruleIds !== currentRuleIds) {\n\n        // Undo previous rules. Before we apply a new set of rules, we need to\n        // roll back completely to base options (#6291).\n        if (currentResponsive) {\n            this.update(currentResponsive.undoOptions, redraw);\n        }\n\n        if (ruleIds) {\n            // Get undo-options for matching rules\n            this.currentResponsive = {\n                ruleIds: ruleIds,\n                mergedOptions: mergedOptions,\n                undoOptions: this.currentOptions(mergedOptions)\n            };\n\n            this.update(mergedOptions, redraw);\n\n        } else {\n            this.currentResponsive = undefined;\n        }\n    }\n};\n\n/**\n * Handle a single responsiveness rule\n */\nChart.prototype.matchResponsiveRule = function (rule, matches) {\n    var condition = rule.condition,\n        fn = condition.callback || function () {\n            return (\n                this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&\n                this.chartHeight <=\n                    pick(condition.maxHeight, Number.MAX_VALUE) &&\n                this.chartWidth >= pick(condition.minWidth, 0) &&\n                this.chartHeight >= pick(condition.minHeight, 0)\n            );\n        };\n\n    if (fn.call(this)) {\n        matches.push(rule._id);\n    }\n\n};\n\n/**\n * Get the current values for a given set of options. Used before we update\n * the chart with a new responsiveness rule.\n * TODO: Restore axis options (by id?)\n */\nChart.prototype.currentOptions = function (options) {\n\n    var ret = {};\n\n    /**\n     * Recurse over a set of options and its current values,\n     * and store the current values in the ret object.\n     */\n    function getCurrent(options, curr, ret, depth) {\n        var i;\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(options, function (val, key) {\n            if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {\n                val = splat(val);\n\n                ret[key] = [];\n\n                // Iterate over collections like series, xAxis or yAxis and map\n                // the items by index.\n                for (i = 0; i < val.length; i++) {\n                    if (curr[key][i]) { // Item exists in current data (#6347)\n                        ret[key][i] = {};\n                        getCurrent(\n                            val[i],\n                            curr[key][i],\n                            ret[key][i],\n                            depth + 1\n                        );\n                    }\n                }\n            } else if (isObject(val)) {\n                ret[key] = isArray(val) ? [] : {};\n                getCurrent(val, curr[key] || {}, ret[key], depth + 1);\n            } else {\n                ret[key] = curr[key] || null;\n            }\n        });\n    }\n\n    getCurrent(options, this.options, ret, 0);\n    return ret;\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Responsive.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js":
/*!**********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType;\n\n/**\n * A scatter plot uses cartesian coordinates to display values for two variables\n * for a set of data.\n *\n * @sample       {highcharts} highcharts/demo/scatter/\n *               Scatter plot\n * @extends      {plotOptions.line}\n * @excluding    pointPlacement, shadow\n * @product      highcharts highstock\n * @optionparent plotOptions.scatter\n */\nseriesType('scatter', 'line', {\n\n    /**\n     * The width of the line connecting the data points.\n     *\n     * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-none/\n     *          0 by default\n     * @sample  {highcharts} highcharts/plotoptions/scatter-linewidth-1/\n     *          1px\n     * @product highcharts highstock\n     */\n    lineWidth: 0,\n\n    findNearestPointBy: 'xy',\n    marker: {\n        enabled: true // Overrides auto-enabling in line series (#3647)\n    },\n\n    /**\n     * Sticky tracking of mouse events. When true, the `mouseOut` event\n     * on a series isn't triggered until the mouse moves over another series,\n     * or out of the plot area. When false, the `mouseOut` event on a series\n     * is triggered when the mouse leaves the area around the series' graph\n     * or markers. This also implies the tooltip. When `stickyTracking`\n     * is false and `tooltip.shared` is false, the tooltip will be hidden\n     * when moving the mouse between series.\n     *\n     * @type      {Boolean}\n     * @default   false\n     * @product   highcharts highstock\n     * @apioption plotOptions.scatter.stickyTracking\n     */\n\n    /**\n     * A configuration object for the tooltip rendering of each single\n     * series. Properties are inherited from [tooltip](#tooltip).\n     * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,\n     * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in\n     * a scatter plot the series.name by default shows in the headerFormat\n     * and point.x and point.y in the pointFormat.\n     *\n     * @product highcharts highstock\n     */\n    tooltip: {\n        \n\n        headerFormat:\n            '<span class=\"highcharts-color-{point.colorIndex}\">\\u25CF</span> ' +\n            '<span class=\"highcharts-header\"> {series.name}</span><br/>',\n        \n\n        pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n    }\n\n// Prototype members\n}, {\n    sorted: false,\n    requireSorting: false,\n    noSharedTooltip: true,\n    trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n    takeOrdinalPosition: false, // #2342\n    drawGraph: function () {\n        if (this.options.lineWidth) {\n            Series.prototype.drawGraph.call(this);\n        }\n    }\n});\n\n/**\n * A `scatter` series. If the [type](#series.scatter.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.scatter\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.scatter\n */\n\n/**\n * An array of data points for the series. For the `scatter` series\n * type, points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 0],\n *         [1, 8],\n *         [2, 9]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 2,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 4,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.scatter.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/ScatterSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/ScrollablePlotArea.js":
/*!***************************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/ScrollablePlotArea.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/**\n * (c) 2010-2018 Torstein Honsi\n *\n * License: www.highcharts.com/license\n *\n * Highcharts feature to make the Y axis stay fixed when scrolling the chart\n * horizontally on mobile devices. Supports left and right side axes.\n */\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each;\n\n/**\n * Options for a scrollable plot area. This feature provides a minimum width for\n * the plot area of the chart. If the width gets smaller than this, typically\n * on mobile devices, a native browser scrollbar is presented below the chart.\n * This scrollbar provides smooth scrolling for the contents of the plot area,\n * whereas the title, legend and axes are fixed.\n *\n * @type    {Object}\n * @sample  {highcharts} highcharts/chart/scrollable-plotarea\n *          Scrollable plot area\n * @since   6.1.0\n * @product highcharts\n * @apioption chart.scrollablePlotArea\n */\n\n/**\n * The minimum width for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type    {Number}\n * @apioption chart.scrollablePlotArea.minWidth\n */\n\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.\n * Typically we would use 1 if the chart has right aligned Y axes.\n *\n * @type    {Number}\n * @apioption chart.scrollablePlotArea.scrollPositionX\n */\n\naddEvent(Chart, 'afterSetChartSize', function (e) {\n\n    var scrollablePlotArea = this.options.chart.scrollablePlotArea,\n        scrollableMinWidth =\n            scrollablePlotArea && scrollablePlotArea.minWidth,\n        scrollablePixels;\n\n    if (scrollableMinWidth && !this.renderer.forExport) {\n\n        // The amount of pixels to scroll, the difference between chart\n        // width and scrollable width\n        this.scrollablePixels = scrollablePixels = Math.max(\n            0,\n            scrollableMinWidth - this.chartWidth\n        );\n\n        if (scrollablePixels) {\n            this.plotWidth += scrollablePixels;\n            this.clipBox.width += scrollablePixels;\n\n            if (!e.skipAxes) {\n                each(this.axes, function (axis) {\n                    if (axis.side === 1) {\n                        // Get the plot lines right in getPlotLinePath,\n                        // temporarily set it to the adjusted plot width.\n                        axis.getPlotLinePath = function () {\n                            var right = this.right,\n                                path;\n                            this.right = right - axis.chart.scrollablePixels;\n                            path = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.prototype.getPlotLinePath.apply(\n                                this,\n                                arguments\n                            );\n                            this.right = right;\n                            return path;\n                        };\n\n                    } else {\n                        // Apply the corrected plotWidth\n                        axis.setAxisSize();\n                        axis.setAxisTranslation();\n                    }\n                });\n            }\n        }\n    }\n});\n\naddEvent(Chart, 'render', function () {\n    if (this.scrollablePixels) {\n        if (this.setUpScrolling) {\n            this.setUpScrolling();\n        }\n        this.applyFixed();\n\n    } else if (this.fixedDiv) { // Has been in scrollable mode\n        this.applyFixed();\n    }\n});\n\nChart.prototype.setUpScrolling = function () {\n\n    // Add the necessary divs to provide scrolling\n    this.scrollingContainer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement('div', {\n        'className': 'highcharts-scrolling'\n    }, {\n        overflowX: 'auto',\n        WebkitOverflowScrolling: 'touch'\n    }, this.renderTo);\n\n    this.innerContainer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement('div', {\n        'className': 'highcharts-inner-container'\n    }, null, this.scrollingContainer);\n\n    // Now move the container inside\n    this.innerContainer.appendChild(this.container);\n\n    // Don't run again\n    this.setUpScrolling = null;\n};\n\nChart.prototype.applyFixed = function () {\n    var container = this.container,\n        fixedRenderer,\n        scrollableWidth,\n        firstTime = !this.fixedDiv;\n\n    // First render\n    if (firstTime) {\n\n        this.fixedDiv = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\n            'div',\n            {\n                className: 'highcharts-fixed'\n            },\n            {\n                position: 'absolute',\n                overflow: 'hidden',\n                pointerEvents: 'none',\n                zIndex: 2\n            },\n            null,\n            true\n        );\n        this.renderTo.insertBefore(\n            this.fixedDiv,\n            this.renderTo.firstChild\n        );\n\n        this.fixedRenderer = fixedRenderer = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer(\n            this.fixedDiv,\n            0,\n            0\n        );\n\n        // Mask\n        this.scrollableMask = fixedRenderer.path()\n            .attr({\n                fill: _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(\n                    this.options.chart.backgroundColor || '#fff'\n                ).setOpacity(0.85).get(),\n                zIndex: -1\n            })\n            .addClass('highcharts-scrollable-mask')\n            .add();\n\n        // These elements are moved over to the fixed renderer and stay fixed\n        // when the user scrolls the chart.\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each([\n            this.inverted ?\n                '.highcharts-xaxis' :\n                '.highcharts-yaxis',\n            this.inverted ?\n                '.highcharts-xaxis-labels' :\n                '.highcharts-yaxis-labels',\n            '.highcharts-contextbutton',\n            '.highcharts-credits',\n            '.highcharts-legend',\n            '.highcharts-subtitle',\n            '.highcharts-title',\n            '.highcharts-legend-checkbox'\n        ], function (className) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each(container.querySelectorAll(className), function (elem) {\n                (\n                    elem.namespaceURI === fixedRenderer.SVG_NS ?\n                        fixedRenderer.box :\n                        fixedRenderer.box.parentNode\n                ).appendChild(elem);\n                elem.style.pointerEvents = 'auto';\n            });\n        });\n    }\n\n    // Set the size of the fixed renderer to the visible width\n    this.fixedRenderer.setSize(\n        this.chartWidth,\n        this.chartHeight\n    );\n\n    // Increase the size of the scrollable renderer and background\n    scrollableWidth = this.chartWidth + this.scrollablePixels;\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stop(this.container);\n    this.container.style.width = scrollableWidth + 'px';\n    this.renderer.boxWrapper.attr({\n        width: scrollableWidth,\n        height: this.chartHeight,\n        viewBox: [0, 0, scrollableWidth, this.chartHeight].join(' ')\n    });\n    this.chartBackground.attr({ width: scrollableWidth });\n\n    // Set scroll position\n    if (firstTime) {\n        var options = this.options.chart.scrollablePlotArea;\n        if (options.scrollPositionX) {\n            this.scrollingContainer.scrollLeft =\n                this.scrollablePixels * options.scrollPositionX;\n        }\n    }\n\n    // Mask behind the left and right side\n    var axisOffset = this.axisOffset,\n        maskTop = this.plotTop - axisOffset[0] - 1,\n        maskBottom = this.plotTop + this.plotHeight + axisOffset[2],\n        maskPlotRight = this.plotLeft + this.plotWidth -\n            this.scrollablePixels;\n\n    this.scrollableMask.attr({\n        d: this.scrollablePixels ? [\n            // Left side\n            'M', 0, maskTop,\n            'L', this.plotLeft - 1, maskTop,\n            'L', this.plotLeft - 1, maskBottom,\n            'L', 0, maskBottom,\n            'Z',\n\n            // Right side\n            'M', maskPlotRight, maskTop,\n            'L', this.chartWidth, maskTop,\n            'L', this.chartWidth, maskBottom,\n            'L', maskPlotRight, maskBottom,\n            'Z'\n        ] : ['M', 0, 0]\n    });\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/ScrollablePlotArea.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Scrollbar.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Scrollbar.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    correctFloat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    hasTouch = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasTouch,\n    isTouchDevice = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isTouchDevice,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    swapXY;\n\n/**\n *\n * The scrollbar is a means of panning over the X axis of a stock chart.\n * Scrollbars can  also be applied to other types of axes.\n *\n * Another approach to scrollable charts is the [chart.scrollablePlotArea](\n * https://api.highcharts.com/highcharts/chart.scrollablePlotArea) option that\n * is especially suitable for simpler cartesian charts on mobile.\n *\n * In styled mode, all the presentational options for the\n * scrollbar are replaced by the classes `.highcharts-scrollbar-thumb`,\n * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n *\n * @sample stock/yaxis/inverted-bar-scrollbar/\n *         A scrollbar on a simple bar chart\n *\n * @product highstock\n * @optionparent scrollbar\n */\nvar defaultScrollbarOptions = {\n\n    /**\n     * The height of the scrollbar. The height also applies to the width\n     * of the scroll arrows so that they are always squares. Defaults to\n     * 20 for touch devices and 14 for mouse devices.\n     *\n     * @sample {highstock} stock/scrollbar/height/\n     *         A 30px scrollbar\n     *\n     * @type       {number}\n     * @default    20/14\n     * @product    highstock\n     * @apioption  scrollbar.height\n     */\n    height: isTouchDevice ? 20 : 14,\n\n    /**\n     * The border rounding radius of the bar.\n     *\n     * @sample {highstock} stock/scrollbar/style/\n     *         Scrollbar styling\n     *\n     * @type       {number}\n     * @default    0\n     * @product    highstock\n     * @apioption  scrollbar.barBorderRadius\n     */\n    barBorderRadius: 0,\n\n    /**\n     * The corner radius of the scrollbar buttons.\n     *\n     * @sample {highstock} stock/scrollbar/style/\n     *         Scrollbar styling\n     *\n     * @type       {number}\n     * @default    0\n     * @product    highstock\n     * @apioption  scrollbar.buttonBorderRadius\n     */\n    buttonBorderRadius: 0,\n\n    /**\n     * Enable or disable the scrollbar.\n     *\n     * @type       {boolean}\n     * @sample     {highstock} stock/scrollbar/enabled/\n     *             Disable the scrollbar, only use navigator\n     * @default    true\n     * @product    highstock\n     * @apioption  scrollbar.enabled\n     */\n\n    /**\n     * Whether to redraw the main chart as the scrollbar or the navigator\n     * zoomed window is moved. Defaults to `true` for modern browsers and\n     * `false` for legacy IE browsers as well as mobile devices.\n     *\n     * @type       {boolean}\n     * @since      1.3\n     * @product    highstock\n     * @apioption  scrollbar.liveRedraw\n     */\n    liveRedraw: undefined,\n\n    /**\n     * The margin between the scrollbar and its axis when the scrollbar is\n     * applied directly to an axis.\n     *\n     * @type       {number}\n     * @default    10\n     * @apioption  scrollbar.margin\n     */\n    margin: 10,\n\n    /**\n     * The minimum width of the scrollbar.\n     *\n     * @type       {number}\n     * @default    6\n     * @since      1.2.5\n     * @product    highstock\n     * @apioption  scrollbar.minWidth\n     */\n    minWidth: 6,\n\n    /**\n     * Whether to show or hide the scrollbar when the scrolled content is\n     * zoomed out to it full extent.\n     *\n     * @type       {boolean}\n     * @default    true\n     * @product    highstock\n     * @apioption  scrollbar.showFull\n     */\n\n    /**\n     * @type       {number}\n     * @default    0.2\n     * @apioption  scrollbar.step\n     */\n    step: 0.2,\n\n    /**\n     * The z index of the scrollbar group.\n     *\n     * @type       {number}\n     * @default    3\n     * @apioption  scrollbar.zIndex\n     */\n    zIndex: 3\n\n    \n};\n\ndefaultOptions.scrollbar = merge(\n    true,\n    defaultScrollbarOptions,\n    defaultOptions.scrollbar\n);\n\n/**\n * When we have vertical scrollbar, rifles and arrow in buttons should be\n * rotated. The same method is used in Navigator's handles, to rotate them.\n *\n * @function Highcharts.swapXY\n *\n * @param  {Array<number|string>} path\n *         Path to be rotated.\n *\n * @param  {boolean} vertical\n *         If vertical scrollbar, swap x-y values.\n *\n * @return {Array<number|string>}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].swapXY = swapXY = function (path, vertical) {\n    var i,\n        len = path.length,\n        temp;\n\n    if (vertical) {\n        for (i = 0; i < len; i += 3) {\n            temp = path[i + 1];\n            path[i + 1] = path[i + 2];\n            path[i + 2] = temp;\n        }\n    }\n\n    return path;\n};\n\n/**\n * A reusable scrollbar, internally used in Highstock's navigator and optionally\n * on individual axes.\n *\n * @class Highcharts.Scrollbar\n *\n * @param {Highcharts.SVGRenderer} renderer\n *\n * @param {Highcharts.ScrollbarOptions} options\n *\n * @param {Highcharts.Chart} chart\n */\nfunction Scrollbar(renderer, options, chart) { // docs\n    this.init(renderer, options, chart);\n}\n\nScrollbar.prototype = {\n\n    /**\n     * @function Highcharts.Scrollbar#init\n     *\n     * @param  {Highcharts.SVGRenderer} renderer\n     *\n     * @param  {Highcharts.ScrollbarOptions} options\n     *\n     * @param  {Highcharts.Chart} chart\n     *\n     * @return {void}\n     */\n    init: function (renderer, options, chart) {\n\n        this.scrollbarButtons = [];\n\n        this.renderer = renderer;\n\n        this.userOptions = options;\n        this.options = merge(defaultScrollbarOptions, options);\n\n        this.chart = chart;\n\n        // backward compatibility\n        this.size = pick(this.options.size, this.options.height);\n\n        // Init\n        if (options.enabled) {\n            this.render();\n            this.initEvents();\n            this.addEvents();\n        }\n    },\n\n    /**\n    * Render scrollbar with all required items.\n    *\n    * @function Highcharts.Scrollbar#render\n    *\n    * @return {void}\n    */\n    render: function () {\n        var scroller = this,\n            renderer = scroller.renderer,\n            options = scroller.options,\n            size = scroller.size,\n            group;\n\n        // Draw the scrollbar group\n        scroller.group = group = renderer.g('scrollbar').attr({\n            zIndex: options.zIndex,\n            translateY: -99999\n        }).add();\n\n        // Draw the scrollbar track:\n        scroller.track = renderer.rect()\n            .addClass('highcharts-scrollbar-track')\n            .attr({\n                x: 0,\n                r: options.trackBorderRadius || 0,\n                height: size,\n                width: size\n            }).add(group);\n\n        \n        this.trackBorderWidth = scroller.track.strokeWidth();\n        scroller.track.attr({\n            y: -this.trackBorderWidth % 2 / 2\n        });\n\n\n        // Draw the scrollbar itself\n        scroller.scrollbarGroup = renderer.g().add(group);\n\n        scroller.scrollbar = renderer.rect()\n            .addClass('highcharts-scrollbar-thumb')\n            .attr({\n                height: size,\n                width: size,\n                r: options.barBorderRadius || 0\n            }).add(scroller.scrollbarGroup);\n\n        scroller.scrollbarRifles = renderer.path(\n            swapXY([\n                'M',\n                -3, size / 4,\n                'L',\n                -3, 2 * size / 3,\n                'M',\n                0, size / 4,\n                'L',\n                0, 2 * size / 3,\n                'M',\n                3, size / 4,\n                'L',\n                3, 2 * size / 3\n            ], options.vertical))\n            .addClass('highcharts-scrollbar-rifles')\n            .add(scroller.scrollbarGroup);\n\n        \n        scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();\n        scroller.scrollbarGroup.translate(\n            -scroller.scrollbarStrokeWidth % 2 / 2,\n            -scroller.scrollbarStrokeWidth % 2 / 2\n        );\n\n        // Draw the buttons:\n        scroller.drawScrollbarButton(0);\n        scroller.drawScrollbarButton(1);\n    },\n\n    /**\n     * Position the scrollbar, method called from a parent with defined\n     * dimensions.\n     *\n     * @function Highcharts.Scrollbar#position\n     *\n     * @param  {number} x\n     *         x-position on the chart\n     *\n     * @param  {number} y\n     *         y-position on the chart\n     *\n     * @param  {number} width\n     *         width of the scrollbar\n     *\n     * @param  {number} height\n     *         height of the scorllbar\n     *\n     * @return {void}\n     */\n    position: function (x, y, width, height) {\n        var scroller = this,\n            options = scroller.options,\n            vertical = options.vertical,\n            xOffset = height,\n            yOffset = 0,\n            method = scroller.rendered ? 'animate' : 'attr';\n\n        scroller.x = x;\n        scroller.y = y + this.trackBorderWidth;\n        scroller.width = width; // width with buttons\n        scroller.height = height;\n        scroller.xOffset = xOffset;\n        scroller.yOffset = yOffset;\n\n        // If Scrollbar is a vertical type, swap options:\n        if (vertical) {\n            scroller.width = scroller.yOffset = width = yOffset = scroller.size;\n            scroller.xOffset = xOffset = 0;\n            scroller.barWidth = height - width * 2; // width without buttons\n            scroller.x = x = x + scroller.options.margin;\n        } else {\n            scroller.height = scroller.xOffset = height = xOffset =\n                scroller.size;\n            scroller.barWidth = width - height * 2; // width without buttons\n            scroller.y = scroller.y + scroller.options.margin;\n        }\n\n        // Set general position for a group:\n        scroller.group[method]({\n            translateX: x,\n            translateY: scroller.y\n        });\n\n        // Resize background/track:\n        scroller.track[method]({\n            width: width,\n            height: height\n        });\n\n        // Move right/bottom button ot it's place:\n        scroller.scrollbarButtons[1][method]({\n            translateX: vertical ? 0 : width - xOffset,\n            translateY: vertical ? height - yOffset : 0\n        });\n    },\n\n    /**\n     * Draw the scrollbar buttons with arrows\n     *\n     * @function Highcharts.Scrollbar#drawScrollbarButton\n     *\n     * @param  {number} index\n     *         0 is left, 1 is right\n     *\n     * @return {void}\n     */\n    drawScrollbarButton: function (index) {\n        var scroller = this,\n            renderer = scroller.renderer,\n            scrollbarButtons = scroller.scrollbarButtons,\n            options = scroller.options,\n            size = scroller.size,\n            group,\n            tempElem;\n\n        group = renderer.g().add(scroller.group);\n        scrollbarButtons.push(group);\n\n        // Create a rectangle for the scrollbar button\n        tempElem = renderer.rect()\n            .addClass('highcharts-scrollbar-button')\n            .add(group);\n\n        \n\n        // Place the rectangle based on the rendered stroke width\n        tempElem.attr(tempElem.crisp({\n            x: -0.5,\n            y: -0.5,\n            width: size + 1, // +1 to compensate for crispifying in rect method\n            height: size + 1,\n            r: options.buttonBorderRadius\n        }, tempElem.strokeWidth()));\n\n        // Button arrow\n        tempElem = renderer\n            .path(swapXY([\n                'M',\n                size / 2 + (index ? -1 : 1),\n                size / 2 - 3,\n                'L',\n                size / 2 + (index ? -1 : 1),\n                size / 2 + 3,\n                'L',\n                size / 2 + (index ? 2 : -2),\n                size / 2\n            ], options.vertical))\n            .addClass('highcharts-scrollbar-arrow')\n            .add(scrollbarButtons[index]);\n\n        \n    },\n\n    /**\n    * Set scrollbar size, with a given scale.\n    *\n    * @function Highcharts.Scrollbar#setRange\n    *\n    * @param  {number} from\n    *         scale (0-1) where bar should start\n    *\n    * @param  {number} to\n    *         scale (0-1) where bar should end\n    *\n    * @return {void}\n    */\n    setRange: function (from, to) {\n        var scroller = this,\n            options = scroller.options,\n            vertical = options.vertical,\n            minWidth = options.minWidth,\n            fullWidth = scroller.barWidth,\n            fromPX,\n            toPX,\n            newPos,\n            newSize,\n            newRiflesPos,\n            method = (\n                this.rendered &&\n                !this.hasDragged &&\n                !(this.chart.navigator && this.chart.navigator.hasDragged)\n            ) ? 'animate' : 'attr';\n\n        if (!defined(fullWidth)) {\n            return;\n        }\n\n        from = Math.max(from, 0);\n        fromPX = Math.ceil(fullWidth * from);\n        toPX = fullWidth * Math.min(to, 1);\n        scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);\n\n        // We need to recalculate position, if minWidth is used\n        if (newSize < minWidth) {\n            fromPX = (fullWidth - minWidth + newSize) * from;\n            newSize = minWidth;\n        }\n        newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);\n        newRiflesPos = newSize / 2 - 0.5; // -0.5 -> rifle line width / 2\n\n        // Store current position:\n        scroller.from = from;\n        scroller.to = to;\n\n        if (!vertical) {\n            scroller.scrollbarGroup[method]({\n                translateX: newPos\n            });\n            scroller.scrollbar[method]({\n                width: newSize\n            });\n            scroller.scrollbarRifles[method]({\n                translateX: newRiflesPos\n            });\n            scroller.scrollbarLeft = newPos;\n            scroller.scrollbarTop = 0;\n        } else {\n            scroller.scrollbarGroup[method]({\n                translateY: newPos\n            });\n            scroller.scrollbar[method]({\n                height: newSize\n            });\n            scroller.scrollbarRifles[method]({\n                translateY: newRiflesPos\n            });\n            scroller.scrollbarTop = newPos;\n            scroller.scrollbarLeft = 0;\n        }\n\n        if (newSize <= 12) {\n            scroller.scrollbarRifles.hide();\n        } else {\n            scroller.scrollbarRifles.show(true);\n        }\n\n        // Show or hide the scrollbar based on the showFull setting\n        if (options.showFull === false) {\n            if (from <= 0 && to >= 1) {\n                scroller.group.hide();\n            } else {\n                scroller.group.show();\n            }\n        }\n\n        scroller.rendered = true;\n    },\n\n    /**\n    * Init events methods, so we have an access to the Scrollbar itself\n    *\n    * @function Highcharts.Scrollbar#initEvents\n    *\n    * @return {void}\n    *\n    * @todo\n    * Make events official: Fires the event `changed`.\n    */\n    initEvents: function () {\n        var scroller = this;\n        /**\n         * Event handler for the mouse move event.\n         */\n        scroller.mouseMoveHandler = function (e) {\n            var normalizedEvent = scroller.chart.pointer.normalize(e),\n                options = scroller.options,\n                direction = options.vertical ? 'chartY' : 'chartX',\n                initPositions = scroller.initPositions,\n                scrollPosition,\n                chartPosition,\n                change;\n\n            // In iOS, a mousemove event with e.pageX === 0 is fired when\n            // holding the finger down in the center of the scrollbar. This\n            // should be ignored.\n            if (\n                scroller.grabbedCenter &&\n                // #4696, scrollbar failed on Android\n                (!e.touches || e.touches[0][direction] !== 0)\n            ) {\n                chartPosition = scroller.cursorToScrollbarPosition(\n                    normalizedEvent\n                )[direction];\n                scrollPosition = scroller[direction];\n\n                change = chartPosition - scrollPosition;\n\n                scroller.hasDragged = true;\n                scroller.updatePosition(\n                    initPositions[0] + change,\n                    initPositions[1] + change\n                );\n\n                if (scroller.hasDragged) {\n                    fireEvent(scroller, 'changed', {\n                        from: scroller.from,\n                        to: scroller.to,\n                        trigger: 'scrollbar',\n                        DOMType: e.type,\n                        DOMEvent: e\n                    });\n                }\n            }\n        };\n\n        /**\n         * Event handler for the mouse up event.\n         */\n        scroller.mouseUpHandler = function (e) {\n            if (scroller.hasDragged) {\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMType: e.type,\n                    DOMEvent: e\n                });\n            }\n            scroller.grabbedCenter =\n                scroller.hasDragged =\n                scroller.chartX =\n                scroller.chartY = null;\n        };\n\n        scroller.mouseDownHandler = function (e) {\n            var normalizedEvent = scroller.chart.pointer.normalize(e),\n                mousePosition = scroller.cursorToScrollbarPosition(\n                    normalizedEvent\n                );\n\n            scroller.chartX = mousePosition.chartX;\n            scroller.chartY = mousePosition.chartY;\n            scroller.initPositions = [scroller.from, scroller.to];\n\n            scroller.grabbedCenter = true;\n        };\n\n        scroller.buttonToMinClick = function (e) {\n            var range = correctFloat(scroller.to - scroller.from) *\n                scroller.options.step;\n            scroller.updatePosition(\n                correctFloat(scroller.from - range),\n                correctFloat(scroller.to - range)\n            );\n            fireEvent(scroller, 'changed', {\n                from: scroller.from,\n                to: scroller.to,\n                trigger: 'scrollbar',\n                DOMEvent: e\n            });\n        };\n\n        scroller.buttonToMaxClick = function (e) {\n            var range = (scroller.to - scroller.from) * scroller.options.step;\n            scroller.updatePosition(scroller.from + range, scroller.to + range);\n            fireEvent(scroller, 'changed', {\n                from: scroller.from,\n                to: scroller.to,\n                trigger: 'scrollbar',\n                DOMEvent: e\n            });\n        };\n\n        scroller.trackClick = function (e) {\n            var normalizedEvent = scroller.chart.pointer.normalize(e),\n                range = scroller.to - scroller.from,\n                top = scroller.y + scroller.scrollbarTop,\n                left = scroller.x + scroller.scrollbarLeft;\n\n            if (\n                (scroller.options.vertical && normalizedEvent.chartY > top) ||\n                (!scroller.options.vertical && normalizedEvent.chartX > left)\n            ) {\n                // On the top or on the left side of the track:\n                scroller.updatePosition(\n                    scroller.from + range,\n                    scroller.to + range\n                );\n            } else {\n                // On the bottom or the right side of the track:\n                scroller.updatePosition(\n                    scroller.from - range,\n                    scroller.to - range\n                );\n            }\n\n            fireEvent(scroller, 'changed', {\n                from: scroller.from,\n                to: scroller.to,\n                trigger: 'scrollbar',\n                DOMEvent: e\n            });\n        };\n    },\n\n    /**\n     * Get normalized (0-1) cursor position over the scrollbar\n     *\n     * @function Highcharts.Scrollbar#cursorToScrollbarPosition\n     *\n     * @param  {*} normalizedEvent\n     *         normalized event, with chartX and chartY values\n     *\n     * @return {*}\n     *         Local position {chartX, chartY}\n     */\n    cursorToScrollbarPosition: function (normalizedEvent) {\n        var scroller = this,\n            options = scroller.options,\n            minWidthDifference = options.minWidth > scroller.calculatedWidth ?\n                options.minWidth :\n                0; // minWidth distorts translation\n\n        return {\n            chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) /\n                (scroller.barWidth - minWidthDifference),\n            chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) /\n                (scroller.barWidth - minWidthDifference)\n        };\n    },\n\n    /**\n    * Update position option in the Scrollbar, with normalized 0-1 scale\n    *\n    * @function Highcharts.Scrollbar#updatePosition\n    *\n    * @param  {number} from\n    *\n    * @param  {number} to\n    *\n    * @return {void}\n    */\n    updatePosition: function (from, to) {\n        if (to > 1) {\n            from = correctFloat(1 - correctFloat(to - from));\n            to = 1;\n        }\n\n        if (from < 0) {\n            to = correctFloat(to - from);\n            from = 0;\n        }\n\n        this.from = from;\n        this.to = to;\n    },\n\n    /**\n     * Update the scrollbar with new options\n     *\n     * @function Highcharts.Scrollbar#update\n     *\n     * @param  {Highcharts.ScrollbarOptions} options\n     *\n     * @return {void}\n     */\n    update: function (options) {\n        this.destroy();\n        this.init(\n            this.chart.renderer,\n            merge(true, this.options, options),\n            this.chart\n        );\n    },\n\n    /**\n     * Set up the mouse and touch events for the Scrollbar\n     *\n     * @function Highcharts.Scrollbar#addEvents\n     *\n     * @return {void}\n     */\n    addEvents: function () {\n        var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1],\n            buttons = this.scrollbarButtons,\n            bar = this.scrollbarGroup.element,\n            track = this.track.element,\n            mouseDownHandler = this.mouseDownHandler,\n            mouseMoveHandler = this.mouseMoveHandler,\n            mouseUpHandler = this.mouseUpHandler,\n            _events;\n\n        // Mouse events\n        _events = [\n            [buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick],\n            [buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick],\n            [track, 'click', this.trackClick],\n            [bar, 'mousedown', mouseDownHandler],\n            [bar.ownerDocument, 'mousemove', mouseMoveHandler],\n            [bar.ownerDocument, 'mouseup', mouseUpHandler]\n        ];\n\n        // Touch events\n        if (hasTouch) {\n            _events.push(\n                [bar, 'touchstart', mouseDownHandler],\n                [bar.ownerDocument, 'touchmove', mouseMoveHandler],\n                [bar.ownerDocument, 'touchend', mouseUpHandler]\n            );\n        }\n\n        // Add them all\n        each(_events, function (args) {\n            addEvent.apply(null, args);\n        });\n        this._events = _events;\n    },\n\n    /**\n     * Removes the event handlers attached previously with addEvents.\n     *\n     * @function Highcharts.Scrollbar#removeEvents\n     *\n     * @return {void}\n     */\n    removeEvents: function () {\n        each(this._events, function (args) {\n            removeEvent.apply(null, args);\n        });\n        this._events.length = 0;\n    },\n\n    /**\n     * Destroys allocated elements.\n     *\n     * @function Highcharts.Scrollbar#destroy\n     *\n     * @return {void}\n     */\n    destroy: function () {\n\n        var scroller = this.chart.scroller;\n\n        // Disconnect events added in addEvents\n        this.removeEvents();\n\n        // Destroy properties\n        each(\n            [\n                'track',\n                'scrollbarRifles',\n                'scrollbar',\n                'scrollbarGroup',\n                'group'\n            ],\n            function (prop) {\n                if (this[prop] && this[prop].destroy) {\n                    this[prop] = this[prop].destroy();\n                }\n            },\n            this\n        );\n\n        // #6421, chart may have more scrollbars\n        if (scroller && this === scroller.scrollbar) {\n            scroller.scrollbar = null;\n\n            // Destroy elements in collection\n            destroyObjectProperties(scroller.scrollbarButtons);\n        }\n    }\n};\n\n/*\n * Wrap axis initialization and create scrollbar if enabled:\n */\naddEvent(Axis, 'afterInit', function () {\n    var axis = this;\n\n    if (axis.options.scrollbar && axis.options.scrollbar.enabled) {\n        // Predefined options:\n        axis.options.scrollbar.vertical = !axis.horiz;\n        axis.options.startOnTick = axis.options.endOnTick = false;\n\n        axis.scrollbar = new Scrollbar(\n            axis.chart.renderer,\n            axis.options.scrollbar,\n            axis.chart\n        );\n\n        addEvent(axis.scrollbar, 'changed', function (e) {\n            var unitedMin = Math.min(\n                    pick(axis.options.min, axis.min),\n                    axis.min,\n                    axis.dataMin\n                ),\n                unitedMax = Math.max(\n                    pick(axis.options.max, axis.max),\n                    axis.max,\n                    axis.dataMax\n                ),\n                range = unitedMax - unitedMin,\n                to,\n                from;\n\n            if (\n                (axis.horiz && !axis.reversed) ||\n                (!axis.horiz && axis.reversed)\n            ) {\n                to = unitedMin + range * this.to;\n                from = unitedMin + range * this.from;\n            } else {\n                // y-values in browser are reversed, but this also applies for\n                // reversed horizontal axis:\n                to = unitedMin + range * (1 - this.from);\n                from = unitedMin + range * (1 - this.to);\n            }\n\n            axis.setExtremes(from, to, true, false, e);\n        });\n    }\n});\n\n/*\n * Wrap rendering axis, and update scrollbar if one is created:\n */\naddEvent(Axis, 'afterRender', function () {\n    var axis = this,\n        scrollMin = Math.min(\n            pick(axis.options.min, axis.min),\n            axis.min,\n            pick(axis.dataMin, axis.min) // #6930\n        ),\n        scrollMax = Math.max(\n            pick(axis.options.max, axis.max),\n            axis.max,\n            pick(axis.dataMax, axis.max) // #6930\n        ),\n        scrollbar = axis.scrollbar,\n        titleOffset = axis.titleOffset || 0,\n        offsetsIndex,\n        from,\n        to;\n\n    if (scrollbar) {\n\n        if (axis.horiz) {\n            scrollbar.position(\n                axis.left,\n                axis.top + axis.height + 2 + axis.chart.scrollbarsOffsets[1] +\n                    (axis.opposite ?\n                        0 :\n                        titleOffset + axis.axisTitleMargin + axis.offset\n                    ),\n                axis.width,\n                axis.height\n            );\n            offsetsIndex = 1;\n        } else {\n            scrollbar.position(\n                axis.left + axis.width + 2 + axis.chart.scrollbarsOffsets[0] +\n                    (axis.opposite ?\n                        titleOffset + axis.axisTitleMargin + axis.offset :\n                        0\n                    ),\n                axis.top,\n                axis.width,\n                axis.height\n            );\n            offsetsIndex = 0;\n        }\n\n        if ((!axis.opposite && !axis.horiz) || (axis.opposite && axis.horiz)) {\n            axis.chart.scrollbarsOffsets[offsetsIndex] +=\n                axis.scrollbar.size + axis.scrollbar.options.margin;\n        }\n\n        if (\n            isNaN(scrollMin) ||\n            isNaN(scrollMax) ||\n            !defined(axis.min) ||\n            !defined(axis.max)\n        ) {\n            // default action: when there is not extremes on the axis, but\n            // scrollbar exists, make it full size\n            scrollbar.setRange(0, 0);\n        } else {\n            from = (axis.min - scrollMin) / (scrollMax - scrollMin);\n            to = (axis.max - scrollMin) / (scrollMax - scrollMin);\n\n            if (\n                (axis.horiz && !axis.reversed) ||\n                (!axis.horiz && axis.reversed)\n            ) {\n                scrollbar.setRange(from, to);\n            } else {\n                scrollbar.setRange(1 - to, 1 - from); // inverse vertical axis\n            }\n        }\n    }\n});\n\n/*\n * Make space for a scrollbar\n */\naddEvent(Axis, 'afterGetOffset', function () {\n    var axis = this,\n        index = axis.horiz ? 2 : 1,\n        scrollbar = axis.scrollbar;\n\n    if (scrollbar) {\n        axis.chart.scrollbarsOffsets = [0, 0]; // reset scrollbars offsets\n        axis.chart.axisOffset[index] +=\n            scrollbar.size + scrollbar.options.margin;\n    }\n});\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Scrollbar = Scrollbar;\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Scrollbar.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Series.js":
/*!***************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Series.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend.js */ \"./node_modules/highcharts/js/es-modules/parts/Legend.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _SvgRenderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Translation and scale for the plot area of a series.\n *\n * @typedef Highcharts.SeriesPlotBoxObject\n *\n * @property {number} translateX\n *\n * @property {number} translateY\n *\n * @property {number} scaleX\n *\n * @property {number} scaleY\n */\n\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    animObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject,\n    arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    correctFloat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions,\n    defaultPlotOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPlotOptions,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    erase = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isString = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    LegendSymbolMixin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LegendSymbolMixin, // @todo add as a requirement\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point, // @todo  add as a requirement\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    SVGElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement,\n    syncTimeout = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win;\n\n/**\n * This is the base series prototype that all other series types inherit from.\n * A new series is initialized either through the\n * {@link https://api.highcharts.com/highcharts/series|series}\n * option structure, or after the chart is initialized, through\n * {@link Highcharts.Chart#addSeries}.\n *\n * The object can be accessed in a number of ways. All series and point event\n * handlers give a reference to the `series` object. The chart object has a\n * {@link Highcharts.Chart.series|series} property that is a collection of all\n * the chart's series. The point objects and axis objects also have the same\n * reference.\n *\n * Another way to reference the series programmatically is by `id`. Add an id\n * in the series configuration options, and get the series object by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the series are given in three levels. Options for\n * all series in a chart are given in the\n * {@link https://api.highcharts.com/highcharts/plotOptions.series|\n * plotOptions.series} object. Then options for all series of a specific type\n * are given in the plotOptions of that type, for example `plotOptions.line`.\n * Next, options for one single series are given in the series array, or as\n * arguements to `chart.addSeries`.\n *\n * The data in the series is stored in various arrays.\n *\n * - First, `series.options.data` contains all the original config options for\n *   each point whether added by options or methods like `series.addPoint`.\n *\n * - Next, `series.data` contains those values converted to points, but in case\n *   the series data length exceeds the `cropThreshold`, or if the data is\n *   grouped, `series.data` doesn't contain all the points. It only contains the\n *   points that have been created on demand.\n *\n * - Then there's `series.points` that contains all currently visible point\n *   objects. In case of cropping, the cropped-away points are not part of this\n *   array. The `series.points` array starts at `series.cropStart` compared to\n *   `series.data` and `series.options.data`. If however the series data is\n *   grouped, these can't be correlated one to one.\n *\n * - `series.xData` and `series.processedXData` contain clean x values,\n *   equivalent to `series.data` and `series.points`.\n *\n * - `series.yData` and `series.processedYData` contain clean y values,\n *   equivalent to `series.data` and `series.points`.\n *\n * @class\n * @name Highcharts.Series\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.PlotSeriesOptions} options\n *        The series options.\n *//**\n * The line series is the base type and is therefor the series base prototype.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.line\n *\n * @augments Highcharts.Series\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType('line', null\n\n/**\n * General options for all series types.\n *\n * @optionparent plotOptions.series\n */\n, { // base series options\n\n    \n\n    /**\n     * For some series, there is a limit that shuts down initial animation\n     * by default when the total number of points in the chart is too high.\n     * For example, for a column chart and its derivatives, animation doesn't\n     * run if there is more than 250 points totally. To disable this cap, set\n     * `animationLimit` to `Infinity`.\n     *\n     * @type      {number}\n     * @apioption plotOptions.series.animationLimit\n     */\n\n    /**\n     * Allow this series' points to be selected by clicking on the graphic\n     * (columns, point markers, pie slices, map areas etc).\n     *\n     * @see {@link Highcharts.Chart#getSelectedPoints}.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/\n     *         Line\n     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/\n     *         Column\n     * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/\n     *         Pie\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Map area\n     * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n     *         Map bubble\n     *\n     * @since 1.2.0\n     */\n    allowPointSelect: false,\n\n    /**\n     * If true, a checkbox is displayed next to the legend item to allow\n     * selecting the series. The state of the checkbox is determined by\n     * the `selected` option.\n     *\n     * @productdesc {highmaps}\n     * Note that if a `colorAxis` is defined, the color axis is represented in\n     * the legend, not the series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/\n     *         Show select box\n     *\n     * @since 1.2.0\n     */\n    showCheckbox: false,\n\n    /**\n     * Enable or disable the initial animation when a series is displayed.\n     * The animation can also be set as a configuration object. Please\n     * note that this option only applies to the initial animation of the\n     * series itself. For other animations, see [chart.animation](\n     * #chart.animation) and the animation parameter under the API methods. The\n     * following properties are supported:\n     *\n     * <dl>\n     *\n     * <dt>duration</dt>\n     *\n     * <dd>The duration of the animation in milliseconds.</dd>\n     *\n     * <dt>easing</dt>\n     *\n     * <dd>Can be a string reference to an easing function set on the `Math`\n     * object or a function. See the _Custom easing function_ demo below.</dd>\n     *\n     * </dl>\n     *\n     * Due to poor performance, animation is disabled in old IE browsers\n     * for several chart types.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/\n     *         Animation disabled\n     * @sample {highcharts} highcharts/plotoptions/series-animation-slower/\n     *         Slower animation\n     * @sample {highcharts} highcharts/plotoptions/series-animation-easing/\n     *         Custom easing function\n     * @sample {highstock} stock/plotoptions/animation-slower/\n     *         Slower animation\n     * @sample {highstock} stock/plotoptions/animation-easing/\n     *         Custom easing function\n     * @sample {highmaps} maps/plotoptions/series-animation-true/\n     *         Animation enabled on map series\n     * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/\n     *         Disabled on mapbubble series\n     *\n     * @type    {boolean|Highcharts.AnimationOptionsObject}\n     * @default {highcharts} true\n     * @default {highstock} true\n     * @default {highmaps} false\n     */\n    animation: {\n\n        /**\n         * @type      {number}\n         * @default   1000\n         * @apioption plotOptions.series.animation.duration\n         */\n        duration: 1000\n    },\n\n    /**\n     * An additional class name to apply to the series' graphical elements. This\n     * option does not replace default class names of the graphical element.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption plotOptions.series.className\n     */\n\n    /**\n     * Disable this option to allow series rendering in the whole plotting\n     * area.\n     *\n     * **Note:** Clipping should be always enabled when\n     * [chart.zoomType](#chart.zoomType) is set\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-clip/\n     *         Disabled clipping\n     *\n     * @default   true\n     * @type      {boolean}\n     * @since     3.0.0\n     * @apioption plotOptions.series.clip\n     */\n\n    /**\n     * The main color of the series. In line type series it applies to the\n     * line and the point markers unless otherwise specified. In bar type\n     * series it applies to the bars unless a color is specified per point.\n     * The default value is pulled from the `options.colors` array.\n     *\n     * In styled mode, the color can be defined by the\n     * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series\n     * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,\n     * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or\n     * individual classes given by the `className` option.\n     *\n     * @productdesc {highmaps}\n     * In maps, the series color is rarely used, as most choropleth maps use the\n     * color to denote the value of each point. The series color can however be\n     * used in a map with multiple series holding categorized data.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-color-general/\n     *         General plot option\n     * @sample {highcharts} highcharts/plotoptions/series-color-specific/\n     *         One specific series\n     * @sample {highcharts} highcharts/plotoptions/series-color-area/\n     *         Area color\n     * @sample {highcharts} highcharts/series/infographic/\n     *         Pattern fill\n     * @sample {highmaps} maps/demo/category-map/\n     *         Category map by multiple series\n     *\n     * @type      {Highcharts.ColorString}\n     * @apioption plotOptions.series.color\n     */\n\n    /**\n     * Styled mode only. A specific color index to use for the series, so its\n     * graphic representations are given the class name `highcharts-color-{n}`.\n     *\n     * @type      {number}\n     * @since     5.0.0\n     * @apioption plotOptions.series.colorIndex\n     */\n\n\n    /**\n     * Whether to connect a graph line across null points, or render a gap\n     * between the two points on either side of the null.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/\n     *         False by default\n     * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/\n     *         True\n     *\n     * @type      {boolean}\n     * @default   false\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.connectNulls\n     */\n\n\n    /**\n     * You can set the cursor to \"pointer\" if you have click events attached\n     * to the series, to signal to the user that the points and lines can\n     * be clicked.\n     *\n     * In styled mode, the series cursor can be set with the same classes\n     * as listed under [series.color](#plotOptions.series.color).\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-cursor-line/\n     *         On line graph\n     * @sample {highcharts} highcharts/plotoptions/series-cursor-column/\n     *         On columns\n     * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/\n     *         On scatter markers\n     * @sample {highstock} stock/plotoptions/cursor/\n     *         Pointer on a line graph\n     * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n     *         Map area\n     * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/\n     *         Map bubble\n     *\n     * @type       {string}\n     * @validvalue [\"crosshair\",\"default\",\"help\",\"none\",\"pointer\"]\n     * @apioption  plotOptions.series.cursor\n     */\n\n\n    /**\n     * A name for the dash style to use for the graph, or for some series types\n     * the outline of each shape.\n     *\n     * In styled mode, the [stroke dash-array](https://jsfiddle.net/gh/get/\n     * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/\n     * series-dashstyle/) can be set with the same classes as listed under\n     * [series.color](#plotOptions.series.color).\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/\n     *         Possible values demonstrated\n     * @sample {highcharts} highcharts/plotoptions/series-dashstyle/\n     *         Chart suitable for printing in black and white\n     * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/\n     *         Possible values demonstrated\n     * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/\n     *         Possible values demonstrated\n     * @sample {highmaps} maps/plotoptions/series-dashstyle/\n     *         Dotted borders on a map\n     *\n     * @type       {string}\n     * @default    Solid\n     * @since      2.1\n     * @validvalue [\"Dash\",\"DashDot\",\"Dot\",\"LongDash\",\"LongDashDot\",\n     *             \"LongDashDotDot\",\"ShortDash\",\"ShortDashDot\",\n     *             \"ShortDashDotDot\",\"ShortDot\",\"Solid\"]\n     * @apioption  plotOptions.series.dashStyle\n     */\n\n    /**\n     * Requires the Accessibility module.\n     *\n     * A description of the series to add to the screen reader information\n     * about the series.\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption plotOptions.series.description\n     */\n\n    /**\n     * Enable or disable the mouse tracking for a specific series. This\n     * includes point tooltips and click events on graphs and points. For\n     * large datasets it improves performance.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/\n     *         No mouse tracking\n     * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/\n     *         No mouse tracking\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption plotOptions.series.enableMouseTracking\n     */\n\n    /**\n     * By default, series are exposed to screen readers as regions. By enabling\n     * this option, the series element itself will be exposed in the same\n     * way as the data points. This is useful if the series is not used\n     * as a grouping entity in the chart, but you still want to attach a\n     * description to the series.\n     *\n     * Requires the Accessibility module.\n     *\n     * @sample highcharts/accessibility/art-grants/\n     *         Accessible data visualization\n     *\n     * @type      {boolean}\n     * @since     5.0.12\n     * @apioption plotOptions.series.exposeElementToA11y\n     */\n\n    /**\n     * Whether to use the Y extremes of the total chart width or only the\n     * zoomed area when zooming in on parts of the X axis. By default, the\n     * Y axis adjusts to the min and max of the visible data. Cartesian\n     * series only.\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.1.6\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.getExtremesFromAll\n     */\n\n    /**\n     * An array specifying which option maps to which key in the data point\n     * array. This makes it convenient to work with unstructured data arrays\n     * from different sources.\n     *\n     * @see [series.data](#series.line.data)\n     *\n     * @sample {highcharts|highstock} highcharts/series/data-keys/\n     *         An extended data array with keys\n     * @sample {highcharts|highstock} highcharts/series/data-nested-keys/\n     *         Nested keys used to access object properties\n     *\n     * @type      {Array<string>}\n     * @since     4.1.6\n     * @apioption plotOptions.series.keys\n     */\n\n    /**\n     * The line cap used for line ends and line joins on the graph.\n     *\n     * @type       {string}\n     * @product    highcharts highstock\n     * @validvalue [\"round\", \"square\"]\n     * @apioption  plotOptions.series.linecap\n     */\n\n    /**\n     * The [id](#series.id) of another series to link to. Additionally,\n     * the value can be \":previous\" to link to the previous series. When\n     * two series are linked, only the first one appears in the legend.\n     * Toggling the visibility of this also toggles the linked series.\n     *\n     * @sample {highcharts|highstock} highcharts/demo/arearange-line/\n     *         Linked series\n     *\n     * @type      {string}\n     * @since     3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.linkedTo\n     */\n\n    /**\n     * Options for the corresponding navigator series if `showInNavigator`\n     * is `true` for this series. Available options are the same as any\n     * series, documented at [plotOptions](#plotOptions.series) and\n     * [series](#series).\n     *\n     * These options are merged with options in [navigator.series](\n     * #navigator.series), and will take precedence if the same option is\n     * defined both places.\n     *\n     * @see [navigator.series](#navigator.series)\n     *\n     * @type      {*}\n     * @since     5.0.0\n     * @product   highstock\n     * @apioption plotOptions.series.navigatorOptions\n     */\n\n    /**\n     * The color for the parts of the graph or points that are below the\n     * [threshold](#plotOptions.series.threshold).\n     *\n     * @see In styled mode, a negative color is applied by setting this option\n     *      to `true` combined with the `.highcharts-negative` class name.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-negative-color/\n     *         Spline, area and column\n     * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/\n     *         Arearange\n     * @sample {highcharts} highcharts/css/series-negative-color/\n     *         Styled mode\n     * @sample {highstock} highcharts/plotoptions/series-negative-color/\n     *         Spline, area and column\n     * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/\n     *         Arearange\n     * @sample {highmaps} highcharts/plotoptions/series-negative-color/\n     *         Spline, area and column\n     * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/\n     *         Arearange\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     3.0\n     * @apioption plotOptions.series.negativeColor\n     */\n\n    /**\n     * Same as [accessibility.pointDescriptionFormatter](\n     * #accessibility.pointDescriptionFormatter), but for an individual series.\n     * Overrides the chart wide configuration.\n     *\n     * @type      {Function}\n     * @since     5.0.12\n     * @apioption plotOptions.series.pointDescriptionFormatter\n     */\n\n    /**\n     * If no x values are given for the points in a series, `pointInterval`\n     * defines the interval of the x values. For example, if a series contains\n     * one value every decade starting from year 0, set `pointInterval` to\n     * `10`. In true `datetime` axes, the `pointInterval` is set in\n     * milliseconds.\n     *\n     * It can be also be combined with `pointIntervalUnit` to draw irregular\n     * time intervals.\n     *\n     * Please note that this options applies to the _series data_, not the\n     * interval of the axis ticks, which is independent.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n     *         Datetime X axis\n     * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n     *         Using pointStart and pointInterval\n     *\n     * @type      {number}\n     * @default   1\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.pointInterval\n     */\n\n    /**\n     * On datetime series, this allows for setting the\n     * [pointInterval](#plotOptions.series.pointInterval) to irregular time\n     * units, `day`, `month` and `year`. A day is usually the same as 24 hours,\n     * but `pointIntervalUnit` also takes the DST crossover into consideration\n     * when dealing with local time. Combine this option with `pointInterval`\n     * to draw weeks, quarters, 6 months, 10 years etc.\n     *\n     * Please note that this options applies to the _series data_, not the\n     * interval of the axis ticks, which is independent.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/\n     *         One point a month\n     * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/\n     *         One point a month\n     *\n     * @type       {string}\n     * @since      4.1.0\n     * @product    highcharts highstock\n     * @validvalue [\"day\", \"month\", \"year\"]\n     * @apioption  plotOptions.series.pointIntervalUnit\n     */\n\n    /**\n     * Possible values: `\"on\"`, `\"between\"`, `number`.\n     *\n     * In a column chart, when pointPlacement is `\"on\"`, the point will\n     * not create any padding of the X axis. In a polar column chart this\n     * means that the first column points directly north. If the pointPlacement\n     * is `\"between\"`, the columns will be laid out between ticks. This\n     * is useful for example for visualising an amount between two points\n     * in time or in a certain sector of a polar chart.\n     *\n     * Since Highcharts 3.0.2, the point placement can also be numeric,\n     * where 0 is on the axis value, -0.5 is between this value and the\n     * previous, and 0.5 is between this value and the next. Unlike the\n     * textual options, numeric point placement options won't affect axis\n     * padding.\n     *\n     * Note that pointPlacement needs a [pointRange](\n     * #plotOptions.series.pointRange) to work. For column series this is\n     * computed, but for line-type series it needs to be set.\n     *\n     * Defaults to `undefined` in cartesian charts, `\"between\"` in polar charts.\n     *\n     * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/\n     *         Between in a column chart\n     * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/\n     *         Numeric placement for custom layout\n     *\n     * @type      {string|number}\n     * @since     2.3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.pointPlacement\n     */\n\n    /**\n     * If no x values are given for the points in a series, pointStart defines\n     * on what value to start. For example, if a series contains one yearly\n     * value starting from 1945, set pointStart to 1945.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/\n     *         Linear\n     * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/\n     *         Datetime\n     * @sample {highstock} stock/plotoptions/pointinterval-pointstart/\n     *         Using pointStart and pointInterval\n     *\n     * @type      {number}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.pointStart\n     */\n\n    /**\n     * Whether to select the series initially. If `showCheckbox` is true,\n     * the checkbox next to the series name in the legend will be checked for a\n     * selected series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-selected/\n     *         One out of two series selected\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     1.2.0\n     * @apioption plotOptions.series.selected\n     */\n\n    /**\n     * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow\n     * can be an object configuration containing `color`, `offsetX`, `offsetY`,\n     * `opacity` and `width`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-shadow/\n     *         Shadow enabled\n     *\n     * @type      {boolean|Highcharts.ShadowOptionsObject}\n     * @default   false\n     * @apioption plotOptions.series.shadow\n     */\n\n    /**\n     * Whether to display this particular series or series type in the legend.\n     * The default value is `true` for standalone series, `false` for linked\n     * series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-showinlegend/\n     *         One series in the legend, one hidden\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption plotOptions.series.showInLegend\n     */\n\n    /**\n     * Whether or not to show the series in the navigator. Takes precedence\n     * over [navigator.baseSeries](#navigator.baseSeries) if defined.\n     *\n     * @type      {boolean}\n     * @since     5.0.0\n     * @product   highstock\n     * @apioption plotOptions.series.showInNavigator\n     */\n\n    /**\n     * If set to `true`, the accessibility module will skip past the points\n     * in this series for keyboard navigation.\n     *\n     * @type      {boolean}\n     * @since     5.0.12\n     * @apioption plotOptions.series.skipKeyboardNavigation\n     */\n\n    /**\n     * Whether to stack the values of each series on top of each other. Possible\n     * values are `undefined` to disable, `\"normal\"` to stack by value or\n     * `\"percent\"`. When stacking is enabled, data must be sorted in ascending\n     * X order. A special stacking option is with the streamgraph series type,\n     * where the stacking option is set to `\"stream\"`.\n     *\n     * @see [yAxis.reversedStacks](#yAxis.reversedStacks)\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-line/\n     *         Line\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-column/\n     *         Column\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/\n     *         Bar\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-area/\n     *         Area\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/\n     *         Line\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/\n     *         Column\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/\n     *         Bar\n     * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/\n     *         Area\n     * @sample {highstock} stock/plotoptions/stacking/\n     *         Area\n     *\n     * @type       {string}\n     * @product    highcharts highstock\n     * @validvalue [\"normal\", \"percent\"]\n     * @apioption  plotOptions.series.stacking\n     */\n\n    /**\n     * Whether to apply steps to the line. Possible values are `left`, `center`\n     * and `right`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/line-step/\n     *         Different step line options\n     * @sample {highcharts} highcharts/plotoptions/area-step/\n     *         Stepped, stacked area\n     * @sample {highstock} stock/plotoptions/line-step/\n     *         Step line\n     *\n     * @type       {string}\n     * @since      1.2.5\n     * @product    highcharts highstock\n     * @validvalue [\"left\", \"center\", \"right\"]\n     * @apioption  plotOptions.series.step\n     */\n\n    /**\n     * The threshold, also called zero level or base level. For line type\n     * series this is only used in conjunction with\n     * [negativeColor](#plotOptions.series.negativeColor).\n     *\n     * @see [softThreshold](#plotOptions.series.softThreshold).\n     *\n     * @type      {number}\n     * @default   0\n     * @since     3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.threshold\n     */\n\n    /**\n     * Set the initial visibility of the series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-visible/\n     *         Two series, one hidden and one visible\n     * @sample {highstock} stock/plotoptions/series-visibility/\n     *         Hidden series\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption plotOptions.series.visible\n     */\n\n    /**\n     * Defines the Axis on which the zones are applied.\n     *\n     * @see [zones](#plotOptions.series.zones)\n     *\n     * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/\n     *         Zones on the X-Axis\n     * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/\n     *         Zones on the X-Axis\n     *\n     * @type      {string}\n     * @default   y\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zoneAxis\n     */\n\n    /**\n     * General event handlers for the series items. These event hooks can also\n     * be attached to the series at run time using the `Highcharts.addEvent`\n     * function.\n     */\n    events: {},\n\n    /**\n     * Fires after the series has finished its initial animation, or in\n     * case animation is disabled, immediately as the series is displayed.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/\n     *         Show label after animate\n     * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/\n     *         Show label after animate\n     *\n     * @type      {Function}\n     * @since     4.0\n     * @product   highcharts highstock\n     * @context   Series\n     * @apioption plotOptions.series.events.afterAnimate\n     */\n\n    /**\n     * Fires when the checkbox next to the series' name in the legend is\n     * clicked. One parameter, `event`, is passed to the function. The state\n     * of the checkbox is found by `event.checked`. The checked item is\n     * found by `event.item`. Return `false` to prevent the default action\n     * which is to toggle the select state of the series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/\n     *         Alert checkbox status\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Series\n     * @apioption plotOptions.series.events.checkboxClick\n     */\n\n    /**\n     * Fires when the series is clicked. One parameter, `event`, is passed to\n     * the function, containing common event information. Additionally,\n     * `event.point` holds a pointer to the nearest point on the graph.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-click/\n     *         Alert click info\n     * @sample {highstock} stock/plotoptions/series-events-click/\n     *         Alert click info\n     * @sample {highmaps} maps/plotoptions/series-events-click/\n     *         Display click info in subtitle\n     *\n     * @type      {Function}\n     * @context   Series\n     * @apioption plotOptions.series.events.click\n     */\n\n    /**\n     * Fires when the series is hidden after chart generation time, either\n     * by clicking the legend item or by calling `.hide()`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-hide/\n     *         Alert when the series is hidden by clicking the legend item\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Series\n     * @apioption plotOptions.series.events.hide\n     */\n\n    /**\n     * Fires when the legend item belonging to the series is clicked. One\n     * parameter, `event`, is passed to the function. The default action\n     * is to toggle the visibility of the series. This can be prevented\n     * by returning `false` or calling `event.preventDefault()`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/\n     *         Confirm hiding and showing\n     *\n     * @type      {Function}\n     * @context   Series\n     * @apioption plotOptions.series.events.legendItemClick\n     */\n\n    /**\n     * Fires when the mouse leaves the graph. One parameter, `event`, is\n     * passed to the function, containing common event information. If the\n     * [stickyTracking](#plotOptions.series) option is true, `mouseOut`\n     * doesn't happen before the mouse enters another graph or leaves the\n     * plot area.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n     *         With sticky tracking by default\n     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n     *         Without sticky tracking\n     *\n     * @type      {Function}\n     * @context   Series\n     * @apioption plotOptions.series.events.mouseOut\n     */\n\n    /**\n     * Fires when the mouse enters the graph. One parameter, `event`, is\n     * passed to the function, containing common event information.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/\n     *         With sticky tracking by default\n     * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/\n     *         Without sticky tracking\n     *\n     * @type      {Function}\n     * @context   Series\n     * @apioption plotOptions.series.events.mouseOver\n     */\n\n    /**\n     * Fires when the series is shown after chart generation time, either\n     * by clicking the legend item or by calling `.show()`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-events-show/\n     *         Alert when the series is shown by clicking the legend item.\n     *\n     * @type      {Function}\n     * @since     1.2.0\n     * @context   Series\n     * @apioption plotOptions.series.events.show\n     */\n\n    /**\n     * Options for the point markers of line-like series. Properties like\n     * `fillColor`, `lineColor` and `lineWidth` define the visual appearance\n     * of the markers. Other series types, like column series, don't have\n     * markers, but have visual options on the series level instead.\n     *\n     * In styled mode, the markers can be styled with the `.highcharts-point`,\n     * `.highcharts-point-hover` and `.highcharts-point-select`\n     * class names.\n     */\n    marker: {\n\n        \n\n        /**\n         * Enable or disable the point marker. If `undefined`, the markers are\n         * hidden when the data is dense, and shown for more widespread data\n         * points.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/\n         *         Disabled markers\n         * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/\n         *         Disabled in normal state but enabled on hover\n         * @sample {highstock} stock/plotoptions/series-marker/\n         *         Enabled markers\n         *\n         * @type      {boolean}\n         * @default   {highcharts} undefined\n         * @default   {highstock} false\n         * @apioption plotOptions.series.marker.enabled\n         */\n\n        /**\n         * Image markers only. Set the image width explicitly. When using this\n         * option, a `width` must also be set.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n         *         Fixed width and height\n         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n         *         Fixed width and height\n         *\n         * @type      {number}\n         * @since     4.0.4\n         * @apioption plotOptions.series.marker.height\n         */\n\n        /**\n         * A predefined shape or symbol for the marker. When undefined, the\n         * symbol is pulled from options.symbols. Other possible values are\n         * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n         *\n         * Additionally, the URL to a graphic can be given on this form:\n         * \"url(graphic.png)\". Note that for the image to be applied to exported\n         * charts, its URL needs to be accessible by the export server.\n         *\n         * Custom callbacks for symbol path generation can also be added to\n         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n         * used by its method name, as shown in the demo.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n         *         Predefined, graphic and custom markers\n         * @sample {highstock} highcharts/plotoptions/series-marker-symbol/\n         *         Predefined, graphic and custom markers\n         *\n         * @type      {string}\n         * @apioption plotOptions.series.marker.symbol\n         */\n\n        /**\n         * The threshold for how dense the point markers should be before they\n         * are hidden, given that `enabled` is not defined. The number indicates\n         * the horizontal distance between the two closest points in the series,\n         * as multiples of the `marker.radius`. In other words, the default\n         * value of 2 means points are hidden if overlapping horizontally.\n         *\n         * @sample highcharts/plotoptions/series-marker-enabledthreshold\n         *         A higher threshold\n         *\n         * @since 6.0.5\n         */\n        enabledThreshold: 2,\n\n        /**\n         * The radius of the point marker.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-radius/\n         *         Bigger markers\n         */\n        radius: 4,\n\n        /**\n         * Image markers only. Set the image width explicitly. When using this\n         * option, a `height` must also be set.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/\n         *         Fixed width and height\n         * @sample {highstock} highcharts/plotoptions/series-marker-width-height/\n         *         Fixed width and height\n         *\n         * @type      {number}\n         * @since     4.0.4\n         * @apioption plotOptions.series.marker.width\n         */\n\n        /**\n         * States for a single point marker.\n         */\n        states: {\n\n            /**\n             * The normal state of a single point marker. Currently only used\n             * for setting animation when returning to normal state from hover.\n             */\n            normal: {\n                /**\n                 * Animation when returning to normal state after hovering.\n                 *\n                 * @type {boolean|Highcharts.AnimationOptionsObject}\n                 */\n                animation: true\n            },\n\n            /**\n             * The hover state for a single point marker.\n             */\n            hover: {\n\n                /**\n                 * Animation when hovering over the marker.\n                 *\n                 * @type {boolean|Highcharts.AnimationOptionsObject}\n                 */\n                animation: {\n\n                    duration: 50\n\n                },\n\n                /**\n                 * Enable or disable the point marker.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/\n                 *         Disabled hover state\n                 */\n                enabled: true,\n\n                /**\n                 * The fill color of the marker in hover state. When\n                 * `undefined`, the series' or point's fillColor for normal\n                 * state is used.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @apioption plotOptions.series.marker.states.hover.fillColor\n                 */\n\n                /**\n                 * The color of the point marker's outline. When `undefined`,\n                 * the series' or point's lineColor for normal state is used.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/\n                 *         White fill color, black line color\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @apioption plotOptions.series.marker.states.hover.lineColor\n                 */\n\n                /**\n                 * The width of the point marker's outline. When `undefined`,\n                 * the series' or point's lineWidth for normal state is used.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/\n                 *         3px line width\n                 *\n                 * @type      {number}\n                 * @apioption plotOptions.series.marker.states.hover.lineWidth\n                 */\n\n                /**\n                 * The radius of the point marker. In hover state, it defaults\n                 * to the normal state's radius + 2 as per the [radiusPlus](\n                 * #plotOptions.series.marker.states.hover.radiusPlus)\n                 * option.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/\n                 *         10px radius\n                 *\n                 * @type      {number}\n                 * @apioption plotOptions.series.marker.states.hover.radius\n                 */\n\n                /**\n                 * The number of pixels to increase the radius of the hovered\n                 * point.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n                 *         5 pixels greater radius on hover\n                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n                 *         5 pixels greater radius on hover\n                 *\n                 * @since 4.0.3\n                 */\n                radiusPlus: 2\n\n                \n\n            }\n\n            \n\n        }\n    },\n\n    /**\n     * Properties for each single point.\n     */\n    point: {\n\n        /**\n         * Fires when a point is clicked. One parameter, `event`, is passed\n         * to the function, containing common event information.\n         *\n         * If the `series.allowPointSelect` option is true, the default\n         * action for the point's click event is to toggle the point's\n         * select state. Returning `false` cancels this action.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-click/\n         *         Click marker to alert values\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/\n         *         Click column\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/\n         *         Go to URL\n         * @sample {highmaps} maps/plotoptions/series-point-events-click/\n         *         Click marker to display values\n         * @sample {highmaps} maps/plotoptions/series-point-events-click-url/\n         *         Go to URL\n         *\n         * @type      {Function}\n         * @context   Point\n         * @apioption plotOptions.series.point.events.click\n         */\n\n        /**\n         * Fires when the mouse leaves the area close to the point. One\n         * parameter, `event`, is passed to the function, containing common\n         * event information.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n         *         Show values in the chart's corner on mouse over\n         *\n         * @type      {Function}\n         * @context   Point\n         * @apioption plotOptions.series.point.events.mouseOut\n         */\n\n        /**\n         * Fires when the mouse enters the area close to the point. One\n         * parameter, `event`, is passed to the function, containing common\n         * event information.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/\n         *         Show values in the chart's corner on mouse over\n         *\n         * @type      {Function}\n         * @context   Point\n         * @apioption plotOptions.series.point.events.mouseOver\n         */\n\n        /**\n         * Fires when the point is removed using the `.remove()` method. One\n         * parameter, `event`, is passed to the function. Returning `false`\n         * cancels the operation.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/\n         *         Remove point and confirm\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Point\n         * @apioption plotOptions.series.point.events.remove\n         */\n\n        /**\n         * Fires when the point is selected either programmatically or\n         * following a click on the point. One parameter, `event`, is passed\n         * to the function. Returning `false` cancels the operation.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-select/\n         *         Report the last selected point\n         * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n         *         Report select and unselect\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Point\n         * @apioption plotOptions.series.point.events.select\n         */\n\n        /**\n         * Fires when the point is unselected either programmatically or\n         * following a click on the point. One parameter, `event`, is passed\n         * to the function.\n         *  Returning `false` cancels the operation.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/\n         *         Report the last unselected point\n         * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n         *         Report select and unselect\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Point\n         * @apioption plotOptions.series.point.events.unselect\n         */\n\n        /**\n         * Fires when the point is updated programmatically through the\n         * `.update()` method. One parameter, `event`, is passed to the\n         * function. The new point options can be accessed through\n         * `event.options`. Returning `false` cancels the operation.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-point-events-update/\n         *         Confirm point updating\n         *\n         * @type      {Function}\n         * @since     1.2.0\n         * @context   Point\n         * @apioption plotOptions.series.point.events.update\n         */\n\n        /**\n         * Events for each single point.\n         */\n        events: {}\n    },\n\n\n\n    /**\n     * Options for the series data labels, appearing next to each data point.\n     *\n     * In styled mode, the data labels can be styled with the\n     * `.highcharts-data-label-box` and `.highcharts-data-label` class names\n     * ([see example](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-datalabels)).\n     */\n    dataLabels: {\n\n\n        /**\n         * The alignment of the data label compared to the point. If `right`,\n         * the right side of the label should be touching the point. For\n         * points with an extent, like columns, the alignments also dictates\n         * how to align it inside the box, as given with the\n         * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of\n         * `left`, `center` or `right`.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/\n         *         Left aligned\n         *\n         * @validvalue [\"left\", \"center\", \"right\"]\n         */\n        align: 'center',\n\n\n        /**\n         * Whether to allow data labels to overlap. To make the labels less\n         * sensitive for overlapping, the [dataLabels.padding](\n         * #plotOptions.series.dataLabels.padding) can be set to 0.\n         *\n         * @sample highcharts/plotoptions/series-datalabels-allowoverlap-false/\n         *         Don't allow overlap\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     4.1.0\n         * @apioption plotOptions.series.dataLabels.allowOverlap\n         */\n\n\n        /**\n         * The border radius in pixels for the data label.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.2.1\n         * @apioption plotOptions.series.dataLabels.borderRadius\n         */\n\n\n        /**\n         * The border width in pixels for the data label.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         * @sample {highstock} highcharts/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.2.1\n         * @apioption plotOptions.series.dataLabels.borderWidth\n         */\n\n        /**\n         * A class name for the data label. Particularly in styled mode, this\n         * can be used to give each series' or point's data label unique\n         * styling. In addition to this option, a default color class name is\n         * added so that we can give the labels a\n         * [contrast text shadow](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-label-contrast/).\n         *\n         * @sample {highcharts} highcharts/css/series-datalabels/\n         *         Styling by CSS\n         * @sample {highstock} highcharts/css/series-datalabels/\n         *         Styling by CSS\n         * @sample {highmaps} highcharts/css/series-datalabels/\n         *         Styling by CSS\n         *\n         * @type      {string}\n         * @since     5.0.0\n         * @apioption plotOptions.series.dataLabels.className\n         */\n\n        /**\n         * The text color for the data labels. Defaults to `undefined`. For\n         * certain series types, like column or map, the data labels can be\n         * drawn inside the points. In this case the data label will be drawn\n         * with maximum contrast by default. Additionally, it will be given a\n         * `text-outline` style with the opposite color, to further increase the\n         * contrast. This can be overridden by setting the `text-outline` style\n         * to `none` in the `dataLabels.style` option.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/\n         *         Red data labels\n         * @sample {highmaps} maps/demo/color-axis/\n         *         White data labels\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption plotOptions.series.dataLabels.color\n         */\n\n        /**\n         * Whether to hide data labels that are outside the plot area. By\n         * default, the data label is moved inside the plot area according to\n         * the [overflow](#plotOptions.series.dataLabels.overflow) option.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     2.3.3\n         * @apioption plotOptions.series.dataLabels.crop\n         */\n\n        /**\n         * Whether to defer displaying the data labels until the initial series\n         * animation has finished.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.0\n         * @product   highcharts highstock\n         * @apioption plotOptions.series.dataLabels.defer\n         */\n\n        /**\n         * Enable or disable the data labels.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/\n         *         Data labels enabled\n         * @sample {highmaps} maps/demo/color-axis/\n         *         Data labels enabled\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption plotOptions.series.dataLabels.enabled\n         */\n\n        /**\n         * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n         * for the data label. Available variables are the same as for\n         * `formatter`.\n         *\n         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-format/\n         *         Add a unit\n         * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n         *         Formatted value in the data label\n         *\n         * @type      {string}\n         * @default   {highcharts} {y}\n         * @default   {highstock} {y}\n         * @default   {highmaps} {point.value}\n         * @since     3.0\n         * @apioption plotOptions.series.dataLabels.format\n         */\n\n        /**\n         * Callback JavaScript function to format the data label. Note that if a\n         * `format` is defined, the format takes precedence and the formatter is\n         * ignored. Available data are:\n         *\n         * <table>\n         *\n         * <tbody>\n         *\n         * <tr>\n         *\n         * <td>`this.percentage`</td>\n         *\n         * <td>Stacked series and pies only. The point's percentage of the\n         * total.</td>\n         *\n         * </tr>\n         *\n         * <tr>\n         *\n         * <td>`this.point`</td>\n         *\n         * <td>The point object. The point name, if defined, is available\n         * through `this.point.name`.</td>\n         *\n         * </tr>\n         *\n         * <tr>\n         *\n         * <td>`this.series`:</td>\n         *\n         * <td>The series object. The series name is available through\n         * `this.series.name`.</td>\n         *\n         * </tr>\n         *\n         * <tr>\n         *\n         * <td>`this.total`</td>\n         *\n         * <td>Stacked series only. The total value at this point's x value.\n         * </td>\n         *\n         * </tr>\n         *\n         * <tr>\n         *\n         * <td>`this.x`:</td>\n         *\n         * <td>The x value.</td>\n         *\n         * </tr>\n         *\n         * <tr>\n         *\n         * <td>`this.y`:</td>\n         *\n         * <td>The y value.</td>\n         *\n         * </tr>\n         *\n         * </tbody>\n         *\n         * </table>\n         *\n         * @sample {highmaps} maps/plotoptions/series-datalabels-format/\n         *         Formatted value\n         *\n         * @type    {Highcharts.FormatterCallbackFunction}\n         * @default function () { return this.y; }\n         */\n        formatter: function () {\n            return this.y === null ? '' : _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(this.y, -1);\n        },\n\n        \n\n        /**\n         * For points with an extent, like columns or map areas, whether to\n         * align the data label inside the box or to the actual value point.\n         * Defaults to `false` in most cases, `true` in stacked columns.\n         *\n         * @type      {boolean}\n         * @since     3.0\n         * @apioption plotOptions.series.dataLabels.inside\n         */\n\n        /**\n         * How to handle data labels that flow outside the plot area. The\n         * default is `\"justify\"`, which aligns them inside the plot area. For\n         * columns and bars, this means it will be moved inside the bar. To\n         * display data labels outside the plot area, set `crop` to `false` and\n         * `overflow` to `\"allow\"`.\n         *\n         * @type       {string}\n         * @default    justify\n         * @since      3.0.6\n         * @validvalue [\"allow\", \"justify\"]\n         * @apioption  plotOptions.series.dataLabels.overflow\n         */\n\n        /**\n         * Text rotation in degrees. Note that due to a more complex structure,\n         * backgrounds, borders and padding will be lost on a rotated data\n         * label.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n         *         Vertical labels\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption plotOptions.series.dataLabels.rotation\n         */\n\n        /**\n         * Whether to\n         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)\n         * to render the labels.\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption plotOptions.series.dataLabels.useHTML\n         */\n\n        /**\n         * The vertical alignment of a data label. Can be one of `top`, `middle`\n         * or `bottom`. The default value depends on the data, for instance\n         * in a column chart, the label is above positive values and below\n         * negative values.\n         *\n         * @since      2.3.3\n         * @validvalue [\"top\", \"middle\", \"bottom\"]\n         */\n        verticalAlign: 'bottom', // above singular point\n\n\n        /**\n         * The x position offset of the label relative to the point in pixels.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n         *         Vertical and positioned\n         */\n        x: 0,\n\n\n        /**\n         * The y position offset of the label relative to the point in pixels.\n         *\n         * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/\n         *         Vertical and positioned\n         */\n        y: 0,\n\n\n        /**\n         * When either the `borderWidth` or the `backgroundColor` is set,\n         * this is the padding within the box.\n         *\n         * @sample {highcharts|highstock} highcharts/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         * @sample {highmaps} maps/plotoptions/series-datalabels-box/\n         *         Data labels box options\n         *\n         * @default {highcharts} 5\n         * @default {highstock} 5\n         * @default {highmaps} 0\n         * @since   2.2.1\n         */\n        padding: 5\n    },\n\n    /**\n     * When the series contains less points than the crop threshold, all\n     * points are drawn, even if the points fall outside the visible plot\n     * area at the current zoom. The advantage of drawing all points (including\n     * markers and columns), is that animation is performed on updates.\n     * On the other hand, when the series contains more points than the\n     * crop threshold, the series data is cropped to only contain points\n     * that fall within the plot area. The advantage of cropping away invisible\n     * points is to increase performance on large series.\n     *\n     * @since   2.2\n     * @product highcharts highstock\n     */\n    cropThreshold: 300,\n\n\n\n    /**\n     * The width of each point on the x axis. For example in a column chart\n     * with one value each day, the pointRange would be 1 day (= 24 * 3600\n     * * 1000 milliseconds). This is normally computed automatically, but\n     * this option can be used to override the automatic value.\n     *\n     * @product highstock\n     */\n    pointRange: 0,\n\n    /**\n     * When this is true, the series will not cause the Y axis to cross\n     * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n     * unless the data actually crosses the plane.\n     *\n     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n     * 3 will make the Y axis show negative values according to the `minPadding`\n     * option. If `softThreshold` is `true`, the Y axis starts at 0.\n     *\n     * @since   4.1.9\n     * @product highcharts highstock\n     */\n    softThreshold: true,\n\n\n\n    /**\n     * A wrapper object for all the series options in specific states.\n     */\n    states: {\n\n        /**\n         * The normal state of a series, or for point items in column, pie and\n         * similar series. Currently only used for setting animation when\n         * returning to normal state from hover.\n         */\n        normal: {\n            /**\n             * Animation when returning to normal state after hovering.\n             *\n             * @type {boolean|Highcharts.AnimationOptionsObject}\n             */\n            animation: true\n        },\n\n        /**\n         * Options for the hovered series. These settings override the normal\n         * state options when a series is moused over or touched.\n         */\n        hover: {\n\n            /**\n             * Enable separate styles for the hovered series to visualize that\n             * the user hovers either the series itself or the legend. .\n             *\n             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/\n             *         Line\n             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/\n             *         Column\n             * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/\n             *         Pie\n             *\n             * @type      {boolean}\n             * @default   true\n             * @since     1.2\n             * @apioption plotOptions.series.states.hover.enabled\n             */\n\n\n            /**\n             * Animation setting for hovering the graph in line-type series.\n             *\n             * @type    {boolean|Highcharts.AnimationOptionsObject}\n             * @since   5.0.8\n             * @product highcharts\n             */\n            animation: {\n\n                /**\n                 * The duration of the hover animation in milliseconds. By\n                 * default the hover state animates quickly in, and slowly back\n                 * to normal.\n                 */\n                duration: 50\n            },\n\n            /**\n             * Pixel width of the graph line. By default this property is\n             * undefined, and the `lineWidthPlus` property dictates how much\n             * to increase the linewidth from normal state.\n             *\n             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/\n             *         5px line on hover\n             *\n             * @type      {number}\n             * @product   highcharts highstock\n             * @apioption plotOptions.series.states.hover.lineWidth\n             */\n\n\n            /**\n             * The additional line width for the graph of a hovered series.\n             *\n             * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/\n             *         5 pixels wider\n             * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/\n             *         5 pixels wider\n             *\n             * @since   4.0.3\n             * @product highcharts highstock\n             */\n            lineWidthPlus: 1,\n\n            /**\n             * In Highcharts 1.0, the appearance of all markers belonging to the\n             * hovered series. For settings on the hover state of the individual\n             * point, see\n             * [marker.states.hover](#plotOptions.series.marker.states.hover).\n             *\n             * @deprecated\n             *\n             * @extends plotOptions.series.marker\n             * @product highcharts highstock\n             */\n            marker: {\n                // lineWidth: base + 1,\n                // radius: base + 1\n            },\n\n            /**\n             * Options for the halo appearing around the hovered point in line-\n             * type series as well as outside the hovered slice in pie charts.\n             * By default the halo is filled by the current point or series\n             * color with an opacity of 0.25\\. The halo can be disabled by\n             * setting the `halo` option to `false`.\n             *\n             * In styled mode, the halo is styled with the `.highcharts-halo`\n             * class, with colors inherited from `.highcharts-color-{n}`.\n             *\n             * @sample {highcharts} highcharts/plotoptions/halo/\n             *         Halo options\n             * @sample {highstock} highcharts/plotoptions/halo/\n             *         Halo options\n             *\n             * @since   4.0\n             * @product highcharts highstock\n             */\n            halo: {\n\n                /**\n                 * A collection of SVG attributes to override the appearance of\n                 * the halo, for example `fill`, `stroke` and `stroke-width`.\n                 *\n                 * @type      {Highcharts.SVGAttributes}\n                 * @since     4.0\n                 * @product   highcharts highstock\n                 * @apioption plotOptions.series.states.hover.halo.attributes\n                 */\n\n\n                /**\n                 * The pixel size of the halo. For point markers this is the\n                 * radius of the halo. For pie slices it is the width of the\n                 * halo outside the slice. For bubbles it defaults to 5 and is\n                 * the width of the halo outside the bubble.\n                 *\n                 * @since   4.0\n                 * @product highcharts highstock\n                 */\n                size: 10\n\n                \n\n            }\n        },\n\n\n        /**\n         * Specific options for point in selected states, after being selected\n         * by [allowPointSelect](#plotOptions.series.allowPointSelect) or\n         * programmatically.\n         *\n         * @sample {highmaps} maps/plotoptions/series-allowpointselect/\n         *         Allow point select demo\n         *\n         * @extends   plotOptions.series.states.hover\n         * @excluding brightness\n         * @product   highmaps\n         */\n        select: {\n            // marker: {}\n        }\n    },\n\n\n\n    /**\n     * Sticky tracking of mouse events. When true, the `mouseOut` event\n     * on a series isn't triggered until the mouse moves over another series,\n     * or out of the plot area. When false, the `mouseOut` event on a\n     * series is triggered when the mouse leaves the area around the series'\n     * graph or markers. This also implies the tooltip when not shared. When\n     * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will\n     * be hidden when moving the mouse between series. Defaults to true for line\n     * and area type series, but to false for columns, pies etc.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/\n     *         True by default\n     * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/\n     *         False\n     *\n     * @default {highcharts} true\n     * @default {highstock} true\n     * @default {highmaps} false\n     * @since   2.0\n     */\n    stickyTracking: true,\n\n    /**\n     * A configuration object for the tooltip rendering of each single series.\n     * Properties are inherited from [tooltip](#tooltip), but only the\n     * following properties can be defined on a series level.\n     *\n     * @since     2.3\n     * @extends   tooltip\n     * @excluding animation,backgroundColor,borderColor,borderRadius,\n     *            borderWidth,crosshairs,enabled,formatter,positioner,shadow,\n     *            shared,shape,snap,style,useHTML\n     * @apioption plotOptions.series.tooltip\n     */\n\n    /**\n     * When a series contains a data array that is longer than this, only\n     * one dimensional arrays of numbers, or two dimensional arrays with\n     * x and y values are allowed. Also, only the first point is tested,\n     * and the rest are assumed to be the same format. This saves expensive\n     * data checking and indexing in long series. Set it to `0` disable.\n     *\n     * @since   2.2\n     * @product highcharts highstock\n     */\n    turboThreshold: 1000,\n\n    /**\n     * An array defining zones within a series. Zones can be applied to\n     * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`\n     * option. The zone definitions have to be in ascending order regarding to\n     * the value.\n     *\n     * In styled mode, the color zones are styled with the\n     * `.highcharts-zone-{n}` class, or custom classed from the `className`\n     * option\n     * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).\n     *\n     * @see [zoneAxis](#plotOptions.series.zoneAxis)\n     *\n     * @sample {highcharts} highcharts/series/color-zones-simple/\n     *         Color zones\n     * @sample {highstock} highcharts/series/color-zones-simple/\n     *         Color zones\n     *\n     * @type      {Array<*>}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zones\n     */\n\n    /**\n     * Styled mode only. A custom class name for the zone.\n     *\n     * @sample highcharts/css/color-zones/\n     *         Zones styled by class name\n     *\n     * @type      {string}\n     * @since     5.0.0\n     * @apioption plotOptions.series.zones.className\n     */\n\n    /**\n     * Defines the color of the series.\n     *\n     * @see [series color](#plotOptions.series.color)\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zones.color\n     */\n\n    /**\n     * A name for the dash style to use for the graph.\n     *\n     * @see [series.dashStyle](#plotOptions.series.dashStyle)\n     *\n     * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/\n     *         Dashed line indicates prognosis\n     *\n     * @type      {string}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zones.dashStyle\n     */\n\n    /**\n     * Defines the fill color for the series (in area type series)\n     *\n     * @see [fillColor](#plotOptions.area.fillColor)\n     *\n     * @type      {Highcharts.ColorString}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zones.fillColor\n     */\n\n    /**\n     * The value up to where the zone extends, if undefined the zones stretches\n     * to the last value in the series.\n     *\n     * @type      {number}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.series.zones.value\n     */\n\n    /**\n     * Determines whether the series should look for the nearest point\n     * in both dimensions or just the x-dimension when hovering the series.\n     * Defaults to `'xy'` for scatter series and `'x'` for most other\n     * series. If the data has duplicate x-values, it is recommended to\n     * set this to `'xy'` to allow hovering over all points.\n     *\n     * Applies only to series types using nearest neighbor search (not\n     * direct hover) for tooltip.\n     *\n     * @sample {highcharts} highcharts/series/findnearestpointby/\n     *         Different hover behaviors\n     * @sample {highstock} highcharts/series/findnearestpointby/\n     *         Different hover behaviors\n     * @sample {highmaps} highcharts/series/findnearestpointby/\n     *         Different hover behaviors\n     *\n     * @since      5.0.10\n     * @validvalue [\"x\", \"xy\"]\n     */\n    findNearestPointBy: 'x'\n\n}, /** @lends Highcharts.Series.prototype */ {\n\n    /**\n     * Series options for specific data and the data itself. In TypeScript you\n     * have to cast the series options to specific series types, to get all\n     * possible options for a series.\n     *\n     * @example\n     * // TypeScript example\n     * Highcharts.chart('container', {\n     *     series: [{\n     *         color: '#06C',\n     *         data: [[0, 1], [2, 3]]\n     *     } as Highcharts.SeriesLineOptions ]\n     * });\n     *\n     *\n     * @type      {Array<*>}\n     * @apioption series\n     */\n\n    /**\n     * An id for the series. This can be used after render time to get a pointer\n     * to the series object through `chart.get()`.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-id/\n     *         Get series by id\n     *\n     * @type      {string}\n     * @since     1.2.0\n     * @apioption series.id\n     */\n\n    /**\n     * The index of the series in the chart, affecting the internal index in the\n     * `chart.series` array, the visible Z index as well as the order in the\n     * legend.\n     *\n     * @type      {number}\n     * @since     2.3.0\n     * @apioption series.index\n     */\n\n    /**\n     * The sequential index of the series in the legend.\n     *\n     * @see [legend.reversed](#legend.reversed),\n     *      [yAxis.reversedStacks](#yAxis.reversedStacks)\n     *\n     * @sample {highcharts|highstock} highcharts/series/legendindex/\n     *         Legend in opposite order\n     *\n     * @type      {number}\n     * @apioption series.legendIndex\n     */\n    /**\n     * The name of the series as shown in the legend, tooltip etc.\n     *\n     * @sample {highcharts} highcharts/series/name/\n     *         Series name\n     * @sample {highmaps} maps/demo/category-map/\n     *         Series name\n     *\n     * @type      {string}\n     * @apioption series.name\n     */\n\n    /**\n     * This option allows grouping series in a stacked chart. The stack option\n     * can be a string or anything else, as long as the grouped series' stack\n     * options match each other after conversion into a string.\n     *\n     * @sample {highcharts} highcharts/series/stack/\n     *         Stacked and grouped columns\n     *\n     * @type      {string|*}\n     * @since     2.1\n     * @product   highcharts highstock\n     * @apioption series.stack\n     */\n\n    /**\n     * The type of series, for example `line` or `column`. By default, the\n     * series type is inherited from [chart.type](#chart.type), so unless the\n     * chart is a combination of series types, there is no need to set it on the\n     * series level.\n     *\n     * @sample {highcharts} highcharts/series/type/\n     *         Line and column in the same chart\n     * @sample {highmaps} maps/demo/mapline-mappoint/\n     *         Multiple types in the same map\n     *\n     * @type      {string}\n     * @apioption series.type\n     */\n\n    /**\n     * When using dual or multiple x axes, this number defines which xAxis the\n     * particular series is connected to. It refers to either the\n     * {@link #xAxis.id|axis id}\n     * or the index of the axis in the xAxis array, with 0 being the first.\n     *\n     * @type      {number|string}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption series.xAxis\n     */\n\n    /**\n     * When using dual or multiple y axes, this number defines which yAxis the\n     * particular series is connected to. It refers to either the\n     * {@link #yAxis.id|axis id}\n     * or the index of the axis in the yAxis array, with 0 being the first.\n     *\n     * @sample {highcharts} highcharts/series/yaxis/\n     *         Apply the column series to the secondary Y axis\n     *\n     * @type      {number|string}\n     * @default   0\n     * @product   highcharts highstock\n     * @apioption series.yAxis\n     */\n\n    /**\n     * Define the visual z index of the series.\n     *\n     * @sample {highcharts} highcharts/plotoptions/series-zindex-default/\n     *         With no z index, the series defined last are on top\n     * @sample {highcharts} highcharts/plotoptions/series-zindex/\n     *         With a z index, the series with the highest z index is on top\n     * @sample {highstock} highcharts/plotoptions/series-zindex-default/\n     *         With no z index, the series defined last are on top\n     * @sample {highstock} highcharts/plotoptions/series-zindex/\n     *         With a z index, the series with the highest z index is on top\n     *\n     * @type      {number}\n     * @product   highcharts highstock\n     * @apioption series.zIndex\n     */\n\n    isCartesian: true,\n    pointClass: Point,\n    sorted: true, // requires the data to be sorted\n    requireSorting: true,\n    directTouch: false,\n    axisTypes: ['xAxis', 'yAxis'],\n    colorCounter: 0,\n    // each point's x and y values are stored in this.xData and this.yData\n    parallelArrays: ['x', 'y'],\n    coll: 'series',\n    init: function (chart, options) {\n        var series = this,\n            events,\n            chartSeries = chart.series,\n            lastSeries;\n\n        /**\n         * Read only. The chart that the series belongs to.\n         *\n         * @name Highcharts.Series#chart\n         * @type {Highcharts.Chart}\n         */\n        series.chart = chart;\n\n        /**\n         * Read only. The series' type, like \"line\", \"area\", \"column\" etc. The\n         * type in the series options anc can be altered using {@link\n         * Series#update}.\n         *\n         * @name Highcharts.Series#type\n         * @type {string}\n         */\n\n        /**\n         * Read only. The series' current options. To update, use {@link\n         * Series#update}.\n         *\n         * @name Highcharts.Series#options\n         * @type {Highcharts.PlotSeriesOptions}\n         */\n        series.options = options = series.setOptions(options);\n        series.linkedSeries = [];\n\n        // bind the axes\n        series.bindAxes();\n\n        // set some variables\n        extend(series, {\n            /**\n             * The series name as given in the options. Defaults to\n             * \"Series {n}\".\n             *\n             * @name Highcharts.Series#name\n             * @type {string}\n             */\n            name: options.name,\n            state: '',\n            /**\n             * Read only. The series' visibility state as set by {@link\n             * Series#show}, {@link Series#hide}, or in the initial\n             * configuration.\n             *\n             * @name Highcharts.Series#visible\n             * @type {boolean}\n             */\n            visible: options.visible !== false, // true by default\n            /**\n             * Read only. The series' selected state as set by {@link\n             * Highcharts.Series#select}.\n             *\n             * @name Highcharts.Series#selected\n             * @type {boolean}\n             */\n            selected: options.selected === true // false by default\n        });\n\n        // register event listeners\n        events = options.events;\n\n        objectEach(events, function (event, eventType) {\n            addEvent(series, eventType, event);\n        });\n        if (\n            (events && events.click) ||\n            (\n                options.point &&\n                options.point.events &&\n                options.point.events.click\n            ) ||\n            options.allowPointSelect\n        ) {\n            chart.runTrackerClick = true;\n        }\n\n        series.getColor();\n        series.getSymbol();\n\n        // Set the data\n        each(series.parallelArrays, function (key) {\n            series[key + 'Data'] = [];\n        });\n        series.setData(options.data, false);\n\n        // Mark cartesian\n        if (series.isCartesian) {\n            chart.hasCartesianSeries = true;\n        }\n\n        // Get the index and register the series in the chart. The index is one\n        // more than the current latest series index (#5960).\n        if (chartSeries.length) {\n            lastSeries = chartSeries[chartSeries.length - 1];\n        }\n        series._i = pick(lastSeries && lastSeries._i, -1) + 1;\n\n        // Insert the series and re-order all series above the insertion point.\n        chart.orderSeries(this.insert(chartSeries));\n\n        fireEvent(this, 'afterInit');\n    },\n\n    /**\n     * Insert the series in a collection with other series, either the chart\n     * series or yAxis series, in the correct order according to the index\n     * option. Used internally when adding series.\n     *\n     * @private\n     * @function Highcharts.Series#insert\n     *\n     * @param {Array<Highcharts.Series>} collection\n     *        A collection of series, like `chart.series` or `xAxis.series`.\n     *\n     * @return {number}\n     *         The index of the series in the collection.\n     */\n    insert: function (collection) {\n        var indexOption = this.options.index,\n            i;\n\n        // Insert by index option\n        if (isNumber(indexOption)) {\n            i = collection.length;\n            while (i--) {\n                // Loop down until the interted element has higher index\n                if (indexOption >=\n                        pick(collection[i].options.index, collection[i]._i)) {\n                    collection.splice(i + 1, 0, this);\n                    break;\n                }\n            }\n            if (i === -1) {\n                collection.unshift(this);\n            }\n            i = i + 1;\n\n        // Or just push it to the end\n        } else {\n            collection.push(this);\n        }\n        return pick(i, collection.length - 1);\n    },\n\n    /**\n     * Set the xAxis and yAxis properties of cartesian series, and register the\n     * series in the `axis.series` array.\n     *\n     * @private\n     * @function Highcharts.Series#bindAxes\n     *\n     * @exception 18\n     */\n    bindAxes: function () {\n        var series = this,\n            seriesOptions = series.options,\n            chart = series.chart,\n            axisOptions;\n\n        // repeat for xAxis and yAxis\n        each(series.axisTypes || [], function (AXIS) {\n\n            // loop through the chart's axis objects\n            each(chart[AXIS], function (axis) {\n                axisOptions = axis.options;\n\n                // apply if the series xAxis or yAxis option mathches the number\n                // of the axis, or if undefined, use the first axis\n                if (\n                    seriesOptions[AXIS] === axisOptions.index ||\n                    (\n                        seriesOptions[AXIS] !== undefined &&\n                        seriesOptions[AXIS] === axisOptions.id\n                    ) ||\n                    (\n                        seriesOptions[AXIS] === undefined &&\n                        axisOptions.index === 0\n                    )\n                ) {\n\n                    // register this series in the axis.series lookup\n                    series.insert(axis.series);\n\n                    // set this series.xAxis or series.yAxis reference\n                    /**\n                     * Read only. The unique xAxis object associated with the\n                     * series.\n                     *\n                     * @name Highcharts.Series#xAxis\n                     * @type {Highcharts.Axis}\n                     */\n                    /**\n                     * Read only. The unique yAxis object associated with the\n                     * series.\n                     *\n                     * @name Highcharts.Series#yAxis\n                     * @type {Highcharts.Axis}\n                     */\n                    series[AXIS] = axis;\n\n                    // mark dirty for redraw\n                    axis.isDirty = true;\n                }\n            });\n\n            // The series needs an X and an Y axis\n            if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(18, true);\n            }\n\n        });\n    },\n\n    /**\n     * For simple series types like line and column, the data values are held in\n     * arrays like xData and yData for quick lookup to find extremes and more.\n     * For multidimensional series like bubble and map, this can be extended\n     * with arrays like zData and valueData by adding to the\n     * `series.parallelArrays` array.\n     *\n     * @private\n     * @function Highcharts.Series#updateParallelArrays\n     *\n     * @param {Highcharts.Point} point\n     *\n     * @param {number|string} i\n     */\n    updateParallelArrays: function (point, i) {\n        var series = point.series,\n            args = arguments,\n            fn = isNumber(i) ?\n                // Insert the value in the given position\n                function (key) {\n                    var val = key === 'y' && series.toYData ?\n                        series.toYData(point) :\n                        point[key];\n                    series[key + 'Data'][i] = val;\n                } :\n                // Apply the method specified in i with the following arguments\n                // as arguments\n                function (key) {\n                    Array.prototype[i].apply(\n                        series[key + 'Data'],\n                        Array.prototype.slice.call(args, 2)\n                    );\n                };\n\n        each(series.parallelArrays, fn);\n    },\n\n    /**\n     * Return an auto incremented x value based on the pointStart and\n     * pointInterval options. This is only used if an x value is not given for\n     * the point that calls autoIncrement.\n     *\n     * @private\n     * @function Highcharts.Series#autoIncrement\n     *\n     * @return {number}\n     */\n    autoIncrement: function () {\n\n        var options = this.options,\n            xIncrement = this.xIncrement,\n            date,\n            pointInterval,\n            pointIntervalUnit = options.pointIntervalUnit,\n            time = this.chart.time;\n\n        xIncrement = pick(xIncrement, options.pointStart, 0);\n\n        this.pointInterval = pointInterval = pick(\n            this.pointInterval,\n            options.pointInterval,\n            1\n        );\n\n        // Added code for pointInterval strings\n        if (pointIntervalUnit) {\n            date = new time.Date(xIncrement);\n\n            if (pointIntervalUnit === 'day') {\n                time.set(\n                    'Date',\n                    date,\n                    time.get('Date', date) + pointInterval\n                );\n            } else if (pointIntervalUnit === 'month') {\n                time.set(\n                    'Month',\n                    date,\n                    time.get('Month', date) + pointInterval\n                );\n            } else if (pointIntervalUnit === 'year') {\n                time.set(\n                    'FullYear',\n                    date,\n                    time.get('FullYear', date) + pointInterval\n                );\n            }\n\n            pointInterval = date.getTime() - xIncrement;\n\n        }\n\n        this.xIncrement = xIncrement + pointInterval;\n        return xIncrement;\n    },\n\n    /**\n     * Set the series options by merging from the options tree. Called\n     * internally on initiating and updating series. This function will not\n     * redraw the series. For API usage, use {@link Series#update}.\n     *\n     * @function Highcharts.Series#setOptions\n     *\n     * @param {Highcharts.PlotSeriesOptions} itemOptions\n     *        The series options.\n     *\n     * @return {Highcharts.PlotSeriesOptions}\n     *\n     * @fires Highcharts.Series#event:afterSetOptions\n     */\n    setOptions: function (itemOptions) {\n        var chart = this.chart,\n            chartOptions = chart.options,\n            plotOptions = chartOptions.plotOptions,\n            userOptions = chart.userOptions || {},\n            userPlotOptions = userOptions.plotOptions || {},\n            typeOptions = plotOptions[this.type],\n            options,\n            zones;\n\n        this.userOptions = itemOptions;\n\n        // General series options take precedence over type options because\n        // otherwise, default type options like column.animation would be\n        // overwritten by the general option. But issues have been raised here\n        // (#3881), and the solution may be to distinguish between default\n        // option and userOptions like in the tooltip below.\n        options = merge(\n            typeOptions,\n            plotOptions.series,\n            itemOptions\n        );\n\n        // The tooltip options are merged between global and series specific\n        // options. Importance order asscendingly:\n        // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]\n        // init userOptions with possible later updates: 4-6 like 1-3 and\n        // (7)this series options\n        this.tooltipOptions = merge(\n            defaultOptions.tooltip, // 1\n            defaultOptions.plotOptions.series &&\n                defaultOptions.plotOptions.series.tooltip, // 2\n            defaultOptions.plotOptions[this.type].tooltip, // 3\n            chartOptions.tooltip.userOptions, // 4\n            plotOptions.series && plotOptions.series.tooltip, // 5\n            plotOptions[this.type].tooltip, // 6\n            itemOptions.tooltip // 7\n        );\n\n        // When shared tooltip, stickyTracking is true by default,\n        // unless user says otherwise.\n        this.stickyTracking = pick(\n            itemOptions.stickyTracking,\n            userPlotOptions[this.type] &&\n                userPlotOptions[this.type].stickyTracking,\n            userPlotOptions.series && userPlotOptions.series.stickyTracking,\n            (\n                this.tooltipOptions.shared && !this.noSharedTooltip ?\n                true :\n                options.stickyTracking\n            )\n        );\n\n        // Delete marker object if not allowed (#1125)\n        if (typeOptions.marker === null) {\n            delete options.marker;\n        }\n\n        // Handle color zones\n        this.zoneAxis = options.zoneAxis;\n        zones = this.zones = (options.zones || []).slice();\n        if (\n            (options.negativeColor || options.negativeFillColor) &&\n            !options.zones\n        ) {\n            zones.push({\n                value:\n                    options[this.zoneAxis + 'Threshold'] ||\n                    options.threshold ||\n                    0,\n                className: 'highcharts-negative'\n                \n            });\n        }\n        if (zones.length) { // Push one extra zone for the rest\n            if (defined(zones[zones.length - 1].value)) {\n                zones.push({\n                    \n                });\n            }\n        }\n\n        fireEvent(this, 'afterSetOptions', { options: options });\n\n        return options;\n    },\n\n    /**\n     * Return series name in \"Series {Number}\" format or the one defined by a\n     * user. This method can be simply overridden as series name format can\n     * vary (e.g. technical indicators).\n     *\n     * @function Highcharts.Series#getName\n     *\n     * @return {string}\n     *         The series name.\n     */\n    getName: function () {\n        return this.name || 'Series ' + (this.index + 1);\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Series#getCyclic\n     *\n     * @param {string} prop\n     *\n     * @param {*} value\n     *\n     * @param {*} [defaults]\n     */\n    getCyclic: function (prop, value, defaults) {\n        var i,\n            chart = this.chart,\n            userOptions = this.userOptions,\n            indexName = prop + 'Index',\n            counterName = prop + 'Counter',\n            len = defaults ? defaults.length : pick(\n                chart.options.chart[prop + 'Count'],\n                chart[prop + 'Count']\n            ),\n            setting;\n\n        if (!value) {\n            // Pick up either the colorIndex option, or the _colorIndex after\n            // Series.update()\n            setting = pick(\n                userOptions[indexName],\n                userOptions['_' + indexName]\n            );\n            if (defined(setting)) { // after Series.update()\n                i = setting;\n            } else {\n                // #6138\n                if (!chart.series.length) {\n                    chart[counterName] = 0;\n                }\n                userOptions['_' + indexName] = i = chart[counterName] % len;\n                chart[counterName] += 1;\n            }\n            if (defaults) {\n                value = defaults[i];\n            }\n        }\n        // Set the colorIndex\n        if (i !== undefined) {\n            this[indexName] = i;\n        }\n        this[prop] = value;\n    },\n\n    /**\n     * Get the series' color based on either the options or pulled from global\n     * options.\n     *\n     * @function Highcharts.Series#getColor\n     */\n    \n    getColor: function () {\n        this.getCyclic('color');\n    },\n    \n    /**\n     * Get the series' symbol based on either the options or pulled from global\n     * options.\n     *\n     * @function Highcharts.Series#getSymbol\n     */\n    getSymbol: function () {\n        var seriesMarkerOption = this.options.marker;\n        this.getCyclic(\n            'symbol',\n            seriesMarkerOption.symbol,\n            this.chart.options.symbols\n        );\n    },\n\n    /**\n     * @private\n     * @borrows LegendSymbolMixin.drawLineMarker as Highcharts.Series#drawLegendSymbol\n     */\n    drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n    /**\n     * Internal function called from setData. If the point count is the same as\n     * is was, or if there are overlapping X values, just run Point.update which\n     * is cheaper, allows animation, and keeps references to points. This also\n     * allows adding or removing points if the X-es don't match.\n     *\n     * @private\n     * @function Highcharts.Series#updateData\n     *\n     * @param {Array<*>} data\n     *\n     * @return {boolean}\n     */\n    updateData: function (data) {\n        var options = this.options,\n            oldData = this.points,\n            pointsToAdd = [],\n            hasUpdatedByKey,\n            i,\n            point,\n            lastIndex,\n            requireSorting = this.requireSorting;\n\n        // Iterate the new data\n        each(data, function (pointOptions) {\n            var x,\n                pointIndex;\n\n            // Get the x of the new data point\n            x = (\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(pointOptions) &&\n                this.pointClass.prototype.optionsToObject.call(\n                    { series: this },\n                    pointOptions\n                ).x\n            );\n\n            if (isNumber(x)) {\n                // Search for the same X in the existing data set\n                pointIndex = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray(x, this.xData, lastIndex);\n\n                // Matching X not found\n                // or used already due to ununique x values (#8995),\n                // add point (but later)\n                if (pointIndex === -1 || oldData[pointIndex].touched) {\n                    pointsToAdd.push(pointOptions);\n\n                // Matching X found, update\n                } else if (pointOptions !== options.data[pointIndex]) {\n                    oldData[pointIndex].update(\n                        pointOptions,\n                        false,\n                        null,\n                        false\n                    );\n\n                    // Mark it touched, below we will remove all points that\n                    // are not touched.\n                    oldData[pointIndex].touched = true;\n\n                    // Speed optimize by only searching after last known index.\n                    // Performs ~20% bettor on large data sets.\n                    if (requireSorting) {\n                        lastIndex = pointIndex + 1;\n                    }\n                // Point exists, no changes, don't remove it\n                } else if (oldData[pointIndex]) {\n                    oldData[pointIndex].touched = true;\n                }\n                hasUpdatedByKey = true;\n            }\n        }, this);\n\n        // Remove points that don't exist in the updated data set\n        if (hasUpdatedByKey) {\n            i = oldData.length;\n            while (i--) {\n                point = oldData[i];\n                if (!point.touched) {\n                    point.remove(false);\n                }\n                point.touched = false;\n            }\n\n        // If we did not find keys (x-values), and the length is the same,\n        // update one-to-one\n        } else if (data.length === oldData.length) {\n            each(data, function (point, i) {\n                // .update doesn't exist on a linked, hidden series (#3709)\n                if (oldData[i].update && point !== options.data[i]) {\n                    oldData[i].update(point, false, null, false);\n                }\n            });\n\n        // Did not succeed in updating data\n        } else {\n            return false;\n        }\n\n        // Add new points\n        each(pointsToAdd, function (point) {\n            this.addPoint(point, false);\n        }, this);\n\n        return true;\n    },\n\n    /**\n     * Apply a new set of data to the series and optionally redraw it. The new\n     * data array is passed by reference (except in case of `updatePoints`), and\n     * may later be mutated when updating the chart data.\n     *\n     * Note the difference in behaviour when setting the same amount of points,\n     * or a different amount of points, as handled by the `updatePoints`\n     * parameter.\n     *\n     * @sample highcharts/members/series-setdata/\n     *         Set new data from a button\n     * @sample highcharts/members/series-setdata-pie/\n     *         Set data in a pie\n     * @sample stock/members/series-setdata/\n     *         Set new data in Highstock\n     * @sample maps/members/series-setdata/\n     *         Set new data in Highmaps\n     *\n     * @function Highcharts.Series#setData\n     *\n     * @param {Array<*>} data\n     *        Takes an array of data in the same format as described under\n     *        `series.{type}.data` for the given series type, for example a\n     *        line series would take data in the form described under\n     *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the series is altered. If doing\n     *        more operations on the chart, it is a good idea to set redraw to\n     *        false and call {@link Chart#redraw} after.\n     *\n     * @param {Highcharts.AnimationOptionsObject} [animation]\n     *        When the updated data is the same length as the existing data,\n     *        points will be updated by default, and animation visualizes how\n     *        the points are changed. Set false to disable animation, or a\n     *        configuration object to set duration or easing.\n     *\n     * @param {boolean} [updatePoints=true]\n     *        When the updated data is the same length as the existing data, or\n     *        points can be matched by X values, points will be updated instead\n     *        of replaced. This allows updating with animation and performs\n     *        better. In this case, the original array is not passed by\n     *        reference. Set `false` to prevent.\n     */\n    setData: function (data, redraw, animation, updatePoints) {\n        var series = this,\n            oldData = series.points,\n            oldDataLength = (oldData && oldData.length) || 0,\n            dataLength,\n            options = series.options,\n            chart = series.chart,\n            firstPoint = null,\n            xAxis = series.xAxis,\n            i,\n            turboThreshold = options.turboThreshold,\n            pt,\n            xData = this.xData,\n            yData = this.yData,\n            pointArrayMap = series.pointArrayMap,\n            valueCount = pointArrayMap && pointArrayMap.length,\n            updatedData;\n\n        data = data || [];\n        dataLength = data.length;\n        redraw = pick(redraw, true);\n\n        // If the point count is the same as is was, just run Point.update which\n        // is cheaper, allows animation, and keeps references to points.\n        if (\n            updatePoints !== false &&\n            dataLength &&\n            oldDataLength &&\n            !series.cropped &&\n            !series.hasGroupedData &&\n            series.visible &&\n            // Soft updating has no benefit in boost, and causes JS error\n            // (#8355)\n            !series.isSeriesBoosting\n        ) {\n            updatedData = this.updateData(data);\n        }\n\n        if (!updatedData) {\n\n            // Reset properties\n            series.xIncrement = null;\n\n            series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n            // Update parallel arrays\n            each(this.parallelArrays, function (key) {\n                series[key + 'Data'].length = 0;\n            });\n\n            // In turbo mode, only one- or twodimensional arrays of numbers are\n            // allowed. The first value is tested, and we assume that all the\n            // rest are defined the same way. Although the 'for' loops are\n            // similar, they are repeated inside each if-else conditional for\n            // max performance.\n            if (turboThreshold && dataLength > turboThreshold) {\n\n                // find the first non-null point\n                i = 0;\n                while (firstPoint === null && i < dataLength) {\n                    firstPoint = data[i];\n                    i++;\n                }\n\n\n                if (isNumber(firstPoint)) { // assume all points are numbers\n                    for (i = 0; i < dataLength; i++) {\n                        xData[i] = this.autoIncrement();\n                        yData[i] = data[i];\n                    }\n\n                // Assume all points are arrays when first point is\n                } else if (isArray(firstPoint)) {\n                    if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                        for (i = 0; i < dataLength; i++) {\n                            pt = data[i];\n                            xData[i] = pt[0];\n                            yData[i] = pt.slice(1, valueCount + 1);\n                        }\n                    } else { // [x, y]\n                        for (i = 0; i < dataLength; i++) {\n                            pt = data[i];\n                            xData[i] = pt[0];\n                            yData[i] = pt[1];\n                        }\n                    }\n                } else {\n                    // Highcharts expects configs to be numbers or arrays in\n                    // turbo mode\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(12);\n                }\n            } else {\n                for (i = 0; i < dataLength; i++) {\n                    if (data[i] !== undefined) { // stray commas in oldIE\n                        pt = { series: series };\n                        series.pointClass.prototype.applyOptions.apply(\n                            pt,\n                            [data[i]]\n                        );\n                        series.updateParallelArrays(pt, i);\n                    }\n                }\n            }\n\n            // Forgetting to cast strings to numbers is a common caveat when\n            // handling CSV or JSON\n            if (yData && isString(yData[0])) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(14, true);\n            }\n\n            series.data = [];\n            series.options.data = series.userOptions.data = data;\n\n            // destroy old points\n            i = oldDataLength;\n            while (i--) {\n                if (oldData[i] && oldData[i].destroy) {\n                    oldData[i].destroy();\n                }\n            }\n\n            // reset minRange (#878)\n            if (xAxis) {\n                xAxis.minRange = xAxis.userMinRange;\n            }\n\n            // redraw\n            series.isDirty = chart.isDirtyBox = true;\n            series.isDirtyData = !!oldData;\n            animation = false;\n        }\n\n        // Typically for pie series, points need to be processed and generated\n        // prior to rendering the legend\n        if (options.legendType === 'point') {\n            this.processData();\n            this.generatePoints();\n        }\n\n        if (redraw) {\n            chart.redraw(animation);\n        }\n    },\n\n    /**\n     * Internal function to process the data by cropping away unused data points\n     * if the series is longer than the crop threshold. This saves computing\n     * time for large series. In Highstock, this function is extended to\n     * provide data grouping.\n     *\n     * @private\n     * @function Highcharts.Series#processData\n     *\n     * @param {boolean} force\n     *        Force data grouping.\n     *\n     * @return {boolean|undefined}\n     */\n    processData: function (force) {\n        var series = this,\n            processedXData = series.xData, // copied during slice operation\n            processedYData = series.yData,\n            dataLength = processedXData.length,\n            croppedData,\n            cropStart = 0,\n            cropped,\n            distance,\n            closestPointRange,\n            xAxis = series.xAxis,\n            i, // loop variable\n            options = series.options,\n            cropThreshold = options.cropThreshold,\n            getExtremesFromAll =\n                series.getExtremesFromAll ||\n                options.getExtremesFromAll, // #4599\n            isCartesian = series.isCartesian,\n            xExtremes,\n            val2lin = xAxis && xAxis.val2lin,\n            isLog = xAxis && xAxis.isLog,\n            throwOnUnsorted = series.requireSorting,\n            min,\n            max;\n\n        // If the series data or axes haven't changed, don't go through this.\n        // Return false to pass the message on to override methods like in data\n        // grouping.\n        if (\n            isCartesian &&\n            !series.isDirty &&\n            !xAxis.isDirty &&\n            !series.yAxis.isDirty &&\n            !force\n        ) {\n            return false;\n        }\n\n        if (xAxis) {\n            xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n            min = xExtremes.min;\n            max = xExtremes.max;\n        }\n\n        // optionally filter out points outside the plot area\n        if (\n            isCartesian &&\n            series.sorted &&\n            !getExtremesFromAll &&\n            (!cropThreshold || dataLength > cropThreshold || series.forceCrop)\n        ) {\n\n            // it's outside current extremes\n            if (\n                processedXData[dataLength - 1] < min ||\n                processedXData[0] > max\n            ) {\n                processedXData = [];\n                processedYData = [];\n\n            // only crop if it's actually spilling out\n            } else if (\n                series.yData && (\n                    processedXData[0] < min ||\n                    processedXData[dataLength - 1] > max\n                )\n            ) {\n                croppedData = this.cropData(\n                    series.xData,\n                    series.yData,\n                    min,\n                    max\n                );\n                processedXData = croppedData.xData;\n                processedYData = croppedData.yData;\n                cropStart = croppedData.start;\n                cropped = true;\n            }\n        }\n\n\n        // Find the closest distance between processed points\n        i = processedXData.length || 1;\n        while (--i) {\n            distance = isLog ?\n                val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                processedXData[i] - processedXData[i - 1];\n\n            if (\n                distance > 0 &&\n                (\n                    closestPointRange === undefined ||\n                    distance < closestPointRange\n                )\n            ) {\n                closestPointRange = distance;\n\n            // Unsorted data is not supported by the line tooltip, as well as\n            // data grouping and navigation in Stock charts (#725) and width\n            // calculation of columns (#1900)\n            } else if (distance < 0 && throwOnUnsorted) {\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(15);\n                throwOnUnsorted = false; // Only once\n            }\n        }\n\n        // Record the properties\n        series.cropped = cropped; // undefined or true\n        series.cropStart = cropStart;\n        series.processedXData = processedXData;\n        series.processedYData = processedYData;\n\n        series.closestPointRange = closestPointRange;\n\n    },\n\n    /**\n     * Iterate over xData and crop values between min and max. Returns object\n     * containing crop start/end cropped xData with corresponding part of yData,\n     * dataMin and dataMax within the cropped range.\n     *\n     * @private\n     * @function Highcharts.Series#cropData\n     *\n     * @param {Array<number>} xData\n     *\n     * @param {Array<number>} yData\n     *\n     * @param {number} min\n     *\n     * @param {number} max\n     *\n     * @param {number} [cropShoulder]\n     *\n     * @return {*}\n     */\n    cropData: function (xData, yData, min, max, cropShoulder) {\n        var dataLength = xData.length,\n            cropStart = 0,\n            cropEnd = dataLength,\n            i,\n            j;\n\n        // line-type series need one point outside\n        cropShoulder = pick(cropShoulder, this.cropShoulder, 1);\n\n        // iterate up to find slice start\n        for (i = 0; i < dataLength; i++) {\n            if (xData[i] >= min) {\n                cropStart = Math.max(0, i - cropShoulder);\n                break;\n            }\n        }\n\n        // proceed to find slice end\n        for (j = i; j < dataLength; j++) {\n            if (xData[j] > max) {\n                cropEnd = j + cropShoulder;\n                break;\n            }\n        }\n\n        return {\n            xData: xData.slice(cropStart, cropEnd),\n            yData: yData.slice(cropStart, cropEnd),\n            start: cropStart,\n            end: cropEnd\n        };\n    },\n\n\n    /**\n     * Generate the data point after the data has been processed by cropping\n     * away unused points and optionally grouped in Highcharts Stock.\n     *\n     * @private\n     * @function Highcharts.Series#generatePoints\n     */\n    generatePoints: function () {\n        var series = this,\n            options = series.options,\n            dataOptions = options.data,\n            data = series.data,\n            dataLength,\n            processedXData = series.processedXData,\n            processedYData = series.processedYData,\n            PointClass = series.pointClass,\n            processedDataLength = processedXData.length,\n            cropStart = series.cropStart || 0,\n            cursor,\n            hasGroupedData = series.hasGroupedData,\n            keys = options.keys,\n            point,\n            points = [],\n            i;\n\n        if (!data && !hasGroupedData) {\n            var arr = [];\n            arr.length = dataOptions.length;\n            data = series.data = arr;\n        }\n\n        if (keys && hasGroupedData) {\n            // grouped data has already applied keys (#6590)\n            series.options.keys = false;\n        }\n\n        for (i = 0; i < processedDataLength; i++) {\n            cursor = cropStart + i;\n            if (!hasGroupedData) {\n                point = data[cursor];\n                if (!point && dataOptions[cursor] !== undefined) { // #970\n                    data[cursor] = point = (new PointClass()).init(\n                        series,\n                        dataOptions[cursor],\n                        processedXData[i]\n                    );\n                }\n            } else {\n                // splat the y data in case of ohlc data array\n                point = (new PointClass()).init(\n                    series,\n                    [processedXData[i]].concat(splat(processedYData[i]))\n                );\n\n                /**\n                 * Highstock only. If a point object is created by data\n                 * grouping, it doesn't reflect actual points in the raw data.\n                 * In this case, the `dataGroup` property holds information\n                 * that points back to the raw data.\n                 *\n                 * - `dataGroup.start` is the index of the first raw data point\n                 * in the group.\n                 * - `dataGroup.length` is the amount of points in the group.\n                 *\n                 * @name Highcharts.Point#dataGroup\n                 * @type {Highcharts.SVGElement|undefined}\n                 *\n                 * @product highstock\n                 */\n                point.dataGroup = series.groupMap[i];\n                if (point.dataGroup.options) {\n                    point.options = point.dataGroup.options;\n                    extend(point, point.dataGroup.options);\n                }\n            }\n            if (point) { // #6279\n                point.index = cursor; // For faster access in Point.update\n                points[i] = point;\n            }\n        }\n\n        // restore keys options (#6590)\n        series.options.keys = keys;\n\n        // Hide cropped-away points - this only runs when the number of points\n        // is above cropThreshold, or when swithching view from non-grouped\n        // data to grouped data (#637)\n        if (\n            data &&\n            (\n                processedDataLength !== (dataLength = data.length) ||\n                hasGroupedData\n            )\n        ) {\n            for (i = 0; i < dataLength; i++) {\n                // when has grouped data, clear all points\n                if (i === cropStart && !hasGroupedData) {\n                    i += processedDataLength;\n                }\n                if (data[i]) {\n                    data[i].destroyElements();\n                    data[i].plotX = undefined; // #1003\n                }\n            }\n        }\n\n        /**\n         * Read only. An array containing those values converted to points.\n         * In case the series data length exceeds the `cropThreshold`, or if the\n         * data is grouped, `series.data` doesn't contain all the points. Also,\n         * in case a series is hidden, the `data` array may be empty. To access\n         * raw values, `series.options.data` will always be up to date.\n         * `Series.data` only contains the points that have been created on\n         * demand. To modify the data, use {@link Highcharts.Series#setData} or\n         * {@link Highcharts.Point#update}.\n         *\n         * @see Series.points\n         *\n         * @name Highcharts.Series#data\n         * @type {Array<Point>}\n         */\n        series.data = data;\n\n        /**\n         * An array containing all currently visible point objects. In case of\n         * cropping, the cropped-away points are not part of this array. The\n         * `series.points` array starts at `series.cropStart` compared to\n         * `series.data` and `series.options.data`. If however the series data\n         * is grouped, these can't be correlated one to one. To\n         * modify the data, use {@link Highcharts.Series#setData} or {@link\n         * Highcharts.Point#update}.\n         *\n         * @name Highcharts.Series#points\n         * @type {Array<Highcharts.Point>}\n         */\n        series.points = points;\n    },\n\n    /**\n     * Calculate Y extremes for the visible data. The result is set as\n     * `dataMin` and `dataMax` on the Series item.\n     *\n     * @function Highcharts.Series#getExtremes\n     *\n     * @param {Array<number>} [yData]\n     *        The data to inspect. Defaults to the current data within the\n     *        visible range.\n     */\n    getExtremes: function (yData) {\n        var xAxis = this.xAxis,\n            yAxis = this.yAxis,\n            xData = this.processedXData,\n            yDataLength,\n            activeYData = [],\n            activeCounter = 0,\n            // #2117, need to compensate for log X axis\n            xExtremes = xAxis.getExtremes(),\n            xMin = xExtremes.min,\n            xMax = xExtremes.max,\n            validValue,\n            withinRange,\n            // Handle X outside the viewed area. This does not work with non-\n            // sorted data like scatter (#7639).\n            shoulder = this.requireSorting ? 1 : 0,\n            x,\n            y,\n            i,\n            j;\n\n        yData = yData || this.stackedYData || this.processedYData || [];\n        yDataLength = yData.length;\n\n        for (i = 0; i < yDataLength; i++) {\n\n            x = xData[i];\n            y = yData[i];\n\n            // For points within the visible range, including the first point\n            // outside the visible range (#7061), consider y extremes.\n            validValue = (\n                (isNumber(y, true) || isArray(y)) &&\n                (!yAxis.positiveValuesOnly || (y.length || y > 0))\n            );\n            withinRange = (\n                this.getExtremesFromAll ||\n                this.options.getExtremesFromAll ||\n                this.cropped ||\n                (\n                    (xData[i + shoulder] || x) >= xMin &&\n                    (xData[i - shoulder] || x) <= xMax\n                )\n            );\n\n            if (validValue && withinRange) {\n\n                j = y.length;\n                if (j) { // array, like ohlc or range data\n                    while (j--) {\n                        if (typeof y[j] === 'number') { // #7380\n                            activeYData[activeCounter++] = y[j];\n                        }\n                    }\n                } else {\n                    activeYData[activeCounter++] = y;\n                }\n            }\n        }\n\n        this.dataMin = arrayMin(activeYData);\n        this.dataMax = arrayMax(activeYData);\n    },\n\n    /**\n     * Translate data points from raw data values to chart specific positioning\n     * data needed later in the `drawPoints` and `drawGraph` functions. This\n     * function can be overridden in plugins and custom series type\n     * implementations.\n     *\n     * @function Highcharts.Series#translate\n     *\n     * @todo\n     * Make events official: Fires the event `afterTranslate`.\n     */\n    translate: function () {\n        if (!this.processedXData) { // hidden series\n            this.processData();\n        }\n        this.generatePoints();\n        var series = this,\n            options = series.options,\n            stacking = options.stacking,\n            xAxis = series.xAxis,\n            categories = xAxis.categories,\n            yAxis = series.yAxis,\n            points = series.points,\n            dataLength = points.length,\n            hasModifyValue = !!series.modifyValue,\n            i,\n            pointPlacement = options.pointPlacement,\n            dynamicallyPlaced =\n                pointPlacement === 'between' ||\n                isNumber(pointPlacement),\n            threshold = options.threshold,\n            stackThreshold = options.startFromThreshold ? threshold : 0,\n            plotX,\n            plotY,\n            lastPlotX,\n            stackIndicator,\n            closestPointRangePx = Number.MAX_VALUE;\n\n        /*\n         * Plotted coordinates need to be within a limited range. Drawing too\n         * far outside the viewport causes various rendering issues (#3201,\n         * #3923, #7555).\n         */\n        function limitedRange(val) {\n            return Math.min(Math.max(-1e5, val), 1e5);\n        }\n\n        // Point placement is relative to each series pointRange (#5889)\n        if (pointPlacement === 'between') {\n            pointPlacement = 0.5;\n        }\n        if (isNumber(pointPlacement)) {\n            pointPlacement *= pick(options.pointRange || xAxis.pointRange);\n        }\n\n        // Translate each point\n        for (i = 0; i < dataLength; i++) {\n            var point = points[i],\n                xValue = point.x,\n                yValue = point.y,\n                yBottom = point.low,\n                stack = stacking && yAxis.stacks[(\n                    series.negStacks &&\n                    yValue < (stackThreshold ? 0 : threshold) ? '-' : ''\n                ) + series.stackKey],\n                pointStack,\n                stackValues;\n\n            // Discard disallowed y values for log axes (#3434)\n            if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {\n                point.isNull = true;\n            }\n\n            // Get the plotX translation\n            point.plotX = plotX = correctFloat( // #5236\n                limitedRange(xAxis.translate( // #3923\n                    xValue,\n                    0,\n                    0,\n                    0,\n                    1,\n                    pointPlacement,\n                    this.type === 'flags'\n                )) // #3923\n            );\n\n            // Calculate the bottom y value for stacked series\n            if (\n                stacking &&\n                series.visible &&\n                !point.isNull &&\n                stack &&\n                stack[xValue]\n            ) {\n                stackIndicator = series.getStackIndicator(\n                    stackIndicator,\n                    xValue,\n                    series.index\n                );\n                pointStack = stack[xValue];\n                stackValues = pointStack.points[stackIndicator.key];\n                yBottom = stackValues[0];\n                yValue = stackValues[1];\n\n                if (\n                    yBottom === stackThreshold &&\n                    stackIndicator.key === stack[xValue].base\n                ) {\n                    yBottom = pick(isNumber(threshold) && threshold, yAxis.min);\n                }\n                if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232\n                    yBottom = null;\n                }\n\n                point.total = point.stackTotal = pointStack.total;\n                point.percentage =\n                    pointStack.total &&\n                    (point.y / pointStack.total * 100);\n                point.stackY = yValue;\n\n                // Place the stack label\n                pointStack.setOffset(\n                    series.pointXOffset || 0,\n                    series.barW || 0\n                );\n\n            }\n\n            // Set translated yBottom or remove it\n            point.yBottom = defined(yBottom) ?\n                limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) :\n                null;\n\n            // general hook, used for Highstock compare mode\n            if (hasModifyValue) {\n                yValue = series.modifyValue(yValue, point);\n            }\n\n            // Set the the plotY value, reset it for redraws\n            point.plotY = plotY =\n                (typeof yValue === 'number' && yValue !== Infinity) ?\n                    limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201\n                    undefined;\n\n            point.isInside =\n                plotY !== undefined &&\n                plotY >= 0 &&\n                plotY <= yAxis.len && // #3519\n                plotX >= 0 &&\n                plotX <= xAxis.len;\n\n\n            // Set client related positions for mouse tracking\n            point.clientX = dynamicallyPlaced ?\n                correctFloat(\n                    xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)\n                ) :\n                plotX; // #1514, #5383, #5518\n\n            point.negative = point.y < (threshold || 0);\n\n            // some API data\n            point.category = categories && categories[point.x] !== undefined ?\n                categories[point.x] : point.x;\n\n            // Determine auto enabling of markers (#3635, #5099)\n            if (!point.isNull) {\n                if (lastPlotX !== undefined) {\n                    closestPointRangePx = Math.min(\n                        closestPointRangePx,\n                        Math.abs(plotX - lastPlotX)\n                    );\n                }\n                lastPlotX = plotX;\n            }\n\n            // Find point zone\n            point.zone = this.zones.length && point.getZone();\n        }\n        series.closestPointRangePx = closestPointRangePx;\n\n        fireEvent(this, 'afterTranslate');\n    },\n\n    /**\n     * Return the series points with null points filtered out.\n     *\n     * @param {Array<Highcharts.Point>} [points]\n     *        The points to inspect, defaults to {@link Series.points}.\n     *\n     * @param {boolean} [insideOnly=false]\n     *        Whether to inspect only the points that are inside the visible\n     *        view.\n     *\n     * @return {Array<Highcharts.Point>}\n     *         The valid points.\n     */\n    getValidPoints: function (points, insideOnly) {\n        var chart = this.chart;\n        // #3916, #5029, #5085\n        return grep(points || this.points || [], function isValidPoint(point) {\n            if (insideOnly && !chart.isInsidePlot(\n                point.plotX,\n                point.plotY,\n                chart.inverted\n            )) {\n                return false;\n            }\n            return !point.isNull;\n        });\n    },\n\n    /**\n     * Set the clipping for the series. For animated series it is called twice,\n     * first to initiate animating the clip then the second time without the\n     * animation to set the final clip.\n     *\n     * @private\n     * @function Highcharts.Series#setClip\n     *\n     * @param {boolean} [animation]\n     */\n    setClip: function (animation) {\n        var chart = this.chart,\n            options = this.options,\n            renderer = chart.renderer,\n            inverted = chart.inverted,\n            seriesClipBox = this.clipBox,\n            clipBox = seriesClipBox || chart.clipBox,\n            sharedClipKey =\n                this.sharedClipKey ||\n                [\n                    '_sharedClip',\n                    animation && animation.duration,\n                    animation && animation.easing,\n                    clipBox.height,\n                    options.xAxis,\n                    options.yAxis\n                ].join(','), // #4526\n            clipRect = chart[sharedClipKey],\n            markerClipRect = chart[sharedClipKey + 'm'];\n\n        // If a clipping rectangle with the same properties is currently present\n        // in the chart, use that.\n        if (!clipRect) {\n\n            // When animation is set, prepare the initial positions\n            if (animation) {\n                clipBox.width = 0;\n                if (inverted) {\n                    clipBox.x = chart.plotSizeX;\n                }\n\n                chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n                    // include the width of the first marker\n                    inverted ? chart.plotSizeX + 99 : -99,\n                    inverted ? -chart.plotLeft : -chart.plotTop,\n                    99,\n                    inverted ? chart.chartWidth : chart.chartHeight\n                );\n            }\n            chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n            // Create hashmap for series indexes\n            clipRect.count = { length: 0 };\n\n        }\n        if (animation) {\n            if (!clipRect.count[this.index]) {\n                clipRect.count[this.index] = true;\n                clipRect.count.length += 1;\n            }\n        }\n\n        if (options.clip !== false) {\n            this.group.clip(\n                animation || seriesClipBox ? clipRect : chart.clipRect\n            );\n            this.markerGroup.clip(markerClipRect);\n            this.sharedClipKey = sharedClipKey;\n        }\n\n        // Remove the shared clipping rectangle when all series are shown\n        if (!animation) {\n            if (clipRect.count[this.index]) {\n                delete clipRect.count[this.index];\n                clipRect.count.length -= 1;\n            }\n\n            if (\n                clipRect.count.length === 0 &&\n                sharedClipKey &&\n                chart[sharedClipKey]\n            ) {\n                if (!seriesClipBox) {\n                    chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                }\n                if (chart[sharedClipKey + 'm']) {\n                    chart[sharedClipKey + 'm'] =\n                        chart[sharedClipKey + 'm'].destroy();\n                }\n            }\n        }\n    },\n\n    /**\n     * Animate in the series. Called internally twice. First with the `init`\n     * parameter set to true, which sets up the initial state of the animation.\n     * Then when ready, it is called with the `init` parameter undefined, in\n     * order to perform the actual animation. After the second run, the function\n     * is removed.\n     *\n     * @function Highcharts.Series#animate\n     *\n     * @param {boolean} init\n     *        Initialize the animation.\n     */\n    animate: function (init) {\n        var series = this,\n            chart = series.chart,\n            clipRect,\n            animation = animObject(series.options.animation),\n            sharedClipKey;\n\n        // Initialize the animation. Set up the clipping rectangle.\n        if (init) {\n\n            series.setClip(animation);\n\n        // Run the animation\n        } else {\n            sharedClipKey = this.sharedClipKey;\n            clipRect = chart[sharedClipKey];\n            if (clipRect) {\n                clipRect.animate({\n                    width: chart.plotSizeX,\n                    x: 0\n                }, animation);\n            }\n            if (chart[sharedClipKey + 'm']) {\n                chart[sharedClipKey + 'm'].animate({\n                    width: chart.plotSizeX + 99,\n                    x: 0\n                }, animation);\n            }\n\n            // Delete this function to allow it only once\n            series.animate = null;\n\n        }\n    },\n\n    /**\n     * This runs after animation to land on the final plot clipping.\n     *\n     * @private\n     * @function Highcharts.Series#afterAnimate\n     *\n     * @todo\n     * Make events official: Fires the event `afterAnimate`.\n     */\n    afterAnimate: function () {\n        this.setClip();\n        fireEvent(this, 'afterAnimate');\n        this.finishedAnimating = true;\n    },\n\n    /**\n     * Draw the markers for line-like series types, and columns or other\n     * graphical representation for {@link Point} objects for other series\n     * types. The resulting element is typically stored as {@link\n     * Point.graphic}, and is created on the first call and updated and moved on\n     * subsequent calls.\n     *\n     * @function Highcharts.Series#drawPoints\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            chart = series.chart,\n            i,\n            point,\n            symbol,\n            graphic,\n            options = series.options,\n            seriesMarkerOptions = options.marker,\n            pointMarkerOptions,\n            hasPointMarker,\n            enabled,\n            isInside,\n            markerGroup = series[series.specialGroup] || series.markerGroup,\n            xAxis = series.xAxis,\n            markerAttribs,\n            globallyEnabled = pick(\n                seriesMarkerOptions.enabled,\n                xAxis.isRadial ? true : null,\n                // Use larger or equal as radius is null in bubbles (#6321)\n                series.closestPointRangePx >= (\n                    seriesMarkerOptions.enabledThreshold *\n                    seriesMarkerOptions.radius\n                )\n            );\n\n        if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n            for (i = 0; i < points.length; i++) {\n                point = points[i];\n                graphic = point.graphic;\n                pointMarkerOptions = point.marker || {};\n                hasPointMarker = !!point.marker;\n                enabled = (\n                    globallyEnabled &&\n                    pointMarkerOptions.enabled === undefined\n                ) || pointMarkerOptions.enabled;\n                isInside = point.isInside;\n\n                // only draw the point if y is defined\n                if (enabled && !point.isNull) {\n\n                    // Shortcuts\n                    symbol = pick(pointMarkerOptions.symbol, series.symbol);\n\n                    markerAttribs = series.markerAttribs(\n                        point,\n                        point.selected && 'select'\n                    );\n\n                    if (graphic) { // update\n                        // Since the marker group isn't clipped, each individual\n                        // marker must be toggled\n                        graphic[isInside ? 'show' : 'hide'](true)\n                            .animate(markerAttribs);\n                    } else if (\n                        isInside &&\n                        (markerAttribs.width > 0 || point.hasImage)\n                    ) {\n\n                        /**\n                         * The graphic representation of the point. Typically\n                         * this is a simple shape, like a `rect` for column\n                         * charts or `path` for line markers, but for some\n                         * complex series types like boxplot or 3D charts, the\n                         * graphic may be a `g` element containing other shapes.\n                         * The graphic is generated the first time {@link\n                         * Series#drawPoints} runs, and updated and moved on\n                         * subsequent runs.\n                         *\n                         * @memberof Point\n                         * @name graphic\n                         * @type {SVGElement}\n                         */\n                        point.graphic = graphic = chart.renderer.symbol(\n                            symbol,\n                            markerAttribs.x,\n                            markerAttribs.y,\n                            markerAttribs.width,\n                            markerAttribs.height,\n                            hasPointMarker ?\n                                pointMarkerOptions :\n                                seriesMarkerOptions\n                        )\n                        .add(markerGroup);\n                    }\n\n                    \n\n                    if (graphic) {\n                        graphic.addClass(point.getClassName(), true);\n                    }\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n        }\n\n    },\n\n    /**\n     * Get non-presentational attributes for a point. Used internally for both\n     * styled mode and classic. Can be overridden for different series types.\n     *\n     * @see Series#pointAttribs\n     *\n     * @param {Highcharts.Point} point\n     *        The Point to inspect.\n     *\n     * @param {string} [state]\n     *        The state, can be either `hover`, `select` or undefined.\n     *\n     * @return {Highcharts.SVGAttributes}\n     *         A hash containing those attributes that are not settable from\n     *         CSS.\n     */\n    markerAttribs: function (point, state) {\n        var seriesMarkerOptions = this.options.marker,\n            seriesStateOptions,\n            pointMarkerOptions = point.marker || {},\n            symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,\n            pointStateOptions,\n            radius = pick(\n                pointMarkerOptions.radius,\n                seriesMarkerOptions.radius\n            ),\n            attribs;\n\n        // Handle hover and select states\n        if (state) {\n            seriesStateOptions = seriesMarkerOptions.states[state];\n            pointStateOptions = pointMarkerOptions.states &&\n                pointMarkerOptions.states[state];\n\n            radius = pick(\n                pointStateOptions && pointStateOptions.radius,\n                seriesStateOptions && seriesStateOptions.radius,\n                radius + (\n                    seriesStateOptions && seriesStateOptions.radiusPlus ||\n                    0\n                )\n            );\n        }\n\n        point.hasImage = symbol && symbol.indexOf('url') === 0;\n\n        if (point.hasImage) {\n            radius = 0; // and subsequently width and height is not set\n        }\n\n        attribs = {\n            x: Math.floor(point.plotX) - radius, // Math.floor for #1843\n            y: point.plotY - radius\n        };\n\n        if (radius) {\n            attribs.width = attribs.height = 2 * radius;\n        }\n\n        return attribs;\n\n    },\n\n    \n\n    /**\n     * Clear DOM objects and free up memory.\n     *\n     * @private\n     * @function Highcharts.Series#destroy\n     *\n     * @todo\n     * Make events official: Fires the event `destroy`.\n     */\n    destroy: function () {\n        var series = this,\n            chart = series.chart,\n            issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n            destroy,\n            i,\n            data = series.data || [],\n            point,\n            axis;\n\n        // add event hook\n        fireEvent(series, 'destroy');\n\n        // remove all events\n        removeEvent(series);\n\n        // erase from axes\n        each(series.axisTypes || [], function (AXIS) {\n            axis = series[AXIS];\n            if (axis && axis.series) {\n                erase(axis.series, series);\n                axis.isDirty = axis.forceRedraw = true;\n            }\n        });\n\n        // remove legend items\n        if (series.legendItem) {\n            series.chart.legend.destroyItem(series);\n        }\n\n        // destroy all points with their elements\n        i = data.length;\n        while (i--) {\n            point = data[i];\n            if (point && point.destroy) {\n                point.destroy();\n            }\n        }\n        series.points = null;\n\n        // Clear the animation timeout if we are destroying the series during\n        // initial animation\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(series.animationTimeout);\n\n        // Destroy all SVGElements associated to the series\n        objectEach(series, function (val, prop) {\n            // Survive provides a hook for not destroying\n            if (val instanceof SVGElement && !val.survive) {\n\n                // issue 134 workaround\n                destroy = issue134 && prop === 'group' ?\n                'hide' :\n                'destroy';\n\n                val[destroy]();\n            }\n        });\n\n        // remove from hoverSeries\n        if (chart.hoverSeries === series) {\n            chart.hoverSeries = null;\n        }\n        erase(chart.series, series);\n        chart.orderSeries();\n\n        // clear all members\n        objectEach(series, function (val, prop) {\n            delete series[prop];\n        });\n    },\n\n    /**\n     * Get the graph path.\n     *\n     * @private\n     * @function Highcharts.Series#getGraphPath\n     *\n     * @param {Array<*>} points\n     *\n     * @param {boolean} nullsAsZeroes\n     *\n     * @param {boolean} connectCliffs\n     *\n     * @return {Array<number|string>}\n     */\n    getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n        var series = this,\n            options = series.options,\n            step = options.step,\n            reversed,\n            graphPath = [],\n            xMap = [],\n            gap;\n\n        points = points || series.points;\n\n        // Bottom of a stack is reversed\n        reversed = points.reversed;\n        if (reversed) {\n            points.reverse();\n        }\n        // Reverse the steps (#5004)\n        step = { right: 1, center: 2 }[step] || (step && 3);\n        if (step && reversed) {\n            step = 4 - step;\n        }\n\n        // Remove invalid points, especially in spline (#5015)\n        if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n            points = this.getValidPoints(points);\n        }\n\n        // Build the line\n        each(points, function (point, i) {\n\n            var plotX = point.plotX,\n                plotY = point.plotY,\n                lastPoint = points[i - 1],\n                pathToPoint; // the path to this point from the previous\n\n            if (\n                (point.leftCliff || (lastPoint && lastPoint.rightCliff)) &&\n                !connectCliffs\n            ) {\n                gap = true; // ... and continue\n            }\n\n            // Line series, nullsAsZeroes is not handled\n            if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                gap = !options.connectNulls;\n\n            // Area series, nullsAsZeroes is set\n            } else if (point.isNull && !nullsAsZeroes) {\n                gap = true;\n\n            } else {\n\n                if (i === 0 || gap) {\n                    pathToPoint = ['M', point.plotX, point.plotY];\n\n                // Generate the spline as defined in the SplineSeries object\n                } else if (series.getPointSpline) {\n\n                    pathToPoint = series.getPointSpline(points, point, i);\n\n                } else if (step) {\n\n                    if (step === 1) { // right\n                        pathToPoint = [\n                            'L',\n                            lastPoint.plotX,\n                            plotY\n                        ];\n\n                    } else if (step === 2) { // center\n                        pathToPoint = [\n                            'L',\n                            (lastPoint.plotX + plotX) / 2,\n                            lastPoint.plotY,\n                            'L',\n                            (lastPoint.plotX + plotX) / 2,\n                            plotY\n                        ];\n\n                    } else {\n                        pathToPoint = [\n                            'L',\n                            plotX,\n                            lastPoint.plotY\n                        ];\n                    }\n                    pathToPoint.push('L', plotX, plotY);\n\n                } else {\n                    // normal line to next point\n                    pathToPoint = [\n                        'L',\n                        plotX,\n                        plotY\n                    ];\n                }\n\n                // Prepare for animation. When step is enabled, there are two\n                // path nodes for each x value.\n                xMap.push(point.x);\n                if (step) {\n                    xMap.push(point.x);\n                    if (step === 2) { // step = center (#8073)\n                        xMap.push(point.x);\n                    }\n                }\n\n                graphPath.push.apply(graphPath, pathToPoint);\n                gap = false;\n            }\n        });\n\n        graphPath.xMap = xMap;\n        series.graphPath = graphPath;\n\n        return graphPath;\n\n    },\n\n    /**\n     * Draw the graph. Called internally when rendering line-like series types.\n     * The first time it generates the `series.graph` item and optionally other\n     * series-wide items like `series.area` for area charts. On subsequent calls\n     * these items are updated with new positions and attributes.\n     *\n     * @function Highcharts.Series#drawGraph\n     */\n    drawGraph: function () {\n        var series = this,\n            options = this.options,\n            graphPath = (this.gappedPath || this.getGraphPath).call(this),\n            props = [[\n                'graph',\n                'highcharts-graph'\n                \n            ]];\n\n        props = series.getZonesGraphs(props);\n\n        // Draw the graph\n        each(props, function (prop, i) {\n            var graphKey = prop[0],\n                graph = series[graphKey],\n                attribs;\n\n            if (graph) {\n                graph.endX = series.preventGraphAnimation ?\n                    null :\n                    graphPath.xMap;\n                graph.animate({ d: graphPath });\n\n            } else if (graphPath.length) { // #1487\n\n                series[graphKey] = series.chart.renderer.path(graphPath)\n                    .addClass(prop[1])\n                    .attr({ zIndex: 1 }) // #1069\n                    .add(series.group);\n\n                \n            }\n\n            // Helpers for animation\n            if (graph) {\n                graph.startX = graphPath.xMap;\n                graph.isArea = graphPath.isArea; // For arearange animation\n            }\n        });\n    },\n\n    /**\n     * Get zones properties for building graphs.\n     * Extendable by series with multiple lines within one series.\n     *\n     * @private\n     * @function Highcharts.Series#getZonesGraphs\n     *\n     * @param {Array<Array<string>>} props\n     *\n     * @return {Array<Array<string>>}\n     */\n    getZonesGraphs: function (props) {\n        // Add the zone properties if any\n        each(this.zones, function (zone, i) {\n            props.push([\n                'zone-graph-' + i,\n                'highcharts-graph highcharts-zone-graph-' + i + ' ' +\n                    (zone.className || '')\n                \n            ]);\n        }, this);\n\n        return props;\n    },\n\n    /**\n     * Clip the graphs into zones for colors and styling.\n     *\n     * @private\n     * @function Highcharts.Series#applyZones\n     */\n    applyZones: function () {\n        var series = this,\n            chart = this.chart,\n            renderer = chart.renderer,\n            zones = this.zones,\n            translatedFrom,\n            translatedTo,\n            clips = this.clips || [],\n            clipAttr,\n            graph = this.graph,\n            area = this.area,\n            chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n            axis = this[(this.zoneAxis || 'y') + 'Axis'],\n            extremes,\n            reversed,\n            inverted = chart.inverted,\n            horiz,\n            pxRange,\n            pxPosMin,\n            pxPosMax,\n            ignoreZones = false;\n\n        if (zones.length && (graph || area) && axis && axis.min !== undefined) {\n            reversed = axis.reversed;\n            horiz = axis.horiz;\n            // The use of the Color Threshold assumes there are no gaps\n            // so it is safe to hide the original graph and area\n            // unless it is not waterfall series, then use showLine property to\n            // set lines between columns to be visible (#7862)\n            if (graph && !this.showLine) {\n                graph.hide();\n            }\n            if (area) {\n                area.hide();\n            }\n\n            // Create the clips\n            extremes = axis.getExtremes();\n            each(zones, function (threshold, i) {\n\n                translatedFrom = reversed ?\n                    (horiz ? chart.plotWidth : 0) :\n                    (horiz ? 0 : axis.toPixels(extremes.min));\n                translatedFrom = Math.min(\n                    Math.max(\n                        pick(translatedTo, translatedFrom), 0\n                    ),\n                    chartSizeMax\n                );\n                translatedTo = Math.min(\n                    Math.max(\n                        Math.round(\n                            axis.toPixels(\n                                pick(threshold.value, extremes.max),\n                                true\n                            )\n                        ),\n                        0\n                    ),\n                    chartSizeMax\n                );\n\n                if (ignoreZones) {\n                    translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                }\n\n                pxRange = Math.abs(translatedFrom - translatedTo);\n                pxPosMin = Math.min(translatedFrom, translatedTo);\n                pxPosMax = Math.max(translatedFrom, translatedTo);\n                if (axis.isXAxis) {\n                    clipAttr = {\n                        x: inverted ? pxPosMax : pxPosMin,\n                        y: 0,\n                        width: pxRange,\n                        height: chartSizeMax\n                    };\n                    if (!horiz) {\n                        clipAttr.x = chart.plotHeight - clipAttr.x;\n                    }\n                } else {\n                    clipAttr = {\n                        x: 0,\n                        y: inverted ? pxPosMax : pxPosMin,\n                        width: chartSizeMax,\n                        height: pxRange\n                    };\n                    if (horiz) {\n                        clipAttr.y = chart.plotWidth - clipAttr.y;\n                    }\n                }\n\n                \n\n                if (clips[i]) {\n                    clips[i].animate(clipAttr);\n                } else {\n                    clips[i] = renderer.clipRect(clipAttr);\n\n                    if (graph) {\n                        series['zone-graph-' + i].clip(clips[i]);\n                    }\n\n                    if (area) {\n                        series['zone-area-' + i].clip(clips[i]);\n                    }\n                }\n                // if this zone extends out of the axis, ignore the others\n                ignoreZones = threshold.value > extremes.max;\n\n                // Clear translatedTo for indicators\n                if (series.resetZones && translatedTo === 0) {\n                    translatedTo = undefined;\n                }\n            });\n            this.clips = clips;\n        }\n    },\n\n    /**\n     * Initialize and perform group inversion on series.group and\n     * series.markerGroup.\n     *\n     * @private\n     * @function Highcharts.Series#invertGroups\n     *\n     * @param {boolean} inverted\n     */\n    invertGroups: function (inverted) {\n        var series = this,\n            chart = series.chart,\n            remover;\n\n        function setInvert() {\n            each(['group', 'markerGroup'], function (groupName) {\n                if (series[groupName]) {\n\n                    // VML/HTML needs explicit attributes for flipping\n                    if (chart.renderer.isVML) {\n                        series[groupName].attr({\n                            width: series.yAxis.len,\n                            height: series.xAxis.len\n                        });\n                    }\n\n                    series[groupName].width = series.yAxis.len;\n                    series[groupName].height = series.xAxis.len;\n                    series[groupName].invert(inverted);\n                }\n            });\n        }\n\n        // Pie, go away (#1736)\n        if (!series.xAxis) {\n            return;\n        }\n\n        // A fixed size is needed for inversion to work\n        remover = addEvent(chart, 'resize', setInvert);\n        addEvent(series, 'destroy', remover);\n\n        // Do it now\n        setInvert(inverted); // do it now\n\n        // On subsequent render and redraw, just do setInvert without setting up\n        // events again\n        series.invertGroups = setInvert;\n    },\n\n    /**\n     * General abstraction for creating plot groups like series.group,\n     * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the\n     * group will only be adjusted to the updated plot size.\n     *\n     * @private\n     * @function Highcharts.Series#plotGroup\n     *\n     * @param {string} prop\n     *\n     * @param {string} name\n     *\n     * @param {string} visibility\n     *\n     * @param {number} zIndex\n     *\n     * @param {Highcharts.SVGElement} parent\n     *\n     * @return {Highcharts.SVGElement}\n     */\n    plotGroup: function (prop, name, visibility, zIndex, parent) {\n        var group = this[prop],\n            isNew = !group;\n\n        // Generate it on first call\n        if (isNew) {\n            this[prop] = group = this.chart.renderer.g()\n                .attr({\n                    zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n                })\n                .add(parent);\n\n        }\n\n        // Add the class names, and replace existing ones as response to\n        // Series.update (#6660)\n        group.addClass(\n            (\n                'highcharts-' + name +\n                ' highcharts-series-' + this.index +\n                ' highcharts-' + this.type + '-series ' +\n                (\n                    defined(this.colorIndex) ?\n                        'highcharts-color-' + this.colorIndex + ' ' :\n                        ''\n                ) +\n                (this.options.className || '') +\n                (\n                    group.hasClass('highcharts-tracker') ?\n                        ' highcharts-tracker' :\n                        ''\n                )\n            ),\n            true\n        );\n\n        // Place it on first and subsequent (redraw) calls\n        group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](\n            this.getPlotBox()\n        );\n        return group;\n    },\n\n    /**\n     * Get the translation and scale for the plot area of this series.\n     *\n     * @function Highcharts.Series#getPlotBox\n     *\n     * @return {Highcharts.SeriesPlotBoxObject}\n     */\n    getPlotBox: function () {\n        var chart = this.chart,\n            xAxis = this.xAxis,\n            yAxis = this.yAxis;\n\n        // Swap axes for inverted (#2339)\n        if (chart.inverted) {\n            xAxis = yAxis;\n            yAxis = this.xAxis;\n        }\n        return {\n            translateX: xAxis ? xAxis.left : chart.plotLeft,\n            translateY: yAxis ? yAxis.top : chart.plotTop,\n            scaleX: 1, // #1623\n            scaleY: 1\n        };\n    },\n\n    /**\n     * Render the graph and markers. Called internally when first rendering and\n     * later when redrawing the chart. This function can be extended in plugins,\n     * but normally shouldn't be called directly.\n     *\n     * @function Highcharts.Series#render\n     *\n     * @todo\n     * Make events official: Fires the event `afterRender`.\n     */\n    render: function () {\n        var series = this,\n            chart = series.chart,\n            group,\n            options = series.options,\n            // Animation doesn't work in IE8 quirks when the group div is\n            // hidden, and looks bad in other oldIE\n            animDuration = (\n                !!series.animate &&\n                chart.renderer.isSVG &&\n                animObject(options.animation).duration\n            ),\n            visibility = series.visible ? 'inherit' : 'hidden', // #2597\n            zIndex = options.zIndex,\n            hasRendered = series.hasRendered,\n            chartSeriesGroup = chart.seriesGroup,\n            inverted = chart.inverted;\n\n        // the group\n        group = series.plotGroup(\n            'group',\n            'series',\n            visibility,\n            zIndex,\n            chartSeriesGroup\n        );\n\n        series.markerGroup = series.plotGroup(\n            'markerGroup',\n            'markers',\n            visibility,\n            zIndex,\n            chartSeriesGroup\n        );\n\n        // initiate the animation\n        if (animDuration) {\n            series.animate(true);\n        }\n\n        // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n        group.inverted = series.isCartesian ? inverted : false;\n\n        // draw the graph if any\n        if (series.drawGraph) {\n            series.drawGraph();\n            series.applyZones();\n        }\n\n/*        each(series.points, function (point) {\n            if (point.redraw) {\n                point.redraw();\n            }\n        });*/\n\n        // draw the data labels (inn pies they go before the points)\n        if (series.drawDataLabels) {\n            series.drawDataLabels();\n        }\n\n        // draw the points\n        if (series.visible) {\n            series.drawPoints();\n        }\n\n\n        // draw the mouse tracking area\n        if (\n            series.drawTracker &&\n            series.options.enableMouseTracking !== false\n        ) {\n            series.drawTracker();\n        }\n\n        // Handle inverted series and tracker groups\n        series.invertGroups(inverted);\n\n        // Initial clipping, must be defined after inverting groups for VML.\n        // Applies to columns etc. (#3839).\n        if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n            group.clip(chart.clipRect);\n        }\n\n        // Run the animation\n        if (animDuration) {\n            series.animate();\n        }\n\n        // Call the afterAnimate function on animation complete (but don't\n        // overwrite the animation.complete option which should be available to\n        // the user).\n        if (!hasRendered) {\n            series.animationTimeout = syncTimeout(function () {\n                series.afterAnimate();\n            }, animDuration);\n        }\n\n        series.isDirty = false; // means data is in accordance with what you see\n        // (See #322) series.isDirty = series.isDirtyData = false; // means\n        // data is in accordance with what you see\n        series.hasRendered = true;\n\n        fireEvent(series, 'afterRender');\n    },\n\n    /**\n     * Redraw the series. This function is called internally from `chart.redraw`\n     * and normally shouldn't be called directly.\n     *\n     * @private\n     * @function Highcharts.Series#redraw\n     */\n    redraw: function () {\n        var series = this,\n            chart = series.chart,\n            // cache it here as it is set to false in render, but used after\n            wasDirty = series.isDirty || series.isDirtyData,\n            group = series.group,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis;\n\n        // reposition on resize\n        if (group) {\n            if (chart.inverted) {\n                group.attr({\n                    width: chart.plotWidth,\n                    height: chart.plotHeight\n                });\n            }\n\n            group.animate({\n                translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                translateY: pick(yAxis && yAxis.top, chart.plotTop)\n            });\n        }\n\n        series.translate();\n        series.render();\n        if (wasDirty) { // #3868, #3945\n            delete this.kdTree;\n        }\n    },\n\n    kdAxisArray: ['clientX', 'plotY'],\n\n    /**\n     * @private\n     * @function Highcharts.Series#searchPoint\n     *\n     * @param {*} e\n     *\n     * @param {*} compareX\n     *\n     * @return {Highcharts.Point}\n     */\n    searchPoint: function (e, compareX) {\n        var series = this,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            inverted = series.chart.inverted;\n\n        return this.searchKDTree({\n            clientX: inverted ?\n                xAxis.len - e.chartY + xAxis.pos :\n                e.chartX - xAxis.pos,\n            plotY: inverted ?\n                yAxis.len - e.chartX + yAxis.pos :\n                e.chartY - yAxis.pos\n        }, compareX);\n    },\n\n    /**\n     * Build the k-d-tree that is used by mouse and touch interaction to get the\n     * closest point. Line-like series typically have a one-dimensional tree\n     * where points are searched along the X axis, while scatter-like series\n     * typically search in two dimensions, X and Y.\n     *\n     * @private\n     * @function Highcharts.Series#buildKDTree\n     */\n    buildKDTree: function () {\n\n        // Prevent multiple k-d-trees from being built simultaneously (#6235)\n        this.buildingKdTree = true;\n\n        var series = this,\n            dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                            2 : 1;\n\n        // Internal function\n        function _kdtree(points, depth, dimensions) {\n            var axis,\n                median,\n                length = points && points.length;\n\n            if (length) {\n\n                // alternate between the axis\n                axis = series.kdAxisArray[depth % dimensions];\n\n                // sort point array\n                points.sort(function (a, b) {\n                    return a[axis] - b[axis];\n                });\n\n                median = Math.floor(length / 2);\n\n                // build and return nod\n                return {\n                    point: points[median],\n                    left: _kdtree(\n                        points.slice(0, median), depth + 1, dimensions\n                    ),\n                    right: _kdtree(\n                        points.slice(median + 1), depth + 1, dimensions\n                    )\n                };\n\n            }\n        }\n\n        // Start the recursive build process with a clone of the points array\n        // and null points filtered out (#3873)\n        function startRecursive() {\n            series.kdTree = _kdtree(\n                series.getValidPoints(\n                    null,\n                    // For line-type series restrict to plot area, but\n                    // column-type series not (#3916, #4511)\n                    !series.directTouch\n                ),\n                dimensions,\n                dimensions\n            );\n            series.buildingKdTree = false;\n        }\n        delete series.kdTree;\n\n        // For testing tooltips, don't build async\n        syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Series#searchKDTree\n     *\n     * @param {*} point\n     *\n     * @param {*} compareX\n     *\n     * @return {Highcharts.Point}\n     */\n    searchKDTree: function (point, compareX) {\n        var series = this,\n            kdX = this.kdAxisArray[0],\n            kdY = this.kdAxisArray[1],\n            kdComparer = compareX ? 'distX' : 'dist',\n            kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                            2 : 1;\n\n        // Set the one and two dimensional distance on the point object\n        function setDistance(p1, p2) {\n            var x = (defined(p1[kdX]) && defined(p2[kdX])) ?\n                    Math.pow(p1[kdX] - p2[kdX], 2) :\n                    null,\n                y = (defined(p1[kdY]) && defined(p2[kdY])) ?\n                    Math.pow(p1[kdY] - p2[kdY], 2) :\n                    null,\n                r = (x || 0) + (y || 0);\n\n            p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n            p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n        }\n        function _search(search, tree, depth, dimensions) {\n            var point = tree.point,\n                axis = series.kdAxisArray[depth % dimensions],\n                tdist,\n                sideA,\n                sideB,\n                ret = point,\n                nPoint1,\n                nPoint2;\n\n            setDistance(search, point);\n\n            // Pick side based on distance to splitting point\n            tdist = search[axis] - point[axis];\n            sideA = tdist < 0 ? 'left' : 'right';\n            sideB = tdist < 0 ? 'right' : 'left';\n\n            // End of tree\n            if (tree[sideA]) {\n                nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n            }\n            if (tree[sideB]) {\n                // compare distance to current best to splitting point to decide\n                // wether to check side B or not\n                if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                    nPoint2 = _search(\n                        search,\n                        tree[sideB],\n                        depth + 1,\n                        dimensions\n                    );\n                    ret = nPoint2[kdComparer] < ret[kdComparer] ?\n                        nPoint2 :\n                        ret;\n                }\n            }\n\n            return ret;\n        }\n\n        if (!this.kdTree && !this.buildingKdTree) {\n            this.buildKDTree();\n        }\n\n        if (this.kdTree) {\n            return _search(point, this.kdTree, kdDimensions, kdDimensions);\n        }\n    }\n\n}); // end Series prototype\n\n/**\n * A line series displays information as a series of data points connected by\n * straight line segments.\n *\n * @sample {highcharts} highcharts/demo/line-basic/\n *         Line chart\n * @sample {highstock} stock/demo/basic-line/\n *         Line chart\n *\n * @extends   plotOptions.series\n * @product   highcharts highstock\n * @apioption plotOptions.line\n */\n\n\n\n/**\n * A `line` series. If the [type](#series.line.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.line\n * @excluding dataParser,dataURL\n * @product   highcharts highstock\n * @apioption series.line\n */\n\n/**\n * An array of data points for the series. For the `line` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 1],\n *         [1, 2],\n *         [2, 8]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.line.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 6,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<number|string|Date>|*>}\n * @apioption series.line.data\n */\n\n/**\n * An additional, individual class name for the data point's graphic\n * representation.\n *\n * @type      {string}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.className\n */\n\n/**\n * Individual color for the point. By default the color is pulled from\n * the global `colors` array.\n *\n * In styled mode, the `color` option doesn't take effect. Instead, use\n * `colorIndex`.\n *\n * @sample {highcharts} highcharts/point/color/\n *         Mark the highest point\n *\n * @type      {Highcharts.ColorString}\n * @product   highcharts highstock\n * @apioption series.line.data.color\n */\n\n/**\n * A specific color index to use for the point, so its graphic representations\n * are given the class name `highcharts-color-{n}`. In styled mode this will\n * change the color of the graphic. In non-styled mode, the color by is set by\n * the `fill` attribute, so the change in class name won't have a visual effect\n * by default.\n *\n * @type      {number}\n * @since     5.0.0\n * @product   highcharts\n * @apioption series.line.data.colorIndex\n */\n\n/**\n * Individual data label for each point. The options are the same as\n * the ones for [plotOptions.series.dataLabels](\n * #plotOptions.series.dataLabels).\n *\n * @sample highcharts/point/datalabels/\n *         Show a label for the last value\n *\n * @type      {Highcharts.PlotSeriesDataLabelsOptions}\n * @product   highcharts highstock\n * @apioption series.line.data.dataLabels\n */\n\n/**\n * A description of the point to add to the screen reader information\n * about the point. Requires the Accessibility module.\n *\n * @type      {string}\n * @since     5.0.0\n * @apioption series.line.data.description\n */\n\n/**\n * An id for the point. This can be used after render time to get a\n * pointer to the point object through `chart.get()`.\n *\n * @sample {highcharts} highcharts/point/id/\n *         Remove an id'd point\n *\n * @type      {string}\n * @since     1.2.0\n * @product   highcharts highstock\n * @apioption series.line.data.id\n */\n\n/**\n * The rank for this point's data label in case of collision. If two\n * data labels are about to overlap, only the one with the highest `labelrank`\n * will be drawn.\n *\n * @type      {number}\n * @apioption series.line.data.labelrank\n */\n\n/**\n * The name of the point as shown in the legend, tooltip, dataLabel\n * etc.\n *\n * @see [xAxis.uniqueNames](#xAxis.uniqueNames)\n *\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Point names\n *\n * @type      {string}\n * @apioption series.line.data.name\n */\n\n/**\n * Whether the data point is selected initially.\n *\n * @type      {boolean}\n * @default   false\n * @product   highcharts highstock\n * @apioption series.line.data.selected\n */\n\n/**\n * The x value of the point. For datetime axes, the X value is the timestamp\n * in milliseconds since 1970.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.x\n */\n\n/**\n * The y value of the point.\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.line.data.y\n */\n\n/**\n * Individual point events\n *\n * @extends   plotOptions.series.point.events\n * @product   highcharts highstock\n * @apioption series.line.data.events\n */\n\n/**\n * @extends   plotOptions.series.marker\n * @product   highcharts highstock\n * @apioption series.line.data.marker\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Series.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/SplineSeries.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/SplineSeries.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Options.js */ \"./node_modules/highcharts/js/es-modules/parts/Options.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\nvar pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    seriesType = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType;\n\n/**\n * A spline series is a special type of line series, where the segments between\n * the data points are smoothed.\n *\n * @sample    {highcharts} highcharts/demo/spline-irregular-time/\n *            Spline chart\n * @sample    {highstock} stock/demo/spline/\n *            Spline chart\n * @extends   plotOptions.series\n * @excluding step\n * @product   highcharts highstock\n * @apioption plotOptions.spline\n */\n\n/**\n * Spline series type.\n *\n * @constructor seriesTypes.spline\n * @extends     {Series}\n */\nseriesType('spline', 'line', {}, /** @lends seriesTypes.spline.prototype */ {\n    /**\n     * Get the spline segment from a given point's previous neighbour to the\n     * given point\n     */\n    getPointSpline: function (points, point, i) {\n        var\n            // 1 means control points midway between points, 2 means 1/3 from\n            // the point, 3 is 1/4 etc\n            smoothing = 1.5,\n            denom = smoothing + 1,\n            plotX = point.plotX,\n            plotY = point.plotY,\n            lastPoint = points[i - 1],\n            nextPoint = points[i + 1],\n            leftContX,\n            leftContY,\n            rightContX,\n            rightContY,\n            ret;\n\n        function doCurve(otherPoint) {\n            return otherPoint &&\n                !otherPoint.isNull &&\n                otherPoint.doCurve !== false &&\n                !point.isCliff; // #6387, area splines next to null\n        }\n\n        // Find control points\n        if (doCurve(lastPoint) && doCurve(nextPoint)) {\n            var lastX = lastPoint.plotX,\n                lastY = lastPoint.plotY,\n                nextX = nextPoint.plotX,\n                nextY = nextPoint.plotY,\n                correction = 0;\n\n            leftContX = (smoothing * plotX + lastX) / denom;\n            leftContY = (smoothing * plotY + lastY) / denom;\n            rightContX = (smoothing * plotX + nextX) / denom;\n            rightContY = (smoothing * plotY + nextY) / denom;\n\n            // Have the two control points make a straight line through main\n            // point\n            if (rightContX !== leftContX) { // #5016, division by zero\n                correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                    (rightContX - leftContX) + plotY - rightContY;\n            }\n\n            leftContY += correction;\n            rightContY += correction;\n\n            // to prevent false extremes, check that control points are between\n            // neighbouring points' y values\n            if (leftContY > lastY && leftContY > plotY) {\n                leftContY = Math.max(lastY, plotY);\n                // mirror of left control point\n                rightContY = 2 * plotY - leftContY;\n            } else if (leftContY < lastY && leftContY < plotY) {\n                leftContY = Math.min(lastY, plotY);\n                rightContY = 2 * plotY - leftContY;\n            }\n            if (rightContY > nextY && rightContY > plotY) {\n                rightContY = Math.max(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            } else if (rightContY < nextY && rightContY < plotY) {\n                rightContY = Math.min(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            }\n\n            // record for drawing in next point\n            point.rightContX = rightContX;\n            point.rightContY = rightContY;\n\n\n        }\n\n        // Visualize control points for debugging\n        /*\n        if (leftContX) {\n            this.chart.renderer.circle(\n                    leftContX + this.chart.plotLeft,\n                    leftContY + this.chart.plotTop,\n                    2\n                )\n                .attr({\n                    stroke: 'red',\n                    'stroke-width': 2,\n                    fill: 'none',\n                    zIndex: 9\n                })\n                .add();\n            this.chart.renderer.path(['M', leftContX + this.chart.plotLeft,\n                leftContY + this.chart.plotTop,\n                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                .attr({\n                    stroke: 'red',\n                    'stroke-width': 2,\n                    zIndex: 9\n                })\n                .add();\n        }\n        if (rightContX) {\n            this.chart.renderer.circle(\n                    rightContX + this.chart.plotLeft,\n                    rightContY + this.chart.plotTop,\n                    2\n                )\n                .attr({\n                    stroke: 'green',\n                    'stroke-width': 2,\n                    fill: 'none',\n                    zIndex: 9\n                })\n                .add();\n            this.chart.renderer.path(['M', rightContX + this.chart.plotLeft,\n                rightContY + this.chart.plotTop,\n                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                .attr({\n                    stroke: 'green',\n                    'stroke-width': 2,\n                    zIndex: 9\n                })\n                .add();\n        }\n        // */\n        ret = [\n            'C',\n            pick(lastPoint.rightContX, lastPoint.plotX),\n            pick(lastPoint.rightContY, lastPoint.plotY),\n            pick(leftContX, plotX),\n            pick(leftContY, plotY),\n            plotX,\n            plotY\n        ];\n        // reset for updating series later\n        lastPoint.rightContX = lastPoint.rightContY = null;\n        return ret;\n    }\n});\n\n/**\n * A `spline` series. If the [type](#series.spline.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.spline\n * @excluding dataParser,dataURL,step\n * @product   highcharts highstock\n * @apioption series.spline\n */\n\n/**\n * An array of data points for the series. For the `spline` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of numerical values. In this case, the numerical values\n * will be interpreted as `y` options. The `x` values will be automatically\n * calculated, either starting at 0 and incremented by 1, or from `pointStart`\n * and `pointInterval` given in the series options. If the axis has\n * categories, these will be used. Example:\n *\n *  ```js\n *  data: [0, 5, 3, 5]\n *  ```\n *\n * 2.  An array of arrays with 2 values. In this case, the values correspond\n * to `x,y`. If the first value is a string, it is applied as the name\n * of the point, and the `x` value is inferred.\n *\n *  ```js\n *     data: [\n *         [0, 9],\n *         [1, 2],\n *         [2, 8]\n *     ]\n *  ```\n *\n * 3.  An array of objects with named values. The following snippet shows only a\n * few settings, see the complete options set below. If the total number of data\n * points exceeds the series' [turboThreshold](#series.spline.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         x: 1,\n *         y: 9,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         x: 1,\n *         y: 0,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array|Number>}\n * @extends   series.line.data\n * @sample    {highcharts} highcharts/chart/reflow-true/\n *            Numerical values\n * @sample    {highcharts} highcharts/series/data-array-of-arrays/\n *            Arrays of numeric x and y\n * @sample    {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *            Arrays of datetime x and y\n * @sample    {highcharts} highcharts/series/data-array-of-name-value/\n *            Arrays of point.name and y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts highstock\n * @apioption series.spline.data\n */\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/SplineSeries.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Stacking.js":
/*!*****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Stacking.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    correctFloat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series;\n\n/**\n * The class for stacks. Each stack, on a specific X value and either negative\n * or positive, has its own stack item.\n *\n * @class\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StackItem = function (axis, options, isNegative, x, stackOption) {\n\n    var inverted = axis.chart.inverted;\n\n    this.axis = axis;\n\n    // Tells if the stack is negative\n    this.isNegative = isNegative;\n\n    // Save the options to be able to style the label\n    this.options = options;\n\n    // Save the x value to be able to position the label later\n    this.x = x;\n\n    // Initialize total value\n    this.total = null;\n\n    // This will keep each points' extremes stored by series.index and point\n    // index\n    this.points = {};\n\n    // Save the stack option on the series configuration object, and whether to\n    // treat it as percent\n    this.stack = stackOption;\n    this.leftCliff = 0;\n    this.rightCliff = 0;\n\n    // The align options and text align varies on whether the stack is negative\n    // and if the chart is inverted or not.\n    // First test the user supplied value, then use the dynamic.\n    this.alignOptions = {\n        align: options.align ||\n            (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n        verticalAlign: options.verticalAlign ||\n            (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n        y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n        x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n    };\n\n    this.textAlign = options.textAlign ||\n        (inverted ? (isNegative ? 'right' : 'left') : 'center');\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StackItem.prototype = {\n    destroy: function () {\n        destroyObjectProperties(this, this.axis);\n    },\n\n    /**\n     * Renders the stack total label and adds it to the stack label group.\n     */\n    render: function (group) {\n        var chart = this.axis.chart,\n            options = this.options,\n            formatOption = options.format,\n            str = formatOption ?\n                format(formatOption, this, chart.time) :\n                options.formatter.call(this);  // format the text in the label\n\n        // Change the text to reflect the new total and set visibility to hidden\n        // in case the serie is hidden\n        if (this.label) {\n            this.label.attr({ text: str, visibility: 'hidden' });\n        // Create new label\n        } else {\n            this.label =\n                chart.renderer.text(str, null, null, options.useHTML)\n                    .css(options.style)\n                    .attr({\n                        align: this.textAlign,\n                        rotation: options.rotation,\n                        visibility: 'hidden' // hidden until setOffset is called\n                    })\n                    .add(group); // add to the labels-group\n        }\n\n        // Rank it higher than data labels (#8742)\n        this.label.labelrank = chart.plotHeight;\n    },\n\n    /**\n     * Sets the offset that the stack has from the x value and repositions the\n     * label.\n     */\n    setOffset: function (xOffset, xWidth) {\n        var stackItem = this,\n            axis = stackItem.axis,\n            chart = axis.chart,\n            // stack value translated mapped to chart coordinates\n            y = axis.translate(\n                axis.usePercentage ? 100 : stackItem.total,\n                0,\n                0,\n                0,\n                1\n            ),\n            yZero = axis.translate(0), // stack origin\n            h = defined(y) && Math.abs(y - yZero), // stack height\n            x = chart.xAxis[0].translate(stackItem.x) + xOffset, // x position\n            stackBox = defined(y) && stackItem.getStackBox(\n                chart,\n                stackItem,\n                x,\n                y,\n                xWidth,\n                h,\n                axis\n            ),\n            label = stackItem.label,\n            alignAttr;\n\n        if (label && stackBox) {\n            // Align the label to the box\n            label.align(stackItem.alignOptions, null, stackBox);\n\n            // Set visibility (#678)\n            alignAttr = label.alignAttr;\n            label[\n                stackItem.options.crop === false || chart.isInsidePlot(\n                    alignAttr.x,\n                    alignAttr.y\n                ) ? 'show' : 'hide'](true);\n        }\n    },\n    getStackBox: function (chart, stackItem, x, y, xWidth, h, axis) {\n        var reversed = stackItem.axis.reversed,\n            inverted = chart.inverted,\n            axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft :\n                chart.plotTop),\n            neg = (stackItem.isNegative && !reversed) ||\n                (!stackItem.isNegative && reversed); // #4056\n\n        return { // this is the box for the complete stack\n            x: inverted ? (neg ? y : y - h) : x,\n            y: inverted ?\n                    axisPos - x - xWidth :\n                    (neg ?\n                        (axisPos - y - h) :\n                        axisPos - y\n                    ),\n            width: inverted ? h : xWidth,\n            height: inverted ? xWidth : h\n        };\n    }\n};\n\n/**\n * Generate stacks for each series and calculate stacks total values\n */\nChart.prototype.getStacks = function () {\n    var chart = this;\n\n    // reset stacks for each yAxis\n    each(chart.yAxis, function (axis) {\n        if (axis.stacks && axis.hasVisibleSeries) {\n            axis.oldStacks = axis.stacks;\n        }\n    });\n\n    each(chart.series, function (series) {\n        if (series.options.stacking && (series.visible === true ||\n                chart.options.chart.ignoreHiddenSeries === false)) {\n            series.stackKey = series.type + pick(series.options.stack, '');\n        }\n    });\n};\n\n\n// Stacking methods defined on the Axis prototype\n\n/**\n * Build the stacks from top down\n *\n * @ignore\n */\nAxis.prototype.buildStacks = function () {\n    var axisSeries = this.series,\n        reversedStacks = pick(this.options.reversedStacks, true),\n        len = axisSeries.length,\n        i;\n    if (!this.isXAxis) {\n        this.usePercentage = false;\n        i = len;\n        while (i--) {\n            axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n        }\n\n        // Loop up again to compute percent and stream stack\n        for (i = 0; i < len; i++) {\n            axisSeries[i].modifyStacks();\n        }\n    }\n};\n\nAxis.prototype.renderStackTotals = function () {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        stacks = axis.stacks,\n        stackTotalGroup = axis.stackTotalGroup;\n\n    // Create a separate group for the stack total labels\n    if (!stackTotalGroup) {\n        axis.stackTotalGroup = stackTotalGroup =\n            renderer.g('stack-labels')\n                .attr({\n                    visibility: 'visible',\n                    zIndex: 6\n                })\n                .add();\n    }\n\n    // plotLeft/Top will change when y axis gets wider so we need to translate\n    // the stackTotalGroup at every render call. See bug #506 and #516\n    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n    // Render each stack total\n    objectEach(stacks, function (type) {\n        objectEach(type, function (stack) {\n            stack.render(stackTotalGroup);\n        });\n    });\n};\n\n/**\n * Set all the stacks to initial states and destroy unused ones.\n *\n * @ignore\n */\nAxis.prototype.resetStacks = function () {\n    var axis = this,\n        stacks = axis.stacks;\n    if (!axis.isXAxis) {\n        objectEach(stacks, function (type) {\n            objectEach(type, function (stack, key) {\n                // Clean up memory after point deletion (#1044, #4320)\n                if (stack.touched < axis.stacksTouched) {\n                    stack.destroy();\n                    delete type[key];\n\n                // Reset stacks\n                } else {\n                    stack.total = null;\n                    stack.cumulative = null;\n                }\n            });\n        });\n    }\n};\n\nAxis.prototype.cleanStacks = function () {\n    var stacks;\n\n    if (!this.isXAxis) {\n        if (this.oldStacks) {\n            stacks = this.stacks = this.oldStacks;\n        }\n\n        // reset stacks\n        objectEach(stacks, function (type) {\n            objectEach(type, function (stack) {\n                stack.cumulative = stack.total;\n            });\n        });\n    }\n};\n\n\n// Stacking methods defnied for Series prototype\n\n/**\n * Adds series' points value to corresponding stack\n */\nSeries.prototype.setStackedPoints = function () {\n    if (!this.options.stacking || (this.visible !== true &&\n            this.chart.options.chart.ignoreHiddenSeries !== false)) {\n        return;\n    }\n\n    var series = this,\n        xData = series.processedXData,\n        yData = series.processedYData,\n        stackedYData = [],\n        yDataLength = yData.length,\n        seriesOptions = series.options,\n        threshold = seriesOptions.threshold,\n        stackThreshold = pick(seriesOptions.startFromThreshold && threshold, 0),\n        stackOption = seriesOptions.stack,\n        stacking = seriesOptions.stacking,\n        stackKey = series.stackKey,\n        negKey = '-' + stackKey,\n        negStacks = series.negStacks,\n        yAxis = series.yAxis,\n        stacks = yAxis.stacks,\n        oldStacks = yAxis.oldStacks,\n        stackIndicator,\n        isNegative,\n        stack,\n        other,\n        key,\n        pointKey,\n        i,\n        x,\n        y;\n\n\n    yAxis.stacksTouched += 1;\n\n    // loop over the non-null y values and read them into a local array\n    for (i = 0; i < yDataLength; i++) {\n        x = xData[i];\n        y = yData[i];\n        stackIndicator = series.getStackIndicator(\n            stackIndicator,\n            x,\n            series.index\n        );\n        pointKey = stackIndicator.key;\n        // Read stacked values into a stack based on the x value,\n        // the sign of y and the stack key. Stacking is also handled for null\n        // values (#739)\n        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n        key = isNegative ? negKey : stackKey;\n\n        // Create empty object for this stack if it doesn't exist yet\n        if (!stacks[key]) {\n            stacks[key] = {};\n        }\n\n        // Initialize StackItem for this x\n        if (!stacks[key][x]) {\n            if (oldStacks[key] && oldStacks[key][x]) {\n                stacks[key][x] = oldStacks[key][x];\n                stacks[key][x].total = null;\n            } else {\n                stacks[key][x] = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StackItem(\n                    yAxis,\n                    yAxis.options.stackLabels,\n                    isNegative,\n                    x,\n                    stackOption\n                );\n            }\n        }\n\n        // If the StackItem doesn't exist, create it first\n        stack = stacks[key][x];\n        if (y !== null) {\n            stack.points[pointKey] = stack.points[series.index] =\n                [pick(stack.cumulative, stackThreshold)];\n\n            // Record the base of the stack\n            if (!defined(stack.cumulative)) {\n                stack.base = pointKey;\n            }\n            stack.touched = yAxis.stacksTouched;\n\n\n            // In area charts, if there are multiple points on the same X value,\n            // let the area fill the full span of those points\n            if (stackIndicator.index > 0 && series.singleStacks === false) {\n                stack.points[pointKey][0] =\n                    stack.points[series.index + ',' + x + ',0'][0];\n            }\n\n        // When updating to null, reset the point stack (#7493)\n        } else {\n            stack.points[pointKey] = stack.points[series.index] = null;\n        }\n\n        // Add value to the stack total\n        if (stacking === 'percent') {\n\n            // Percent stacked column, totals are the same for the positive and\n            // negative stacks\n            other = isNegative ? stackKey : negKey;\n            if (negStacks && stacks[other] && stacks[other][x]) {\n                other = stacks[other][x];\n                stack.total = other.total =\n                    Math.max(other.total, stack.total) + Math.abs(y) || 0;\n\n            // Percent stacked areas\n            } else {\n                stack.total = correctFloat(stack.total + (Math.abs(y) || 0));\n            }\n        } else {\n            stack.total = correctFloat(stack.total + (y || 0));\n        }\n\n        stack.cumulative = pick(stack.cumulative, stackThreshold) + (y || 0);\n\n        if (y !== null) {\n            stack.points[pointKey].push(stack.cumulative);\n            stackedYData[i] = stack.cumulative;\n        }\n\n    }\n\n    if (stacking === 'percent') {\n        yAxis.usePercentage = true;\n    }\n\n    this.stackedYData = stackedYData; // To be used in getExtremes\n\n    // Reset old stacks\n    yAxis.oldStacks = {};\n};\n\n/**\n * Iterate over all stacks and compute the absolute values to percent\n */\nSeries.prototype.modifyStacks = function () {\n    var series = this,\n        stackKey = series.stackKey,\n        stacks = series.yAxis.stacks,\n        processedXData = series.processedXData,\n        stackIndicator,\n        stacking = series.options.stacking;\n\n    if (series[stacking + 'Stacker']) { // Modifier function exists\n        each([stackKey, '-' + stackKey], function (key) {\n            var i = processedXData.length,\n                x,\n                stack,\n                pointExtremes;\n\n            while (i--) {\n                x = processedXData[i];\n                stackIndicator = series.getStackIndicator(\n                    stackIndicator,\n                    x,\n                    series.index,\n                    key\n                );\n                stack = stacks[key] && stacks[key][x];\n                pointExtremes = stack && stack.points[stackIndicator.key];\n                if (pointExtremes) {\n                    series[stacking + 'Stacker'](pointExtremes, stack, i);\n                }\n            }\n        });\n    }\n};\n\n/**\n * Modifier function for percent stacks. Blows up the stack to 100%.\n */\nSeries.prototype.percentStacker = function (pointExtremes, stack, i) {\n    var totalFactor = stack.total ? 100 / stack.total : 0;\n    // Y bottom value\n    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);\n    // Y value\n    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);\n    this.stackedYData[i] = pointExtremes[1];\n};\n\n/**\n* Get stack indicator, according to it's x-value, to determine points with the\n* same x-value\n*/\nSeries.prototype.getStackIndicator = function (stackIndicator, x, index, key) {\n    // Update stack indicator, when:\n    // first point in a stack || x changed || stack type (negative vs positive)\n    // changed:\n    if (!defined(stackIndicator) || stackIndicator.x !== x ||\n            (key && stackIndicator.key !== key)) {\n        stackIndicator = {\n            x: x,\n            index: 0,\n            key: key\n        };\n    } else {\n        stackIndicator.index++;\n    }\n\n    stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n    return stackIndicator;\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Stacking.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/StockChart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/StockChart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart.js */ \"./node_modules/highcharts/js/es-modules/parts/Chart.js\");\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Axis.js */ \"./node_modules/highcharts/js/es-modules/parts/Axis.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/highcharts/js/es-modules/parts/Point.js\");\n/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ \"./node_modules/highcharts/js/es-modules/parts/Pointer.js\");\n/* harmony import */ var _Series_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Series.js */ \"./node_modules/highcharts/js/es-modules/parts/Series.js\");\n/* harmony import */ var _SvgRenderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SvgRenderer.js */ \"./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\n\n\n\nvar addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    arrayMax = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax,\n    arrayMin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin,\n    Axis = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis,\n    Chart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Chart,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    isString = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Point = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point,\n    Renderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer,\n    Series = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Series,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    SVGRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer,\n    VMLRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].VMLRenderer,\n    wrap = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap,\n\n\n    seriesProto = Series.prototype,\n    seriesInit = seriesProto.init,\n    seriesProcessData = seriesProto.processData,\n    pointTooltipFormatter = Point.prototype.tooltipFormatter;\n\n\n/**\n * Compare the values of the series against the first non-null, non-\n * zero value in the visible range. The y axis will show percentage\n * or absolute change depending on whether `compare` is set to `\"percent\"`\n * or `\"value\"`. When this is applied to multiple series, it allows\n * comparing the development of the series against each other. Adds\n * a `change` field to every point object.\n *\n * @type {String}\n * @see [compareBase](#plotOptions.series.compareBase),\n *      [Axis.setCompare()](/class-reference/Highcharts.Axis#setCompare)\n * @sample {highstock} stock/plotoptions/series-compare-percent/ Percent\n * @sample {highstock} stock/plotoptions/series-compare-value/ Value\n * @default undefined\n * @since 1.0.1\n * @product highstock\n * @apioption plotOptions.series.compare\n */\n\n/**\n * Defines if comparison should start from the first point within the visible\n * range or should start from the first point <b>before</b> the range.\n * In other words, this flag determines if first point within the visible range\n * will have 0% (`compareStart=true`) or should have been already calculated\n * according to the previous point (`compareStart=false`).\n *\n * @type {Boolean}\n * @sample {highstock} stock/plotoptions/series-comparestart/\n *         Calculate compare within visible range\n * @default false\n * @since 6.0.0\n * @product highstock\n * @apioption plotOptions.series.compareStart\n */\n\n/**\n * When [compare](#plotOptions.series.compare) is `percent`, this option\n * dictates whether to use 0 or 100 as the base of comparison.\n *\n * @validvalue [0, 100]\n * @type {Number}\n * @sample {highstock} / Compare base is 100\n * @default 0\n * @since 5.0.6\n * @product highstock\n * @apioption plotOptions.series.compareBase\n */\n\n/**\n * Factory function for creating new stock charts. Creates a new {@link Chart|\n * Chart} object with different default options than the basic Chart.\n *\n * @function #stockChart\n * @memberof Highcharts\n *\n * @param  {String|HTMLDOMElement} renderTo\n *         The DOM element to render to, or its id.\n * @param  {Options} options\n *         The chart options structure as described in the {@link\n *         https://api.highcharts.com/highstock|options reference}.\n * @param  {Function} callback\n *         A function to execute when the chart object is finished loading and\n *         rendering. In most cases the chart is built in one thread, but in\n *         Internet Explorer version 8 or less the chart is sometimes\n *         initialized before the document is ready, and in these cases the\n *         chart object will not be finished synchronously. As a consequence,\n *         code that relies on the newly built Chart object should always run in\n *         the callback. Defining a {@link https://api.highcharts.com/highstock/chart.events.load|\n *         chart.event.load} handler is equivalent.\n *\n * @return {Chart}\n *         The chart object.\n *\n * @example\n * var chart = Highcharts.stockChart('container', {\n *     series: [{\n *         data: [1, 2, 3, 4, 5, 6, 7, 8, 9],\n *         pointInterval: 24 * 60 * 60 * 1000\n *     }]\n * });\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StockChart = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stockChart = function (a, b, c) {\n    var hasRenderToArg = isString(a) || a.nodeName,\n        options = arguments[hasRenderToArg ? 1 : 0],\n        // to increase performance, don't merge the data\n        seriesOptions = options.series,\n        defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getOptions(),\n        opposite,\n\n        // Always disable startOnTick:true on the main axis when the navigator\n        // is enabled (#1090)\n        navigatorEnabled = pick(\n            options.navigator && options.navigator.enabled,\n            defaultOptions.navigator.enabled,\n            true\n        ),\n        disableStartOnTick = navigatorEnabled ? {\n            startOnTick: false,\n            endOnTick: false\n        } : null,\n\n        lineOptions = {\n\n            marker: {\n                enabled: false,\n                radius: 2\n            }\n            // gapSize: 0\n        },\n        columnOptions = {\n            shadow: false,\n            borderWidth: 0\n        };\n\n    // apply X axis options to both single and multi y axes\n    options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions, i) {\n        return merge(\n            { // defaults\n                minPadding: 0,\n                maxPadding: 0,\n                overscroll: 0,\n                ordinal: true,\n                title: {\n                    text: null\n                },\n                labels: {\n                    overflow: 'justify'\n                },\n                showLastLabel: true\n            },\n            defaultOptions.xAxis, // #3802\n            defaultOptions.xAxis && defaultOptions.xAxis[i], // #7690\n            xAxisOptions, // user options\n            { // forced options\n                type: 'datetime',\n                categories: null\n            },\n            disableStartOnTick\n        );\n    });\n\n    // apply Y axis options to both single and multi y axes\n    options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions, i) {\n        opposite = pick(yAxisOptions.opposite, true);\n        return merge({ // defaults\n            labels: {\n                y: -2\n            },\n            opposite: opposite,\n\n            /**\n             * @default {highcharts} true\n             * @default {highstock} false\n             * @apioption yAxis.showLastLabel\n             */\n            showLastLabel: !!(\n                // #6104, show last label by default for category axes\n                yAxisOptions.categories ||\n                yAxisOptions.type === 'category'\n            ),\n\n            title: {\n                text: null\n            }\n        },\n        defaultOptions.yAxis, // #3802\n        defaultOptions.yAxis && defaultOptions.yAxis[i], // #7690\n        yAxisOptions // user options\n        );\n    });\n\n    options.series = null;\n\n    options = merge(\n        {\n            chart: {\n                panning: true,\n                pinchType: 'x'\n            },\n            navigator: {\n                enabled: navigatorEnabled\n            },\n            scrollbar: {\n                // #4988 - check if setOptions was called\n                enabled: pick(defaultOptions.scrollbar.enabled, true)\n            },\n            rangeSelector: {\n                // #4988 - check if setOptions was called\n                enabled: pick(defaultOptions.rangeSelector.enabled, true)\n            },\n            title: {\n                text: null\n            },\n            tooltip: {\n                split: pick(defaultOptions.tooltip.split, true),\n                crosshairs: true\n            },\n            legend: {\n                enabled: false\n            },\n\n            plotOptions: {\n                line: lineOptions,\n                spline: lineOptions,\n                area: lineOptions,\n                areaspline: lineOptions,\n                arearange: lineOptions,\n                areasplinerange: lineOptions,\n                column: columnOptions,\n                columnrange: columnOptions,\n                candlestick: columnOptions,\n                ohlc: columnOptions\n            }\n\n        },\n\n        options, // user's options\n\n        { // forced options\n            isStock: true // internal flag\n        }\n    );\n\n    options.series = seriesOptions;\n\n    return hasRenderToArg ?\n        new Chart(a, options, c) :\n        new Chart(options, b);\n};\n\n// Override the automatic label alignment so that the first Y axis' labels\n// are drawn on top of the grid line, and subsequent axes are drawn outside\nwrap(Axis.prototype, 'autoLabelAlign', function (proceed) {\n    var chart = this.chart,\n        options = this.options,\n        panes = chart._labelPanes = chart._labelPanes || {},\n        key,\n        labelOptions = this.options.labels;\n    if (this.chart.options.isStock && this.coll === 'yAxis') {\n        key = options.top + ',' + options.height;\n        // do it only for the first Y axis of each pane\n        if (!panes[key] && labelOptions.enabled) {\n            if (labelOptions.x === 15) { // default\n                labelOptions.x = 0;\n            }\n            if (labelOptions.align === undefined) {\n                labelOptions.align = 'right';\n            }\n            panes[key] = this;\n            return 'right';\n        }\n    }\n    return proceed.apply(this, [].slice.call(arguments, 1));\n});\n\n// Clear axis from label panes (#6071)\naddEvent(Axis, 'destroy', function () {\n    var chart = this.chart,\n        key = this.options && (this.options.top + ',' + this.options.height);\n\n    if (key && chart._labelPanes && chart._labelPanes[key] === this) {\n        delete chart._labelPanes[key];\n    }\n});\n\n// Override getPlotLinePath to allow for multipane charts\nwrap(Axis.prototype, 'getPlotLinePath', function (\n    proceed,\n    value,\n    lineWidth,\n    old,\n    force,\n    translatedValue\n) {\n    var axis = this,\n        series = (\n            this.isLinked && !this.series ?\n                this.linkedParent.series :\n                this.series\n        ),\n        chart = axis.chart,\n        renderer = chart.renderer,\n        axisLeft = axis.left,\n        axisTop = axis.top,\n        x1,\n        y1,\n        x2,\n        y2,\n        result = [],\n        axes = [], // #3416 need a default array\n        axes2,\n        uniqueAxes,\n        transVal;\n\n    /**\n     * Return the other axis based on either the axis option or on related\n     * series.\n     */\n    function getAxis(coll) {\n        var otherColl = coll === 'xAxis' ? 'yAxis' : 'xAxis',\n            opt = axis.options[otherColl];\n\n        // Other axis indexed by number\n        if (isNumber(opt)) {\n            return [chart[otherColl][opt]];\n        }\n\n        // Other axis indexed by id (like navigator)\n        if (isString(opt)) {\n            return [chart.get(opt)];\n        }\n\n        // Auto detect based on existing series\n        return map(series, function (s) {\n            return s[otherColl];\n        });\n    }\n\n    // Ignore in case of colorAxis or zAxis. #3360, #3524, #6720\n    if (axis.coll !== 'xAxis' && axis.coll !== 'yAxis') {\n        return proceed.apply(this, [].slice.call(arguments, 1));\n    }\n\n    // Get the related axes based on series\n    axes = getAxis(axis.coll);\n\n    // Get the related axes based options.*Axis setting #2810\n    axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);\n    each(axes2, function (A) {\n        if (\n            defined(A.options.id) ?\n                A.options.id.indexOf('navigator') === -1 :\n                true\n        ) {\n            var a = (A.isXAxis ? 'yAxis' : 'xAxis'),\n                rax = (\n                    defined(A.options[a]) ?\n                        chart[a][A.options[a]] :\n                        chart[a][0]\n                );\n\n            if (axis === rax) {\n                axes.push(A);\n            }\n        }\n    });\n\n\n    // Remove duplicates in the axes array. If there are no axes in the axes\n    // array, we are adding an axis without data, so we need to populate this\n    // with grid lines (#2796).\n    uniqueAxes = axes.length ?\n        [] :\n        [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; // #3742\n    each(axes, function (axis2) {\n        if (\n            inArray(axis2, uniqueAxes) === -1 &&\n            // Do not draw on axis which overlap completely. #5424\n            !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find(uniqueAxes, function (unique) {\n                return unique.pos === axis2.pos && unique.len === axis2.len;\n            })\n        ) {\n            uniqueAxes.push(axis2);\n        }\n    });\n\n    transVal = pick(translatedValue, axis.translate(value, null, null, old));\n    if (isNumber(transVal)) {\n        if (axis.horiz) {\n            each(uniqueAxes, function (axis2) {\n                var skip;\n\n                y1 = axis2.pos;\n                y2 = y1 + axis2.len;\n                x1 = x2 = Math.round(transVal + axis.transB);\n\n                // outside plot area\n                if (x1 < axisLeft || x1 > axisLeft + axis.width) {\n                    if (force) {\n                        x1 = x2 = Math.min(\n                            Math.max(axisLeft, x1),\n                            axisLeft + axis.width\n                        );\n                    } else {\n                        skip = true;\n                    }\n                }\n                if (!skip) {\n                    result.push('M', x1, y1, 'L', x2, y2);\n                }\n            });\n        } else {\n            each(uniqueAxes, function (axis2) {\n                var skip;\n\n                x1 = axis2.pos;\n                x2 = x1 + axis2.len;\n                y1 = y2 = Math.round(axisTop + axis.height - transVal);\n\n                // outside plot area\n                if (y1 < axisTop || y1 > axisTop + axis.height) {\n                    if (force) {\n                        y1 = y2 = Math.min(\n                            Math.max(axisTop, y1),\n                            axis.top + axis.height\n                        );\n                    } else {\n                        skip = true;\n                    }\n                }\n                if (!skip) {\n                    result.push('M', x1, y1, 'L', x2, y2);\n                }\n            });\n        }\n    }\n    return result.length > 0 ?\n        renderer.crispPolyLine(result, lineWidth || 1) :\n        null; // #3557 getPlotLinePath in regular Highcharts also returns null\n});\n\n// Function to crisp a line with multiple segments\nSVGRenderer.prototype.crispPolyLine = function (points, width) {\n    // points format: ['M', 0, 0, 'L', 100, 0]\n    // normalize to a crisp line\n    var i;\n    for (i = 0; i < points.length; i = i + 6) {\n        if (points[i + 1] === points[i + 4]) {\n            // Substract due to #1129. Now bottom and left axis gridlines behave\n            // the same.\n            points[i + 1] = points[i + 4] =\n                Math.round(points[i + 1]) - (width % 2 / 2);\n        }\n        if (points[i + 2] === points[i + 5]) {\n            points[i + 2] = points[i + 5] =\n                Math.round(points[i + 2]) + (width % 2 / 2);\n        }\n    }\n    return points;\n};\n\n\n// Wrapper to hide the label\nwrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {\n\n    proceed.call(this, i);\n\n    if (this.crossLabel) {\n        this.crossLabel = this.crossLabel.hide();\n    }\n});\n\n// Extend crosshairs to also draw the label\naddEvent(Axis, 'afterDrawCrosshair', function (event) {\n\n    // Check if the label has to be drawn\n    if (\n        !defined(this.crosshair.label) ||\n        !this.crosshair.label.enabled ||\n        !this.cross\n    ) {\n        return;\n    }\n\n    var chart = this.chart,\n        options = this.options.crosshair.label,        // the label's options\n        horiz = this.horiz,                            // axis orientation\n        opposite = this.opposite,                    // axis position\n        left = this.left,                            // left position\n        top = this.top,                                // top position\n        crossLabel = this.crossLabel,                // the svgElement\n        posx,\n        posy,\n        crossBox,\n        formatOption = options.format,\n        formatFormat = '',\n        limit,\n        align,\n        tickInside = this.options.tickPosition === 'inside',\n        snap = this.crosshair.snap !== false,\n        value,\n        offset = 0,\n        // Use last available event (#5287)\n        e = event.e || (this.cross && this.cross.e),\n        point = event.point,\n        lin2log = this.lin2log,\n        min,\n        max;\n\n    if (this.isLog) {\n        min = lin2log(this.min);\n        max = lin2log(this.max);\n    } else {\n        min = this.min;\n        max = this.max;\n    }\n\n    align = (horiz ? 'center' : opposite ?\n        (this.labelAlign === 'right' ? 'right' : 'left') :\n        (this.labelAlign === 'left' ? 'left' : 'center'));\n\n    // If the label does not exist yet, create it.\n    if (!crossLabel) {\n        crossLabel = this.crossLabel = chart.renderer.label(\n                null,\n                null,\n                null,\n                options.shape || 'callout'\n            )\n            .addClass('highcharts-crosshair-label' + (\n                this.series[0] &&\n                ' highcharts-color-' + this.series[0].colorIndex)\n            )\n            .attr({\n                align: options.align || align,\n                padding: pick(options.padding, 8),\n                r: pick(options.borderRadius, 3),\n                zIndex: 2\n            })\n            .add(this.labelGroup);\n\n        \n    }\n\n    if (horiz) {\n        posx = snap ? point.plotX + left : e.chartX;\n        posy = top + (opposite ? 0 : this.height);\n    } else {\n        posx = opposite ? this.width + left : 0;\n        posy = snap ? point.plotY + top : e.chartY;\n    }\n\n    if (!formatOption && !options.formatter) {\n        if (this.isDatetimeAxis) {\n            formatFormat = '%b %d, %Y';\n        }\n        formatOption =\n            '{value' + (formatFormat ? ':' + formatFormat : '') + '}';\n    }\n\n    // Show the label\n    value = snap ?\n        point[this.isXAxis ? 'x' : 'y'] :\n        this.toValue(horiz ? e.chartX : e.chartY);\n\n    crossLabel.attr({\n        text: formatOption ?\n            format(formatOption, { value: value }, chart.time) :\n            options.formatter.call(this, value),\n        x: posx,\n        y: posy,\n        // Crosshair should be rendered within Axis range (#7219)\n        visibility: value < min || value > max ? 'hidden' : 'visible'\n    });\n\n    crossBox = crossLabel.getBBox();\n\n    // now it is placed we can correct its position\n    if (horiz) {\n        if ((tickInside && !opposite) || (!tickInside && opposite)) {\n            posy = crossLabel.y - crossBox.height;\n        }\n    } else {\n        posy = crossLabel.y - (crossBox.height / 2);\n    }\n\n    // check the edges\n    if (horiz) {\n        limit = {\n            left: left - crossBox.x,\n            right: left + this.width - crossBox.x\n        };\n    } else {\n        limit = {\n            left: this.labelAlign === 'left' ? left : 0,\n            right: this.labelAlign === 'right' ?\n                left + this.width :\n                chart.chartWidth\n        };\n    }\n\n    // left edge\n    if (crossLabel.translateX < limit.left) {\n        offset = limit.left - crossLabel.translateX;\n    }\n    // right edge\n    if (crossLabel.translateX + crossBox.width >= limit.right) {\n        offset = -(crossLabel.translateX + crossBox.width - limit.right);\n    }\n\n    // show the crosslabel\n    crossLabel.attr({\n        x: posx + offset,\n        y: posy,\n        // First set x and y, then anchorX and anchorY, when box is actually\n        // calculated, #5702\n        anchorX: horiz ?\n            posx :\n            (this.opposite ? 0 : chart.chartWidth),\n        anchorY: horiz ?\n            (this.opposite ? chart.chartHeight : 0) :\n            posy + crossBox.height / 2\n    });\n});\n\n/* ****************************************************************************\n * Start value compare logic                                                  *\n *****************************************************************************/\n\n/**\n * Extend series.init by adding a method to modify the y value used for plotting\n * on the y axis. This method is called both from the axis when finding dataMin\n * and dataMax, and from the series.translate method.\n */\nseriesProto.init = function () {\n\n    // Call base method\n    seriesInit.apply(this, arguments);\n\n    // Set comparison mode\n    this.setCompare(this.options.compare);\n};\n\n/**\n * Highstock only. Set the {@link\n * http://api.highcharts.com/highstock/plotOptions.series.compare|\n * compare} mode of the series after render time. In most cases it is more\n * useful running {@link Axis#setCompare} on the X axis to update all its\n * series.\n *\n * @function setCompare\n * @memberof Series.prototype\n *\n * @param  {String} compare\n *         Can be one of `null`, `\"percent\"` or `\"value\"`.\n */\nseriesProto.setCompare = function (compare) {\n\n    // Set or unset the modifyValue method\n    this.modifyValue = (compare === 'value' || compare === 'percent') ?\n        function (value, point) {\n            var compareValue = this.compareValue;\n\n            if (\n                value !== undefined &&\n                compareValue !== undefined\n            ) { // #2601, #5814\n\n                // Get the modified value\n                if (compare === 'value') {\n                    value -= compareValue;\n\n                // Compare percent\n                } else {\n                    value = 100 * (value / compareValue) -\n                        (this.options.compareBase === 100 ? 0 : 100);\n                }\n\n                // record for tooltip etc.\n                if (point) {\n                    point.change = value;\n                }\n\n                return value;\n            }\n        } :\n        null;\n\n    // Survive to export, #5485\n    this.userOptions.compare = compare;\n\n    // Mark dirty\n    if (this.chart.hasRendered) {\n        this.isDirty = true;\n    }\n\n};\n\n/**\n * Extend series.processData by finding the first y value in the plot area,\n * used for comparing the following values\n */\nseriesProto.processData = function () {\n    var series = this,\n        i,\n        keyIndex = -1,\n        processedXData,\n        processedYData,\n        compareStart = series.options.compareStart === true ? 0 : 1,\n        length,\n        compareValue;\n\n    // call base method\n    seriesProcessData.apply(this, arguments);\n\n    if (series.xAxis && series.processedYData) { // not pies\n\n        // local variables\n        processedXData = series.processedXData;\n        processedYData = series.processedYData;\n        length = processedYData.length;\n\n        // For series with more than one value (range, OHLC etc), compare\n        // against close or the pointValKey (#4922, #3112)\n        if (series.pointArrayMap) {\n            // Use close if present (#3112)\n            keyIndex = inArray('close', series.pointArrayMap);\n            if (keyIndex === -1) {\n                keyIndex = inArray(\n                    series.pointValKey || 'y',\n                    series.pointArrayMap\n                );\n            }\n        }\n\n        // find the first value for comparison\n        for (i = 0; i < length - compareStart; i++) {\n            compareValue = processedYData[i] && keyIndex > -1 ?\n                processedYData[i][keyIndex] :\n                processedYData[i];\n            if (\n                isNumber(compareValue) &&\n                processedXData[i + compareStart] >= series.xAxis.min &&\n                compareValue !== 0\n            ) {\n                series.compareValue = compareValue;\n                break;\n            }\n        }\n    }\n};\n\n/**\n * Modify series extremes\n */\nwrap(seriesProto, 'getExtremes', function (proceed) {\n    var extremes;\n\n    proceed.apply(this, [].slice.call(arguments, 1));\n\n    if (this.modifyValue) {\n        extremes = [\n            this.modifyValue(this.dataMin),\n            this.modifyValue(this.dataMax)\n        ];\n        this.dataMin = arrayMin(extremes);\n        this.dataMax = arrayMax(extremes);\n    }\n});\n\n/**\n * Highstock only. Set the compare mode on all series belonging to an Y axis\n * after render time.\n *\n * @param  {String} compare\n *         The compare mode. Can be one of `null`, `\"value\"` or `\"percent\"`.\n * @param  {Boolean} [redraw=true]\n *         Whether to redraw the chart or to wait for a later call to {@link\n *         Chart#redraw},\n *\n * @function setCompare\n * @memberof Axis.prototype\n *\n * @see    {@link https://api.highcharts.com/highstock/series.plotOptions.compare|\n *         series.plotOptions.compare}\n *\n * @sample stock/members/axis-setcompare/\n *         Set compoare\n */\nAxis.prototype.setCompare = function (compare, redraw) {\n    if (!this.isXAxis) {\n        each(this.series, function (series) {\n            series.setCompare(compare);\n        });\n        if (pick(redraw, true)) {\n            this.chart.redraw();\n        }\n    }\n};\n\n/**\n * Extend the tooltip formatter by adding support for the point.change variable\n * as well as the changeDecimals option\n */\nPoint.prototype.tooltipFormatter = function (pointFormat) {\n    var point = this;\n\n    pointFormat = pointFormat.replace(\n        '{point.change}',\n        (point.change > 0 ? '+' : '') + _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(\n            point.change,\n            pick(point.series.tooltipOptions.changeDecimals, 2)\n        )\n    );\n\n    return pointTooltipFormatter.apply(this, [pointFormat]);\n};\n\n/* ****************************************************************************\n * End value compare logic                                                    *\n *****************************************************************************/\n\n\n/**\n * Extend the Series prototype to create a separate series clip box. This is\n * related to using multiple panes, and a future pane logic should incorporate\n * this feature (#2754).\n */\nwrap(Series.prototype, 'render', function (proceed) {\n    var clipHeight;\n    // Only do this on not 3d (#2939, #5904) nor polar (#6057) charts, and only\n    // if the series type handles clipping in the animate method (#2975).\n    if (\n        !(this.chart.is3d && this.chart.is3d()) &&\n        !this.chart.polar &&\n        this.xAxis &&\n        !this.xAxis.isRadial // Gauge, #6192\n    ) {\n        // Include xAxis line width, #8031\n        clipHeight = this.yAxis.len - (this.xAxis.axisLine ?\n            Math.floor(this.xAxis.axisLine.strokeWidth() / 2) :\n            0);\n\n        // First render, initial clip box\n        if (!this.clipBox && this.animate) {\n            this.clipBox = merge(this.chart.clipBox);\n            this.clipBox.width = this.xAxis.len;\n            this.clipBox.height = clipHeight;\n\n        // On redrawing, resizing etc, update the clip rectangle\n        } else if (this.chart[this.sharedClipKey]) {\n            this.chart[this.sharedClipKey].attr({\n                width: this.xAxis.len,\n                height: clipHeight\n            });\n        // #3111\n        } else if (this.clipBox) {\n            this.clipBox.width = this.xAxis.len;\n            this.clipBox.height = clipHeight;\n        }\n    }\n    proceed.call(this);\n});\n\nwrap(Chart.prototype, 'getSelectedPoints', function (proceed) {\n    var points = proceed.call(this);\n\n    each(this.series, function (serie) {\n        // series.points - for grouped points (#6445)\n        if (serie.hasGroupedData) {\n            points = points.concat(grep(serie.points || [], function (point) {\n                return point.selected;\n            }));\n        }\n    });\n    return points;\n});\n\naddEvent(Chart, 'update', function (e) {\n    var options = e.options;\n    // Use case: enabling scrollbar from a disabled state.\n    // Scrollbar needs to be initialized from a controller, Navigator in this\n    // case (#6615)\n    if ('scrollbar' in options && this.navigator) {\n        merge(true, this.options.scrollbar, options.scrollbar);\n        this.navigator.update({}, false);\n        delete options.scrollbar;\n    }\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/StockChart.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js":
/*!********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color.js */ \"./node_modules/highcharts/js/es-modules/parts/Color.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Options to align the element relative to the chart or another box.\n *\n * @typedef Highcharts.AlignObject\n *\n * @property {string} [align='left']\n *           Horizontal alignment. Can be one of `left`, `center` and\n *           `right`.\n *\n * @property {string} [verticalAlign='top']\n *           Vertical alignment. Can be one of `top`, `middle` and `bottom`.\n *\n * @property {number} [x=0]\n *           Horizontal pixel offset from alignment.\n *\n * @property {number} [y=0]\n *           Vertical pixel offset from alignment.\n *\n * @property {boolean} [alignByTranslate=false]\n *           Use the `transform` attribute with translateX and translateY\n *           custom attributes to align this elements rather than `x` and\n *           `y` attributes.\n */\n\n/**\n * Bounding box of an element.\n *\n * @typedef Highcharts.BBoxObject\n *\n * @property {number} height\n *           Height of the bounding box.\n *\n * @property {number} width\n *           Width of the bounding box.\n *\n * @property {number} x\n *           Horizontal position of the bounding box.\n *\n * @property {number} y\n *           Vertical position of the bounding box.\n */\n\n/**\n * A clipping rectangle that can be applied to one or more\n * {@link SVGElement} instances. It is instanciated with the\n * {@link SVGRenderer#clipRect} function and applied with the\n * {@link SVGElement#clip} function.\n *\n * @example\n * var circle = renderer.circle(100, 100, 100)\n *     .attr({ fill: 'red' })\n *     .add();\n * var clipRect = renderer.clipRect(100, 100, 100, 100);\n *\n * // Leave only the lower right quarter visible\n * circle.clip(clipRect);\n *\n * @typedef {Highcharts.SVGElement} Highcharts.ClipRectElement\n */\n\n/**\n * The font metrics.\n *\n * @typedef Highcharts.FontMetricsObject\n *\n * @property {number} b\n *           The baseline relative to the top of the box.\n *\n * @property {number} h\n *           The line height.\n *\n * @property {number} f\n *           The font size.\n */\n\n/**\n * Gradient options instead of a solid color.\n *\n * @example\n * // Linear gradient used as a color option\n * color: {\n *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n *         stops: [\n *             [0, '#003399'], // start\n *             [0.5, '#ffffff'], // middle\n *             [1, '#3366AA'] // end\n *         ]\n *     }\n * }\n *\n * @private\n * @typedef Highcharts.GradientColorObject\n *\n * @property {Highcharts.LinearGradientColorObject} linearGradient\n *           Holds an object that defines the start position and the end\n *           position relative to the shape.\n *\n * @property {Highcharts.RadialGradientColorObject} radialGradient\n *           Holds an object that defines the center position and the\n *           radius.\n *\n * @property {Array<Array<number|string>>} stops\n *           The first item in each tuple is the position in the gradient,\n *           where 0 is the start of the gradient and 1 is the end of the\n *           gradient. Multiple stops can be applied. The second item is the\n *           color for each stop. This color can also be given in the rgba\n *           format.\n */\n\n/**\n * Defines the start position and the end position for a gradient relative\n * to the shape.\n *\n * @private\n * @typedef Highcharts.LinearGradientColorObject\n *\n * @property {number} x1\n *           Start horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} x2\n *           End horizontal position of the gradient. Ranges 0-1.\n *\n * @property {number} y1\n *           Start vertical position of the gradient. Ranges 0-1.\n *\n * @property {number} y2\n *           End vertical position of the gradient. Ranges 0-1.\n */\n\n/**\n * Defines the center position and the radius for a gradient.\n *\n * @private\n * @typedef Highcharts.RadialGradientColorObject\n *\n * @property {number} cx\n *           Center horizontal position relative to the shape. Ranges 0-1.\n *\n * @property {number} cy\n *           Center vertical position relative to the shape. Ranges 0-1.\n *\n * @property {number} r\n *           Radius relative to the shape. Ranges 0-1.\n */\n\n/**\n * A rectangle.\n *\n * @typedef Highcharts.RectangleObject\n *\n * @property {number} height\n *           Height of the rectangle.\n *\n * @property {number} width\n *           Width of the rectangle.\n *\n * @property {number} x\n *           Horizontal position of the rectangle.\n *\n * @property {number} y\n *           Vertical position of the rectangle.\n */\n\n/**\n * The shadow options.\n *\n * @typedef Highcharts.ShadowOptionsObject\n *\n * @property {string} [color=#000000]\n *           The shadow color.\n *\n * @property {number} [offsetX=1]\n *           The horizontal offset from the element.\n *\n * @property {number} [offsetY=1]\n *           The vertical offset from the element.\n *\n * @property {number} [opacity=0.15]\n *           The shadow opacity.\n *\n * @property {number} [width=3]\n *           The shadow width or distance from the element.\n */\n\n/**\n * Serialized form of an SVG definition, including children. Some key\n * property names are reserved: tagName, textContent, and children.\n *\n * @typedef Highcharts.SVGDefinitionObject\n *\n * @property {number|string|Array<Highcharts.SVGDefinitionObject>|undefined} [key:string]\n *\n * @property {Array<Highcharts.SVGDefinitionObject>} [children]\n *\n * @property {string} [tagName]\n *\n * @property {string} [textContent]\n */\n\n/**\n * An extendable collection of functions for defining symbol paths.\n *\n * @typedef Highcharts.SymbolDictionary\n *\n * @property {Function} [key:Highcharts.SymbolKey]\n */\n\n/**\n * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n * `triangle`, `triangle-down`. Symbols are used internally for point\n * markers, button and label borders and backgrounds, or custom shapes.\n * Extendable by adding to {@link SVGRenderer#symbols}.\n *\n * @typedef {string} Highcharts.SymbolKey\n *\n * @validvalue [\"arc\", \"callout\", \"circle\", \"diamond\", \"square\", \"triangle\",\n *             \"triangle-down\"]\n */\n\n/**\n * Additional options, depending on the actual symbol drawn.\n *\n * @typedef Highcharts.SymbolOptionsObject\n *\n * @property {number} anchorX\n *           The anchor X position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} anchorY\n *           The anchor Y position for the `callout` symbol. This is where\n *           the chevron points to.\n *\n * @property {number} end\n *           The end angle of an `arc` symbol.\n *\n * @property {boolean} open\n *           Whether to draw `arc` symbol open or closed.\n *\n * @property {number} r\n *           The radius of an `arc` symbol, or the border radius for the\n *           `callout` symbol.\n *\n * @property {number} start\n *           The start angle of an `arc` symbol.\n */\n\n\n\n\n\n\n\nvar SVGElement,\n    SVGRenderer,\n\n    addEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent,\n    animate = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animate,\n    attr = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].attr,\n    charts = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    color = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color,\n    css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css,\n    createElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    deg2rad = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    doc = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    erase = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase,\n    grep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep,\n    hasTouch = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasTouch,\n    inArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray,\n    isArray = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray,\n    isFirefox = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFirefox,\n    isMS = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isMS,\n    isObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject,\n    isString = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString,\n    isWebKit = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isWebKit,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    objectEach = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    pInt = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt,\n    removeEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    stop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stop,\n    svg = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg,\n    SVG_NS = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVG_NS,\n    symbolSizes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].symbolSizes,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win;\n\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the {@link\n * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n * in the charts or even in HTML pages without instanciating a chart. The\n * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n * created with the `useHTML` parameter.\n *\n * The SVGElement instances are created through factory functions on the\n * {@link Highcharts.SVGRenderer} object, like\n * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n * Highcharts.SVGRenderer#g} and more.\n *\n * @class\n * @name Highcharts.SVGElement\n */\nSVGElement = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGElement = function () {\n    return this;\n};\nextend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {\n\n    // Default base for animation\n    opacity: 1,\n    SVG_NS: SVG_NS,\n\n    /**\n     * For labels, these CSS properties are applied to the `text` node directly.\n     *\n     * @private\n     * @name Highcharts.SVGElement#textProps\n     * @type {Array<string>}\n     */\n    textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',\n        'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',\n        'textDecoration', 'textOverflow', 'textOutline', 'cursor'],\n\n    /**\n     * Initialize the SVG element. This function only exists to make the\n     * initiation process overridable. It should not be called directly.\n     *\n     * @function Highcharts.SVGElement#init\n     *\n     * @param {Highcharts.SVGRenderer} renderer\n     *        The SVGRenderer instance to initialize to.\n     *\n     * @param {string} nodeName\n     *        The SVG node name.\n     */\n    init: function (renderer, nodeName) {\n\n        /**\n         * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n         * node, but may also represent more nodes.\n         *\n         * @name Highcharts.SVGElement#element\n         * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}\n         */\n        this.element = nodeName === 'span' ?\n            createElement(nodeName) :\n            doc.createElementNS(this.SVG_NS, nodeName);\n\n        /**\n         * The renderer that the SVGElement belongs to.\n         *\n         * @name Highcharts.SVGElement#renderer\n         * @type {Highcharts.SVGRenderer}\n         */\n        this.renderer = renderer;\n    },\n\n    /**\n     * Animate to given attributes or CSS properties.\n     *\n     * @sample highcharts/members/element-on/\n     *         Setting some attributes by animation\n     *\n     * @function Highcharts.SVGElement#animate\n     *\n     * @param {Highcharts.SVGAttributes} params\n     *        SVG attributes or CSS to animate.\n     *\n     * @param {Highcharts.AnimationOptionsObject} [options]\n     *        Animation options.\n     *\n     * @param {Function} [complete]\n     *        Function to perform at the end of animation.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    animate: function (params, options, complete) {\n        var animOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject(\n            pick(options, this.renderer.globalAnimation, true)\n        );\n        if (animOptions.duration !== 0) {\n            // allows using a callback with the global animation without\n            // overwriting it\n            if (complete) {\n                animOptions.complete = complete;\n            }\n            animate(this, params, animOptions);\n        } else {\n            this.attr(params, null, complete);\n            if (animOptions.step) {\n                animOptions.step.call(this);\n            }\n        }\n        return this;\n    },\n\n    /**\n     * Build and apply an SVG gradient out of a common JavaScript configuration\n     * object. This function is called from the attribute setters. An event\n     * hook is added for supporting other complex color types.\n     *\n     * @private\n     * @function Highcharts.SVGElement#complexColor\n     *\n     * @param {Highcharts.GradientColorObject} color\n     *        The gradient options structure.\n     *\n     * @param {string} prop\n     *        The property to apply, can either be `fill` or `stroke`.\n     *\n     * @param {Highcharts.SVGDOMElement} elem\n     *        SVG DOM element to apply the gradient on.\n     */\n    complexColor: function (color, prop, elem) {\n        var renderer = this.renderer,\n            colorObject,\n            gradName,\n            gradAttr,\n            radAttr,\n            gradients,\n            gradientObject,\n            stops,\n            stopColor,\n            stopOpacity,\n            radialReference,\n            id,\n            key = [],\n            value;\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent(this.renderer, 'complexColor', {\n            args: arguments\n        }, function () {\n            // Apply linear or radial gradients\n            if (color.radialGradient) {\n                gradName = 'radialGradient';\n            } else if (color.linearGradient) {\n                gradName = 'linearGradient';\n            }\n\n            if (gradName) {\n                gradAttr = color[gradName];\n                gradients = renderer.gradients;\n                stops = color.stops;\n                radialReference = elem.radialReference;\n\n                // Keep < 2.2 kompatibility\n                if (isArray(gradAttr)) {\n                    color[gradName] = gradAttr = {\n                        x1: gradAttr[0],\n                        y1: gradAttr[1],\n                        x2: gradAttr[2],\n                        y2: gradAttr[3],\n                        gradientUnits: 'userSpaceOnUse'\n                    };\n                }\n\n                // Correct the radial gradient for the radial reference system\n                if (\n                    gradName === 'radialGradient' &&\n                    radialReference &&\n                    !defined(gradAttr.gradientUnits)\n                ) {\n                    // Save the radial attributes for updating\n                    radAttr = gradAttr;\n                    gradAttr = merge(\n                        gradAttr,\n                        renderer.getRadialAttr(radialReference, radAttr),\n                        { gradientUnits: 'userSpaceOnUse' }\n                    );\n                }\n\n                // Build the unique key to detect whether we need to create a\n                // new element (#1282)\n                objectEach(gradAttr, function (val, n) {\n                    if (n !== 'id') {\n                        key.push(n, val);\n                    }\n                });\n                objectEach(stops, function (val) {\n                    key.push(val);\n                });\n                key = key.join(',');\n\n                // Check if a gradient object with the same config object is\n                // created within this renderer\n                if (gradients[key]) {\n                    id = gradients[key].attr('id');\n\n                } else {\n\n                    // Set the id and create the element\n                    gradAttr.id = id = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey();\n                    gradients[key] = gradientObject =\n                        renderer.createElement(gradName)\n                            .attr(gradAttr)\n                            .add(renderer.defs);\n\n                    gradientObject.radAttr = radAttr;\n\n                    // The gradient needs to keep a list of stops to be able to\n                    // destroy them\n                    gradientObject.stops = [];\n                    each(stops, function (stop) {\n                        var stopObject;\n                        if (stop[1].indexOf('rgba') === 0) {\n                            colorObject = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(stop[1]);\n                            stopColor = colorObject.get('rgb');\n                            stopOpacity = colorObject.get('a');\n                        } else {\n                            stopColor = stop[1];\n                            stopOpacity = 1;\n                        }\n                        stopObject = renderer.createElement('stop').attr({\n                            offset: stop[0],\n                            'stop-color': stopColor,\n                            'stop-opacity': stopOpacity\n                        }).add(gradientObject);\n\n                        // Add the stop element to the gradient\n                        gradientObject.stops.push(stopObject);\n                    });\n                }\n\n                // Set the reference to the gradient object\n                value = 'url(' + renderer.url + '#' + id + ')';\n                elem.setAttribute(prop, value);\n                elem.gradient = key;\n\n                // Allow the color to be concatenated into tooltips formatters\n                // etc. (#2995)\n                color.toString = function () {\n                    return value;\n                };\n            }\n        });\n    },\n\n    /**\n     * Apply a text outline through a custom CSS property, by copying the text\n     * element and apply stroke to the copy. Used internally. Contrast checks at\n     * {@link https://jsfiddle.net/highcharts/43soe9m1/2/}.\n     *\n     * @example\n     * // Specific color\n     * text.css({\n     *    textOutline: '1px black'\n     * });\n     * // Automatic contrast\n     * text.css({\n     *    color: '#000000', // black text\n     *    textOutline: '1px contrast' // => white outline\n     * });\n     *\n     * @private\n     * @function Highcharts.SVGElement#applyTextOutline\n     *\n     * @param {string} textOutline\n     *        A custom CSS `text-outline` setting, defined by `width color`.\n     */\n    applyTextOutline: function (textOutline) {\n        var elem = this.element,\n            tspans,\n            tspan,\n            hasContrast = textOutline.indexOf('contrast') !== -1,\n            styles = {},\n            color,\n            strokeWidth,\n            firstRealChild,\n            i;\n\n        // When the text shadow is set to contrast, use dark stroke for light\n        // text and vice versa.\n        if (hasContrast) {\n            styles.textOutline = textOutline = textOutline.replace(\n                /contrast/g,\n                this.renderer.getContrast(elem.style.fill)\n            );\n        }\n\n        // Extract the stroke width and color\n        textOutline = textOutline.split(' ');\n        color = textOutline[textOutline.length - 1];\n        strokeWidth = textOutline[0];\n\n        if (strokeWidth && strokeWidth !== 'none' && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg) {\n\n            this.fakeTS = true; // Fake text shadow\n\n            tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\n            // In order to get the right y position of the clone,\n            // copy over the y setter\n            this.ySetter = this.xSetter;\n\n            // Since the stroke is applied on center of the actual outline, we\n            // need to double it to get the correct stroke-width outside the\n            // glyphs.\n            strokeWidth = strokeWidth.replace(\n                /(^[\\d\\.]+)(.*?)$/g,\n                function (match, digit, unit) {\n                    return (2 * digit) + unit;\n                }\n            );\n\n            // Remove shadows from previous runs. Iterate from the end to\n            // support removing items inside the cycle (#6472).\n            i = tspans.length;\n            while (i--) {\n                tspan = tspans[i];\n                if (tspan.getAttribute('class') === 'highcharts-text-outline') {\n                    // Remove then erase\n                    erase(tspans, elem.removeChild(tspan));\n                }\n            }\n\n            // For each of the tspans, create a stroked copy behind it.\n            firstRealChild = elem.firstChild;\n            each(tspans, function (tspan, y) {\n                var clone;\n\n                // Let the first line start at the correct X position\n                if (y === 0) {\n                    tspan.setAttribute('x', elem.getAttribute('x'));\n                    y = elem.getAttribute('y');\n                    tspan.setAttribute('y', y || 0);\n                    if (y === null) {\n                        elem.setAttribute('y', 0);\n                    }\n                }\n\n                // Create the clone and apply outline properties\n                clone = tspan.cloneNode(1);\n                attr(clone, {\n                    'class': 'highcharts-text-outline',\n                    'fill': color,\n                    'stroke': color,\n                    'stroke-width': strokeWidth,\n                    'stroke-linejoin': 'round'\n                });\n                elem.insertBefore(clone, firstRealChild);\n            });\n        }\n    },\n\n    /**\n     * Apply native and custom attributes to the SVG elements.\n     *\n     * In order to set the rotation center for rotation, set x and y to 0 and\n     * use `translateX` and `translateY` attributes to position the element\n     * instead.\n     *\n     * Attributes frequently used in Highcharts are `fill`, `stroke`,\n     * `stroke-width`.\n     *\n     * @sample highcharts/members/renderer-rect/\n     *         Setting some attributes\n     *\n     * @example\n     * // Set multiple attributes\n     * element.attr({\n     *     stroke: 'red',\n     *     fill: 'blue',\n     *     x: 10,\n     *     y: 10\n     * });\n     *\n     * // Set a single attribute\n     * element.attr('stroke', 'red');\n     *\n     * // Get an attribute\n     * element.attr('stroke'); // => 'red'\n     *\n     * @function Highcharts.SVGElement#attr\n     *\n     * @param {string|Highcharts.SVGAttributes} [hash]\n     *        The native and custom SVG attributes.\n     *\n     * @param {string} [val]\n     *        If the type of the first argument is `string`, the second can be a\n     *        value, which will serve as a single attribute setter. If the first\n     *        argument is a string and the second is undefined, the function\n     *        serves as a getter and the current value of the property is\n     *        returned.\n     *\n     * @param {Function} [complete]\n     *        A callback function to execute after setting the attributes. This\n     *        makes the function compliant and interchangeable with the\n     *        {@link SVGElement#animate} function.\n     *\n     * @param {boolean} [continueAnimation=true]\n     *        Used internally when `.attr` is called as part of an animation\n     *        step. Otherwise, calling `.attr` for an attribute will stop\n     *        animation for that attribute.\n     *\n     * @return {number|string|Highcharts.SVGElement}\n     *         If used as a setter, it returns the current\n     *         {@link Highcharts.SVGElement} so the calls can be chained. If\n     *         used as a getter, the current value of the attribute is returned.\n     */\n    attr: function (hash, val, complete, continueAnimation) {\n        var key,\n            element = this.element,\n            hasSetSymbolSize,\n            ret = this,\n            skipAttr,\n            setter;\n\n        // single key-value pair\n        if (typeof hash === 'string' && val !== undefined) {\n            key = hash;\n            hash = {};\n            hash[key] = val;\n        }\n\n        // used as a getter: first argument is a string, second is undefined\n        if (typeof hash === 'string') {\n            ret = (this[hash + 'Getter'] || this._defaultGetter).call(\n                this,\n                hash,\n                element\n            );\n\n        // setter\n        } else {\n\n            objectEach(hash, function eachAttribute(val, key) {\n                skipAttr = false;\n\n                // Unless .attr is from the animator update, stop current\n                // running animation of this property\n                if (!continueAnimation) {\n                    stop(this, key);\n                }\n\n                // Special handling of symbol attributes\n                if (\n                    this.symbolName &&\n                    /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/\n                    .test(key)\n                ) {\n                    if (!hasSetSymbolSize) {\n                        this.symbolAttr(hash);\n                        hasSetSymbolSize = true;\n                    }\n                    skipAttr = true;\n                }\n\n                if (this.rotation && (key === 'x' || key === 'y')) {\n                    this.doTransform = true;\n                }\n\n                if (!skipAttr) {\n                    setter = this[key + 'Setter'] || this._defaultSetter;\n                    setter.call(this, val, key, element);\n\n                    \n                }\n            }, this);\n\n            this.afterSetters();\n        }\n\n        // In accordance with animate, run a complete callback\n        if (complete) {\n            complete.call(this);\n        }\n\n        return ret;\n    },\n\n    /**\n     * This method is executed in the end of `attr()`, after setting all\n     * attributes in the hash. In can be used to efficiently consolidate\n     * multiple attributes in one SVG property -- e.g., translate, rotate and\n     * scale are merged in one \"transform\" attribute in the SVG node.\n     *\n     * @private\n     * @function Highcharts.SVGElement#afterSetters\n     */\n    afterSetters: function () {\n        // Update transform. Do this outside the loop to prevent redundant\n        // updating for batch setting of attributes.\n        if (this.doTransform) {\n            this.updateTransform();\n            this.doTransform = false;\n        }\n    },\n\n    \n\n    /**\n     * Add a class name to an element.\n     *\n     * @function Highcharts.SVGElement#addClass\n     *\n     * @param {string} className\n     *        The new class name to add.\n     *\n     * @param {boolean} [replace=false]\n     *        When true, the existing class name(s) will be overwritten with\n     *        the new one. When false, the new one is added.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Return the SVG element for chainability.\n     */\n    addClass: function (className, replace) {\n        var currentClassName = this.attr('class') || '';\n        if (currentClassName.indexOf(className) === -1) {\n            if (!replace) {\n                className =\n                    (currentClassName + (currentClassName ? ' ' : '') +\n                    className).replace('  ', ' ');\n            }\n            this.attr('class', className);\n        }\n\n        return this;\n    },\n\n    /**\n     * Check if an element has the given class name.\n     *\n     * @function Highcharts.SVGElement#hasClass\n     *\n     * @param {string} className\n     *        The class name to check for.\n     *\n     * @return {boolean}\n     *         Whether the class name is found.\n     */\n    hasClass: function (className) {\n        return inArray(\n            className,\n            (this.attr('class') || '').split(' ')\n        ) !== -1;\n    },\n\n    /**\n     * Remove a class name from the element.\n     *\n     * @function Highcharts.SVGElement#removeClass\n     *\n     * @param {string|RegExp} className\n     *        The class name to remove.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n     */\n    removeClass: function (className) {\n        return this.attr(\n            'class',\n            (this.attr('class') || '').replace(className, '')\n        );\n    },\n\n    /**\n     * If one of the symbol size affecting parameters are changed,\n     * check all the others only once for each call to an element's\n     * .attr() method\n     *\n     * @private\n     * @function Highcharts.SVGElement#symbolAttr\n     *\n     * @param {Highcharts.Dictionary<number|string>} hash\n     *        The attributes to set.\n     */\n    symbolAttr: function (hash) {\n        var wrapper = this;\n\n        each([\n            'x',\n            'y',\n            'r',\n            'start',\n            'end',\n            'width',\n            'height',\n            'innerR',\n            'anchorX',\n            'anchorY'\n        ], function (key) {\n            wrapper[key] = pick(hash[key], wrapper[key]);\n        });\n\n        wrapper.attr({\n            d: wrapper.renderer.symbols[wrapper.symbolName](\n                wrapper.x,\n                wrapper.y,\n                wrapper.width,\n                wrapper.height,\n                wrapper\n            )\n        });\n    },\n\n    /**\n     * Apply a clipping rectangle to this element.\n     *\n     * @function Highcharts.SVGElement#clip\n     *\n     * @param {Highcharts.ClipRectElement} [clipRect]\n     *        The clipping rectangle. If skipped, the current clip is removed.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVG element to allow chaining.\n     */\n    clip: function (clipRect) {\n        return this.attr(\n            'clip-path',\n            clipRect ?\n                'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n                'none'\n        );\n    },\n\n    /**\n     * Calculate the coordinates needed for drawing a rectangle crisply and\n     * return the calculated attributes.\n     *\n     * @function Highcharts.SVGElement#crisp\n     *\n     * @param {Highcharts.RectangleObject} rect\n     *        Rectangle to crisp.\n     *\n     * @param {number} [strokeWidth]\n     *        The stroke width to consider when computing crisp positioning. It\n     *        can also be set directly on the rect parameter.\n     *\n     * @return {Highcharts.RectangleObject}\n     *         The modified rectangle arguments.\n     */\n    crisp: function (rect, strokeWidth) {\n\n        var wrapper = this,\n            normalizer;\n\n        strokeWidth = strokeWidth || rect.strokeWidth || 0;\n        // Math.round because strokeWidth can sometimes have roundoff errors\n        normalizer = Math.round(strokeWidth) % 2 / 2;\n\n        // normalize for crisp edges\n        rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n        rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n        rect.width = Math.floor(\n            (rect.width || wrapper.width || 0) - 2 * normalizer\n        );\n        rect.height = Math.floor(\n            (rect.height || wrapper.height || 0) - 2 * normalizer\n        );\n        if (defined(rect.strokeWidth)) {\n            rect.strokeWidth = strokeWidth;\n        }\n        return rect;\n    },\n\n    /**\n     * Set styles for the element. In addition to CSS styles supported by\n     * native SVG and HTML elements, there are also some custom made for\n     * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n     * elements.\n     *\n     * @sample highcharts/members/renderer-text-on-chart/\n     *         Styled text\n     *\n     * @function Highcharts.SVGElement#css\n     *\n     * @param {Highcharts.CSSObject} styles\n     *        The new CSS styles.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Return the SVG element for chaining.\n     */\n    css: function (styles) {\n        var oldStyles = this.styles,\n            newStyles = {},\n            elem = this.element,\n            textWidth,\n            serializedCss = '',\n            hyphenate,\n            hasNew = !oldStyles,\n            // These CSS properties are interpreted internally by the SVG\n            // renderer, but are not supported by SVG and should not be added to\n            // the DOM. In styled mode, no CSS should find its way to the DOM\n            // whatsoever (#6173, #6474).\n            svgPseudoProps = ['textOutline', 'textOverflow', 'width'];\n\n        // convert legacy\n        if (styles && styles.color) {\n            styles.fill = styles.color;\n        }\n\n        // Filter out existing styles to increase performance (#2640)\n        if (oldStyles) {\n            objectEach(styles, function (style, n) {\n                if (style !== oldStyles[n]) {\n                    newStyles[n] = style;\n                    hasNew = true;\n                }\n            });\n        }\n        if (hasNew) {\n\n            // Merge the new styles with the old ones\n            if (oldStyles) {\n                styles = extend(\n                    oldStyles,\n                    newStyles\n                );\n            }\n\n            // Get the text width from style\n            if (styles) {\n                // Previously set, unset it (#8234)\n                if (styles.width === null || styles.width === 'auto') {\n                    delete this.textWidth;\n\n                // Apply new\n                } else if (\n                    elem.nodeName.toLowerCase() === 'text' &&\n                    styles.width\n                ) {\n                    textWidth = this.textWidth = pInt(styles.width);\n                }\n            }\n\n            // store object\n            this.styles = styles;\n\n            if (textWidth && (!svg && this.renderer.forExport)) {\n                delete styles.width;\n            }\n\n            // Serialize and set style attribute\n            if (elem.namespaceURI === this.SVG_NS) { // #7633\n                hyphenate = function (a, b) {\n                    return '-' + b.toLowerCase();\n                };\n                objectEach(styles, function (style, n) {\n                    if (inArray(n, svgPseudoProps) === -1) {\n                        serializedCss +=\n                        n.replace(/([A-Z])/g, hyphenate) + ':' +\n                        style + ';';\n                    }\n                });\n                if (serializedCss) {\n                    attr(elem, 'style', serializedCss); // #1881\n                }\n            } else {\n                css(elem, styles);\n            }\n\n\n            if (this.added) {\n\n                // Rebuild text after added. Cache mechanisms in the buildText\n                // will prevent building if there are no significant changes.\n                if (this.element.nodeName === 'text') {\n                    this.renderer.buildText(this);\n                }\n\n                // Apply text outline after added\n                if (styles && styles.textOutline) {\n                    this.applyTextOutline(styles.textOutline);\n                }\n            }\n        }\n\n        return this;\n    },\n\n    \n    /**\n     * Get the computed style. Only in styled mode.\n     *\n     * @example\n     * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n     *\n     * @function Highcharts.SVGElement#getStyle\n     *\n     * @param {string} prop\n     *        The property name to check for.\n     *\n     * @return {string}\n     *         The current computed value.\n     */\n    getStyle: function (prop) {\n        return win.getComputedStyle(this.element || this, '')\n            .getPropertyValue(prop);\n    },\n\n    /**\n     * Get the computed stroke width in pixel values. This is used extensively\n     * when drawing shapes to ensure the shapes are rendered crisp and\n     * positioned correctly relative to each other. Using\n     * `shape-rendering: crispEdges` leaves us less control over positioning,\n     * for example when we want to stack columns next to each other, or position\n     * things pixel-perfectly within the plot box.\n     *\n     * The common pattern when placing a shape is:\n     * - Create the SVGElement and add it to the DOM. In styled mode, it will\n     *   now receive a stroke width from the style sheet. In classic mode we\n     *   will add the `stroke-width` attribute.\n     * - Read the computed `elem.strokeWidth()`.\n     * - Place it based on the stroke width.\n     *\n     * @function Highcharts.SVGElement#strokeWidth\n     *\n     * @return {number}\n     *         The stroke width in pixels. Even if the given stroke widtch (in\n     *         CSS or by attributes) is based on `em` or other units, the pixel\n     *         size is returned.\n     */\n    strokeWidth: function () {\n        var val = this.getStyle('stroke-width'),\n            ret,\n            dummy;\n\n        // Read pixel values directly\n        if (val.indexOf('px') === val.length - 2) {\n            ret = pInt(val);\n\n        // Other values like em, pt etc need to be measured\n        } else {\n            dummy = doc.createElementNS(SVG_NS, 'rect');\n            attr(dummy, {\n                'width': val,\n                'stroke-width': 0\n            });\n            this.element.parentNode.appendChild(dummy);\n            ret = dummy.getBBox().width;\n            dummy.parentNode.removeChild(dummy);\n        }\n        return ret;\n    },\n    \n    /**\n     * Add an event listener. This is a simple setter that replaces all other\n     * events of the same type, opposed to the {@link Highcharts#addEvent}\n     * function.\n     *\n     * @sample highcharts/members/element-on/\n     *         A clickable rectangle\n     *\n     * @function Highcharts.SVGElement#on\n     *\n     * @param {string} eventType\n     *        The event type. If the type is `click`, Highcharts will internally\n     *        translate it to a `touchstart` event on touch devices, to prevent\n     *        the browser from waiting for a click event from firing.\n     *\n     * @param {Function} handler\n     *        The handler callback.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The SVGElement for chaining.\n     */\n    on: function (eventType, handler) {\n        var svgElement = this,\n            element = svgElement.element;\n\n        // touch\n        if (hasTouch && eventType === 'click') {\n            element.ontouchstart = function (e) {\n                svgElement.touchEventFired = Date.now(); // #2269\n                e.preventDefault();\n                handler.call(element, e);\n            };\n            element.onclick = function (e) {\n                if (win.navigator.userAgent.indexOf('Android') === -1 ||\n                        Date.now() - (svgElement.touchEventFired || 0) > 1100) {\n                    handler.call(element, e);\n                }\n            };\n        } else {\n            // simplest possible event model for internal use\n            element['on' + eventType] = handler;\n        }\n        return this;\n    },\n\n    /**\n     * Set the coordinates needed to draw a consistent radial gradient across\n     * a shape regardless of positioning inside the chart. Used on pie slices\n     * to make all the slices have the same radial reference point.\n     *\n     * @function Highcharts.SVGElement#setRadialReference\n     *\n     * @param {Array<number>} coordinates\n     *        The center reference. The format is `[centerX, centerY, diameter]`\n     *        in pixels.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    setRadialReference: function (coordinates) {\n        var existingGradient = this.renderer.gradients[this.element.gradient];\n\n        this.element.radialReference = coordinates;\n\n        // On redrawing objects with an existing gradient, the gradient needs\n        // to be repositioned (#3801)\n        if (existingGradient && existingGradient.radAttr) {\n            existingGradient.animate(\n                this.renderer.getRadialAttr(\n                    coordinates,\n                    existingGradient.radAttr\n                )\n            );\n        }\n\n        return this;\n    },\n\n    /**\n     * Move an object and its children by x and y values.\n     *\n     * @function Highcharts.SVGElement#translate\n     *\n     * @param {number} x\n     *        The x value.\n     *\n     * @param {number} y\n     *        The y value.\n     */\n    translate: function (x, y) {\n        return this.attr({\n            translateX: x,\n            translateY: y\n        });\n    },\n\n    /**\n     * Invert a group, rotate and flip. This is used internally on inverted\n     * charts, where the points and graphs are drawn as if not inverted, then\n     * the series group elements are inverted.\n     *\n     * @function Highcharts.SVGElement#invert\n     *\n     * @param {boolean} inverted\n     *        Whether to invert or not. An inverted shape can be un-inverted by\n     *        setting it to false.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Return the SVGElement for chaining.\n     */\n    invert: function (inverted) {\n        var wrapper = this;\n        wrapper.inverted = inverted;\n        wrapper.updateTransform();\n        return wrapper;\n    },\n\n    /**\n     * Update the transform attribute based on internal properties. Deals with\n     * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n     * attributes and updates the SVG `transform` attribute.\n     *\n     * @private\n     * @function Highcharts.SVGElement#updateTransform\n     */\n    updateTransform: function () {\n        var wrapper = this,\n            translateX = wrapper.translateX || 0,\n            translateY = wrapper.translateY || 0,\n            scaleX = wrapper.scaleX,\n            scaleY = wrapper.scaleY,\n            inverted = wrapper.inverted,\n            rotation = wrapper.rotation,\n            matrix = wrapper.matrix,\n            element = wrapper.element,\n            transform;\n\n        // Flipping affects translate as adjustment for flipping around the\n        // group's axis\n        if (inverted) {\n            translateX += wrapper.width;\n            translateY += wrapper.height;\n        }\n\n        // Apply translate. Nearly all transformed elements have translation,\n        // so instead of checking for translate = 0, do it always (#1767,\n        // #1846).\n        transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n        // apply matrix\n        if (defined(matrix)) {\n            transform.push(\n                'matrix(' + matrix.join(',') + ')'\n            );\n        }\n\n        // apply rotation\n        if (inverted) {\n            transform.push('rotate(90) scale(-1,1)');\n        } else if (rotation) { // text rotation\n            transform.push(\n                'rotate(' + rotation + ' ' +\n                pick(this.rotationOriginX, element.getAttribute('x'), 0) +\n                ' ' +\n                pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')'\n            );\n        }\n\n        // apply scale\n        if (defined(scaleX) || defined(scaleY)) {\n            transform.push(\n                'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'\n            );\n        }\n\n        if (transform.length) {\n            element.setAttribute('transform', transform.join(' '));\n        }\n    },\n\n    /**\n     * Bring the element to the front. Alternatively, a new zIndex can be set.\n     *\n     * @sample highcharts/members/element-tofront/\n     *         Click an element to bring it to front\n     *\n     * @function Highcharts.SVGElement#toFront\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    toFront: function () {\n        var element = this.element;\n        element.parentNode.appendChild(element);\n        return this;\n    },\n\n\n    /**\n     * Align the element relative to the chart or another box.\n     *\n     * @function Highcharts.SVGElement#align\n     *\n     * @param {Highcharts.AlignObject} [alignOptions]\n     *        The alignment options. The function can be called without this\n     *        parameter in order to re-align an element after the box has been\n     *        updated.\n     *\n     * @param {boolean} [alignByTranslate]\n     *        Align element by translation.\n     *\n     * @param {string|Highcharts.BBoxObject} [box]\n     *        The box to align to, needs a width and height. When the box is a\n     *        string, it refers to an object in the Renderer. For example, when\n     *        box is `spacingBox`, it refers to `Renderer.spacingBox` which\n     *        holds `width`, `height`, `x` and `y` properties.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n     */\n    align: function (alignOptions, alignByTranslate, box) {\n        var align,\n            vAlign,\n            x,\n            y,\n            attribs = {},\n            alignTo,\n            renderer = this.renderer,\n            alignedObjects = renderer.alignedObjects,\n            alignFactor,\n            vAlignFactor;\n\n        // First call on instanciate\n        if (alignOptions) {\n            this.alignOptions = alignOptions;\n            this.alignByTranslate = alignByTranslate;\n            if (!box || isString(box)) {\n                this.alignTo = alignTo = box || 'renderer';\n                // prevent duplicates, like legendGroup after resize\n                erase(alignedObjects, this);\n                alignedObjects.push(this);\n                box = null; // reassign it below\n            }\n\n        // When called on resize, no arguments are supplied\n        } else {\n            alignOptions = this.alignOptions;\n            alignByTranslate = this.alignByTranslate;\n            alignTo = this.alignTo;\n        }\n\n        box = pick(box, renderer[alignTo], renderer);\n\n        // Assign variables\n        align = alignOptions.align;\n        vAlign = alignOptions.verticalAlign;\n        x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n        y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n        // Align\n        if (align === 'right') {\n            alignFactor = 1;\n        } else if (align === 'center') {\n            alignFactor = 2;\n        }\n        if (alignFactor) {\n            x += (box.width - (alignOptions.width || 0)) / alignFactor;\n        }\n        attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n        // Vertical align\n        if (vAlign === 'bottom') {\n            vAlignFactor = 1;\n        } else if (vAlign === 'middle') {\n            vAlignFactor = 2;\n        }\n        if (vAlignFactor) {\n            y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n        }\n        attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n        // Animate only if already placed\n        this[this.placed ? 'animate' : 'attr'](attribs);\n        this.placed = true;\n        this.alignAttr = attribs;\n\n        return this;\n    },\n\n    /**\n     * Get the bounding box (width, height, x and y) for the element. Generally\n     * used to get rendered text size. Since this is called a lot in charts,\n     * the results are cached based on text properties, in order to save DOM\n     * traffic. The returned bounding box includes the rotation, so for example\n     * a single text line of rotation 90 will report a greater height, and a\n     * width corresponding to the line-height.\n     *\n     * @sample highcharts/members/renderer-on-chart/\n     *         Draw a rectangle based on a text's bounding box\n     *\n     * @function Highcharts.SVGElement#getBBox\n     *\n     * @param {boolean} [reload]\n     *        Skip the cache and get the updated DOM bouding box.\n     *\n     * @param {number} [rot]\n     *        Override the element's rotation. This is internally used on axis\n     *        labels with a value of 0 to find out what the bounding box would\n     *        be have been if it were not rotated.\n     *\n     * @return {Highcharts.BBoxObject}\n     *         The bounding box with `x`, `y`, `width` and `height` properties.\n     */\n    getBBox: function (reload, rot) {\n        var wrapper = this,\n            bBox, // = wrapper.bBox,\n            renderer = wrapper.renderer,\n            width,\n            height,\n            rotation,\n            rad,\n            element = wrapper.element,\n            styles = wrapper.styles,\n            fontSize,\n            textStr = wrapper.textStr,\n            toggleTextShadowShim,\n            cache = renderer.cache,\n            cacheKeys = renderer.cacheKeys,\n            cacheKey;\n\n        rotation = pick(rot, wrapper.rotation);\n        rad = rotation * deg2rad;\n\n        \n        fontSize = element &&\n            SVGElement.prototype.getStyle.call(element, 'font-size');\n        \n\n        // Avoid undefined and null (#7316)\n        if (defined(textStr)) {\n\n            cacheKey = textStr.toString();\n\n            // Since numbers are monospaced, and numerical labels appear a lot\n            // in a chart, we assume that a label of n characters has the same\n            // bounding box as others of the same length. Unless there is inner\n            // HTML in the label. In that case, leave the numbers as is (#5899).\n            if (cacheKey.indexOf('<') === -1) {\n                cacheKey = cacheKey.replace(/[0-9]/g, '0');\n            }\n\n            // Properties that affect bounding box\n            cacheKey += [\n                '',\n                rotation || 0,\n                fontSize,\n                wrapper.textWidth, // #7874, also useHTML\n                styles && styles.textOverflow // #5968\n            ]\n            .join(',');\n\n        }\n\n        if (cacheKey && !reload) {\n            bBox = cache[cacheKey];\n        }\n\n        // No cache found\n        if (!bBox) {\n\n            // SVG elements\n            if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n                try { // Fails in Firefox if the container has display: none.\n\n                    // When the text shadow shim is used, we need to hide the\n                    // fake shadows to get the correct bounding box (#3872)\n                    toggleTextShadowShim = this.fakeTS && function (display) {\n                        each(\n                            element.querySelectorAll(\n                                '.highcharts-text-outline'\n                            ),\n                            function (tspan) {\n                                tspan.style.display = display;\n                            }\n                        );\n                    };\n\n                    // Workaround for #3842, Firefox reporting wrong bounding\n                    // box for shadows\n                    if (toggleTextShadowShim) {\n                        toggleTextShadowShim('none');\n                    }\n\n                    bBox = element.getBBox ?\n                        // SVG: use extend because IE9 is not allowed to change\n                        // width and height in case of rotation (below)\n                        extend({}, element.getBBox()) : {\n\n                            // Legacy IE in export mode\n                            width: element.offsetWidth,\n                            height: element.offsetHeight\n                        };\n\n                    // #3842\n                    if (toggleTextShadowShim) {\n                        toggleTextShadowShim('');\n                    }\n                } catch (e) {}\n\n                // If the bBox is not set, the try-catch block above failed. The\n                // other condition is for Opera that returns a width of\n                // -Infinity on hidden elements.\n                if (!bBox || bBox.width < 0) {\n                    bBox = { width: 0, height: 0 };\n                }\n\n\n            // VML Renderer or useHTML within SVG\n            } else {\n\n                bBox = wrapper.htmlGetBBox();\n\n            }\n\n            // True SVG elements as well as HTML elements in modern browsers\n            // using the .useHTML option need to compensated for rotation\n            if (renderer.isSVG) {\n                width = bBox.width;\n                height = bBox.height;\n\n                // Workaround for wrong bounding box in IE, Edge and Chrome on\n                // Windows. With Highcharts' default font, IE and Edge report\n                // a box height of 16.899 and Chrome rounds it to 17. If this\n                // stands uncorrected, it results in more padding added below\n                // the text than above when adding a label border or background.\n                // Also vertical positioning is affected.\n                // https://jsfiddle.net/highcharts/em37nvuj/\n                // (#1101, #1505, #1669, #2568, #6213).\n                if (\n                    styles &&\n                    styles.fontSize === '11px' &&\n                    Math.round(height) === 17\n                ) {\n                    bBox.height = height = 14;\n                }\n\n                // Adjust for rotated text\n                if (rotation) {\n                    bBox.width = Math.abs(height * Math.sin(rad)) +\n                        Math.abs(width * Math.cos(rad));\n                    bBox.height = Math.abs(height * Math.cos(rad)) +\n                        Math.abs(width * Math.sin(rad));\n                }\n            }\n\n            // Cache it. When loading a chart in a hidden iframe in Firefox and\n            // IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n            if (cacheKey && bBox.height > 0) {\n\n                // Rotate (#4681)\n                while (cacheKeys.length > 250) {\n                    delete cache[cacheKeys.shift()];\n                }\n\n                if (!cache[cacheKey]) {\n                    cacheKeys.push(cacheKey);\n                }\n                cache[cacheKey] = bBox;\n            }\n        }\n        return bBox;\n    },\n\n    /**\n     * Show the element after it has been hidden.\n     *\n     * @function Highcharts.SVGElement#show\n     *\n     * @param {boolean} [inherit=false]\n     *        Set the visibility attribute to `inherit` rather than `visible`.\n     *        The difference is that an element with `visibility=\"visible\"`\n     *        will be visible even if the parent is hidden.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    show: function (inherit) {\n        return this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n    },\n\n    /**\n     * Hide the element, equivalent to setting the `visibility` attribute to\n     * `hidden`.\n     *\n     * @function Highcharts.SVGElement#hide\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    hide: function () {\n        return this.attr({ visibility: 'hidden' });\n    },\n\n    /**\n     * Fade out an element by animating its opacity down to 0, and hide it on\n     * complete. Used internally for the tooltip.\n     *\n     * @function Highcharts.SVGElement#fadeOut\n     *\n     * @param {number} [duration=150]\n     *        The fade duration in milliseconds.\n     */\n    fadeOut: function (duration) {\n        var elemWrapper = this;\n        elemWrapper.animate({\n            opacity: 0\n        }, {\n            duration: duration || 150,\n            complete: function () {\n                // #3088, assuming we're only using this for tooltips\n                elemWrapper.attr({ y: -9999 });\n            }\n        });\n    },\n\n    /**\n     * Add the element to the DOM. All elements must be added this way.\n     *\n     * @sample highcharts/members/renderer-g\n     *         Elements added to a group\n     *\n     * @function Highcharts.SVGElement#add\n     *\n     * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [parent]\n     *        The parent item to add it to. If undefined, the element is added\n     *        to the {@link Highcharts.SVGRenderer.box}.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    add: function (parent) {\n\n        var renderer = this.renderer,\n            element = this.element,\n            inserted;\n\n        if (parent) {\n            this.parentGroup = parent;\n        }\n\n        // mark as inverted\n        this.parentInverted = parent && parent.inverted;\n\n        // build formatted text\n        if (this.textStr !== undefined) {\n            renderer.buildText(this);\n        }\n\n        // Mark as added\n        this.added = true;\n\n        // If we're adding to renderer root, or other elements in the group\n        // have a z index, we need to handle it\n        if (!parent || parent.handleZ || this.zIndex) {\n            inserted = this.zIndexSetter();\n        }\n\n        // If zIndex is not handled, append at the end\n        if (!inserted) {\n            (parent ? parent.element : renderer.box).appendChild(element);\n        }\n\n        // fire an event for internal hooks\n        if (this.onAdd) {\n            this.onAdd();\n        }\n\n        return this;\n    },\n\n    /**\n     * Removes an element from the DOM.\n     *\n     * @private\n     * @function Highcharts.SVGElement#safeRemoveChild\n     *\n     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n     *        The DOM node to remove.\n     */\n    safeRemoveChild: function (element) {\n        var parentNode = element.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(element);\n        }\n    },\n\n    /**\n     * Destroy the element and element wrapper and clear up the DOM and event\n     * hooks.\n     *\n     * @function Highcharts.SVGElement#destroy\n     */\n    destroy: function () {\n        var wrapper = this,\n            element = wrapper.element || {},\n            parentToClean =\n                wrapper.renderer.isSVG &&\n                element.nodeName === 'SPAN' &&\n                wrapper.parentGroup,\n            grandParent,\n            ownerSVGElement = element.ownerSVGElement,\n            i,\n            clipPath = wrapper.clipPath;\n\n        // remove events\n        element.onclick = element.onmouseout = element.onmouseover =\n            element.onmousemove = element.point = null;\n        stop(wrapper); // stop running animations\n\n        if (clipPath && ownerSVGElement) {\n            // Look for existing references to this clipPath and remove them\n            // before destroying the element (#6196).\n            each(\n                // The upper case version is for Edge\n                ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'),\n                function (el) {\n                    var clipPathAttr = el.getAttribute('clip-path'),\n                        clipPathId = clipPath.element.id;\n                    // Include the closing paranthesis in the test to rule out\n                    // id's from 10 and above (#6550). Edge puts quotes inside\n                    // the url, others not.\n                    if (\n                        clipPathAttr.indexOf('(#' + clipPathId + ')') > -1 ||\n                        clipPathAttr.indexOf('(\"#' + clipPathId + '\")') > -1\n                    ) {\n                        el.removeAttribute('clip-path');\n                    }\n                }\n            );\n            wrapper.clipPath = clipPath.destroy();\n        }\n\n        // Destroy stops in case this is a gradient object\n        if (wrapper.stops) {\n            for (i = 0; i < wrapper.stops.length; i++) {\n                wrapper.stops[i] = wrapper.stops[i].destroy();\n            }\n            wrapper.stops = null;\n        }\n\n        // remove element\n        wrapper.safeRemoveChild(element);\n\n        \n\n        // In case of useHTML, clean up empty containers emulating SVG groups\n        // (#1960, #2393, #2697).\n        while (\n            parentToClean &&\n            parentToClean.div &&\n            parentToClean.div.childNodes.length === 0\n        ) {\n            grandParent = parentToClean.parentGroup;\n            wrapper.safeRemoveChild(parentToClean.div);\n            delete parentToClean.div;\n            parentToClean = grandParent;\n        }\n\n        // remove from alignObjects\n        if (wrapper.alignTo) {\n            erase(wrapper.renderer.alignedObjects, wrapper);\n        }\n\n        objectEach(wrapper, function (val, key) {\n            delete wrapper[key];\n        });\n\n        return null;\n    },\n\n    \n\n    /**\n     * @private\n     * @function Highcharts.SVGElement#xGetter\n     *\n     * @param {string} key\n     *\n     * @return {number|string|null}\n     */\n    xGetter: function (key) {\n        if (this.element.nodeName === 'circle') {\n            if (key === 'x') {\n                key = 'cx';\n            } else if (key === 'y') {\n                key = 'cy';\n            }\n        }\n        return this._defaultGetter(key);\n    },\n\n    /**\n     * Get the current value of an attribute or pseudo attribute,\n     * used mainly for animation. Called internally from\n     * the {@link Highcharts.SVGRenderer#attr} function.\n     *\n     * @private\n     * @function Highcharts.SVGElement#_defaultGetter\n     *\n     * @param {string} key\n     *        Property key.\n     *\n     * @return {number|string|null}\n     *         Property value.\n     */\n    _defaultGetter: function (key) {\n        var ret = pick(\n            this[key + 'Value'], // align getter\n            this[key],\n            this.element ? this.element.getAttribute(key) : null,\n            0\n        );\n\n        if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n            ret = parseFloat(ret);\n        }\n        return ret;\n    },\n\n    /**\n     * @private\n     * @function Highcharts.SVGElement#dSettter\n     *\n     * @param {number|string|Highcharts.SVGPathArray} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    dSetter: function (value, key, element) {\n        if (value && value.join) { // join path\n            value = value.join(' ');\n        }\n        if (/(NaN| {2}|^$)/.test(value)) {\n            value = 'M 0 0';\n        }\n\n        // Check for cache before resetting. Resetting causes disturbance in the\n        // DOM, causing flickering in some cases in Edge/IE (#6747). Also\n        // possible performance gain.\n        if (this[key] !== value) {\n            element.setAttribute(key, value);\n            this[key] = value;\n        }\n\n    },\n\n    \n\n    /**\n     * @private\n     * @function Highcharts.SVGElement#alignSetter\n     *\n     * @param {\"start\"|\"middle\"|\"end\"} value\n     */\n    alignSetter: function (value) {\n        var convert = { left: 'start', center: 'middle', right: 'end' };\n        this.alignValue = value;\n        this.element.setAttribute('text-anchor', convert[value]);\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#opacitySetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    opacitySetter: function (value, key, element) {\n        this[key] = value;\n        element.setAttribute(key, value);\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#titleSetter\n     *\n     * @param {string} value\n     */\n    titleSetter: function (value) {\n        var titleNode = this.element.getElementsByTagName('title')[0];\n        if (!titleNode) {\n            titleNode = doc.createElementNS(this.SVG_NS, 'title');\n            this.element.appendChild(titleNode);\n        }\n\n        // Remove text content if it exists\n        if (titleNode.firstChild) {\n            titleNode.removeChild(titleNode.firstChild);\n        }\n\n        titleNode.appendChild(\n            doc.createTextNode(\n                // #3276, #3895\n                (String(pick(value), ''))\n                    .replace(/<[^>]*>/g, '')\n                    .replace(/&lt;/g, '<')\n                    .replace(/&gt;/g, '>')\n            )\n        );\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#textSetter\n     *\n     * @param {string} value\n     */\n    textSetter: function (value) {\n        if (value !== this.textStr) {\n            // Delete bBox memo when the text changes\n            delete this.bBox;\n\n            this.textStr = value;\n            if (this.added) {\n                this.renderer.buildText(this);\n            }\n        }\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#fillSetter\n     *\n     * @param {Highcharts.Color|Highcharts.ColorString} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    fillSetter: function (value, key, element) {\n        if (typeof value === 'string') {\n            element.setAttribute(key, value);\n        } else if (value) {\n            this.complexColor(value, key, element);\n        }\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#visibilitySetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    visibilitySetter: function (value, key, element) {\n        // IE9-11 doesn't handle visibilty:inherit well, so we remove the\n        // attribute instead (#2881, #3909)\n        if (value === 'inherit') {\n            element.removeAttribute(key);\n        } else if (this[key] !== value) { // #6747\n            element.setAttribute(key, value);\n        }\n        this[key] = value;\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#zIndexSetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @return {boolean}\n     */\n    zIndexSetter: function (value, key) {\n        var renderer = this.renderer,\n            parentGroup = this.parentGroup,\n            parentWrapper = parentGroup || renderer,\n            parentNode = parentWrapper.element || renderer.box,\n            childNodes,\n            otherElement,\n            otherZIndex,\n            element = this.element,\n            inserted,\n            undefinedOtherZIndex,\n            svgParent = parentNode === renderer.box,\n            run = this.added,\n            i;\n\n        if (defined(value)) {\n            // So we can read it for other elements in the group\n            element.setAttribute('data-z-index', value);\n\n            value = +value;\n            if (this[key] === value) { // Only update when needed (#3865)\n                run = false;\n            }\n        } else if (defined(this[key])) {\n            element.removeAttribute('data-z-index');\n        }\n\n        this[key] = value;\n\n        // Insert according to this and other elements' zIndex. Before .add() is\n        // called, nothing is done. Then on add, or by later calls to\n        // zIndexSetter, the node is placed on the right place in the DOM.\n        if (run) {\n            value = this.zIndex;\n\n            if (value && parentGroup) {\n                parentGroup.handleZ = true;\n            }\n\n            childNodes = parentNode.childNodes;\n            for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n                otherElement = childNodes[i];\n                otherZIndex = otherElement.getAttribute('data-z-index');\n                undefinedOtherZIndex = !defined(otherZIndex);\n\n                if (otherElement !== element) {\n                    if (\n                        // Negative zIndex versus no zIndex:\n                        // On all levels except the highest. If the parent is\n                        // <svg>, then we don't want to put items before <desc>\n                        // or <defs>\n                        (value < 0 && undefinedOtherZIndex && !svgParent && !i)\n                    ) {\n                        parentNode.insertBefore(element, childNodes[i]);\n                        inserted = true;\n                    } else if (\n                        // Insert after the first element with a lower zIndex\n                        pInt(otherZIndex) <= value ||\n                        // If negative zIndex, add this before first undefined\n                        // zIndex element\n                        (\n                            undefinedOtherZIndex &&\n                            (!defined(value) || value >= 0)\n                        )\n                    ) {\n                        parentNode.insertBefore(\n                            element,\n                            childNodes[i + 1] || null // null for oldIE export\n                        );\n                        inserted = true;\n                    }\n                }\n            }\n\n            if (!inserted) {\n                parentNode.insertBefore(\n                    element,\n                    childNodes[svgParent ? 3 : 0] || null // null for oldIE\n                );\n                inserted = true;\n            }\n        }\n        return inserted;\n    },\n    /**\n     * @private\n     * @function Highcharts.SVGElement#_defaultSetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    _defaultSetter: function (value, key, element) {\n        element.setAttribute(key, value);\n    }\n});\n\n// Some shared setters and getters\nSVGElement.prototype.yGetter =\nSVGElement.prototype.xGetter;\nSVGElement.prototype.translateXSetter =\nSVGElement.prototype.translateYSetter =\nSVGElement.prototype.rotationSetter =\nSVGElement.prototype.verticalAlignSetter =\nSVGElement.prototype.rotationOriginXSetter =\nSVGElement.prototype.rotationOriginYSetter =\nSVGElement.prototype.scaleXSetter =\nSVGElement.prototype.scaleYSetter =\nSVGElement.prototype.matrixSetter = function (value, key) {\n    this[key] = value;\n    this.doTransform = true;\n};\n\n\n\n/**\n * Allows direct access to the Highcharts rendering layer in order to draw\n * primitive shapes like circles, rectangles, paths or text directly on a chart,\n * or independent from any chart. The SVGRenderer represents a wrapper object\n * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`\n * module, it also brings vector graphics to IE <= 8.\n *\n * An existing chart's renderer can be accessed through {@link Chart.renderer}.\n * The renderer can also be used completely decoupled from a chart.\n *\n * @sample highcharts/members/renderer-on-chart\n *         Annotating a chart programmatically.\n * @sample highcharts/members/renderer-basic\n *         Independent SVG drawing.\n *\n * @example\n * // Use directly without a chart object.\n * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n *\n * @class\n * @name Highcharts.SVGRenderer\n *\n * @param {Highcharts.HTMLDOMElement} container\n *        Where to put the SVG in the web page.\n *\n * @param {number} width\n *        The width of the SVG.\n *\n * @param {number} height\n *        The height of the SVG.\n *\n * @param {boolean} [forExport=false]\n *        Whether the rendered content is intended for export.\n *\n * @param {boolean} [allowHTML=true]\n *        Whether the renderer is allowed to include HTML text, which will be\n *        projected on top of the SVG.\n */\nSVGRenderer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SVGRenderer = function () {\n    this.init.apply(this, arguments);\n};\nextend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {\n    /**\n     * A pointer to the renderer's associated Element class. The VMLRenderer\n     * will have a pointer to VMLElement here.\n     *\n     * @name Highcharts.SVGRenderer#Element\n     * @type {Highcharts.SVGElement}\n     */\n    Element: SVGElement,\n\n    SVG_NS: SVG_NS,\n\n    /**\n     * Initialize the SVGRenderer. Overridable initiator function that takes\n     * the same parameters as the constructor.\n     *\n     * @function Highcharts.SVGRenderer#init\n     *\n     * @param {Highcharts.HTMLDOMElement} container\n     *        Where to put the SVG in the web page.\n     *\n     * @param {number} width\n     *        The width of the SVG.\n     *\n     * @param {number} height\n     *        The height of the SVG.\n     *\n     * @param {boolean} [forExport=false]\n     *        Whether the rendered content is intended for export.\n     *\n     * @param {boolean} [allowHTML=true]\n     *        Whether the renderer is allowed to include HTML text, which will\n     *        be projected on top of the SVG.\n     */\n    init: function (container, width, height, style, forExport, allowHTML) {\n        var renderer = this,\n            boxWrapper,\n            element,\n            desc;\n\n        boxWrapper = renderer.createElement('svg')\n            .attr({\n                'version': '1.1',\n                'class': 'highcharts-root'\n            })\n            ;\n        element = boxWrapper.element;\n        container.appendChild(element);\n\n        // Always use ltr on the container, otherwise text-anchor will be\n        // flipped and text appear outside labels, buttons, tooltip etc (#3482)\n        attr(container, 'dir', 'ltr');\n\n        // For browsers other than IE, add the namespace attribute (#1978)\n        if (container.innerHTML.indexOf('xmlns') === -1) {\n            attr(element, 'xmlns', this.SVG_NS);\n        }\n\n        // object properties\n        renderer.isSVG = true;\n\n        /**\n         * The root `svg` node of the renderer.\n         *\n         * @name Highcharts.SVGRenderer#box\n         * @type {Highcharts.SVGDOMElement}\n         */\n        this.box = element;\n        /**\n         * The wrapper for the root `svg` node of the renderer.\n         *\n         * @name Highcharts.SVGRenderer#boxWrapper\n         * @type {Highcharts.SVGElement}\n         */\n        this.boxWrapper = boxWrapper;\n        renderer.alignedObjects = [];\n\n        /**\n         * Page url used for internal references.\n         *\n         * @private\n         * @name Highcharts.SVGRenderer#url\n         * @type {string}\n         */\n        // #24, #672, #1070\n        this.url = (\n                (isFirefox || isWebKit) &&\n                doc.getElementsByTagName('base').length\n            ) ?\n                win.location.href\n                    .split('#')[0] // remove the hash\n                    .replace(/<[^>]*>/g, '') // wing cut HTML\n                    // escape parantheses and quotes\n                    .replace(/([\\('\\)])/g, '\\\\$1')\n                    // replace spaces (needed for Safari only)\n                    .replace(/ /g, '%20') :\n                '';\n\n        // Add description\n        desc = this.createElement('desc').add();\n        desc.element.appendChild(\n            doc.createTextNode('Created with @product.name@ @product.version@')\n        );\n\n        /**\n         * A pointer to the `defs` node of the root SVG.\n         *\n         * @name Highcharts.SVGRenderer#defs\n         * @type {Highcharts.SVGElement}\n         */\n        renderer.defs = this.createElement('defs').add();\n        renderer.allowHTML = allowHTML;\n        renderer.forExport = forExport;\n        renderer.gradients = {}; // Object where gradient SvgElements are stored\n        renderer.cache = {}; // Cache for numerical bounding boxes\n        renderer.cacheKeys = [];\n        renderer.imgCount = 0;\n\n        renderer.setSize(width, height, false);\n\n\n\n        // Issue 110 workaround:\n        // In Firefox, if a div is positioned by percentage, its pixel position\n        // may land between pixels. The container itself doesn't display this,\n        // but an SVG element inside this container will be drawn at subpixel\n        // precision. In order to draw sharp lines, this must be compensated\n        // for. This doesn't seem to work inside iframes though (like in\n        // jsFiddle).\n        var subPixelFix, rect;\n        if (isFirefox && container.getBoundingClientRect) {\n            subPixelFix = function () {\n                css(container, { left: 0, top: 0 });\n                rect = container.getBoundingClientRect();\n                css(container, {\n                    left: (Math.ceil(rect.left) - rect.left) + 'px',\n                    top: (Math.ceil(rect.top) - rect.top) + 'px'\n                });\n            };\n\n            // run the fix now\n            subPixelFix();\n\n            // run it on resize\n            renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n        }\n    },\n\n    \n\n    /**\n     * General method for adding a definition to the SVG `defs` tag. Can be used\n     * for gradients, fills, filters etc. Styled mode only. A hook for adding\n     * general definitions to the SVG's defs tag. Definitions can be referenced\n     * from the CSS by its `id`. Read more in\n     * {@link https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns|gradients, shadows and patterns}.\n     * Styled mode only.\n     *\n     * @function Highcharts.SVGRenderer#definition\n     *\n     * @param {Highcharts.SVGDefinitionObject} def\n     *        A serialized form of an SVG definition, including children.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The inserted node.\n     */\n    definition: function (def) {\n        var ren = this;\n\n        function recurse(config, parent) {\n            var ret;\n            each(splat(config), function (item) {\n                var node = ren.createElement(item.tagName),\n                    attr = {};\n\n                // Set attributes\n                objectEach(item, function (val, key) {\n                    if (\n                        key !== 'tagName' &&\n                        key !== 'children' &&\n                        key !== 'textContent'\n                    ) {\n                        attr[key] = val;\n                    }\n                });\n                node.attr(attr);\n\n                // Add to the tree\n                node.add(parent || ren.defs);\n\n                // Add text content\n                if (item.textContent) {\n                    node.element.appendChild(\n                        doc.createTextNode(item.textContent)\n                    );\n                }\n\n                // Recurse\n                recurse(item.children || [], node);\n\n                ret = node;\n            });\n\n            // Return last node added (on top level it's the only one)\n            return ret;\n        }\n        return recurse(def);\n    },\n\n    \n\n    \n\n    /**\n     * Detect whether the renderer is hidden. This happens when one of the\n     * parent elements has `display: none`. Used internally to detect when we\n     * needto render preliminarily in another div to get the text bounding boxes\n     * right.\n     *\n     * @function Highcharts.SVGRenderer#isHidden\n     *\n     * @return {boolean}\n     *         True if it is hidden.\n     */\n    isHidden: function () { // #608\n        return !this.boxWrapper.getBBox().width;\n    },\n\n    /**\n     * Destroys the renderer and its allocated members.\n     *\n     * @function Highcharts.SVGRenderer#destroy\n     */\n    destroy: function () {\n        var renderer = this,\n            rendererDefs = renderer.defs;\n        renderer.box = null;\n        renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n        // Call destroy on all gradient elements\n        destroyObjectProperties(renderer.gradients || {});\n        renderer.gradients = null;\n\n        // Defs are null in VMLRenderer\n        // Otherwise, destroy them here.\n        if (rendererDefs) {\n            renderer.defs = rendererDefs.destroy();\n        }\n\n        // Remove sub pixel fix handler (#982)\n        if (renderer.unSubPixelFix) {\n            renderer.unSubPixelFix();\n        }\n\n        renderer.alignedObjects = null;\n\n        return null;\n    },\n\n    /**\n     * Create a wrapper for an SVG element. Serves as a factory for\n     * {@link SVGElement}, but this function is itself mostly called from\n     * primitive factories like {@link SVGRenderer#path}, {@link\n     * SVGRenderer#rect} or {@link SVGRenderer#text}.\n     *\n     * @function Highcharts.SVGRenderer#createElement\n     *\n     * @param {string} nodeName\n     *        The node name, for example `rect`, `g` etc.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated SVGElement.\n     */\n    createElement: function (nodeName) {\n        var wrapper = new this.Element();\n        wrapper.init(this, nodeName);\n        return wrapper;\n    },\n\n    /**\n     * Dummy function for plugins, called every time the renderer is updated.\n     * Prior to Highcharts 5, this was used for the canvg renderer.\n     *\n     * @deprecated\n     * @function Highcharts.SVGRenderer#draw\n     */\n    draw: noop,\n\n    /**\n     * Get converted radial gradient attributes according to the radial\n     * reference. Used internally from the {@link SVGElement#colorGradient}\n     * function.\n     *\n     * @private\n     * @function Highcharts.SVGRenderer#getRadialAttr\n     *\n     * @param {Array<number>} radialReference\n     *\n     * @param {Highcharts.SVGAttributes} gradAttr\n     *\n     * @return {Highcharts.SVGAttributes}\n     */\n    getRadialAttr: function (radialReference, gradAttr) {\n        return {\n            cx: (radialReference[0] - radialReference[2] / 2) +\n                gradAttr.cx * radialReference[2],\n            cy: (radialReference[1] - radialReference[2] / 2) +\n                gradAttr.cy * radialReference[2],\n            r: gradAttr.r * radialReference[2]\n        };\n    },\n\n    /**\n     * Truncate the text node contents to a given length. Used when the css\n     * width is set. If the `textOverflow` is `ellipsis`, the text is truncated\n     * character by character to the given length. If not, the text is\n     * word-wrapped line by line.\n     *\n     * @private\n     * @function Highcharts.SVGRenderer#truncate\n     *\n     * @param {Highcharts.SVGElement} wrapper\n     *\n     * @param {Highcharts.SVGDOMElement} tspan\n     *\n     * @param {string} text\n     *\n     * @param {Array.<string>} words\n     *\n     * @param {number} width\n     *\n     * @param {Function} getString\n     *\n     * @return {boolean}\n     *         True if tspan is too long.\n     */\n    truncate: function (\n        wrapper,\n        tspan,\n        text,\n        words,\n        startAt,\n        width,\n        getString\n    ) {\n        var renderer = this,\n            rotation = wrapper.rotation,\n            str,\n            // Word wrap can not be truncated to shorter than one word, ellipsis\n            // text can be completely blank.\n            minIndex = words ? 1 : 0,\n            maxIndex = (text || words).length,\n            currentIndex = maxIndex,\n            // Cache the lengths to avoid checking the same twice\n            lengths = [],\n            updateTSpan = function (s) {\n                if (tspan.firstChild) {\n                    tspan.removeChild(tspan.firstChild);\n                }\n                if (s) {\n                    tspan.appendChild(doc.createTextNode(s));\n                }\n            },\n            getSubStringLength = function (charEnd, concatenatedEnd) {\n                // charEnd is useed when finding the character-by-character\n                // break for ellipsis, concatenatedEnd is used for word-by-word\n                // break for word wrapping.\n                var end = concatenatedEnd || charEnd;\n                if (lengths[end] === undefined) {\n                    // Modern browsers\n                    if (tspan.getSubStringLength) {\n                        // Fails with DOM exception on unit-tests/legend/members\n                        // of unknown reason. Desired width is 0, text content\n                        // is \"5\" and end is 1.\n                        try {\n                            lengths[end] = startAt + tspan.getSubStringLength(\n                                0,\n                                words ? end + 1 : end\n                            );\n\n                        } catch (e) {}\n\n                    // Legacy\n                    } else {\n                        updateTSpan(getString(text || words, charEnd));\n                        lengths[end] = startAt +\n                            renderer.getSpanWidth(wrapper, tspan);\n                    }\n                }\n                return lengths[end];\n            },\n            actualWidth,\n            truncated;\n\n        wrapper.rotation = 0; // discard rotation when computing box\n        actualWidth = getSubStringLength(tspan.textContent.length);\n        truncated = startAt + actualWidth > width;\n        if (truncated) {\n\n            // Do a binary search for the index where to truncate the text\n            while (minIndex <= maxIndex) {\n                currentIndex = Math.ceil((minIndex + maxIndex) / 2);\n\n                // When checking words for word-wrap, we need to build the\n                // string and measure the subStringLength at the concatenated\n                // word length.\n                if (words) {\n                    str = getString(words, currentIndex);\n                }\n                actualWidth = getSubStringLength(\n                    currentIndex,\n                    str && str.length - 1\n                );\n\n                if (minIndex === maxIndex) {\n                    // Complete\n                    minIndex = maxIndex + 1;\n                } else if (actualWidth > width) {\n                    // Too large. Set max index to current.\n                    maxIndex = currentIndex - 1;\n                } else {\n                    // Within width. Set min index to current.\n                    minIndex = currentIndex;\n                }\n            }\n            // If max index was 0 it means the shortest possible text was also\n            // too large. For ellipsis that means only the ellipsis, while for\n            // word wrap it means the whole first word.\n            if (maxIndex === 0) {\n                // Remove ellipsis\n                updateTSpan('');\n\n            // If the new text length is one less than the original, we don't\n            // need the ellipsis\n            } else if (!(text && maxIndex === text.length - 1)) {\n                updateTSpan(str || getString(text || words, currentIndex));\n            }\n        }\n\n        // When doing line wrapping, prepare for the next line by removing the\n        // items from this line.\n        if (words) {\n            words.splice(0, currentIndex);\n        }\n\n        wrapper.actualWidth = actualWidth;\n        wrapper.rotation = rotation; // Apply rotation again.\n        return truncated;\n    },\n\n    /**\n     * A collection of characters mapped to HTML entities. When `useHTML` on an\n     * element is true, these entities will be rendered correctly by HTML. In\n     * the SVG pseudo-HTML, they need to be unescaped back to simple characters,\n     * so for example `&lt;` will render as `<`.\n     *\n     * @example\n     * // Add support for unescaping quotes\n     * Highcharts.SVGRenderer.prototype.escapes['\"'] = '&quot;';\n     *\n     * @name Highcharts.SVGRenderer#escapes\n     * @type {Highcharts.Dictionary<string>}\n     */\n    escapes: {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        \"'\": '&#39;', // eslint-disable-line quotes\n        '\"': '&quot;'\n    },\n\n    /**\n     * Parse a simple HTML string into SVG tspans. Called internally when text\n     * is set on an SVGElement. The function supports a subset of HTML tags, CSS\n     * text features like `width`, `text-overflow`, `white-space`, and also\n     * attributes like `href` and `style`.\n     *\n     * @private\n     * @function Highcharts.SVGRenderer#buildText\n     *\n     * @param {Highcharts.SVGElement} wrapper\n     *        The parent SVGElement.\n     */\n    buildText: function (wrapper) {\n        var textNode = wrapper.element,\n            renderer = this,\n            forExport = renderer.forExport,\n            textStr = pick(wrapper.textStr, '').toString(),\n            hasMarkup = textStr.indexOf('<') !== -1,\n            lines,\n            childNodes = textNode.childNodes,\n            truncated,\n            parentX = attr(textNode, 'x'),\n            textStyles = wrapper.styles,\n            width = wrapper.textWidth,\n            textLineHeight = textStyles && textStyles.lineHeight,\n            textOutline = textStyles && textStyles.textOutline,\n            ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n            noWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n            fontSize = textStyles && textStyles.fontSize,\n            textCache,\n            isSubsequentLine,\n            i = childNodes.length,\n            tempParent = width && !wrapper.added && this.box,\n            getLineHeight = function (tspan) {\n                var fontSizeStyle;\n                \n\n                return textLineHeight ?\n                    pInt(textLineHeight) :\n                    renderer.fontMetrics(\n                        fontSizeStyle,\n                        // Get the computed size from parent if not explicit\n                        tspan.getAttribute('style') ? tspan : textNode\n                    ).h;\n            },\n            unescapeEntities = function (inputStr, except) {\n                objectEach(renderer.escapes, function (value, key) {\n                    if (!except || inArray(value, except) === -1) {\n                        inputStr = inputStr.toString().replace(\n                            new RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp\n                            key\n                        );\n                    }\n                });\n                return inputStr;\n            },\n            parseAttribute = function (s, attr) {\n                var start,\n                    delimiter;\n\n                start = s.indexOf('<');\n                s = s.substring(start, s.indexOf('>') - start);\n\n                start = s.indexOf(attr + '=');\n                if (start !== -1) {\n                    start = start + attr.length + 1;\n                    delimiter = s.charAt(start);\n                    if (delimiter === '\"' || delimiter === \"'\") { // eslint-disable-line quotes\n                        s = s.substring(start + 1);\n                        return s.substring(0, s.indexOf(delimiter));\n                    }\n                }\n            };\n\n        // The buildText code is quite heavy, so if we're not changing something\n        // that affects the text, skip it (#6113).\n        textCache = [\n            textStr,\n            ellipsis,\n            noWrap,\n            textLineHeight,\n            textOutline,\n            fontSize,\n            width\n        ].join(',');\n        if (textCache === wrapper.textCache) {\n            return;\n        }\n        wrapper.textCache = textCache;\n\n        // Remove old text\n        while (i--) {\n            textNode.removeChild(childNodes[i]);\n        }\n\n        // Skip tspans, add text directly to text node. The forceTSpan is a hook\n        // used in text outline hack.\n        if (\n            !hasMarkup &&\n            !textOutline &&\n            !ellipsis &&\n            !width &&\n            textStr.indexOf(' ') === -1\n        ) {\n            textNode.appendChild(doc.createTextNode(unescapeEntities(textStr)));\n\n        // Complex strings, add more logic\n        } else {\n\n            if (tempParent) {\n                // attach it to the DOM to read offset width\n                tempParent.appendChild(textNode);\n            }\n\n            if (hasMarkup) {\n                lines = textStr\n                    \n                    .replace(\n                        /<(b|strong)>/g,\n                        '<span class=\"highcharts-strong\">'\n                    )\n                    .replace(\n                        /<(i|em)>/g,\n                        '<span class=\"highcharts-emphasized\">'\n                    )\n                    \n                    .replace(/<a/g, '<span')\n                    .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                    .split(/<br.*?>/g);\n\n            } else {\n                lines = [textStr];\n            }\n\n\n            // Trim empty lines (#5261)\n            lines = grep(lines, function (line) {\n                return line !== '';\n            });\n\n\n            // build the lines\n            each(lines, function buildTextLines(line, lineNo) {\n                var spans,\n                    spanNo = 0,\n                    lineLength = 0;\n                line = line\n                    // Trim to prevent useless/costly process on the spaces\n                    // (#5258)\n                    .replace(/^\\s+|\\s+$/g, '')\n                    .replace(/<span/g, '|||<span')\n                    .replace(/<\\/span>/g, '</span>|||');\n                spans = line.split('|||');\n\n                each(spans, function buildTextSpans(span) {\n                    if (span !== '' || spans.length === 1) {\n                        var attributes = {},\n                            tspan = doc.createElementNS(\n                                renderer.SVG_NS,\n                                'tspan'\n                            ),\n                            classAttribute,\n                            styleAttribute, // #390\n                            hrefAttribute;\n\n                        classAttribute = parseAttribute(span, 'class');\n                        if (classAttribute) {\n                            attr(tspan, 'class', classAttribute);\n                        }\n\n                        styleAttribute = parseAttribute(span, 'style');\n                        if (styleAttribute) {\n                            styleAttribute = styleAttribute.replace(\n                                /(;| |^)color([ :])/,\n                                '$1fill$2'\n                            );\n                            attr(tspan, 'style', styleAttribute);\n                        }\n\n                        // Not for export - #1529\n                        hrefAttribute = parseAttribute(span, 'href');\n                        if (hrefAttribute && !forExport) {\n                            attr(\n                                tspan,\n                                'onclick',\n                                'location.href=\\\"' + hrefAttribute + '\\\"'\n                            );\n                            attr(tspan, 'class', 'highcharts-anchor');\n                            \n                        }\n\n                        // Strip away unsupported HTML tags (#7126)\n                        span = unescapeEntities(\n                            span.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '') || ' '\n                        );\n\n                        // Nested tags aren't supported, and cause crash in\n                        // Safari (#1596)\n                        if (span !== ' ') {\n\n                            // add the text node\n                            tspan.appendChild(doc.createTextNode(span));\n\n                            // First span in a line, align it to the left\n                            if (!spanNo) {\n                                if (lineNo && parentX !== null) {\n                                    attributes.x = parentX;\n                                }\n                            } else {\n                                attributes.dx = 0; // #16\n                            }\n\n                            // add attributes\n                            attr(tspan, attributes);\n\n                            // Append it\n                            textNode.appendChild(tspan);\n\n                            // first span on subsequent line, add the line\n                            // height\n                            if (!spanNo && isSubsequentLine) {\n\n                                // allow getting the right offset height in\n                                // exporting in IE\n                                if (!svg && forExport) {\n                                    css(tspan, { display: 'block' });\n                                }\n\n                                // Set the line height based on the font size of\n                                // either the text element or the tspan element\n                                attr(\n                                    tspan,\n                                    'dy',\n                                    getLineHeight(tspan)\n                                );\n                            }\n\n                            // Check width and apply soft breaks or ellipsis\n                            if (width) {\n                                var words = span.replace(\n                                        /([^\\^])-/g,\n                                        '$1- '\n                                    ).split(' '), // #1273\n                                    hasWhiteSpace = !noWrap && (\n                                        spans.length > 1 ||\n                                        lineNo ||\n                                        words.length > 1\n                                    ),\n                                    wrapLineNo = 0,\n                                    dy = getLineHeight(tspan);\n\n                                if (ellipsis) {\n                                    truncated = renderer.truncate(\n                                        wrapper,\n                                        tspan,\n                                        span,\n                                        undefined,\n                                        0,\n                                        // Target width\n                                        Math.max(\n                                            0,\n                                            // Substract the font face to make\n                                            // room for the ellipsis itself\n                                            width - parseInt(fontSize || 12, 10)\n                                        ),\n                                        // Build the text to test for\n                                        function (text, currentIndex) {\n                                            return text.substring(\n                                                0,\n                                                currentIndex\n                                            ) + '\\u2026';\n                                        }\n                                    );\n                                } else if (hasWhiteSpace) {\n\n                                    while (words.length) {\n\n                                        // For subsequent lines, create tspans\n                                        // with the same style attributes as the\n                                        // parent text node.\n                                        if (\n                                            words.length &&\n                                            !noWrap &&\n                                            wrapLineNo > 0\n                                        ) {\n\n                                            tspan = doc.createElementNS(\n                                                SVG_NS,\n                                                'tspan'\n                                            );\n                                            attr(tspan, {\n                                                dy: dy,\n                                                x: parentX\n                                            });\n                                            if (styleAttribute) { // #390\n                                                attr(\n                                                    tspan,\n                                                    'style',\n                                                    styleAttribute\n                                                );\n                                            }\n                                            // Start by appending the full\n                                            // remaining text\n                                            tspan.appendChild(\n                                                doc.createTextNode(\n                                                    words.join(' ')\n                                                        .replace(/- /g, '-')\n                                                )\n                                            );\n                                            textNode.appendChild(tspan);\n                                        }\n\n                                        // For each line, truncate the remaining\n                                        // words into the line length.\n                                        renderer.truncate(\n                                            wrapper,\n                                            tspan,\n                                            null,\n                                            words,\n                                            wrapLineNo === 0 ? lineLength : 0,\n                                            width,\n                                            // Build the text to test for\n                                            function (text, currentIndex) {\n                                                return words\n                                                    .slice(0, currentIndex)\n                                                    .join(' ')\n                                                    .replace(/- /g, '-');\n                                            }\n                                        );\n\n                                        lineLength = wrapper.actualWidth;\n                                        wrapLineNo++;\n                                    }\n                                }\n                            }\n\n                            spanNo++;\n                        }\n\n                    }\n\n                });\n\n                // To avoid beginning lines that doesn't add to the textNode\n                // (#6144)\n                isSubsequentLine = (\n                    isSubsequentLine ||\n                    textNode.childNodes.length\n                );\n            });\n\n            if (ellipsis && truncated) {\n                wrapper.attr(\n                    'title',\n                    unescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179\n                );\n            }\n            if (tempParent) {\n                tempParent.removeChild(textNode);\n            }\n\n            // Apply the text outline\n            if (textOutline && wrapper.applyTextOutline) {\n                wrapper.applyTextOutline(textOutline);\n            }\n        }\n    },\n\n    /**\n     * Returns white for dark colors and black for bright colors.\n     *\n     * @function Highcharts.SVGRenderer#getContrast\n     *\n     * @param {Highcharts.ColorString} rgba\n     *        The color to get the contrast for.\n     *\n     * @return {string}\n     *         The contrast color, either `#000000` or `#FFFFFF`.\n     */\n    getContrast: function (rgba) {\n        rgba = color(rgba).rgba;\n\n        // The threshold may be discussed. Here's a proposal for adding\n        // different weight to the color channels (#6216)\n        rgba[0] *= 1; // red\n        rgba[1] *= 1.2; // green\n        rgba[2] *= 0.5; // blue\n\n        return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? '#000000' : '#FFFFFF';\n    },\n\n    /**\n     * Create a button with preset states.\n     *\n     * @function Highcharts.SVGRenderer#button\n     *\n     * @param {string} text\n     *        The text or HTML to draw.\n     *\n     * @param {number} x\n     *        The x position of the button's left side.\n     *\n     * @param {number} y\n     *        The y position of the button's top side.\n     *\n     * @param {Function} callback\n     *        The function to execute on button click or touch.\n     *\n     * @param {Highcharts.SVGAttributes} [normalState]\n     *        SVG attributes for the normal state.\n     *\n     * @param {Highcharts.SVGAttributes} [hoverState]\n     *        SVG attributes for the hover state.\n     *\n     * @param {Highcharts.SVGAttributes} [pressedState]\n     *        SVG attributes for the pressed state.\n     *\n     * @param {Highcharts.SVGAttributes} [disabledState]\n     *        SVG attributes for the disabled state.\n     *\n     * @param {Highcharts.SymbolKey} [shape=rect]\n     *        The shape type.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The button element.\n     */\n    button: function (\n        text,\n        x,\n        y,\n        callback,\n        normalState,\n        hoverState,\n        pressedState,\n        disabledState,\n        shape\n    ) {\n        var label = this.label(\n                text,\n                x,\n                y,\n                shape,\n                null,\n                null,\n                null,\n                null,\n                'button'\n            ),\n            curState = 0;\n\n        // Default, non-stylable attributes\n        label.attr(merge({\n            'padding': 8,\n            'r': 2\n        }, normalState));\n\n        \n\n        // Add the events. IE9 and IE10 need mouseover and mouseout to funciton\n        // (#667).\n        addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n            if (curState !== 3) {\n                label.setState(1);\n            }\n        });\n        addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n            if (curState !== 3) {\n                label.setState(curState);\n            }\n        });\n\n        label.setState = function (state) {\n            // Hover state is temporary, don't record it\n            if (state !== 1) {\n                label.state = curState = state;\n            }\n            // Update visuals\n            label.removeClass(\n                    /highcharts-button-(normal|hover|pressed|disabled)/\n                )\n                .addClass(\n                    'highcharts-button-' +\n                    ['normal', 'hover', 'pressed', 'disabled'][state || 0]\n                );\n\n            \n        };\n\n\n        \n\n        return label\n            .on('click', function (e) {\n                if (curState !== 3) {\n                    callback.call(label, e);\n                }\n            });\n    },\n\n    /**\n     * Make a straight line crisper by not spilling out to neighbour pixels.\n     *\n     * @function Highcharts.SVGRenderer#crispLine\n     *\n     * @param {Highcharts.SVGPathArray} points\n     *        The original points on the format `['M', 0, 0, 'L', 100, 0]`.\n     *\n     * @param {number} width\n     *        The width of the line.\n     *\n     * @return {Highcharts.SVGPathArray}\n     *         The original points array, but modified to render crisply.\n     */\n    crispLine: function (points, width) {\n        // normalize to a crisp line\n        if (points[1] === points[4]) {\n            // Substract due to #1129. Now bottom and left axis gridlines behave\n            // the same.\n            points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n        }\n        if (points[2] === points[5]) {\n            points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n        }\n        return points;\n    },\n\n\n    /**\n     * Draw a path, wraps the SVG `path` element.\n     *\n     * @sample highcharts/members/renderer-path-on-chart/\n     *         Draw a path in a chart\n     * @sample highcharts/members/renderer-path/\n     *         Draw a path independent from a chart\n     *\n     * @example\n     * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n     *     .attr({ stroke: '#ff00ff' })\n     *     .add();\n     *\n     * @function Highcharts.SVGRenderer#path\n     *\n     * @param {Highcharts.SVGPathArray} [path]\n     *        An SVG path definition in array form.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     *\n     *//**\n     * Draw a path, wraps the SVG `path` element.\n     *\n     * @function Highcharts.SVGRenderer#path\n     *\n     * @param {Highcharts.SVGAttributes} [attribs]\n     *        The initial attributes.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    path: function (path) {\n        var attribs = {\n            \n        };\n        if (isArray(path)) {\n            attribs.d = path;\n        } else if (isObject(path)) { // attributes\n            extend(attribs, path);\n        }\n        return this.createElement('path').attr(attribs);\n    },\n\n    /**\n     * Draw a circle, wraps the SVG `circle` element.\n     *\n     * @sample highcharts/members/renderer-circle/\n     *         Drawing a circle\n     *\n     * @function Highcharts.SVGRenderer#circle\n     *\n     * @param {number} [x]\n     *        The center x position.\n     *\n     * @param {number} [y]\n     *        The center y position.\n     *\n     * @param {number} [r]\n     *        The radius.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     *//**\n     * Draw a circle, wraps the SVG `circle` element.\n     *\n     * @function Highcharts.SVGRenderer#circle\n     *\n     * @param {Highcharts.SVGAttributes} [attribs]\n     *        The initial attributes.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    circle: function (x, y, r) {\n        var attribs = isObject(x) ? x : { x: x, y: y, r: r },\n            wrapper = this.createElement('circle');\n\n        // Setting x or y translates to cx and cy\n        wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n            element.setAttribute('c' + key, value);\n        };\n\n        return wrapper.attr(attribs);\n    },\n\n    /**\n     * Draw and return an arc.\n     *\n     * @sample highcharts/members/renderer-arc/\n     *         Drawing an arc\n     *\n     * @function Highcharts.SVGRenderer#arc\n     *\n     * @param {number} [x=0]\n     *        Center X position.\n     *\n     * @param {number} [y=0]\n     *        Center Y position.\n     *\n     * @param {number} [r=0]\n     *        The outer radius of the arc.\n     *\n     * @param {number} [innerR=0]\n     *        Inner radius like used in donut charts.\n     *\n     * @param {number} [start=0]\n     *        The starting angle of the arc in radians, where 0 is to the right\n     *         and `-Math.PI/2` is up.\n     *\n     * @param {number} [end=0]\n     *        The ending angle of the arc in radians, where 0 is to the right\n     *        and `-Math.PI/2` is up.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     *//**\n     * Draw and return an arc. Overloaded function that takes arguments object.\n     *\n     * @function Highcharts.SVGRenderer#arc\n     *\n     * @param {Highcharts.SVGAttributes} attribs\n     *        Initial SVG attributes.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    arc: function (x, y, r, innerR, start, end) {\n        var arc,\n            options;\n\n        if (isObject(x)) {\n            options = x;\n            y = options.y;\n            r = options.r;\n            innerR = options.innerR;\n            start = options.start;\n            end = options.end;\n            x = options.x;\n        } else {\n            options = {\n                innerR: innerR,\n                start: start,\n                end: end\n            };\n        }\n\n        // Arcs are defined as symbols for the ability to set\n        // attributes in attr and animate\n        arc = this.symbol('arc', x, y, r, r, options);\n        arc.r = r; // #959\n        return arc;\n    },\n\n    /**\n     * Draw and return a rectangle.\n     *\n     * @function Highcharts.SVGRenderer#rect\n     *\n     * @param {number} [x]\n     *        Left position.\n     *\n     * @param {number} [y]\n     *        Top position.\n     *\n     * @param {number} [width]\n     *        Width of the rectangle.\n     *\n     * @param {number} [height]\n     *        Height of the rectangle.\n     *\n     * @param {number} [r]\n     *        Border corner radius.\n     *\n     * @param {number} [strokeWidth]\n     *        A stroke width can be supplied to allow crisp drawing.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     *//**\n     * Draw and return a rectangle.\n     *\n     * @sample highcharts/members/renderer-rect-on-chart/\n     *         Draw a rectangle in a chart\n     * @sample highcharts/members/renderer-rect/\n     *         Draw a rectangle independent from a chart\n     *\n     * @function Highcharts.SVGRenderer#rect\n     *\n     * @param {Highcharts.SVGAttributes} [attributes]\n     *        General SVG attributes for the rectangle.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    rect: function (x, y, width, height, r, strokeWidth) {\n\n        r = isObject(x) ? x.r : r;\n\n        var wrapper = this.createElement('rect'),\n            attribs = isObject(x) ? x : x === undefined ? {} : {\n                x: x,\n                y: y,\n                width: Math.max(width, 0),\n                height: Math.max(height, 0)\n            };\n\n        \n\n        if (r) {\n            attribs.r = r;\n        }\n\n        wrapper.rSetter = function (value, key, element) {\n            attr(element, {\n                rx: value,\n                ry: value\n            });\n        };\n\n        return wrapper.attr(attribs);\n    },\n\n    /**\n     * Resize the {@link SVGRenderer#box} and re-align all aligned child\n     * elements.\n     *\n     * @sample highcharts/members/renderer-g/\n     *         Show and hide grouped objects\n     *\n     * @function Highcharts.SVGRenderer#setSize\n     *\n     * @param {number} width\n     *        The new pixel width.\n     *\n     * @param {number} height\n     *        The new pixel height.\n     *\n     * @param {boolean|Highcharts.AnimationOptionsObject} [animate=true]\n     *        Whether and how to animate.\n     */\n    setSize: function (width, height, animate) {\n        var renderer = this,\n            alignedObjects = renderer.alignedObjects,\n            i = alignedObjects.length;\n\n        renderer.width = width;\n        renderer.height = height;\n\n        renderer.boxWrapper.animate({\n            width: width,\n            height: height\n        }, {\n            step: function () {\n                this.attr({\n                    viewBox: '0 0 ' + this.attr('width') + ' ' +\n                        this.attr('height')\n                });\n            },\n            duration: pick(animate, true) ? undefined : 0\n        });\n\n        while (i--) {\n            alignedObjects[i].align();\n        }\n    },\n\n    /**\n     * Create and return an svg group element. Child\n     * {@link Highcharts.SVGElement} objects are added to the group by using the\n     * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.\n     *\n     * @function Highcharts.SVGRenderer#g\n     *\n     * @param {string} [name]\n     *        The group will be given a class name of `highcharts-{name}`. This\n     *        can be used for styling and scripting.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    g: function (name) {\n        var elem = this.createElement('g');\n        return name ? elem.attr({ 'class': 'highcharts-' + name }) : elem;\n    },\n\n    /**\n     * Display an image.\n     *\n     * @sample highcharts/members/renderer-image-on-chart/\n     *         Add an image in a chart\n     * @sample highcharts/members/renderer-image/\n     *         Add an image independent of a chart\n     *\n     * @function Highcharts.SVGRenderer#image\n     *\n     * @param {string} src\n     *        The image source.\n     *\n     * @param {number} [x]\n     *        The X position.\n     *\n     * @param {number} [y]\n     *        The Y position.\n     *\n     * @param {number} [width]\n     *        The image width. If omitted, it defaults to the image file width.\n     *\n     * @param {number} [height]\n     *        The image height. If omitted it defaults to the image file\n     *        height.\n     *\n     * @param {Function} [onload]\n     *        Event handler for image load.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated wrapper element.\n     */\n    image: function (src, x, y, width, height, onload) {\n        var attribs = {\n                preserveAspectRatio: 'none'\n            },\n            elemWrapper,\n            dummy,\n            setSVGImageSource = function (el, src) {\n                // Set the href in the xlink namespace\n                if (el.setAttributeNS) {\n                    el.setAttributeNS(\n                        'http://www.w3.org/1999/xlink', 'href', src\n                    );\n                } else {\n                    // could be exporting in IE\n                    // using href throws \"not supported\" in ie7 and under,\n                    // requries regex shim to fix later\n                    el.setAttribute('hc-svg-href', src);\n                }\n            },\n            onDummyLoad = function (e) {\n                setSVGImageSource(elemWrapper.element, src);\n                onload.call(elemWrapper, e);\n            };\n\n        // optional properties\n        if (arguments.length > 1) {\n            extend(attribs, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n\n        elemWrapper = this.createElement('image').attr(attribs);\n\n        // Add load event if supplied\n        if (onload) {\n            // We have to use a dummy HTML image since IE support for SVG image\n            // load events is very buggy. First set a transparent src, wait for\n            // dummy to load, and then add the real src to the SVG image.\n            setSVGImageSource(\n                elemWrapper.element,\n                'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==' /* eslint-disable-line */\n            );\n            dummy = new win.Image();\n            addEvent(dummy, 'load', onDummyLoad);\n            dummy.src = src;\n            if (dummy.complete) {\n                onDummyLoad({});\n            }\n        } else {\n            setSVGImageSource(elemWrapper.element, src);\n        }\n\n        return elemWrapper;\n    },\n\n    /**\n     * Draw a symbol out of pre-defined shape paths from\n     * {@link SVGRenderer#symbols}.\n     * It is used in Highcharts for point makers, which cake a `symbol` option,\n     * and label and button backgrounds like in the tooltip and stock flags.\n     *\n     * @function Highcharts.SVGRenderer#symbol\n     *\n     * @param {symbol} symbol\n     *        The symbol name.\n     *\n     * @param {number} x\n     *        The X coordinate for the top left position.\n     *\n     * @param {number} y\n     *        The Y coordinate for the top left position.\n     *\n     * @param {number} width\n     *        The pixel width.\n     *\n     * @param {number} height\n     *        The pixel height.\n     *\n     * @param {Highcharts.SymbolOptionsObject} [options]\n     *        Additional options, depending on the actual symbol drawn.\n     *\n     * @return {Highcharts.SVGElement}\n     */\n    symbol: function (symbol, x, y, width, height, options) {\n\n        var ren = this,\n            obj,\n            imageRegex = /^url\\((.*?)\\)$/,\n            isImage = imageRegex.test(symbol),\n            sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n\n\n            // get the symbol definition function\n            symbolFn = sym && this.symbols[sym],\n\n            // check if there's a path defined for this symbol\n            path = defined(x) && symbolFn && symbolFn.call(\n                this.symbols,\n                Math.round(x),\n                Math.round(y),\n                width,\n                height,\n                options\n            ),\n            imageSrc,\n            centerImage;\n\n        if (symbolFn) {\n            obj = this.path(path);\n\n            \n\n            // expando properties for use in animate and attr\n            extend(obj, {\n                symbolName: sym,\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n            if (options) {\n                extend(obj, options);\n            }\n\n\n        // Image symbols\n        } else if (isImage) {\n\n\n            imageSrc = symbol.match(imageRegex)[1];\n\n            // Create the image synchronously, add attribs async\n            obj = this.image(imageSrc);\n\n            // The image width is not always the same as the symbol width. The\n            // image may be centered within the symbol, as is the case when\n            // image shapes are used as label backgrounds, for example in flags.\n            obj.imgwidth = pick(\n                symbolSizes[imageSrc] && symbolSizes[imageSrc].width,\n                options && options.width\n            );\n            obj.imgheight = pick(\n                symbolSizes[imageSrc] && symbolSizes[imageSrc].height,\n                options && options.height\n            );\n            /**\n             * Set the size and position\n             */\n            centerImage = function () {\n                obj.attr({\n                    width: obj.width,\n                    height: obj.height\n                });\n            };\n\n            /**\n             * Width and height setters that take both the image's physical size\n             * and the label size into consideration, and translates the image\n             * to center within the label.\n             */\n            each(['width', 'height'], function (key) {\n                obj[key + 'Setter'] = function (value, key) {\n                    var attribs = {},\n                        imgSize = this['img' + key],\n                        trans = key === 'width' ? 'translateX' : 'translateY';\n                    this[key] = value;\n                    if (defined(imgSize)) {\n                        if (this.element) {\n                            this.element.setAttribute(key, imgSize);\n                        }\n                        if (!this.alignByTranslate) {\n                            attribs[trans] = ((this[key] || 0) - imgSize) / 2;\n                            this.attr(attribs);\n                        }\n                    }\n                };\n            });\n\n\n            if (defined(x)) {\n                obj.attr({\n                    x: x,\n                    y: y\n                });\n            }\n            obj.isImg = true;\n\n            if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n                centerImage();\n            } else {\n                // Initialize image to be 0 size so export will still function\n                // if there's no cached sizes.\n                obj.attr({ width: 0, height: 0 });\n\n                // Create a dummy JavaScript image to get the width and height.\n                createElement('img', {\n                    onload: function () {\n\n                        var chart = charts[ren.chartIndex];\n\n                        // Special case for SVGs on IE11, the width is not\n                        // accessible until the image is part of the DOM\n                        // (#2854).\n                        if (this.width === 0) {\n                            css(this, {\n                                position: 'absolute',\n                                top: '-999em'\n                            });\n                            doc.body.appendChild(this);\n                        }\n\n                        // Center the image\n                        symbolSizes[imageSrc] = { // Cache for next\n                            width: this.width,\n                            height: this.height\n                        };\n                        obj.imgwidth = this.width;\n                        obj.imgheight = this.height;\n\n                        if (obj.element) {\n                            centerImage();\n                        }\n\n                        // Clean up after #2854 workaround.\n                        if (this.parentNode) {\n                            this.parentNode.removeChild(this);\n                        }\n\n                        // Fire the load event when all external images are\n                        // loaded\n                        ren.imgCount--;\n                        if (!ren.imgCount && chart && chart.onload) {\n                            chart.onload();\n                        }\n                    },\n                    src: imageSrc\n                });\n                this.imgCount++;\n            }\n        }\n\n        return obj;\n    },\n\n    /**\n     * An extendable collection of functions for defining symbol paths.\n     *\n     * @name Highcharts.SVGRenderer#symbols\n     * @type {Highcharts.SymbolDictionary}\n     */\n    symbols: {\n        'circle': function (x, y, w, h) {\n            // Return a full arc\n            return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n                start: 0,\n                end: Math.PI * 2,\n                open: false\n            });\n        },\n\n        'square': function (x, y, w, h) {\n            return [\n                'M', x, y,\n                'L', x + w, y,\n                x + w, y + h,\n                x, y + h,\n                'Z'\n            ];\n        },\n\n        'triangle': function (x, y, w, h) {\n            return [\n                'M', x + w / 2, y,\n                'L', x + w, y + h,\n                x, y + h,\n                'Z'\n            ];\n        },\n\n        'triangle-down': function (x, y, w, h) {\n            return [\n                'M', x, y,\n                'L', x + w, y,\n                x + w / 2, y + h,\n                'Z'\n            ];\n        },\n        'diamond': function (x, y, w, h) {\n            return [\n                'M', x + w / 2, y,\n                'L', x + w, y + h / 2,\n                x + w / 2, y + h,\n                x, y + h / 2,\n                'Z'\n            ];\n        },\n        'arc': function (x, y, w, h, options) {\n            var start = options.start,\n                rx = options.r || w,\n                ry = options.r || h || w,\n                proximity = 0.001,\n                fullCircle =\n                    Math.abs(options.end - options.start - 2 * Math.PI) <\n                    proximity,\n                // Substract a small number to prevent cos and sin of start and\n                // end from becoming equal on 360 arcs (related: #1561)\n                end = options.end - proximity,\n                innerRadius = options.innerR,\n                open = pick(options.open, fullCircle),\n                cosStart = Math.cos(start),\n                sinStart = Math.sin(start),\n                cosEnd = Math.cos(end),\n                sinEnd = Math.sin(end),\n                // Proximity takes care of rounding errors around PI (#6971)\n                longArc = options.end - start - Math.PI < proximity ? 0 : 1,\n                arc;\n\n            arc = [\n                'M',\n                x + rx * cosStart,\n                y + ry * sinStart,\n                'A', // arcTo\n                rx, // x radius\n                ry, // y radius\n                0, // slanting\n                longArc, // long or short arc\n                1, // clockwise\n                x + rx * cosEnd,\n                y + ry * sinEnd\n            ];\n\n            if (defined(innerRadius)) {\n                arc.push(\n                    open ? 'M' : 'L',\n                    x + innerRadius * cosEnd,\n                    y + innerRadius * sinEnd,\n                    'A', // arcTo\n                    innerRadius, // x radius\n                    innerRadius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    0, // clockwise\n                    x + innerRadius * cosStart,\n                    y + innerRadius * sinStart\n                );\n            }\n\n            arc.push(open ? '' : 'Z'); // close\n            return arc;\n        },\n\n        /**\n         * Callout shape used for default tooltips, also used for rounded\n         * rectangles in VML\n         */\n        'callout': function (x, y, w, h, options) {\n            var arrowLength = 6,\n                halfDistance = 6,\n                r = Math.min((options && options.r) || 0, w, h),\n                safeDistance = r + halfDistance,\n                anchorX = options && options.anchorX,\n                anchorY = options && options.anchorY,\n                path;\n\n            path = [\n                'M', x + r, y,\n                'L', x + w - r, y, // top side\n                'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                'L', x + w, y + h - r, // right side\n                'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt\n                'L', x + r, y + h, // bottom side\n                'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                'L', x, y + r, // left side\n                'C', x, y, x, y, x + r, y // top-left corner\n            ];\n\n            // Anchor on right side\n            if (anchorX && anchorX > w) {\n\n                // Chevron\n                if (\n                    anchorY > y + safeDistance &&\n                    anchorY < y + h - safeDistance\n                ) {\n                    path.splice(13, 3,\n                        'L', x + w, anchorY - halfDistance,\n                        x + w + arrowLength, anchorY,\n                        x + w, anchorY + halfDistance,\n                        x + w, y + h - r\n                    );\n\n                // Simple connector\n                } else {\n                    path.splice(13, 3,\n                        'L', x + w, h / 2,\n                        anchorX, anchorY,\n                        x + w, h / 2,\n                        x + w, y + h - r\n                    );\n                }\n\n            // Anchor on left side\n            } else if (anchorX && anchorX < 0) {\n\n                // Chevron\n                if (\n                    anchorY > y + safeDistance &&\n                    anchorY < y + h - safeDistance\n                ) {\n                    path.splice(33, 3,\n                        'L', x, anchorY + halfDistance,\n                        x - arrowLength, anchorY,\n                        x, anchorY - halfDistance,\n                        x, y + r\n                    );\n\n                // Simple connector\n                } else {\n                    path.splice(33, 3,\n                        'L', x, h / 2,\n                        anchorX, anchorY,\n                        x, h / 2,\n                        x, y + r\n                    );\n                }\n\n            } else if ( // replace bottom\n                anchorY &&\n                anchorY > h &&\n                anchorX > x + safeDistance &&\n                anchorX < x + w - safeDistance\n            ) {\n                path.splice(23, 3,\n                    'L', anchorX + halfDistance, y + h,\n                    anchorX, y + h + arrowLength,\n                    anchorX - halfDistance, y + h,\n                    x + r, y + h\n                    );\n\n            } else if ( // replace top\n                anchorY &&\n                anchorY < 0 &&\n                anchorX > x + safeDistance &&\n                anchorX < x + w - safeDistance\n            ) {\n                path.splice(3, 3,\n                    'L', anchorX - halfDistance, y,\n                    anchorX, y - arrowLength,\n                    anchorX + halfDistance, y,\n                    w - r, y\n                );\n            }\n\n            return path;\n        }\n    },\n\n    /**\n     * Define a clipping rectangle. The clipping rectangle is later applied\n     * to {@link SVGElement} objects through the {@link SVGElement#clip}\n     * function.\n     *\n     * @example\n     * var circle = renderer.circle(100, 100, 100)\n     *     .attr({ fill: 'red' })\n     *     .add();\n     * var clipRect = renderer.clipRect(100, 100, 100, 100);\n     *\n     * // Leave only the lower right quarter visible\n     * circle.clip(clipRect);\n     *\n     * @function Highcharts.SVGRenderer#clipRect\n     *\n     * @param {string} id\n     *\n     * @param {number} x\n     *\n     * @param {number} y\n     *\n     * @param {number} width\n     *\n     * @param {number} height\n     *\n     * @return {Highcharts.ClipRectElement}\n     *         A clipping rectangle.\n     */\n    clipRect: function (x, y, width, height) {\n        var wrapper,\n            id = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey(),\n\n            clipPath = this.createElement('clipPath').attr({\n                id: id\n            }).add(this.defs);\n\n        wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n        wrapper.id = id;\n        wrapper.clipPath = clipPath;\n        wrapper.count = 0;\n\n        return wrapper;\n    },\n\n\n\n\n\n    /**\n     * Draw text. The text can contain a subset of HTML, like spans and anchors\n     * and some basic text styling of these. For more advanced features like\n     * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n     * To update the text after render, run `text.attr({ text: 'New text' })`.\n     *\n     * @sample highcharts/members/renderer-text-on-chart/\n     *         Annotate the chart freely\n     * @sample highcharts/members/renderer-on-chart/\n     *         Annotate with a border and in response to the data\n     * @sample highcharts/members/renderer-text/\n     *         Formatted text\n     *\n     * @function Highcharts.SVGRenderer#text\n     *\n     * @param {string} str\n     *        The text of (subset) HTML to draw.\n     *\n     * @param {number} x\n     *        The x position of the text's lower left corner.\n     *\n     * @param {number} y\n     *        The y position of the text's lower left corner.\n     *\n     * @param {boolean} [useHTML=false]\n     *        Use HTML to render the text.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The text object.\n     */\n    text: function (str, x, y, useHTML) {\n\n        // declare variables\n        var renderer = this,\n            wrapper,\n            attribs = {};\n\n        if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n            return renderer.html(str, x, y);\n        }\n\n        attribs.x = Math.round(x || 0); // X always needed for line-wrap logic\n        if (y) {\n            attribs.y = Math.round(y);\n        }\n        if (str || str === 0) {\n            attribs.text = str;\n        }\n\n        wrapper = renderer.createElement('text')\n            .attr(attribs);\n\n        if (!useHTML) {\n            wrapper.xSetter = function (value, key, element) {\n                var tspans = element.getElementsByTagName('tspan'),\n                    tspan,\n                    parentVal = element.getAttribute(key),\n                    i;\n                for (i = 0; i < tspans.length; i++) {\n                    tspan = tspans[i];\n                    // If the x values are equal, the tspan represents a\n                    // linebreak\n                    if (tspan.getAttribute(key) === parentVal) {\n                        tspan.setAttribute(key, value);\n                    }\n                }\n                element.setAttribute(key, value);\n            };\n        }\n\n        return wrapper;\n    },\n\n    /**\n     * Utility to return the baseline offset and total line height from the font\n     * size.\n     *\n     * @function Highcharts.SVGRenderer#fontMetrics\n     *\n     * @param {string} [fontSize]\n     *        The current font size to inspect. If not given, the font size\n     *        will be found from the DOM element.\n     *\n     * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement} [elem]\n     *        The element to inspect for a current font size.\n     *\n     * @return {Highcharts.FontMetricsObject}\n     *         The font metrics.\n     */\n    fontMetrics: function (fontSize, elem) {\n        var lineHeight,\n            baseline;\n\n        \n        fontSize = elem && SVGElement.prototype.getStyle.call(\n            elem,\n            'font-size'\n        );\n        \n\n        // Handle different units\n        if (/px/.test(fontSize)) {\n            fontSize = pInt(fontSize);\n        } else if (/em/.test(fontSize)) {\n            // The em unit depends on parent items\n            fontSize = parseFloat(fontSize) *\n                (elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n        } else {\n            fontSize = 12;\n        }\n\n        // Empirical values found by comparing font size and bounding box\n        // height. Applies to the default font family.\n        // https://jsfiddle.net/highcharts/7xvn7/\n        lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n        baseline = Math.round(lineHeight * 0.8);\n\n        return {\n            h: lineHeight,\n            b: baseline,\n            f: fontSize\n        };\n    },\n\n    /**\n     * Correct X and Y positioning of a label for rotation (#1764).\n     *\n     * @private\n     * @function Highcharts.SVGRenderer#rotCorr\n     *\n     * @param {number} baseline\n     *\n     * @param {number} rotation\n     *\n     * @param {boolean} alterY\n     */\n    rotCorr: function (baseline, rotation, alterY) {\n        var y = baseline;\n        if (rotation && alterY) {\n            y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n        }\n        return {\n            x: (-baseline / 3) * Math.sin(rotation * deg2rad),\n            y: y\n        };\n    },\n\n    /**\n     * Draw a label, which is an extended text element with support for border\n     * and background. Highcharts creates a `g` element with a text and a `path`\n     * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n     * background are set through `stroke`, `stroke-width` and `fill` attributes\n     * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n     * text after render, run `label.attr({ text: 'New text' })`.\n     *\n     * @sample highcharts/members/renderer-label-on-chart/\n     *         A label on the chart\n     *\n     * @function Highcharts.SVGRenderer#label\n     *\n     * @param {string} str\n     *        The initial text string or (subset) HTML to render.\n     *\n     * @param {number} x\n     *        The x position of the label's left side.\n     *\n     * @param {number} y\n     *        The y position of the label's top side or baseline, depending on\n     *        the `baseline` parameter.\n     *\n     * @param {string} [shape='rect']\n     *        The shape of the label's border/background, if any. Defaults to\n     *        `rect`. Other possible values are `callout` or other shapes\n     *        defined in {@link Highcharts.SVGRenderer#symbols}.\n     *\n     * @param {string} [shape='rect']\n     *        The shape of the label's border/background, if any. Defaults to\n     *        `rect`. Other possible values are `callout` or other shapes\n     *        defined in {@link Highcharts.SVGRenderer#symbols}.\n     *\n     * @param {number} [anchorX]\n     *        In case the `shape` has a pointer, like a flag, this is the\n     *        coordinates it should be pinned to.\n     *\n     * @param {number} [anchorY]\n     *        In case the `shape` has a pointer, like a flag, this is the\n     *        coordinates it should be pinned to.\n     *\n     * @param {boolean} [useHTML=false]\n     *        Wether to use HTML to render the label.\n     *\n     * @param {boolean} [baseline=false]\n     *        Whether to position the label relative to the text baseline,\n     *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n     *        upper border of the rectangle.\n     *\n     * @param {string} [className]\n     *        Class name for the group.\n     *\n     * @return {Highcharts.SVGElement}\n     *         The generated label.\n     */\n    label: function (\n        str,\n        x,\n        y,\n        shape,\n        anchorX,\n        anchorY,\n        useHTML,\n        baseline,\n        className\n    ) {\n\n        var renderer = this,\n            wrapper = renderer.g(className !== 'button' && 'label'),\n            text = wrapper.text = renderer.text('', 0, 0, useHTML)\n                .attr({\n                    zIndex: 1\n                }),\n            box,\n            bBox,\n            alignFactor = 0,\n            padding = 3,\n            paddingLeft = 0,\n            width,\n            height,\n            wrapperX,\n            wrapperY,\n            textAlign,\n            deferredAttr = {},\n            strokeWidth,\n            baselineOffset,\n            hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n            needsBox = hasBGImage,\n            getCrispAdjust,\n            updateBoxSize,\n            updateTextPadding,\n            boxAttr;\n\n        if (className) {\n            wrapper.addClass('highcharts-' + className);\n        }\n\n        \n        needsBox = true; // for styling\n        getCrispAdjust = function () {\n            return box.strokeWidth() % 2 / 2;\n        };\n        \n\n        /*\n         * This function runs after the label is added to the DOM (when the\n         * bounding box is available), and after the text of the label is\n         * updated to detect the new bounding box and reflect it in the border\n         * box.\n         */\n        updateBoxSize = function () {\n            var style = text.element.style,\n                crispAdjust,\n                attribs = {};\n\n            bBox = (\n                (width === undefined || height === undefined || textAlign) &&\n                defined(text.textStr) &&\n                text.getBBox()\n            ); // #3295 && 3514 box failure when string equals 0\n\n            wrapper.width = (\n                (width || bBox.width || 0) +\n                2 * padding +\n                paddingLeft\n            );\n            wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n            // Update the label-scoped y offset\n            baselineOffset = padding +\n                renderer.fontMetrics(style && style.fontSize, text).b;\n\n            if (needsBox) {\n\n                // Create the border box if it is not already present\n                if (!box) {\n                    // Symbol definition exists (#5324)\n                    wrapper.box = box = renderer.symbols[shape] || hasBGImage ?\n                        renderer.symbol(shape) :\n                        renderer.rect();\n\n                    box.addClass( // Don't use label className for buttons\n                        (className === 'button' ? '' : 'highcharts-label-box') +\n                        (className ? ' highcharts-' + className + '-box' : '')\n                    );\n\n                    box.add(wrapper);\n\n                    crispAdjust = getCrispAdjust();\n                    attribs.x = crispAdjust;\n                    attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n                }\n\n                // Apply the box attributes\n                attribs.width = Math.round(wrapper.width);\n                attribs.height = Math.round(wrapper.height);\n\n                box.attr(extend(attribs, deferredAttr));\n                deferredAttr = {};\n            }\n        };\n\n        /*\n         * This function runs after setting text or padding, but only if padding\n         * is changed.\n         */\n        updateTextPadding = function () {\n            var textX = paddingLeft + padding,\n                textY;\n\n            // determin y based on the baseline\n            textY = baseline ? 0 : baselineOffset;\n\n            // compensate for alignment\n            if (\n                defined(width) &&\n                bBox &&\n                (textAlign === 'center' || textAlign === 'right')\n            ) {\n                textX += { center: 0.5, right: 1 }[textAlign] *\n                    (width - bBox.width);\n            }\n\n            // update if anything changed\n            if (textX !== text.x || textY !== text.y) {\n                text.attr('x', textX);\n                // #8159 - prevent misplaced data labels in treemap\n                // (useHTML: true)\n                if (text.hasBoxWidthChanged) {\n                    bBox = text.getBBox(true);\n                    updateBoxSize();\n                }\n                if (textY !== undefined) {\n                    text.attr('y', textY);\n                }\n            }\n\n            // record current values\n            text.x = textX;\n            text.y = textY;\n        };\n\n        /*\n         * Set a box attribute, or defer it if the box is not yet created\n         */\n        boxAttr = function (key, value) {\n            if (box) {\n                box.attr(key, value);\n            } else {\n                deferredAttr[key] = value;\n            }\n        };\n\n        /*\n         * After the text element is added, get the desired size of the border\n         * box and add it before the text in the DOM.\n         */\n        wrapper.onAdd = function () {\n            text.add(wrapper);\n            wrapper.attr({\n                // Alignment is available now  (#3295, 0 not rendered if given\n                // as a value)\n                text: (str || str === 0) ? str : '',\n                x: x,\n                y: y\n            });\n\n            if (box && defined(anchorX)) {\n                wrapper.attr({\n                    anchorX: anchorX,\n                    anchorY: anchorY\n                });\n            }\n        };\n\n        /*\n         * Add specific attribute setters.\n         */\n\n        // only change local variables\n        wrapper.widthSetter = function (value) {\n            width = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(value) ? value : null; // width:auto => null\n        };\n        wrapper.heightSetter = function (value) {\n            height = value;\n        };\n        wrapper['text-alignSetter'] = function (value) {\n            textAlign = value;\n        };\n        wrapper.paddingSetter = function (value) {\n            if (defined(value) && value !== padding) {\n                padding = wrapper.padding = value;\n                updateTextPadding();\n            }\n        };\n        wrapper.paddingLeftSetter = function (value) {\n            if (defined(value) && value !== paddingLeft) {\n                paddingLeft = value;\n                updateTextPadding();\n            }\n        };\n\n\n        // change local variable and prevent setting attribute on the group\n        wrapper.alignSetter = function (value) {\n            value = { left: 0, center: 0.5, right: 1 }[value];\n            if (value !== alignFactor) {\n                alignFactor = value;\n                // Bounding box exists, means we're dynamically changing\n                if (bBox) {\n                    wrapper.attr({ x: wrapperX }); // #5134\n                }\n            }\n        };\n\n        // apply these to the box and the text alike\n        wrapper.textSetter = function (value) {\n            if (value !== undefined) {\n                text.textSetter(value);\n            }\n            updateBoxSize();\n            updateTextPadding();\n        };\n\n        // apply these to the box but not to the text\n        wrapper['stroke-widthSetter'] = function (value, key) {\n            if (value) {\n                needsBox = true;\n            }\n            strokeWidth = this['stroke-width'] = value;\n            boxAttr(key, value);\n        };\n        \n        wrapper.rSetter = function (value, key) {\n            boxAttr(key, value);\n        };\n        \n        wrapper.anchorXSetter = function (value, key) {\n            anchorX = wrapper.anchorX = value;\n            boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n        };\n        wrapper.anchorYSetter = function (value, key) {\n            anchorY = wrapper.anchorY = value;\n            boxAttr(key, value - wrapperY);\n        };\n\n        // rename attributes\n        wrapper.xSetter = function (value) {\n            wrapper.x = value; // for animation getter\n            if (alignFactor) {\n                value -= alignFactor * ((width || bBox.width) + 2 * padding);\n\n                // Force animation even when setting to the same value (#7898)\n                wrapper['forceAnimate:x'] = true;\n            }\n            wrapperX = Math.round(value);\n            wrapper.attr('translateX', wrapperX);\n        };\n        wrapper.ySetter = function (value) {\n            wrapperY = wrapper.y = Math.round(value);\n            wrapper.attr('translateY', wrapperY);\n        };\n\n        // Redirect certain methods to either the box or the text\n        var baseCss = wrapper.css;\n        return extend(wrapper, {\n            /*\n             * Pick up some properties and apply them to the text instead of the\n             * wrapper.\n             */\n            css: function (styles) {\n                if (styles) {\n                    var textStyles = {};\n                    // Create a copy to avoid altering the original object\n                    // (#537)\n                    styles = merge(styles);\n                    each(wrapper.textProps, function (prop) {\n                        if (styles[prop] !== undefined) {\n                            textStyles[prop] = styles[prop];\n                            delete styles[prop];\n                        }\n                    });\n                    text.css(textStyles);\n\n                    if ('width' in textStyles) {\n                        updateBoxSize();\n                    }\n                }\n                return baseCss.call(wrapper, styles);\n            },\n            /*\n             * Return the bounding box of the box, not the group.\n             */\n            getBBox: function () {\n                return {\n                    width: bBox.width + 2 * padding,\n                    height: bBox.height + 2 * padding,\n                    x: bBox.x - padding,\n                    y: bBox.y - padding\n                };\n            },\n            \n            /*\n             * Destroy and release memory.\n             */\n            destroy: function () {\n\n                // Added by button implementation\n                removeEvent(wrapper.element, 'mouseenter');\n                removeEvent(wrapper.element, 'mouseleave');\n\n                if (text) {\n                    text = text.destroy();\n                }\n                if (box) {\n                    box = box.destroy();\n                }\n                // Call base implementation to destroy the rest\n                SVGElement.prototype.destroy.call(wrapper);\n\n                // Release local pointers (#1298)\n                wrapper =\n                renderer =\n                updateBoxSize =\n                updateTextPadding =\n                boxAttr = null;\n            }\n        });\n    }\n}); // end SVGRenderer\n\n\n// general renderer\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer = SVGRenderer;\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/SvgRenderer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Tick.js":
/*!*************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Tick.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\nvar correctFloat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat,\n    defined = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined,\n    destroyObjectProperties = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties,\n    fireEvent = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    deg2rad = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deg2rad;\n\n/**\n * The Tick class\n * @ignore\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick = function (axis, pos, type, noLabel) {\n    this.axis = axis;\n    this.pos = pos;\n    this.type = type || '';\n    this.isNew = true;\n    this.isNewLabel = true;\n\n    if (!type && !noLabel) {\n        this.addLabel();\n    }\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tick.prototype = {\n    /**\n     * Write the tick label\n     */\n    addLabel: function () {\n        var tick = this,\n            axis = tick.axis,\n            options = axis.options,\n            chart = axis.chart,\n            categories = axis.categories,\n            names = axis.names,\n            pos = tick.pos,\n            labelOptions = options.labels,\n            str,\n            tickPositions = axis.tickPositions,\n            isFirst = pos === tickPositions[0],\n            isLast = pos === tickPositions[tickPositions.length - 1],\n            value = categories ?\n                pick(categories[pos], names[pos], pos) :\n                pos,\n            label = tick.label,\n            tickPositionInfo = tickPositions.info,\n            dateTimeLabelFormat,\n            params;\n\n        // Set the datetime label format. If a higher rank is set for this\n        // position, use that. If not, use the general format.\n        if (axis.isDatetimeAxis && tickPositionInfo) {\n            dateTimeLabelFormat =\n                options.dateTimeLabelFormats[\n                    tickPositionInfo.higherRanks[pos] ||\n                    tickPositionInfo.unitName\n                ];\n        }\n        // set properties for access in render method\n        tick.isFirst = isFirst;\n        tick.isLast = isLast;\n\n        // Get the string. Provide params both as scope (legacy) and as first\n        // parameter which allows use in arrow functions (#8580).\n        params = {\n            axis: axis,\n            chart: chart,\n            isFirst: isFirst,\n            isLast: isLast,\n            dateTimeLabelFormat: dateTimeLabelFormat,\n            value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,\n            pos: pos\n        };\n        str = axis.labelFormatter.call(params, params);\n\n        // first call\n        if (!defined(label)) {\n\n            tick.label = label =\n                defined(str) && labelOptions.enabled ?\n                    chart.renderer.text(\n                            str,\n                            0,\n                            0,\n                            labelOptions.useHTML\n                        )\n                        \n                        .add(axis.labelGroup) :\n                    null;\n\n            // Un-rotated length\n            if (label) {\n                label.textPxLength = label.getBBox().width;\n            }\n\n\n            // Base value to detect change for new calls to getBBox\n            tick.rotation = 0;\n\n        // update\n        } else if (label && label.textStr !== str) {\n            // When resetting text, also reset the width if dynamically set\n            // (#8809)\n            if (\n                label.textWidth &&\n                !(labelOptions.style && labelOptions.style.width) &&\n                !label.styles.width\n            ) {\n                label.css({ width: null });\n            }\n\n            label.attr({ text: str });\n        }\n    },\n\n    /**\n     * Get the offset height or width of the label\n     */\n    getLabelSize: function () {\n        return this.label ?\n            this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n            0;\n    },\n\n    /**\n     * Handle the label overflow by adjusting the labels to the left and right\n     * edge, or hide them if they collide into the neighbour label.\n     */\n    handleOverflow: function (xy) {\n        var tick = this,\n            axis = this.axis,\n            labelOptions = axis.options.labels,\n            pxPos = xy.x,\n            chartWidth = axis.chart.chartWidth,\n            spacing = axis.chart.spacing,\n            leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n            rightBound = pick(\n                axis.labelRight,\n                Math.max(\n                    !axis.isRadial ? axis.pos + axis.len : 0,\n                    chartWidth - spacing[1]\n                )\n            ),\n            label = this.label,\n            rotation = this.rotation,\n            factor = { left: 0, center: 0.5, right: 1 }[\n                axis.labelAlign || label.attr('align')\n            ],\n            labelWidth = label.getBBox().width,\n            slotWidth = axis.getSlotWidth(tick),\n            modifiedSlotWidth = slotWidth,\n            xCorrection = factor,\n            goRight = 1,\n            leftPos,\n            rightPos,\n            textWidth,\n            css = {};\n\n        // Check if the label overshoots the chart spacing box. If it does, move\n        // it. If it now overshoots the slotWidth, add ellipsis.\n        if (!rotation && pick(labelOptions.overflow, 'justify') === 'justify') {\n            leftPos = pxPos - factor * labelWidth;\n            rightPos = pxPos + (1 - factor) * labelWidth;\n\n            if (leftPos < leftBound) {\n                modifiedSlotWidth =\n                    xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n            } else if (rightPos > rightBound) {\n                modifiedSlotWidth =\n                    rightBound - xy.x + modifiedSlotWidth * factor;\n                goRight = -1;\n            }\n\n            modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n            if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                xy.x += (\n                    goRight *\n                    (\n                        slotWidth -\n                        modifiedSlotWidth -\n                        xCorrection * (\n                            slotWidth - Math.min(labelWidth, modifiedSlotWidth)\n                        )\n                    )\n                );\n            }\n            // If the label width exceeds the available space, set a text width\n            // to be picked up below. Also, if a width has been set before, we\n            // need to set a new one because the reported labelWidth will be\n            // limited by the box (#3938).\n            if (\n                labelWidth > modifiedSlotWidth ||\n                (axis.autoRotation && (label.styles || {}).width)\n            ) {\n                textWidth = modifiedSlotWidth;\n            }\n\n        // Add ellipsis to prevent rotated labels to be clipped against the edge\n        // of the chart\n        } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n            textWidth = Math.round(\n                pxPos / Math.cos(rotation * deg2rad) - leftBound\n            );\n        } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n            textWidth = Math.round(\n                (chartWidth - pxPos) / Math.cos(rotation * deg2rad)\n            );\n        }\n\n        if (textWidth) {\n            css.width = textWidth;\n            if (!(labelOptions.style || {}).textOverflow) {\n                css.textOverflow = 'ellipsis';\n            }\n            label.css(css);\n        }\n    },\n\n    /**\n     * Get the x and y position for ticks and labels\n     */\n    getPosition: function (horiz, tickPos, tickmarkOffset, old) {\n        var axis = this.axis,\n            chart = axis.chart,\n            cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n            pos;\n\n        pos = {\n            x: horiz ?\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat(\n                    axis.translate(tickPos + tickmarkOffset, null, null, old) +\n                    axis.transB\n                ) :\n                (\n                    axis.left +\n                    axis.offset +\n                    (\n                        axis.opposite ?\n                            (\n                                (\n                                    (old && chart.oldChartWidth) ||\n                                    chart.chartWidth\n                                ) -\n                                axis.right -\n                                axis.left\n                            ) :\n                            0\n                    )\n                ),\n\n            y: horiz ?\n                (\n                    cHeight -\n                    axis.bottom +\n                    axis.offset -\n                    (axis.opposite ? axis.height : 0)\n                ) :\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat(\n                    cHeight -\n                    axis.translate(tickPos + tickmarkOffset, null, null, old) -\n                    axis.transB\n                )\n        };\n\n        fireEvent(this, 'afterGetPosition', { pos: pos });\n\n        return pos;\n\n    },\n\n    /**\n     * Get the x, y position of the tick label\n     */\n    getLabelPosition: function (\n        x,\n        y,\n        label,\n        horiz,\n        labelOptions,\n        tickmarkOffset,\n        index,\n        step\n    ) {\n        var axis = this.axis,\n            transA = axis.transA,\n            reversed = axis.reversed,\n            staggerLines = axis.staggerLines,\n            rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n            yOffset = labelOptions.y,\n\n            // Adjust for label alignment if we use reserveSpace: true (#5286)\n            labelOffsetCorrection = (\n                !horiz && !axis.reserveSpaceDefault ?\n                    -axis.labelOffset * (\n                        axis.labelAlign === 'center' ? 0.5 : 1\n                    ) :\n                    0\n            ),\n            line,\n            pos = {};\n\n        if (!defined(yOffset)) {\n            if (axis.side === 0) {\n                yOffset = label.rotation ? -8 : -label.getBBox().height;\n            } else if (axis.side === 2) {\n                yOffset = rotCorr.y + 8;\n            } else {\n                // #3140, #3140\n                yOffset = Math.cos(label.rotation * deg2rad) *\n                    (rotCorr.y - label.getBBox(false, 0).height / 2);\n            }\n        }\n\n        x = x +\n            labelOptions.x +\n            labelOffsetCorrection +\n            rotCorr.x -\n            (\n                tickmarkOffset && horiz ?\n                    tickmarkOffset * transA * (reversed ? -1 : 1) :\n                    0\n            );\n        y = y + yOffset - (tickmarkOffset && !horiz ?\n            tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n        // Correct for staggered labels\n        if (staggerLines) {\n            line = (index / (step || 1) % staggerLines);\n            if (axis.opposite) {\n                line = staggerLines - line - 1;\n            }\n            y += line * (axis.labelOffset / staggerLines);\n        }\n\n        pos.x = x;\n        pos.y = Math.round(y);\n\n        fireEvent(this, 'afterGetLabelPosition', { pos: pos });\n\n        return pos;\n    },\n\n    /**\n     * Extendible method to return the path of the marker\n     */\n    getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n        return renderer.crispLine([\n            'M',\n            x,\n            y,\n            'L',\n            x + (horiz ? 0 : -tickLength),\n            y + (horiz ? tickLength : 0)\n        ], tickWidth);\n    },\n\n    /**\n     * Renders the gridLine.\n     * @param  {Boolean} old         Whether or not the tick is old\n     * @param  {number} opacity      The opacity of the grid line\n     * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n     * @return {undefined}\n     */\n    renderGridLine: function (old, opacity, reverseCrisp) {\n        var tick = this,\n            axis = tick.axis,\n            options = axis.options,\n            gridLine = tick.gridLine,\n            gridLinePath,\n            attribs = {},\n            pos = tick.pos,\n            type = tick.type,\n            tickmarkOffset = axis.tickmarkOffset,\n            renderer = axis.chart.renderer;\n\n        \n\n        if (!gridLine) {\n            \n            if (!type) {\n                attribs.zIndex = 1;\n            }\n            if (old) {\n                attribs.opacity = 0;\n            }\n            tick.gridLine = gridLine = renderer.path()\n                .attr(attribs)\n                .addClass(\n                    'highcharts-' + (type ? type + '-' : '') + 'grid-line'\n                )\n                .add(axis.gridGroup);\n        }\n\n        // If the parameter 'old' is set, the current call will be followed\n        // by another call, therefore do not do any animations this time\n        if (!old && gridLine) {\n            gridLinePath = axis.getPlotLinePath(\n                pos + tickmarkOffset,\n                gridLine.strokeWidth() * reverseCrisp,\n                old, true\n            );\n            if (gridLinePath) {\n                gridLine[tick.isNew ? 'attr' : 'animate']({\n                    d: gridLinePath,\n                    opacity: opacity\n                });\n            }\n        }\n    },\n\n    /**\n     * Renders the tick mark.\n     * @param  {Object} xy           The position vector of the mark\n     * @param  {number} xy.x         The x position of the mark\n     * @param  {number} xy.y         The y position of the mark\n     * @param  {number} opacity      The opacity of the mark\n     * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n     * @return {undefined}\n     */\n    renderMark: function (xy, opacity, reverseCrisp) {\n        var tick = this,\n            axis = tick.axis,\n            options = axis.options,\n            renderer = axis.chart.renderer,\n            type = tick.type,\n            tickPrefix = type ? type + 'Tick' : 'tick',\n            tickSize = axis.tickSize(tickPrefix),\n            mark = tick.mark,\n            isNewMark = !mark,\n            x = xy.x,\n            y = xy.y;\n\n        \n\n        if (tickSize) {\n\n            // negate the length\n            if (axis.opposite) {\n                tickSize[0] = -tickSize[0];\n            }\n\n            // First time, create it\n            if (isNewMark) {\n                tick.mark = mark = renderer.path()\n                    .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')\n                    .add(axis.axisGroup);\n\n                \n            }\n            mark[isNewMark ? 'attr' : 'animate']({\n                d: tick.getMarkPath(\n                    x,\n                    y,\n                    tickSize[0],\n                    mark.strokeWidth() * reverseCrisp,\n                    axis.horiz,\n                    renderer),\n                opacity: opacity\n            });\n\n        }\n    },\n\n    /**\n     * Renders the tick label.\n     * Note: The label should already be created in init(), so it should only\n     * have to be moved into place.\n     * @param  {Object} xy      The position vector of the label\n     * @param  {number} xy.x    The x position of the label\n     * @param  {number} xy.y    The y position of the label\n     * @param  {Boolean} old    Whether or not the tick is old\n     * @param  {number} opacity The opacity of the label\n     * @param  {number} index   The index of the tick\n     * @return {undefined}\n     */\n    renderLabel: function (xy, old, opacity, index) {\n        var tick = this,\n            axis = tick.axis,\n            horiz = axis.horiz,\n            options = axis.options,\n            label = tick.label,\n            labelOptions = options.labels,\n            step = labelOptions.step,\n            tickmarkOffset = axis.tickmarkOffset,\n            show = true,\n            x = xy.x,\n            y = xy.y;\n        if (label && isNumber(x)) {\n            label.xy = xy = tick.getLabelPosition(\n                x,\n                y,\n                label,\n                horiz,\n                labelOptions,\n                tickmarkOffset,\n                index,\n                step\n            );\n\n            // Apply show first and show last. If the tick is both first and\n            // last, it is a single centered tick, in which case we show the\n            // label anyway (#2100).\n            if (\n                (\n                    tick.isFirst &&\n                    !tick.isLast &&\n                    !pick(options.showFirstLabel, 1)\n                ) ||\n                (\n                    tick.isLast &&\n                    !tick.isFirst &&\n                    !pick(options.showLastLabel, 1)\n                )\n            ) {\n                show = false;\n\n            // Handle label overflow and show or hide accordingly\n            } else if (\n                horiz &&\n                !labelOptions.step &&\n                !labelOptions.rotation &&\n                !old &&\n                opacity !== 0\n            ) {\n                tick.handleOverflow(xy);\n            }\n\n            // apply step\n            if (step && index % step) {\n                // show those indices dividable by step\n                show = false;\n            }\n\n            // Set the new position, and show or hide\n            if (show && isNumber(xy.y)) {\n                xy.opacity = opacity;\n                label[tick.isNewLabel ? 'attr' : 'animate'](xy);\n                tick.isNewLabel = false;\n            } else {\n                label.attr('y', -9999); // #1338\n                tick.isNewLabel = true;\n            }\n        }\n    },\n\n    /**\n     * Put everything in place\n     *\n     * @param index {Number}\n     * @param old {Boolean} Use old coordinates to prepare an animation into new\n     *                      position\n     */\n    render: function (index, old, opacity) {\n        var tick = this,\n            axis = tick.axis,\n            horiz = axis.horiz,\n            pos = tick.pos,\n            tickmarkOffset = axis.tickmarkOffset,\n            xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n            x = xy.x,\n            y = xy.y,\n            reverseCrisp = ((horiz && x === axis.pos + axis.len) ||\n                (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n        opacity = pick(opacity, 1);\n        this.isActive = true;\n\n        // Create the grid line\n        this.renderGridLine(old, opacity, reverseCrisp);\n\n        // create the tick mark\n        this.renderMark(xy, opacity, reverseCrisp);\n\n        // the label is created on init - now move it into place\n        this.renderLabel(xy, old, opacity, index);\n\n        tick.isNew = false;\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent(this, 'afterRender');\n    },\n\n    /**\n     * Destructor for the tick prototype\n     */\n    destroy: function () {\n        destroyObjectProperties(this, this.axis);\n    }\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Tick.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Time.js":
/*!*************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Time.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Normalized interval.\n *\n * @typedef Highcharts.NormalizedIntervalObject\n *\n * @property {number} unitRange\n *           The interval in axis values (ms)\n *\n * @property {number} count\n *           The count\n */\n\n/**\n * Additonal time tick information.\n *\n * @typedef {Highcharts.NormalizedIntervalObject} Highcharts.TimeTicksInfoObject\n *\n * @property {Array<string>} higherRanks\n *\n * @property {number} totalRange\n */\n\n/**\n * Time ticks.\n *\n * @typedef {Array<number>} Highcharts.TimeTicksObject\n *\n * @property {Highcharts.TimeTicksInfoObject} info\n */\n\n\n\n\n\nvar H = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    defined = H.defined,\n    each = H.each,\n    extend = H.extend,\n    merge = H.merge,\n    pick = H.pick,\n    timeUnits = H.timeUnits,\n    win = H.win;\n\n/**\n * The Time class. Time settings are applied in general for each page using\n * `Highcharts.setOptions`, or individually for each Chart item through the\n * [time](https://api.highcharts.com/highcharts/time) options set.\n *\n * The Time object is available from\n * [Chart.time](http://api.highcharts.com/class-reference/Highcharts.Chart#.time),\n * which refers to  `Highcharts.time` if no individual time settings are\n * applied.\n *\n * @example\n * // Apply time settings globally\n * Highcharts.setOptions({\n *     time: {\n *         timezone: 'Europe/London'\n *     }\n * });\n *\n * // Apply time settings by instance\n * var chart = Highcharts.chart('container', {\n *     time: {\n *         timezone: 'America/New_York'\n *     },\n *     series: [{\n *         data: [1, 4, 3, 5]\n *     }]\n * });\n *\n * // Use the Time object\n * console.log(\n *        'Current time in New York',\n *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())\n * );\n *\n * @class\n * @name Highcharts.Time\n *\n * @param {Highcharts.TimeOptions} options\n *        Time options as defined in [chart.options.time](/highcharts/time).\n *\n * @since 6.0.5\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Time = function (options) {\n    this.update(options, false);\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Time.prototype = {\n\n    /**\n     * Time options that can apply globally or to individual charts. These\n     * settings affect how `datetime` axes are laid out, how tooltips are\n     * formatted, how series\n     * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how\n     * the Highstock range selector handles time.\n     *\n     * The common use case is that all charts in the same Highcharts object\n     * share the same time settings, in which case the global settings are set\n     * using `setOptions`.\n     *\n     * ```js\n     * // Apply time settings globally\n     * Highcharts.setOptions({\n     *     time: {\n     *         timezone: 'Europe/London'\n     *     }\n     * });\n     * // Apply time settings by instance\n     * var chart = Highcharts.chart('container', {\n     *     time: {\n     *         timezone: 'America/New_York'\n     *     },\n     *     series: [{\n     *         data: [1, 4, 3, 5]\n     *     }]\n     * });\n     *\n     * // Use the Time object\n     * console.log(\n     *        'Current time in New York',\n     *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())\n     * );\n     * ```\n     *\n     * Since v6.0.5, the time options were moved from the `global` obect to the\n     * `time` object, and time options can be set on each individual chart.\n     *\n     * @sample {highcharts|highstock}\n     *         highcharts/time/timezone/\n     *         Set the timezone globally\n     * @sample {highcharts}\n     *         highcharts/time/individual/\n     *         Set the timezone per chart instance\n     * @sample {highstock}\n     *         stock/time/individual/\n     *         Set the timezone per chart instance\n     *\n     * @since     6.0.5\n     * @apioption time\n     */\n\n    /**\n     * Whether to use UTC time for axis scaling, tickmark placement and\n     * time display in `Highcharts.dateFormat`. Advantages of using UTC\n     * is that the time displays equally regardless of the user agent's\n     * time zone settings. Local time can be used when the data is loaded\n     * in real time or when correct Daylight Saving Time transitions are\n     * required.\n     *\n     * @sample {highcharts} highcharts/time/useutc-true/\n     *         True by default\n     * @sample {highcharts} highcharts/time/useutc-false/\n     *         False\n     *\n     * @type      {boolean}\n     * @default   true\n     * @apioption time.useUTC\n     */\n\n    /**\n     * A custom `Date` class for advanced date handling. For example,\n     * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to\n     * handle Jalali dates.\n     *\n     * @type      {*}\n     * @since     4.0.4\n     * @product   highcharts highstock\n     * @apioption time.Date\n     */\n\n    /**\n     * A callback to return the time zone offset for a given datetime. It\n     * takes the timestamp in terms of milliseconds since January 1 1970,\n     * and returns the timezone offset in minutes. This provides a hook\n     * for drawing time based charts in specific time zones using their\n     * local DST crossover dates, with the help of external libraries.\n     *\n     * @see [global.timezoneOffset](#global.timezoneOffset)\n     *\n     * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/\n     *         Use moment.js to draw Oslo time regardless of browser locale\n     *\n     * @type      {Function}\n     * @since     4.1.0\n     * @product   highcharts highstock\n     * @apioption time.getTimezoneOffset\n     */\n\n    /**\n     * Requires [moment.js](http://momentjs.com/). If the timezone option\n     * is specified, it creates a default\n     * [getTimezoneOffset](#time.getTimezoneOffset) function that looks\n     * up the specified timezone in moment.js. If moment.js is not included,\n     * this throws a Highcharts error in the console, but does not crash the\n     * chart.\n     *\n     * @see [getTimezoneOffset](#time.getTimezoneOffset)\n     *\n     * @sample {highcharts|highstock} highcharts/time/timezone/\n     *         Europe/Oslo\n     *\n     * @type      {string}\n     * @since     5.0.7\n     * @product   highcharts highstock\n     * @apioption time.timezone\n     */\n\n    /**\n     * The timezone offset in minutes. Positive values are west, negative\n     * values are east of UTC, as in the ECMAScript\n     * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)\n     * method. Use this to display UTC based data in a predefined time zone.\n     *\n     * @see [time.getTimezoneOffset](#time.getTimezoneOffset)\n     *\n     * @sample {highcharts|highstock} highcharts/time/timezoneoffset/\n     *         Timezone offset\n     *\n     * @type      {number}\n     * @default   0\n     * @since     3.0.8\n     * @product   highcharts highstock\n     * @apioption time.timezoneOffset\n     */\n\n    defaultOptions: {},\n\n    /**\n     * Update the Time object with current options. It is called internally on\n     * initiating Highcharts, after running `Highcharts.setOptions` and on\n     * `Chart.update`.\n     *\n     * @private\n     * @function Highcharts.Time#update\n     *\n     * @param {Highcharts.TimeOptions} options\n     */\n    update: function (options) {\n        var useUTC = pick(options && options.useUTC, true),\n            time = this;\n\n        this.options = options = merge(true, this.options || {}, options);\n\n        // Allow using a different Date class\n        this.Date = options.Date || win.Date;\n\n        this.useUTC = useUTC;\n        this.timezoneOffset = useUTC && options.timezoneOffset;\n\n        /**\n         * Get the time zone offset based on the current timezone information as\n         * set in the global options.\n         *\n         * @function Highcharts.Time#getTimezoneOffset\n         *\n         * @param {number} timestamp\n         *        The JavaScript timestamp to inspect.\n         *\n         * @return {number}\n         *         The timezone offset in minutes compared to UTC.\n         */\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n\n        /*\n         * The time object has options allowing for variable time zones, meaning\n         * the axis ticks or series data needs to consider this.\n         */\n        this.variableTimezone = !!(\n            !useUTC ||\n            options.getTimezoneOffset ||\n            options.timezone\n        );\n\n        // UTC time with timezone handling\n        if (this.variableTimezone || this.timezoneOffset) {\n            this.get = function (unit, date) {\n                var realMs = date.getTime(),\n                    ms = realMs - time.getTimezoneOffset(date),\n                    ret;\n\n                date.setTime(ms); // Temporary adjust to timezone\n                ret = date['getUTC' + unit]();\n                date.setTime(realMs); // Reset\n\n                return ret;\n            };\n            this.set = function (unit, date, value) {\n                var ms, offset, newOffset;\n\n                // For lower order time units, just set it directly using local\n                // time\n                if (\n                    unit === 'Milliseconds' ||\n                    unit === 'Seconds' ||\n\n                    // If we're dealting with minutes, we only need to\n                    // consider timezone if we're in Indian time zones with\n                    // half-hour offsets (#8768).\n                    (\n                        unit === 'Minutes' &&\n                        date.getTimezoneOffset() % 60 === 0\n                    )\n                ) {\n                    date['set' + unit](value);\n\n                // Higher order time units need to take the time zone into\n                // account\n                } else {\n\n                    // Adjust by timezone\n                    offset = time.getTimezoneOffset(date);\n                    ms = date.getTime() - offset;\n                    date.setTime(ms);\n\n                    date['setUTC' + unit](value);\n                    newOffset = time.getTimezoneOffset(date);\n\n                    ms = date.getTime() + newOffset;\n                    date.setTime(ms);\n                }\n\n            };\n\n        // UTC time with no timezone handling\n        } else if (useUTC) {\n            this.get = function (unit, date) {\n                return date['getUTC' + unit]();\n            };\n            this.set = function (unit, date, value) {\n                return date['setUTC' + unit](value);\n            };\n\n        // Local time\n        } else {\n            this.get = function (unit, date) {\n                return date['get' + unit]();\n            };\n            this.set = function (unit, date, value) {\n                return date['set' + unit](value);\n            };\n        }\n\n    },\n\n    /**\n     * Make a time and returns milliseconds. Interprets the inputs as UTC time,\n     * local time or a specific timezone time depending on the current time\n     * settings.\n     *\n     * @function Highcharts.Time#makeTime\n     *\n     * @param {number} year\n     *        The year\n     *\n     * @param {number} month\n     *        The month. Zero-based, so January is 0.\n     *\n     * @param {number} [date=1]\n     *        The day of the month\n     *\n     * @param {number} [hours=0]\n     *        The hour of the day, 0-23.\n     *\n     * @param {number} [minutes=0]\n     *        The minutes\n     *\n     * @param {number} [seconds=0]\n     *        The seconds\n     *\n     * @return {number}\n     *         The time in milliseconds since January 1st 1970.\n     */\n    makeTime: function (year, month, date, hours, minutes, seconds) {\n        var d, offset, newOffset;\n        if (this.useUTC) {\n            d = this.Date.UTC.apply(0, arguments);\n            offset = this.getTimezoneOffset(d);\n            d += offset;\n            newOffset = this.getTimezoneOffset(d);\n\n            if (offset !== newOffset) {\n                d += newOffset - offset;\n\n            // A special case for transitioning from summer time to winter time.\n            // When the clock is set back, the same time is repeated twice, i.e.\n            // 02:30 am is repeated since the clock is set back from 3 am to\n            // 2 am. We need to make the same time as local Date does.\n            } else if (\n                offset - 36e5 === this.getTimezoneOffset(d - 36e5) &&\n                !H.isSafari\n            ) {\n                d -= 36e5;\n            }\n\n        } else {\n            d = new this.Date(\n                year,\n                month,\n                pick(date, 1),\n                pick(hours, 0),\n                pick(minutes, 0),\n                pick(seconds, 0)\n            ).getTime();\n        }\n        return d;\n    },\n\n    /**\n     * Sets the getTimezoneOffset function. If the `timezone` option is set, a\n     * default getTimezoneOffset function with that timezone is returned. If\n     * a `getTimezoneOffset` option is defined, it is returned. If neither are\n     * specified, the function using the `timezoneOffset` option or 0 offset is\n     * returned.\n     *\n     * @private\n     * @function Highcharts.Time#timezoneOffsetFunction\n     *\n     * @return {Function}\n     *         A getTimezoneOffset function\n     */\n    timezoneOffsetFunction: function () {\n        var time = this,\n            options = this.options,\n            moment = win.moment;\n\n        if (!this.useUTC) {\n            return function (timestamp) {\n                return new Date(timestamp).getTimezoneOffset() * 60000;\n            };\n        }\n\n        if (options.timezone) {\n            if (!moment) {\n                // getTimezoneOffset-function stays undefined because it depends\n                // on Moment.js\n                H.error(25);\n\n            } else {\n                return function (timestamp) {\n                    return -moment.tz(\n                        timestamp,\n                        options.timezone\n                    ).utcOffset() * 60000;\n                };\n            }\n        }\n\n        // If not timezone is set, look for the getTimezoneOffset callback\n        if (this.useUTC && options.getTimezoneOffset) {\n            return function (timestamp) {\n                return options.getTimezoneOffset(timestamp) * 60000;\n            };\n        }\n\n        // Last, use the `timezoneOffset` option if set\n        return function () {\n            return (time.timezoneOffset || 0) * 60000;\n        };\n    },\n\n    /**\n     * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)\n     * into a human readable date string. The format is a subset of the formats\n     * for PHP's [strftime](http://www.php.net/manual/en/function.strftime.php)\n     * function. Additional formats can be given in the\n     * {@link Highcharts.dateFormats} hook.\n     *\n     * @function Highcharts.Time#dateFormat\n     *\n     * @param {string} [format]\n     *        The desired format where various time representations are\n     *        prefixed with %.\n     *\n     * @param {number} timestamp\n     *        The JavaScript timestamp.\n     *\n     * @param {boolean} [capitalize=false]\n     *        Upper case first letter in the return.\n     *\n     * @return {string}\n     *         The formatted date.\n     */\n    dateFormat: function (format, timestamp, capitalize) {\n        if (!H.defined(timestamp) || isNaN(timestamp)) {\n            return H.defaultOptions.lang.invalidDate || '';\n        }\n        format = H.pick(format, '%Y-%m-%d %H:%M:%S');\n\n        var time = this,\n            date = new this.Date(timestamp),\n            // get the basic time values\n            hours = this.get('Hours', date),\n            day = this.get('Day', date),\n            dayOfMonth = this.get('Date', date),\n            month = this.get('Month', date),\n            fullYear = this.get('FullYear', date),\n            lang = H.defaultOptions.lang,\n            langWeekdays = lang.weekdays,\n            shortWeekdays = lang.shortWeekdays,\n            pad = H.pad,\n\n            // List all format keys. Custom formats can be added from the\n            // outside.\n            replacements = H.extend(\n                {\n\n                    // Day\n                    // Short weekday, like 'Mon'\n                    'a': shortWeekdays ?\n                        shortWeekdays[day] :\n                        langWeekdays[day].substr(0, 3),\n                    // Long weekday, like 'Monday'\n                    'A': langWeekdays[day],\n                    // Two digit day of the month, 01 to 31\n                    'd': pad(dayOfMonth),\n                    // Day of the month, 1 through 31\n                    'e': pad(dayOfMonth, 2, ' '),\n                    'w': day,\n\n                    // Week (none implemented)\n                    // 'W': weekNumber(),\n\n                    // Month\n                    // Short month, like 'Jan'\n                    'b': lang.shortMonths[month],\n                    // Long month, like 'January'\n                    'B': lang.months[month],\n                    // Two digit month number, 01 through 12\n                    'm': pad(month + 1),\n                    // Month number, 1 through 12 (#8150)\n                    'o': month + 1,\n\n                    // Year\n                    // Two digits year, like 09 for 2009\n                    'y': fullYear.toString().substr(2, 2),\n                    // Four digits year, like 2009\n                    'Y': fullYear,\n\n                    // Time\n                    // Two digits hours in 24h format, 00 through 23\n                    'H': pad(hours),\n                    // Hours in 24h format, 0 through 23\n                    'k': hours,\n                    // Two digits hours in 12h format, 00 through 11\n                    'I': pad((hours % 12) || 12),\n                    // Hours in 12h format, 1 through 12\n                    'l': (hours % 12) || 12,\n                    // Two digits minutes, 00 through 59\n                    'M': pad(time.get('Minutes', date)),\n                    // Upper case AM or PM\n                    'p': hours < 12 ? 'AM' : 'PM',\n                    // Lower case AM or PM\n                    'P': hours < 12 ? 'am' : 'pm',\n                    // Two digits seconds, 00 through  59\n                    'S': pad(date.getSeconds()),\n                    // Milliseconds (naming from Ruby)\n                    'L': pad(Math.floor(timestamp % 1000), 3)\n                },\n\n                /**\n                 * A hook for defining additional date format specifiers. New\n                 * specifiers are defined as key-value pairs by using the\n                 * specifier as key, and a function which takes the timestamp as\n                 * value. This function returns the formatted portion of the\n                 * date.\n                 *\n                 * @sample highcharts/global/dateformats/\n                 *         Adding support for week number\n                 *\n                 * @name Highcharts.dateFormats\n                 * @type {Highcharts.Dictionary<Function>}\n                 */\n                H.dateFormats\n            );\n\n\n        // Do the replaces\n        H.objectEach(replacements, function (val, key) {\n            // Regex would do it in one line, but this is faster\n            while (format.indexOf('%' + key) !== -1) {\n                format = format.replace(\n                    '%' + key,\n                    typeof val === 'function' ? val.call(time, timestamp) : val\n                );\n            }\n\n        });\n\n        // Optionally capitalize the string and return\n        return capitalize ?\n            format.substr(0, 1).toUpperCase() + format.substr(1) :\n            format;\n    },\n\n    /**\n     * Return an array with time positions distributed on round time values\n     * right and right after min and max. Used in datetime axes as well as for\n     * grouping data on a datetime axis.\n     *\n     * @function Highcharts.Time#getTimeTicks\n     *\n     * @param {Highcharts.NormalizedIntervalObject} normalizedInterval\n     *        The interval in axis values (ms) and the count\n     *\n     * @param {number} [min]\n     *        The minimum in axis values\n     *\n     * @param {number} [max]\n     *        The maximum in axis values\n     *\n     * @param {number} [startOfWeek=1]\n     *\n     * @return {Highcharts.TimeTicksObject}\n     */\n    getTimeTicks: function (\n        normalizedInterval,\n        min,\n        max,\n        startOfWeek\n    ) {\n        var time = this,\n            Date = time.Date,\n            tickPositions = [],\n            i,\n            higherRanks = {},\n            minYear, // used in months and years as a basis for Date.UTC()\n            // When crossing DST, use the max. Resolves #6278.\n            minDate = new Date(min),\n            interval = normalizedInterval.unitRange,\n            count = normalizedInterval.count || 1,\n            variableDayLength,\n            minDay;\n\n        startOfWeek = pick(startOfWeek, 1);\n\n        if (defined(min)) { // #1300\n            time.set(\n                'Milliseconds',\n                minDate,\n                interval >= timeUnits.second ?\n                    0 : // #3935\n                    count * Math.floor(\n                        time.get('Milliseconds', minDate) / count\n                    )\n            ); // #3652, #3654\n\n            if (interval >= timeUnits.second) { // second\n                time.set('Seconds',\n                    minDate,\n                    interval >= timeUnits.minute ?\n                        0 : // #3935\n                        count * Math.floor(time.get('Seconds', minDate) / count)\n                );\n            }\n\n            if (interval >= timeUnits.minute) { // minute\n                time.set('Minutes', minDate,\n                    interval >= timeUnits.hour ?\n                        0 :\n                        count * Math.floor(time.get('Minutes', minDate) / count)\n                );\n            }\n\n            if (interval >= timeUnits.hour) { // hour\n                time.set(\n                    'Hours',\n                    minDate,\n                    interval >= timeUnits.day ?\n                        0 :\n                        count * Math.floor(\n                            time.get('Hours', minDate) / count\n                        )\n                );\n            }\n\n            if (interval >= timeUnits.day) { // day\n                time.set(\n                    'Date',\n                    minDate,\n                    interval >= timeUnits.month ?\n                        1 :\n                        count * Math.floor(time.get('Date', minDate) / count)\n                    );\n            }\n\n            if (interval >= timeUnits.month) { // month\n                time.set(\n                    'Month',\n                    minDate,\n                    interval >= timeUnits.year ? 0 :\n                        count * Math.floor(time.get('Month', minDate) / count)\n                );\n                minYear = time.get('FullYear', minDate);\n            }\n\n            if (interval >= timeUnits.year) { // year\n                minYear -= minYear % count;\n                time.set('FullYear', minDate, minYear);\n            }\n\n            // week is a special case that runs outside the hierarchy\n            if (interval === timeUnits.week) {\n                // get start of current week, independent of count\n                minDay = time.get('Day', minDate);\n                time.set(\n                    'Date',\n                    minDate,\n                    (\n                        time.get('Date', minDate) -\n                        minDay + startOfWeek +\n                        // We don't want to skip days that are before\n                        // startOfWeek (#7051)\n                        (minDay < startOfWeek ? -7 : 0)\n                    )\n                );\n            }\n\n\n            // Get basics for variable time spans\n            minYear = time.get('FullYear', minDate);\n            var minMonth = time.get('Month', minDate),\n                minDateDate = time.get('Date', minDate),\n                minHours = time.get('Hours', minDate);\n\n            // Redefine min to the floored/rounded minimum time (#7432)\n            min = minDate.getTime();\n\n            // Handle local timezone offset\n            if (time.variableTimezone) {\n\n                // Detect whether we need to take the DST crossover into\n                // consideration. If we're crossing over DST, the day length may\n                // be 23h or 25h and we need to compute the exact clock time for\n                // each tick instead of just adding hours. This comes at a cost,\n                // so first we find out if it is needed (#4951).\n                variableDayLength = (\n                    // Long range, assume we're crossing over.\n                    max - min > 4 * timeUnits.month ||\n                    // Short range, check if min and max are in different time\n                    // zones.\n                    time.getTimezoneOffset(min) !== time.getTimezoneOffset(max)\n                );\n            }\n\n            // Iterate and add tick positions at appropriate values\n            var t = minDate.getTime();\n            i = 1;\n            while (t < max) {\n                tickPositions.push(t);\n\n                // if the interval is years, use Date.UTC to increase years\n                if (interval === timeUnits.year) {\n                    t = time.makeTime(minYear + i * count, 0);\n\n                // if the interval is months, use Date.UTC to increase months\n                } else if (interval === timeUnits.month) {\n                    t = time.makeTime(minYear, minMonth + i * count);\n\n                // if we're using global time, the interval is not fixed as it\n                // jumps one hour at the DST crossover\n                } else if (\n                    variableDayLength &&\n                    (interval === timeUnits.day || interval === timeUnits.week)\n                ) {\n                    t = time.makeTime(\n                        minYear,\n                        minMonth,\n                        minDateDate +\n                            i * count * (interval === timeUnits.day ? 1 : 7)\n                    );\n\n                } else if (\n                    variableDayLength &&\n                    interval === timeUnits.hour &&\n                    count > 1\n                ) {\n                    // make sure higher ranks are preserved across DST (#6797,\n                    // #7621)\n                    t = time.makeTime(\n                        minYear,\n                        minMonth,\n                        minDateDate,\n                        minHours + i * count\n                    );\n\n                // else, the interval is fixed and we use simple addition\n                } else {\n                    t += interval * count;\n                }\n\n                i++;\n            }\n\n            // push the last time\n            tickPositions.push(t);\n\n\n            // Handle higher ranks. Mark new days if the time is on midnight\n            // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold\n            // to prevent looping over dense data grouping (#6156).\n            if (interval <= timeUnits.hour && tickPositions.length < 10000) {\n                each(tickPositions, function (t) {\n                    if (\n                        // Speed optimization, no need to run dateFormat unless\n                        // we're on a full or half hour\n                        t % 1800000 === 0 &&\n                        // Check for local or global midnight\n                        time.dateFormat('%H%M%S%L', t) === '000000000'\n                    ) {\n                        higherRanks[t] = 'day';\n                    }\n                });\n            }\n        }\n\n\n        // record information on the chosen unit - for dynamic label formatter\n        tickPositions.info = extend(normalizedInterval, {\n            higherRanks: higherRanks,\n            totalRange: interval * count\n        });\n\n        return tickPositions;\n    }\n\n}; // end of Time\n\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Time.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Tooltip.js":
/*!****************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Tooltip.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar doc = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    format = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format,\n    isNumber = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    merge = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    splat = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat,\n    syncTimeout = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout,\n    timeUnits = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timeUnits;\n\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n *        Tooltip options.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tooltip = function () {\n    this.init.apply(this, arguments);\n};\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Tooltip.prototype = {\n\n    /**\n     * @private\n     * @function Highcharts.Tooltip#init\n     *\n     * @param {Highcharts.Chart} chart\n     *        The chart instance.\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *        Tooltip options.\n     */\n    init: function (chart, options) {\n\n        /**\n         * Chart of the tooltip.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#chart\n         * @type {Highcharts.Chart}\n         */\n        this.chart = chart;\n\n        /**\n         * Used tooltip options.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#options\n         * @type {Highcharts.TooltipOptions}\n         */\n        this.options = options;\n\n        /**\n         * List of crosshairs.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#crosshairs\n         * @type {Array<*>}\n         */\n        this.crosshairs = [];\n\n        /**\n         * Current values of x and y when animating.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#now\n         * @type {*}\n         */\n        this.now = { x: 0, y: 0 };\n\n        /**\n         * Tooltips are initially hidden.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#isHidden\n         * @type {boolean}\n         */\n        this.isHidden = true;\n\n        /**\n         * True, if the tooltip is splitted into one label per series, with the\n         * header close to the axis.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#split\n         * @type {boolean}\n         */\n        this.split = options.split && !chart.inverted;\n\n        /**\n         * When the tooltip is shared, the entire plot area will capture mouse\n         * movement or touch events.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#shared\n         * @type {boolean}\n         */\n        this.shared = options.shared || this.split;\n\n        /**\n         * Whether to allow the tooltip to render outside the chart's SVG\n         * element box. By default (false), the tooltip is rendered within the\n         * chart's SVG element, which results in the tooltip being aligned\n         * inside the chart area.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#outside\n         * @type {boolean}\n         *\n         * @todo\n         * Split tooltip does not support outside in the first iteration. Should\n         * not be too complicated to implement.\n         */\n        this.outside = options.outside && !this.split;\n\n    },\n\n    /**\n     * Destroy the single tooltips in a split tooltip.\n     * If the tooltip is active then it is not destroyed, unless forced to.\n     *\n     * @private\n     * @function Highcharts.Tooltip#cleanSplit\n     *\n     * @param {boolean} force\n     *        Force destroy all tooltips.\n     */\n    cleanSplit: function (force) {\n        each(this.chart.series, function (series) {\n            var tt = series && series.tt;\n            if (tt) {\n                if (!tt.isActive || force) {\n                    series.tt = tt.destroy();\n                } else {\n                    tt.isActive = false;\n                }\n            }\n        });\n    },\n\n    \n\n    /**\n     * In styled mode, apply the default filter for the tooltip drop-shadow. It\n     * needs to have an id specific to the chart, otherwise there will be issues\n     * when one tooltip adopts the filter of a different chart, specifically one\n     * where the container is hidden.\n     *\n     * @private\n     * @function Highcharts.Tooltip#applyFilter\n     */\n    applyFilter: function () {\n\n        var chart = this.chart;\n        chart.renderer.definition({\n            tagName: 'filter',\n            id: 'drop-shadow-' + chart.index,\n            opacity: 0.5,\n            children: [{\n                tagName: 'feGaussianBlur',\n                in: 'SourceAlpha',\n                stdDeviation: 1\n            }, {\n                tagName: 'feOffset',\n                dx: 1,\n                dy: 1\n            }, {\n                tagName: 'feComponentTransfer',\n                children: [{\n                    tagName: 'feFuncA',\n                    type: 'linear',\n                    slope: 0.3\n                }]\n            }, {\n                tagName: 'feMerge',\n                children: [{\n                    tagName: 'feMergeNode'\n                }, {\n                    tagName: 'feMergeNode',\n                    in: 'SourceGraphic'\n                }]\n            }]\n        });\n        chart.renderer.definition({\n            tagName: 'style',\n            textContent: '.highcharts-tooltip-' + chart.index + '{' +\n                'filter:url(#drop-shadow-' + chart.index + ')' +\n            '}'\n        });\n    },\n\n    \n\n\n    /**\n     * Creates the Tooltip label element if it does not exist, then returns it.\n     *\n     * @function Highcharts.Tooltip#getLabel\n     *\n     * @return {Highcharts.SVGElement}\n     */\n    getLabel: function () {\n\n        var renderer = this.chart.renderer,\n            options = this.options,\n            container;\n\n        if (!this.label) {\n\n            if (this.outside) {\n                this.container = container = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc.createElement('div');\n                container.className = 'highcharts-tooltip-container';\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css(container, {\n                    position: 'absolute',\n                    top: '1px',\n                    pointerEvents: options.style && options.style.pointerEvents\n                });\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc.body.appendChild(container);\n\n                this.renderer = renderer = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Renderer(container, 0, 0);\n            }\n\n\n            // Create the label\n            if (this.split) {\n                this.label = renderer.g('tooltip');\n            } else {\n                this.label = renderer.label(\n                        '',\n                        0,\n                        0,\n                        options.shape || 'callout',\n                        null,\n                        null,\n                        options.useHTML,\n                        null,\n                        'tooltip'\n                    )\n                    .attr({\n                        padding: options.padding,\n                        r: options.borderRadius\n                    });\n\n                \n            }\n\n            \n            // Apply the drop-shadow filter\n            this.applyFilter();\n            this.label.addClass('highcharts-tooltip-' + this.chart.index);\n            \n\n            if (this.outside) {\n                this.label.attr({\n                    x: this.distance,\n                    y: this.distance\n                });\n                this.label.xSetter = function (value) {\n                    container.style.left = value + 'px';\n                };\n                this.label.ySetter = function (value) {\n                    container.style.top = value + 'px';\n                };\n            }\n\n            this.label\n                .attr({\n                    zIndex: 8\n                })\n                .add();\n        }\n        return this.label;\n    },\n\n    /**\n     * Updates the tooltip with the provided tooltip options.\n     *\n     * @function Highcharts.Tooltip#update\n     *\n     * @param {Highcharts.TooltipOptions} options\n     */\n    update: function (options) {\n        this.destroy();\n        // Update user options (#6218)\n        merge(true, this.chart.options.tooltip.userOptions, options);\n        this.init(this.chart, merge(true, this.options, options));\n    },\n\n    /**\n     * Removes and destroys the tooltip and its elements.\n     *\n     * @function Highcharts.Tooltip#destroy\n     */\n    destroy: function () {\n        // Destroy and clear local variables\n        if (this.label) {\n            this.label = this.label.destroy();\n        }\n        if (this.split && this.tt) {\n            this.cleanSplit(this.chart, true);\n            this.tt = this.tt.destroy();\n        }\n        if (this.renderer) {\n            this.renderer = this.renderer.destroy();\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].discardElement(this.container);\n        }\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(this.hideTimer);\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(this.tooltipTimeout);\n    },\n\n    /**\n     * Moves the tooltip with a soft animation to a new position.\n     *\n     * @function Highcharts.Tooltip#move\n     *\n     * @param {number} x\n     *\n     * @param {number} y\n     *\n     * @param {number} anchorX\n     *\n     * @param {number} anchorY\n     */\n    move: function (x, y, anchorX, anchorY) {\n        var tooltip = this,\n            now = tooltip.now,\n            animate = tooltip.options.animation !== false &&\n                !tooltip.isHidden &&\n                // When we get close to the target position, abort animation and\n                // land on the right place (#3056)\n                (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n            skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n        // Get intermediate values for animation\n        extend(now, {\n            x: animate ? (2 * now.x + x) / 3 : x,\n            y: animate ? (now.y + y) / 2 : y,\n            anchorX: skipAnchor ?\n                undefined :\n                animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n            anchorY: skipAnchor ?\n                undefined :\n                animate ? (now.anchorY + anchorY) / 2 : anchorY\n        });\n\n        // Move to the intermediate value\n        tooltip.getLabel().attr(now);\n\n\n        // Run on next tick of the mouse tracker\n        if (animate) {\n\n            // Never allow two timeouts\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(this.tooltipTimeout);\n\n            // Set the fixed interval ticking for the smooth tooltip\n            this.tooltipTimeout = setTimeout(function () {\n                // The interval function may still be running during destroy,\n                // so check that the chart is really there before calling.\n                if (tooltip) {\n                    tooltip.move(x, y, anchorX, anchorY);\n                }\n            }, 32);\n\n        }\n    },\n\n    /**\n     * Hides the tooltip with a fade out animation.\n     *\n     * @function Highcharts.Tooltip#hide\n     *\n     * @param {number} [delay]\n     *        The fade out in milliseconds. If no value is provided the value\n     *        of the tooltip.hideDelay option is used. A value of 0 disables\n     *        the fade out animation.\n     */\n    hide: function (delay) {\n        var tooltip = this;\n        // disallow duplicate timers (#1728, #1766)\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(this.hideTimer);\n        delay = pick(delay, this.options.hideDelay, 500);\n        if (!this.isHidden) {\n            this.hideTimer = syncTimeout(function () {\n                tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();\n                tooltip.isHidden = true;\n            }, delay);\n        }\n    },\n\n    /**\n     * Extendable method to get the anchor position of the tooltip\n     * from a point or set of points\n     *\n     * @private\n     * @function Highcharts.Tooltip#getAnchor\n     *\n     * @param {Array<Highchart.Points>} points\n     *\n     * @param {global.Event} [mouseEvent]\n     */\n    getAnchor: function (points, mouseEvent) {\n        var ret,\n            chart = this.chart,\n            pointer = chart.pointer,\n            inverted = chart.inverted,\n            plotTop = chart.plotTop,\n            plotLeft = chart.plotLeft,\n            plotX = 0,\n            plotY = 0,\n            yAxis,\n            xAxis;\n\n        points = splat(points);\n\n        // When tooltip follows mouse, relate the position to the mouse\n        if (this.followPointer && mouseEvent) {\n            if (mouseEvent.chartX === undefined) {\n                mouseEvent = pointer.normalize(mouseEvent);\n            }\n            ret = [\n                mouseEvent.chartX - chart.plotLeft,\n                mouseEvent.chartY - plotTop\n            ];\n        // Pie uses a special tooltipPos\n        } else if (points[0].tooltipPos) {\n            ret = points[0].tooltipPos;\n        // When shared, use the average position\n        } else {\n            each(points, function (point) {\n                yAxis = point.series.yAxis;\n                xAxis = point.series.xAxis;\n                plotX += point.plotX +\n                    (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                plotY +=\n                    (\n                        point.plotLow ?\n                            (point.plotLow + point.plotHigh) / 2 :\n                            point.plotY\n                    ) +\n                    (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n            });\n\n            plotX /= points.length;\n            plotY /= points.length;\n\n            ret = [\n                inverted ? chart.plotWidth - plotY : plotX,\n                this.shared && !inverted && points.length > 1 && mouseEvent ?\n                    // place shared tooltip next to the mouse (#424)\n                    mouseEvent.chartY - plotTop :\n                    inverted ? chart.plotHeight - plotX : plotY\n            ];\n        }\n\n        return map(ret, Math.round);\n    },\n\n    /**\n     * Place the tooltip in a chart without spilling over\n     * and not covering the point it self.\n     *\n     * @private\n     * @function Highcharts.Tooltip#getPosition\n     *\n     * @param {number} boxWidth\n     *\n     * @param {number} boxHeight\n     *\n     * @param {Highcharts.Point} point\n     *\n     * @return {*}\n     */\n    getPosition: function (boxWidth, boxHeight, point) {\n\n        var chart = this.chart,\n            distance = this.distance,\n            ret = {},\n            // Don't use h if chart isn't inverted (#7242)\n            h = (chart.inverted && point.h) || 0, // #4117\n            swapped,\n            outside = this.outside,\n            outerWidth = outside ?\n                // substract distance to prevent scrollbars\n                doc.documentElement.clientWidth - 2 * distance :\n                chart.chartWidth,\n            outerHeight = outside ?\n                Math.max(\n                    doc.body.scrollHeight,\n                    doc.documentElement.scrollHeight,\n                    doc.body.offsetHeight,\n                    doc.documentElement.offsetHeight,\n                    doc.documentElement.clientHeight\n                ) :\n                chart.chartHeight,\n            chartPosition = chart.pointer.chartPosition,\n            first = [\n                'y',\n                outerHeight,\n                boxHeight,\n                (outside ? chartPosition.top - distance : 0) +\n                    point.plotY + chart.plotTop,\n                outside ? 0 : chart.plotTop,\n                outside ? outerHeight : chart.plotTop + chart.plotHeight\n            ],\n            second = [\n                'x',\n                outerWidth,\n                boxWidth,\n                (outside ? chartPosition.left - distance : 0) +\n                    point.plotX + chart.plotLeft,\n                outside ? 0 : chart.plotLeft,\n                outside ? outerWidth : chart.plotLeft + chart.plotWidth\n            ],\n            // The far side is right or bottom\n            preferFarSide = !this.followPointer && pick(\n                point.ttBelow,\n                !chart.inverted === !!point.negative\n            ), // #4984\n\n            /*\n             * Handle the preferred dimension. When the preferred dimension is\n             * tooltip on top or bottom of the point, it will look for space\n             * there.\n             *\n             * @private\n             */\n            firstDimension = function (\n                dim,\n                outerSize,\n                innerSize,\n                point,\n                min,\n                max\n            ) {\n                var roomLeft = innerSize < point - distance,\n                    roomRight = point + distance + innerSize < outerSize,\n                    alignedLeft = point - distance - innerSize,\n                    alignedRight = point + distance;\n\n                if (preferFarSide && roomRight) {\n                    ret[dim] = alignedRight;\n                } else if (!preferFarSide && roomLeft) {\n                    ret[dim] = alignedLeft;\n                } else if (roomLeft) {\n                    ret[dim] = Math.min(\n                        max - innerSize,\n                        alignedLeft - h < 0 ? alignedLeft : alignedLeft - h\n                    );\n                } else if (roomRight) {\n                    ret[dim] = Math.max(\n                        min,\n                        alignedRight + h + innerSize > outerSize ?\n                            alignedRight :\n                            alignedRight + h\n                    );\n                } else {\n                    return false;\n                }\n            },\n\n            /*\n             * Handle the secondary dimension. If the preferred dimension is\n             * tooltip on top or bottom of the point, the second dimension is to\n             * align the tooltip above the point, trying to align center but\n             * allowing left or right align within the chart box.\n             *\n             * @private\n             */\n            secondDimension = function (dim, outerSize, innerSize, point) {\n                var retVal;\n\n                // Too close to the edge, return false and swap dimensions\n                if (point < distance || point > outerSize - distance) {\n                    retVal = false;\n                // Align left/top\n                } else if (point < innerSize / 2) {\n                    ret[dim] = 1;\n                // Align right/bottom\n                } else if (point > outerSize - innerSize / 2) {\n                    ret[dim] = outerSize - innerSize - 2;\n                // Align center\n                } else {\n                    ret[dim] = point - innerSize / 2;\n                }\n                return retVal;\n            },\n\n            /*\n             * Swap the dimensions\n             */\n            swap = function (count) {\n                var temp = first;\n                first = second;\n                second = temp;\n                swapped = count;\n            },\n            run = function () {\n                if (firstDimension.apply(0, first) !== false) {\n                    if (\n                        secondDimension.apply(0, second) === false &&\n                        !swapped\n                    ) {\n                        swap(true);\n                        run();\n                    }\n                } else if (!swapped) {\n                    swap(true);\n                    run();\n                } else {\n                    ret.x = ret.y = 0;\n                }\n            };\n\n        // Under these conditions, prefer the tooltip on the side of the point\n        if (chart.inverted || this.len > 1) {\n            swap();\n        }\n        run();\n\n        return ret;\n\n    },\n\n    /**\n     * In case no user defined formatter is given, this will be used. Note that\n     * the context here is an object holding point, series, x, y etc.\n     *\n     * @private\n     * @function Highcharts.Tooltip#defaultFormatter\n     *\n     * @param {Highcharts.Tooltip} tooltip\n     *\n     * @return {Array<string>}\n     */\n    defaultFormatter: function (tooltip) {\n        var items = this.points || splat(this),\n            s;\n\n        // Build the header\n        s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n\n        // build the values\n        s = s.concat(tooltip.bodyFormatter(items));\n\n        // footer\n        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n\n        return s;\n    },\n\n    /**\n     * Refresh the tooltip's text and position.\n     *\n     * @function Highcharts.Tooltip#refresh\n     *\n     * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n     *        Either a point or an array of points.\n     *\n     * @param {global.Event} [mouseEvent]\n     *        Mouse event, that is responsible for the refresh and should be\n     *        used for the tooltip update.\n     */\n    refresh: function (pointOrPoints, mouseEvent) {\n        var tooltip = this,\n            label,\n            options = tooltip.options,\n            x,\n            y,\n            point = pointOrPoints,\n            anchor,\n            textConfig = {},\n            text,\n            pointConfig = [],\n            formatter = options.formatter || tooltip.defaultFormatter,\n            shared = tooltip.shared,\n            currentSeries;\n\n        if (!options.enabled) {\n            return;\n        }\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout(this.hideTimer);\n\n        // get the reference point coordinates (pie charts use tooltipPos)\n        tooltip.followPointer = splat(point)[0].series.tooltipOptions\n            .followPointer;\n        anchor = tooltip.getAnchor(point, mouseEvent);\n        x = anchor[0];\n        y = anchor[1];\n\n        // shared tooltip, array is sent over\n        if (shared && !(point.series && point.series.noSharedTooltip)) {\n            each(point, function (item) {\n                item.setState('hover');\n\n                pointConfig.push(item.getLabelConfig());\n            });\n\n            textConfig = {\n                x: point[0].category,\n                y: point[0].y\n            };\n            textConfig.points = pointConfig;\n            point = point[0];\n\n        // single point tooltip\n        } else {\n            textConfig = point.getLabelConfig();\n        }\n        this.len = pointConfig.length; // #6128\n        text = formatter.call(textConfig, tooltip);\n\n        // register the current series\n        currentSeries = point.series;\n        this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n        // update the inner HTML\n        if (text === false) {\n            this.hide();\n        } else {\n\n            label = tooltip.getLabel();\n\n            // show it\n            if (tooltip.isHidden) {\n                label.attr({\n                    opacity: 1\n                }).show();\n            }\n\n            // update text\n            if (tooltip.split) {\n                this.renderSplit(text, splat(pointOrPoints));\n            } else {\n\n                // Prevent the tooltip from flowing over the chart box (#6659)\n                \n                    label.css({\n                        width: this.chart.spacingBox.width\n                    });\n                \n\n                label.attr({\n                    text: text && text.join ? text.join('') : text\n                });\n\n                // Set the stroke color of the box to reflect the point\n                label.removeClass(/highcharts-color-[\\d]+/g)\n                    .addClass(\n                        'highcharts-color-' +\n                        pick(point.colorIndex, currentSeries.colorIndex)\n                    );\n\n                \n\n                tooltip.updatePosition({\n                    plotX: x,\n                    plotY: y,\n                    negative: point.negative,\n                    ttBelow: point.ttBelow,\n                    h: anchor[2] || 0\n                });\n            }\n\n            this.isHidden = false;\n        }\n    },\n\n    /**\n     * Render the split tooltip. Loops over each point's text and adds\n     * a label next to the point, then uses the distribute function to\n     * find best non-overlapping positions.\n     *\n     * @private\n     * @function Highcharts.Tooltip#renderSplit\n     *\n     * @param {Array<Highcharts.Label>} labels\n     *\n     * @param {Array<Highcharts.Point>} points\n     */\n    renderSplit: function (labels, points) {\n        var tooltip = this,\n            boxes = [],\n            chart = this.chart,\n            ren = chart.renderer,\n            rightAligned = true,\n            options = this.options,\n            headerHeight = 0,\n            headerTop,\n            tooltipLabel = this.getLabel(),\n            distributionBoxTop = chart.plotTop;\n\n        // Graceful degradation for legacy formatters\n        if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(labels)) {\n            labels = [false, labels];\n        }\n        // Create the individual labels for header and points, ignore footer\n        each(labels.slice(0, points.length + 1), function (str, i) {\n            if (str !== false) {\n                var point = points[i - 1] ||\n                        // Item 0 is the header. Instead of this, we could also\n                        // use the crosshair label\n                        { isHeader: true, plotX: points[0].plotX },\n                    owner = point.series || tooltip,\n                    tt = owner.tt,\n                    series = point.series || {},\n                    colorClass = 'highcharts-color-' + pick(\n                        point.colorIndex,\n                        series.colorIndex,\n                        'none'\n                    ),\n                    target,\n                    x,\n                    bBox,\n                    boxWidth;\n\n                // Store the tooltip referance on the series\n                if (!tt) {\n                    owner.tt = tt = ren.label(\n                            null,\n                            null,\n                            null,\n                            'callout',\n                            null,\n                            null,\n                            options.useHTML\n                        )\n                        .addClass(\n                            'highcharts-tooltip-box ' + colorClass +\n                            (point.isHeader ? ' highcharts-tooltip-header' : '')\n                        )\n                        .attr({\n                            'padding': options.padding,\n                            'r': options.borderRadius\n                            \n                        })\n                        .add(tooltipLabel);\n                }\n\n                tt.isActive = true;\n                tt.attr({\n                    text: str\n                });\n                \n\n                // Get X position now, so we can move all to the other side in\n                // case of overflow\n                bBox = tt.getBBox();\n                boxWidth = bBox.width + tt.strokeWidth();\n                if (point.isHeader) {\n                    headerHeight = bBox.height;\n                    if (chart.xAxis[0].opposite) {\n                        headerTop = true;\n                        distributionBoxTop -= headerHeight;\n                    }\n                    x = Math.max(\n                        0, // No left overflow\n                        Math.min(\n                            point.plotX + chart.plotLeft - boxWidth / 2,\n                            // No right overflow (#5794)\n                            chart.chartWidth +\n                            (\n                                // Scrollable plot area\n                                chart.scrollablePixels ?\n                                    chart.scrollablePixels - chart.marginRight :\n                                    0\n                            ) -\n                            boxWidth\n                        )\n                    );\n                } else {\n                    x = point.plotX + chart.plotLeft -\n                        pick(options.distance, 16) - boxWidth;\n                }\n\n\n                // If overflow left, we don't use this x in the next loop\n                if (x < 0) {\n                    rightAligned = false;\n                }\n\n                // Prepare for distribution\n                target = (point.series && point.series.yAxis &&\n                    point.series.yAxis.pos) + (point.plotY || 0);\n                target -= distributionBoxTop;\n\n                if (point.isHeader) {\n                    target = headerTop ?\n                        -headerHeight :\n                        chart.plotHeight + headerHeight;\n                }\n                boxes.push({\n                    target: target,\n                    rank: point.isHeader ? 1 : 0,\n                    size: owner.tt.getBBox().height + 1,\n                    point: point,\n                    x: x,\n                    tt: tt\n                });\n            }\n        });\n\n        // Clean previous run (for missing points)\n        this.cleanSplit();\n\n        // Distribute and put in place\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].distribute(boxes, chart.plotHeight + headerHeight);\n        each(boxes, function (box) {\n            var point = box.point,\n                series = point.series;\n\n            // Put the label in place\n            box.tt.attr({\n                visibility: box.pos === undefined ? 'hidden' : 'inherit',\n                x: (rightAligned || point.isHeader ?\n                    box.x :\n                    point.plotX + chart.plotLeft + pick(options.distance, 16)),\n                y: box.pos + distributionBoxTop,\n                anchorX: point.isHeader ?\n                    point.plotX + chart.plotLeft :\n                    point.plotX + series.xAxis.pos,\n                anchorY: point.isHeader ?\n                    chart.plotTop + chart.plotHeight / 2 :\n                    point.plotY + series.yAxis.pos\n            });\n        });\n    },\n\n    /**\n     * Find the new position and perform the move\n     *\n     * @private\n     * @function Highcharts.Tooltip#updatePosition\n     *\n     * @param {Highcharts.Point} point\n     */\n    updatePosition: function (point) {\n        var chart = this.chart,\n            label = this.getLabel(),\n            pos = (this.options.positioner || this.getPosition).call(\n                this,\n                label.width,\n                label.height,\n                point\n            ),\n            anchorX = point.plotX + chart.plotLeft,\n            anchorY = point.plotY + chart.plotTop,\n            pad;\n\n        // Set the renderer size dynamically to prevent document size to change\n        if (this.outside) {\n            pad = (this.options.borderWidth || 0) + 2 * this.distance;\n            this.renderer.setSize(\n                label.width + pad,\n                label.height + pad,\n                false\n            );\n            anchorX += chart.pointer.chartPosition.left - pos.x;\n            anchorY += chart.pointer.chartPosition.top - pos.y;\n        }\n\n        // do the move\n        this.move(\n            Math.round(pos.x),\n            Math.round(pos.y || 0), // can be undefined (#3977)\n            anchorX,\n            anchorY\n        );\n    },\n\n    /**\n     * Get the optimal date format for a point, based on a range.\n     *\n     * @private\n     * @function Highcharts.Tooltip#getDateFormat\n     *\n     * @param {number} range\n     *        The time range\n     *\n     * @param {number|Date} date\n     *        The date of the point in question\n     *\n     * @param {number} startOfWeek\n     *        An integer representing the first day of the week, where 0 is\n     *        Sunday.\n     *\n     * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats\n     *        A map of time units to formats.\n     *\n     * @return {string}\n     *         The optimal date format for a point.\n     */\n    getDateFormat: function (range, date, startOfWeek, dateTimeLabelFormats) {\n        var time = this.chart.time,\n            dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),\n            format,\n            n,\n            blank = '01-01 00:00:00.000',\n            strpos = {\n                millisecond: 15,\n                second: 12,\n                minute: 9,\n                hour: 6,\n                day: 3\n            },\n            lastN = 'millisecond'; // for sub-millisecond data, #4223\n        for (n in timeUnits) {\n\n            // If the range is exactly one week and we're looking at a\n            // Sunday/Monday, go for the week format\n            if (\n                range === timeUnits.week &&\n                +time.dateFormat('%w', date) === startOfWeek &&\n                dateStr.substr(6) === blank.substr(6)\n            ) {\n                n = 'week';\n                break;\n            }\n\n            // The first format that is too great for the range\n            if (timeUnits[n] > range) {\n                n = lastN;\n                break;\n            }\n\n            // If the point is placed every day at 23:59, we need to show\n            // the minutes as well. #2637.\n            if (\n                strpos[n] &&\n                dateStr.substr(strpos[n]) !== blank.substr(strpos[n])\n            ) {\n                break;\n            }\n\n            // Weeks are outside the hierarchy, only apply them on\n            // Mondays/Sundays like in the first condition\n            if (n !== 'week') {\n                lastN = n;\n            }\n        }\n\n        if (n) {\n            format = dateTimeLabelFormats[n];\n        }\n\n        return format;\n    },\n\n    /**\n     * Get the best X date format based on the closest point range on the axis.\n     *\n     * @private\n     * @function Highcharts.Tooltip#getXDateFormat\n     *\n     * @param {Highcharts.Point} point\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *\n     * @param {Highcharts.Axis} xAxis\n     *\n     * @return {string}\n     */\n    getXDateFormat: function (point, options, xAxis) {\n        var xDateFormat,\n            dateTimeLabelFormats = options.dateTimeLabelFormats,\n            closestPointRange = xAxis && xAxis.closestPointRange;\n\n        if (closestPointRange) {\n            xDateFormat = this.getDateFormat(\n                closestPointRange,\n                point.x,\n                xAxis.options.startOfWeek,\n                dateTimeLabelFormats\n            );\n        } else {\n            xDateFormat = dateTimeLabelFormats.day;\n        }\n\n        return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n    },\n\n    /**\n     * Format the footer/header of the tooltip\n     * #3397: abstraction to enable formatting of footer and header\n     *\n     * @private\n     * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n     *\n     * @param {*} labelConfig\n     *\n     * @param {boolean} isFooter\n     *\n     * @return {string}\n     */\n    tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {\n        var footOrHead = isFooter ? 'footer' : 'header',\n            series = labelConfig.series,\n            tooltipOptions = series.tooltipOptions,\n            xDateFormat = tooltipOptions.xDateFormat,\n            xAxis = series.xAxis,\n            isDateTime = (\n                xAxis &&\n                xAxis.options.type === 'datetime' &&\n                isNumber(labelConfig.key)\n            ),\n            formatString = tooltipOptions[footOrHead + 'Format'];\n\n        // Guess the best date format based on the closest point distance (#568,\n        // #3418)\n        if (isDateTime && !xDateFormat) {\n            xDateFormat = this.getXDateFormat(\n                labelConfig,\n                tooltipOptions,\n                xAxis\n            );\n        }\n\n        // Insert the footer date format if any\n        if (isDateTime && xDateFormat) {\n            each(\n                (labelConfig.point && labelConfig.point.tooltipDateKeys) ||\n                    ['key'],\n                function (key) {\n                    formatString = formatString.replace(\n                        '{point.' + key + '}',\n                        '{point.' + key + ':' + xDateFormat + '}'\n                    );\n                }\n            );\n        }\n\n        return format(formatString, {\n            point: labelConfig,\n            series: series\n        }, this.chart.time);\n    },\n\n    /**\n     * Build the body (lines) of the tooltip by iterating over the items and\n     * returning one entry for each item, abstracting this functionality allows\n     * to easily overwrite and extend it.\n     *\n     * @private\n     * @function Highcharts.Tooltip#bodyFormatter\n     *\n     * @param {Array<Highcharts.Point>} items\n     *\n     * @return {string}\n     */\n    bodyFormatter: function (items) {\n        return map(items, function (item) {\n            var tooltipOptions = item.series.tooltipOptions;\n            return (\n                tooltipOptions[\n                    (item.point.formatPrefix || 'point') + 'Formatter'\n                ] ||\n                item.point.tooltipFormatter\n            ).call(\n                item.point,\n                tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']\n            );\n        });\n    }\n\n};\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Tooltip.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/TouchPointer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/TouchPointer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/* harmony import */ var _Utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utilities.js */ \"./node_modules/highcharts/js/es-modules/parts/Utilities.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n\n\n\n\n\nvar charts = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    each = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each,\n    extend = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend,\n    map = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map,\n    noop = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].noop,\n    pick = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick,\n    Pointer = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pointer;\n\n// Support for touch devices\nextend(Pointer.prototype, /** @lends Pointer.prototype */ {\n\n    /**\n     * Run translation operations\n     *\n     * @private\n     * @function Highcharts.Pointer#pinchTranslate\n     *\n     * @param {Array<*>} pinchDown\n     *\n     * @param {Array<*>} touches\n     *\n     * @param {*} transform\n     *\n     * @param {*} selectionMarker\n     *\n     * @param {*} clip\n     *\n     * @param {*} lastValidTouch\n     */\n    pinchTranslate: function (\n        pinchDown,\n        touches,\n        transform,\n        selectionMarker,\n        clip,\n        lastValidTouch\n    ) {\n        if (this.zoomHor) {\n            this.pinchTranslateDirection(\n                true,\n                pinchDown,\n                touches,\n                transform,\n                selectionMarker,\n                clip,\n                lastValidTouch\n            );\n        }\n        if (this.zoomVert) {\n            this.pinchTranslateDirection(\n                false,\n                pinchDown,\n                touches,\n                transform,\n                selectionMarker,\n                clip,\n                lastValidTouch\n            );\n        }\n    },\n\n    /**\n     * Run translation operations for each direction (horizontal and vertical)\n     * independently.\n     *\n     * @private\n     * @function Highcharts.Pointer#pinchTranslateDirection\n     *\n     * @param {boolean} horiz\n     *\n     * @param {Array<*>} pinchDown\n     *\n     * @param {Array<*>} touches\n     *\n     * @param {*} transform\n     *\n     * @param {*} selectionMarker\n     *\n     * @param {*} clip\n     *\n     * @param {*} lastValidTouch\n     *\n     * @param {number|undefined} [forcedScale=1]\n     */\n    pinchTranslateDirection: function (horiz, pinchDown, touches, transform,\n            selectionMarker, clip, lastValidTouch, forcedScale) {\n        var chart = this.chart,\n            xy = horiz ? 'x' : 'y',\n            XY = horiz ? 'X' : 'Y',\n            sChartXY = 'chart' + XY,\n            wh = horiz ? 'width' : 'height',\n            plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n            selectionWH,\n            selectionXY,\n            clipXY,\n            scale = forcedScale || 1,\n            inverted = chart.inverted,\n            bounds = chart.bounds[horiz ? 'h' : 'v'],\n            singleTouch = pinchDown.length === 1,\n            touch0Start = pinchDown[0][sChartXY],\n            touch0Now = touches[0][sChartXY],\n            touch1Start = !singleTouch && pinchDown[1][sChartXY],\n            touch1Now = !singleTouch && touches[1][sChartXY],\n            outOfBounds,\n            transformScale,\n            scaleKey,\n            setScale = function () {\n                // Don't zoom if fingers are too close on this axis\n                if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {\n                    scale = forcedScale ||\n                        Math.abs(touch0Now - touch1Now) /\n                        Math.abs(touch0Start - touch1Start);\n                }\n\n                clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] /\n                    scale;\n            };\n\n        // Set the scale, first pass\n        setScale();\n\n        // The clip position (x or y) is altered if out of bounds, the selection\n        // position is not\n        selectionXY = clipXY;\n\n        // Out of bounds\n        if (selectionXY < bounds.min) {\n            selectionXY = bounds.min;\n            outOfBounds = true;\n        } else if (selectionXY + selectionWH > bounds.max) {\n            selectionXY = bounds.max - selectionWH;\n            outOfBounds = true;\n        }\n\n        // Is the chart dragged off its bounds, determined by dataMin and\n        // dataMax?\n        if (outOfBounds) {\n\n            // Modify the touchNow position in order to create an elastic drag\n            // movement. This indicates to the user that the chart is responsive\n            // but can't be dragged further.\n            touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n            if (!singleTouch) {\n                touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n            }\n\n            // Set the scale, second pass to adapt to the modified touchNow\n            // positions\n            setScale();\n\n        } else {\n            lastValidTouch[xy] = [touch0Now, touch1Now];\n        }\n\n        // Set geometry for clipping, selection and transformation\n        if (!inverted) {\n            clip[xy] = clipXY - plotLeftTop;\n            clip[wh] = selectionWH;\n        }\n        scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n        transformScale = inverted ? 1 / scale : scale;\n\n        selectionMarker[wh] = selectionWH;\n        selectionMarker[xy] = selectionXY;\n        transform[scaleKey] = scale;\n        transform['translate' + XY] = (transformScale * plotLeftTop) +\n            (touch0Now - (transformScale * touch0Start));\n    },\n\n    /**\n     * Handle touch events with two touches\n     *\n     * @private\n     * @function Highcharts.Pointer#pinch\n     *\n     * @param {Highcharts.PointerEvent} e\n     */\n    pinch: function (e) {\n\n        var self = this,\n            chart = self.chart,\n            pinchDown = self.pinchDown,\n            touches = e.touches,\n            touchesLength = touches.length,\n            lastValidTouch = self.lastValidTouch,\n            hasZoom = self.hasZoom,\n            selectionMarker = self.selectionMarker,\n            transform = {},\n            fireClickEvent = touchesLength === 1 && (\n                (\n                    self.inClass(e.target, 'highcharts-tracker') &&\n                    chart.runTrackerClick\n                ) ||\n                self.runChartClick\n            ),\n            clip = {};\n\n        // Don't initiate panning until the user has pinched. This prevents us\n        // from blocking page scrolling as users scroll down a long page\n        // (#4210).\n        if (touchesLength > 1) {\n            self.initiated = true;\n        }\n\n        // On touch devices, only proceed to trigger click if a handler is\n        // defined\n        if (hasZoom && self.initiated && !fireClickEvent) {\n            e.preventDefault();\n        }\n\n        // Normalize each touch\n        map(touches, function (e) {\n            return self.normalize(e);\n        });\n\n        // Register the touch start position\n        if (e.type === 'touchstart') {\n            each(touches, function (e, i) {\n                pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n            });\n            lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] &&\n                pinchDown[1].chartX];\n            lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] &&\n                pinchDown[1].chartY];\n\n            // Identify the data bounds in pixels\n            each(chart.axes, function (axis) {\n                if (axis.zoomEnabled) {\n                    var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                        minPixelPadding = axis.minPixelPadding,\n                        min = axis.toPixels(\n                            pick(axis.options.min, axis.dataMin)\n                        ),\n                        max = axis.toPixels(\n                            pick(axis.options.max, axis.dataMax)\n                        ),\n                        absMin = Math.min(min, max),\n                        absMax = Math.max(min, max);\n\n                    // Store the bounds for use in the touchmove handler\n                    bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                    bounds.max = Math.max(\n                        axis.pos + axis.len,\n                        absMax + minPixelPadding\n                    );\n                }\n            });\n            self.res = true; // reset on next move\n\n        // Optionally move the tooltip on touchmove\n        } else if (self.followTouchMove && touchesLength === 1) {\n            this.runPointActions(self.normalize(e));\n\n        // Event type is touchmove, handle panning and pinching\n        } else if (pinchDown.length) { // can be 0 when releasing, if touchend\n                // fires first\n\n\n            // Set the marker\n            if (!selectionMarker) {\n                self.selectionMarker = selectionMarker = extend({\n                    destroy: noop,\n                    touch: true\n                }, chart.plotBox);\n            }\n\n            self.pinchTranslate(\n                pinchDown,\n                touches,\n                transform,\n                selectionMarker,\n                clip,\n                lastValidTouch\n            );\n\n            self.hasPinched = hasZoom;\n\n            // Scale and translate the groups to provide visual feedback during\n            // pinching\n            self.scaleGroups(transform, clip);\n\n            if (self.res) {\n                self.res = false;\n                this.reset(false, 0);\n            }\n        }\n    },\n\n    /**\n     * General touch handler shared by touchstart and touchmove.\n     *\n     * @private\n     * @function Highcharts.Pointer#touch\n     *\n     * @param {Highcharts.PointerEvent} e\n     *\n     * @param {boolean} start\n     */\n    touch: function (e, start) {\n        var chart = this.chart,\n            hasMoved,\n            pinchDown,\n            isInside;\n\n        if (chart.index !== _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex) {\n            this.onContainerMouseLeave({ relatedTarget: true });\n        }\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex = chart.index;\n\n        if (e.touches.length === 1) {\n\n            e = this.normalize(e);\n\n            isInside = chart.isInsidePlot(\n                e.chartX - chart.plotLeft,\n                e.chartY - chart.plotTop\n            );\n            if (isInside && !chart.openMenu) {\n\n                // Run mouse events and display tooltip etc\n                if (start) {\n                    this.runPointActions(e);\n                }\n\n                // Android fires touchmove events after the touchstart even if\n                // the finger hasn't moved, or moved only a pixel or two. In iOS\n                // however, the touchmove doesn't fire unless the finger moves\n                // more than ~4px. So we emulate this behaviour in Android by\n                // checking how much it moved, and cancelling on small\n                // distances. #3450.\n                if (e.type === 'touchmove') {\n                    pinchDown = this.pinchDown;\n                    hasMoved = pinchDown[0] ? Math.sqrt( // #5266\n                        Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                        Math.pow(pinchDown[0].chartY - e.chartY, 2)\n                    ) >= 4 : false;\n                }\n\n                if (pick(hasMoved, true)) {\n                    this.pinch(e);\n                }\n\n            } else if (start) {\n                // Hide the tooltip on touching outside the plot area (#1203)\n                this.reset();\n            }\n\n        } else if (e.touches.length === 2) {\n            this.pinch(e);\n        }\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerTouchStart\n     *\n     * @param {Highcharts.PointerEvent} e\n     */\n    onContainerTouchStart: function (e) {\n        this.zoomOption(e);\n        this.touch(e, true);\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerTouchMove\n     *\n     * @param {Highcharts.PointerEvent} e\n     */\n    onContainerTouchMove: function (e) {\n        this.touch(e);\n    },\n\n    /**\n     * @private\n     * @function Highcharts.Pointer#onDocumentTouchEnd\n     *\n     * @param {Highcharts.PointerEvent} e\n     */\n    onDocumentTouchEnd: function (e) {\n        if (charts[_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex]) {\n            charts[_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hoverChartIndex].pointer.drop(e);\n        }\n    }\n\n});\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/TouchPointer.js?");

/***/ }),

/***/ "./node_modules/highcharts/js/es-modules/parts/Utilities.js":
/*!******************************************************************!*\
  !*** ./node_modules/highcharts/js/es-modules/parts/Utilities.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globals.js */ \"./node_modules/highcharts/js/es-modules/parts/Globals.js\");\n/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/**\n * Reference to the global SVGElement class as a workaround for a name conflict\n * in the Highcharts namespace.\n *\n * @typedef {global.SVGElement} GlobalSVGElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * An animation configuration. Animation configurations can also be defined as\n * booleans, where `false` turns off animation and `true` defaults to a duration\n * of 500ms.\n *\n * @typedef Highcharts.AnimationOptionsObject\n *\n * @property {number} duration\n *           The animation duration in milliseconds.\n *\n * @property {string} [easing]\n *           The name of an easing function as defined on the `Math` object.\n *\n * @property {Function} [complete]\n *           A callback function to exectute when the animation finishes.\n *\n * @property {Function} [step]\n *           A callback function to execute on each step of each attribute or\n *           CSS property that's being animated. The first argument contains\n *           information about the animation and progress.\n */\n\n/**\n * A style object with camel case property names to define visual appearance of\n * a SVG element or HTML element. The properties can be whatever styles are\n * supported on the given SVG or HTML element.\n *\n * @example\n * {\n *    fontFamily: 'monospace',\n *    fontSize: '1.2em'\n * }\n *\n * @typedef Highcharts.CSSObject\n *\n * @property {boolean|number|string|undefined} [key:string]\n *\n * @property {string} [background]\n *           Background style for the element.\n *\n * @property {Highcharts.ColorString} [backgroundColor]\n *           Background color of the element.\n *\n * @property {string} [border]\n *           Border style for the element.\n *\n * @property {number} [borderRadius]\n *           Radius of the element border.\n *\n * @property {\"contrast\"|Highcharts.ColorString} [color]\n *           Color used in the element. The \"contrast\" option is a Highcharts\n *           custom property that results in black or white, depending on the\n *           background of the element.\n *\n * @property {string} [cursor]\n *           Style of the mouse cursor when resting over the element.\n *\n * @property {string} [fontFamily]\n *           Font family of the element text. Multiple values have to be in\n *           decreasing preference order and separated by comma.\n *\n * @property {string} [fontSize]\n *           Font size of the element text.\n *\n * @property {string} [fontWeight]\n *           Font weight of the element text.\n *\n * @property {number} [height]\n *           Height of the element.\n *\n * @property {number} [lineWidth]\n *           Width of the element border.\n *\n * @property {number} [opacity]\n *           Opacity of the element.\n *\n * @property {string} [padding]\n *           Space around the element content.\n *\n * @property {string} [pointerEvents]\n *           Behaviour of the element when the mouse cursor rests over it.\n *\n * @property {string} [position]\n *           Positioning of the element.\n *\n * @property {string} [textAlign]\n *           Alignment of the element text.\n *\n * @property {string} [textOutline]\n *           Outline style of the element text.\n *\n * @property {string} [textDecoration]\n *           Additional decoration of the element text.\n *\n * @property {string} [textOverflow]\n *           Line break style of the element text. Highcharts SVG elements\n *           support `ellipsis` when a `width` is set.\n *\n * @property {string} [transition]\n *           Animated transition of selected element properties.\n *\n * @property {string} [top]\n *           Top spacing of the element relative to the parent element.\n *\n * @property {string} [whiteSpace]\n *           Line break style of the element text.\n *\n * @property {number} [width]\n *           Width of the element.\n */\n\n/**\n * Generic dictionary in TypeScript notation.\n *\n * @typedef Highcharts.Dictionary<T>\n *\n * @property {T} [key:string]\n */\n\n/**\n * An object of key-value pairs for HTML attributes.\n *\n * @typedef {Highcharts.Dictionary<boolean|number|string>} Highcharts.HTMLAttributes\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.EachCallbackFunction<T>\n *\n * @param {T} item\n *        The array item.\n *\n * @param {number} index\n *        The item's index in the array.\n *\n * @param {Array<T>} arr\n *        The array that each is being applied to.\n */\n\n/**\n * The function callback to execute when the event is fired. The `this` context\n * contains the instance, that fired the event.\n *\n * @callback Highcharts.EventCallbackFunction\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Event arguments.\n */\n\n/**\n * Formats data as a string. Usually the data is accessible throught the `this`\n * keyword.\n *\n * @callback Highcharts.FormatterCallbackFunction\n *\n * @return {string}\n */\n\n/**\n * An HTML DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.HTMLElement} Highcharts.HTMLDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n */\n\n/**\n * The iterator callback.\n *\n * @callback Highcharts.ObjectEachCallbackFunction\n *\n * @param {*} value\n *        The property value.\n *\n * @param {string} key\n *        The property key.\n *\n * @param {*} obj\n *        The object that objectEach is being applied to.\n */\n\n/**\n * An object containing `left` and `top` properties for the position in the\n * page.\n *\n * @typedef Highcharts.OffsetObject\n *\n * @property {number} left\n *           Left distance to the page border.\n *\n * @property {number} top\n *           Top distance to the page border.\n */\n\n/**\n * An object containing `x` and `y` properties for the position of an element.\n *\n * @typedef Highcharts.PositionObject\n *\n * @property {number} x\n *           X position of the element.\n *\n * @property {number} y\n *           Y position of the element.\n */\n\n/**\n * If a number is given, it defines the pixel length. If a percentage string is\n * given, like for example `'50%'`, the setting defines a length relative to a\n * base size, for example the size of a container.\n *\n * @typedef {number|string} Highcharts.RelativeSize\n */\n\n/**\n * An object of key-value pairs for SVG attributes. Attributes in Highcharts\n * elements for the most parts correspond to SVG, but some are specific to\n * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,\n * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n * attributes containing a hyphen are _not_ camel-cased, they should be\n * quoted to preserve the hyphen.\n *\n * @example\n * {\n *     'stroke': '#ff0000', // basic\n *     'stroke-width': 2, // hyphenated\n *     'rotation': 45 // custom\n *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n * }\n *\n * @typedef Highcharts.SVGAttributes\n *\n * @property {boolean|number|string|Array<any>|undefined} [key:string]\n *\n * @property {string|Highcharts.SVGPathArray} [d]\n *\n * @property {boolean} [inverted]\n *\n * @property {Array<number>} [matrix]\n *\n * @property {Highcharts.ColorString} [stroke]\n *\n * @property {string} [rotation]\n *\n * @property {number} [rotationOriginX]\n *\n * @property {number} [rotationOriginY]\n *\n * @property {number} [scaleX]\n *\n * @property {number} [scaleY]\n *\n * @property {number} [translateX]\n *\n * @property {number} [translateY]\n *\n * @property {number} [zIndex]\n */\n\n/**\n * An SVG DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {global.GlobalSVGElement} Highcharts.SVGDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n\n/**\n * Array of path commands, that will go into the `d` attribute of an SVG\n * element.\n *\n * @typedef {Array<number|Highcharts.SVGPathCommand>} Highcharts.SVGPathArray\n */\n\n/**\n * Possible path commands in a SVG path array.\n *\n * @typedef {string} Highcharts.SVGPathCommand\n * @validvalue [\"a\",\"c\",\"h\",\"l\",\"m\",\"q\",\"s\",\"t\",\"v\",\"z\",\"A\",\"C\",\"H\",\"L\",\"M\",\"Q\",\"S\",\"T\",\"V\",\"Z\"]\n */\n\n\n\n\n\n/**\n * The Highcharts object is the placeholder for all other members, and various\n * utility functions. The most important member of the namespace would be the\n * chart constructor.\n *\n * @example\n * var chart = Highcharts.chart('container', { ... });\n *\n * @namespace Highcharts\n */\n\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers = [];\n\nvar charts = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charts,\n    doc = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].doc,\n    win = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].win;\n\n/**\n * Provide error messages for debugging, with links to online explanation. This\n * function can be overridden to provide custom error handling.\n *\n * @sample highcharts/chart/highcharts-error/\n *         Custom error handler\n *\n * @function Highcharts.error\n *\n * @param {number|string} code\n *        The error code. See\n *        [errors.xml]{@link https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}\n *        for available codes. If it is a string, the error message is printed\n *        directly in the console.\n *\n * @param {boolean} [stop=false]\n *        Whether to throw an error or just log a warning in the console.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error = function (code, stop) {\n    var msg = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(code) ?\n        'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :\n        code;\n    if (stop) {\n        throw new Error(msg);\n    }\n    // else ...\n    if (win.console) {\n        console.log(msg); // eslint-disable-line no-console\n    }\n};\n\n/**\n * An animator object used internally. One instance applies to one property\n * (attribute or style prop) on one element. Animation is always initiated\n * through {@link SVGElement#animate}.\n *\n * @example\n * var rect = renderer.rect(0, 0, 10, 10).add();\n * rect.animate({ width: 100 });\n *\n * @private\n * @class Highcharts.Fx\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem\n *        The element to animate.\n *\n * @param {Highcharts.AnimationOptionsObject} options\n *        Animation options.\n *\n * @param {string} prop\n *        The single attribute or CSS property to animate.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx = function (elem, options, prop) {\n    this.options = options;\n    this.elem = elem;\n    this.prop = prop;\n};\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx.prototype = {\n\n    /**\n     * Set the current step of a path definition on SVGElement.\n     *\n     * @function Highcharts.Fx#dSetter\n     */\n    dSetter: function () {\n        var start = this.paths[0],\n            end = this.paths[1],\n            ret = [],\n            now = this.now,\n            i = start.length,\n            startVal;\n\n        // Land on the final path without adjustment points appended in the ends\n        if (now === 1) {\n            ret = this.toD;\n\n        } else if (i === end.length && now < 1) {\n            while (i--) {\n                startVal = parseFloat(start[i]);\n                ret[i] =\n                    isNaN(startVal) ? // a letter instruction like M or L\n                            end[i] :\n                            now * (parseFloat(end[i] - startVal)) + startVal;\n\n            }\n        // If animation is finished or length not matching, land on right value\n        } else {\n            ret = end;\n        }\n        this.elem.attr('d', ret, null, true);\n    },\n\n    /**\n     * Update the element with the current animation step.\n     *\n     * @function Highcharts.Fx#update\n     */\n    update: function () {\n        var elem = this.elem,\n            prop = this.prop, // if destroyed, it is null\n            now = this.now,\n            step = this.options.step;\n\n        // Animation setter defined from outside\n        if (this[prop + 'Setter']) {\n            this[prop + 'Setter']();\n\n        // Other animations on SVGElement\n        } else if (elem.attr) {\n            if (elem.element) {\n                elem.attr(prop, now, null, true);\n            }\n\n        // HTML styles, raw HTML content like container size\n        } else {\n            elem.style[prop] = now + this.unit;\n        }\n\n        if (step) {\n            step.call(elem, now, this);\n        }\n\n    },\n\n    /**\n     * Run an animation.\n     *\n     * @function Highcharts.Fx#run\n     *\n     * @param {number} from\n     *        The current value, value to start from.\n     *\n     * @param {number} to\n     *        The end value, value to land on.\n     *\n     * @param {string} [unit]\n     *        The property unit, for example `px`.\n     */\n    run: function (from, to, unit) {\n        var self = this,\n            options = self.options,\n            timer = function (gotoEnd) {\n                return timer.stopped ? false : self.step(gotoEnd);\n            },\n            requestAnimationFrame =\n                win.requestAnimationFrame ||\n                function (step) {\n                    setTimeout(step, 13);\n                },\n            step = function () {\n                for (var i = 0; i < _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers.length; i++) {\n                    if (!_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers[i]()) {\n                        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers.splice(i--, 1);\n                    }\n                }\n\n                if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers.length) {\n                    requestAnimationFrame(step);\n                }\n            };\n\n        if (from === to && !this.elem['forceAnimate:' + this.prop]) {\n            delete options.curAnim[this.prop];\n            if (options.complete && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keys(options.curAnim).length === 0) {\n                options.complete.call(this.elem);\n            }\n        } else { // #7166\n            this.startTime = +new Date();\n            this.start = from;\n            this.end = to;\n            this.unit = unit;\n            this.now = this.start;\n            this.pos = 0;\n\n            timer.elem = this.elem;\n            timer.prop = this.prop;\n\n            if (timer() && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers.push(timer) === 1) {\n                requestAnimationFrame(step);\n            }\n        }\n    },\n\n    /**\n     * Run a single step in the animation.\n     *\n     * @function Highcharts.Fx#step\n     *\n     * @param {boolean} [gotoEnd]\n     *        Whether to go to the endpoint of the animation after abort.\n     *\n     * @return {boolean}\n     *         Returns `true` if animation continues.\n     */\n    step: function (gotoEnd) {\n        var t = +new Date(),\n            ret,\n            done,\n            options = this.options,\n            elem = this.elem,\n            complete = options.complete,\n            duration = options.duration,\n            curAnim = options.curAnim;\n\n        if (elem.attr && !elem.element) { // #2616, element is destroyed\n            ret = false;\n\n        } else if (gotoEnd || t >= duration + this.startTime) {\n            this.now = this.end;\n            this.pos = 1;\n            this.update();\n\n            curAnim[this.prop] = true;\n\n            done = true;\n\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(curAnim, function (val) {\n                if (val !== true) {\n                    done = false;\n                }\n            });\n\n            if (done && complete) {\n                complete.call(elem);\n            }\n            ret = false;\n\n        } else {\n            this.pos = options.easing((t - this.startTime) / duration);\n            this.now = this.start + ((this.end - this.start) * this.pos);\n            this.update();\n            ret = true;\n        }\n        return ret;\n    },\n\n    /**\n     * Prepare start and end values so that the path can be animated one to one.\n     *\n     * @function Highcharts.Fx#initPath\n     *\n     * @param {Highcharts.SVGElement} elem\n     *        The SVGElement item.\n     *\n     * @param {string} fromD\n     *        Starting path definition.\n     *\n     * @param {Highcharts.SVGPathArray} toD\n     *        Ending path definition.\n     *\n     * @return {Array<Highcharts.SVGPathArray>}\n     *         An array containing start and end paths in array form so that\n     *         they can be animated in parallel.\n     */\n    initPath: function (elem, fromD, toD) {\n        fromD = fromD || '';\n        var shift,\n            startX = elem.startX,\n            endX = elem.endX,\n            bezier = fromD.indexOf('C') > -1,\n            numParams = bezier ? 7 : 3,\n            fullLength,\n            slice,\n            i,\n            start = fromD.split(' '),\n            end = toD.slice(), // copy\n            isArea = elem.isArea,\n            positionFactor = isArea ? 2 : 1,\n            reverse;\n\n        /**\n         * In splines make moveTo and lineTo points have six parameters like\n         * bezier curves, to allow animation one-to-one.\n         */\n        function sixify(arr) {\n            var isOperator,\n                nextIsOperator;\n            i = arr.length;\n            while (i--) {\n\n                // Fill in dummy coordinates only if the next operator comes\n                // three places behind (#5788)\n                isOperator = arr[i] === 'M' || arr[i] === 'L';\n                nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);\n                if (isOperator && nextIsOperator) {\n                    arr.splice(\n                        i + 1, 0,\n                        arr[i + 1], arr[i + 2],\n                        arr[i + 1], arr[i + 2]\n                    );\n                }\n            }\n        }\n\n        /**\n         * Insert an array at the given position of another array\n         */\n        function insertSlice(arr, subArr, index) {\n            [].splice.apply(\n                arr,\n                [index, 0].concat(subArr)\n            );\n        }\n\n        /**\n         * If shifting points, prepend a dummy point to the end path.\n         */\n        function prepend(arr, other) {\n            while (arr.length < fullLength) {\n\n                // Move to, line to or curve to?\n                arr[0] = other[fullLength - arr.length];\n\n                // Prepend a copy of the first point\n                insertSlice(arr, arr.slice(0, numParams), 0);\n\n                // For areas, the bottom path goes back again to the left, so we\n                // need to append a copy of the last point.\n                if (isArea) {\n                    insertSlice(\n                        arr,\n                        arr.slice(arr.length - numParams), arr.length\n                    );\n                    i--;\n                }\n            }\n            arr[0] = 'M';\n        }\n\n        /**\n         * Copy and append last point until the length matches the end length.\n         */\n        function append(arr, other) {\n            var i = (fullLength - arr.length) / numParams;\n            while (i > 0 && i--) {\n\n                // Pull out the slice that is going to be appended or inserted.\n                // In a line graph, the positionFactor is 1, and the last point\n                // is sliced out. In an area graph, the positionFactor is 2,\n                // causing the middle two points to be sliced out, since an area\n                // path starts at left, follows the upper path then turns and\n                // follows the bottom back.\n                slice = arr.slice().splice(\n                    (arr.length / positionFactor) - numParams,\n                    numParams * positionFactor\n                );\n\n                // Move to, line to or curve to?\n                slice[0] = other[fullLength - numParams - (i * numParams)];\n\n                // Disable first control point\n                if (bezier) {\n                    slice[numParams - 6] = slice[numParams - 2];\n                    slice[numParams - 5] = slice[numParams - 1];\n                }\n\n                // Now insert the slice, either in the middle (for areas) or at\n                // the end (for lines)\n                insertSlice(arr, slice, arr.length / positionFactor);\n\n                if (isArea) {\n                    i--;\n                }\n            }\n        }\n\n        if (bezier) {\n            sixify(start);\n            sixify(end);\n        }\n\n        // For sideways animation, find out how much we need to shift to get the\n        // start path Xs to match the end path Xs.\n        if (startX && endX) {\n            for (i = 0; i < startX.length; i++) {\n                // Moving left, new points coming in on right\n                if (startX[i] === endX[0]) {\n                    shift = i;\n                    break;\n                // Moving right\n                } else if (startX[0] ===\n                        endX[endX.length - startX.length + i]) {\n                    shift = i;\n                    reverse = true;\n                    break;\n                }\n            }\n            if (shift === undefined) {\n                start = [];\n            }\n        }\n\n        if (start.length && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(shift)) {\n\n            // The common target length for the start and end array, where both\n            // arrays are padded in opposite ends\n            fullLength = end.length + shift * positionFactor * numParams;\n\n            if (!reverse) {\n                prepend(end, start);\n                append(start, end);\n            } else {\n                prepend(start, end);\n                append(end, start);\n            }\n        }\n\n        return [start, end];\n    },\n\n    /**\n     * Handle animation of the color attributes directly.\n     *\n     * @function Highcharts.Fx#fillSetter\n     */\n    fillSetter: function () {\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx.prototype.strokeSetter.apply(this, arguments);\n    },\n\n    /**\n     * Handle animation of the color attributes directly.\n     *\n     * @function Highcharts.Fx#strokeSetter\n     */\n    strokeSetter: function () {\n        this.elem.attr(\n            this.prop,\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(this.start).tweenTo(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].color(this.end), this.pos),\n            null,\n            true\n        );\n    }\n\n}; // End of Fx prototype\n\n\n\n/**\n * Utility function to deep merge two or more objects and return a third object.\n * The merge function can also be used with a single object argument to create a\n * deep copy of an object.\n *\n * @function Highcharts.merge\n *\n * @param {*} a\n *        The first object to extend. When only this is given, the function\n *        returns a deep copy.\n *\n * @param {*} [n]\n *        An object to merge into the previous one.\n *\n * @return {*}\n *         The merged object. If the first argument is true, the return is the\n *         same as the second argument.\n *//**\n * Utility function to deep merge two or more objects and return a third object.\n * If the first argument is true, the contents of the second object is copied\n * into the first object. The merge function can also be used with a single\n * object argument to create a deep copy of an object.\n *\n * @function Highcharts.merge\n *\n * @param {boolean} extend\n *        Whether to extend the left-side object (a) or return a whole new\n *        object.\n *\n * @param {*} a\n *        The first object to extend. When only this is given, the function\n *        returns a deep copy.\n *\n * @param {*} [n]\n *        An object to merge into the previous one.\n *\n * @return {*}\n *         The merged object. If the first argument is true, the return is the\n *         same as the second argument.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge = function () {\n    var i,\n        args = arguments,\n        len,\n        ret = {},\n        doCopy = function (copy, original) {\n            // An object is replacing a primitive\n            if (typeof copy !== 'object') {\n                copy = {};\n            }\n\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(original, function (value, key) {\n\n                // Copy the contents of objects, but not arrays or DOM nodes\n                if (\n                        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(value, true) &&\n                        !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isClass(value) &&\n                        !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDOMElement(value)\n                ) {\n                    copy[key] = doCopy(copy[key] || {}, value);\n\n                // Primitives and arrays are copied over directly\n                } else {\n                    copy[key] = original[key];\n                }\n            });\n            return copy;\n        };\n\n    // If first argument is true, copy into the existing object. Used in\n    // setOptions.\n    if (args[0] === true) {\n        ret = args[1];\n        args = Array.prototype.slice.call(args, 2);\n    }\n\n    // For each argument, extend the return\n    len = args.length;\n    for (i = 0; i < len; i++) {\n        ret = doCopy(ret, args[i]);\n    }\n\n    return ret;\n};\n\n/**\n * Shortcut for parseInt\n *\n * @private\n * @function Highcharts.pInt\n *\n * @param {*} s\n *\n * @param {number} mag\n *        Magnitude\n *\n * @return {number}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt = function (s, mag) {\n    return parseInt(s, mag || 10);\n};\n\n/**\n * Utility function to check for string type.\n *\n * @function Highcharts.isString\n *\n * @param {*} s\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a string.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString = function (s) {\n    return typeof s === 'string';\n};\n\n/**\n * Utility function to check if an item is an array.\n *\n * @function Highcharts.isArray\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an array.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray = function (obj) {\n    var str = Object.prototype.toString.call(obj);\n    return str === '[object Array]' || str === '[object Array Iterator]';\n};\n\n/**\n * Utility function to check if an item is of type object.\n *\n * @function Highcharts.isObject\n *\n * @param {*} obj\n *        The item to check.\n *\n * @param {boolean} [strict=false]\n *        Also checks that the object is not an array.\n *\n * @return {boolean}\n *         True if the argument is an object.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject = function (obj, strict) {\n    return !!obj && typeof obj === 'object' && (!strict || !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(obj));\n};\n\n/**\n * Utility function to check if an Object is a HTML Element.\n *\n * @function Highcharts.isDOMElement\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is a HTML Element.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDOMElement = function (obj) {\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(obj) && typeof obj.nodeType === 'number';\n};\n\n/**\n * Utility function to check if an Object is an class.\n *\n * @function Highcharts.isClass\n *\n * @param {*} obj\n *        The item to check.\n *\n * @return {boolean}\n *         True if the argument is an class.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isClass = function (obj) {\n    var c = obj && obj.constructor;\n    return !!(\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(obj, true) &&\n        !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDOMElement(obj) &&\n        (c && c.name && c.name !== 'Object')\n    );\n};\n\n/**\n * Utility function to check if an item is a number and it is finite (not NaN,\n * Infinity or -Infinity).\n *\n * @function Highcharts.isNumber\n *\n * @param {*} n\n *        The item to check.\n *\n * @return {boolean}\n *         True if the item is a finite number\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber = function (n) {\n    return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;\n};\n\n/**\n * Remove the last occurence of an item from an array.\n *\n * @function Highcharts.erase\n *\n * @param {Array} arr\n *        The array.\n *\n * @param {*} item\n *        The item to remove.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].erase = function (arr, item) {\n    var i = arr.length;\n    while (i--) {\n        if (arr[i] === item) {\n            arr.splice(i, 1);\n            break;\n        }\n    }\n};\n\n/**\n * Check if an object is null or undefined.\n *\n * @function Highcharts.defined\n *\n * @param {*} obj\n *        The object to check.\n *\n * @return {boolean}\n *         False if the object is null or undefined, otherwise true.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined = function (obj) {\n    return obj !== undefined && obj !== null;\n};\n\n/**\n * Set or get an attribute or an object of attributes. To use as a setter, pass\n * a key and a value, or let the second argument be a collection of keys and\n * values. To use as a getter, pass only a string as the second argument.\n *\n * @function Highcharts.attr\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem\n *        The DOM element to receive the attribute(s).\n *\n * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [prop]\n *        The property or an object of key-value pairs.\n *\n * @param {string} [value]\n *        The value if a single property is set.\n *\n * @return {*}\n *         When used as a getter, return the value.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].attr = function (elem, prop, value) {\n    var ret;\n\n    // if the prop is a string\n    if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(prop)) {\n        // set the value\n        if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(value)) {\n            elem.setAttribute(prop, value);\n\n        // get the value\n        } else if (elem && elem.getAttribute) {\n            ret = elem.getAttribute(prop);\n\n            // IE7 and below cannot get class through getAttribute (#7850)\n            if (!ret && prop === 'class') {\n                ret = elem.getAttribute(prop + 'Name');\n            }\n        }\n\n    // else if prop is defined, it is a hash of key/value pairs\n    } else if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(prop) && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(prop)) {\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(prop, function (val, key) {\n            elem.setAttribute(key, val);\n        });\n    }\n    return ret;\n};\n\n/**\n * Check if an element is an array, and if not, make it into an array.\n *\n * @function Highcharts.splat\n *\n * @param {*} obj\n *        The object to splat.\n *\n * @return {Array}\n *         The produced or original array.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].splat = function (obj) {\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(obj) ? obj : [obj];\n};\n\n/**\n * Set a timeout if the delay is given, otherwise perform the function\n * synchronously.\n *\n * @function Highcharts.syncTimeout\n *\n * @param {Function} fn\n *        The function callback.\n *\n * @param {number} delay\n *        Delay in milliseconds.\n *\n * @param {*} [context]\n *        The context.\n *\n * @return {number}\n *         An identifier for the timeout that can later be cleared with\n *         Highcharts.clearTimeout.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].syncTimeout = function (fn, delay, context) {\n    if (delay) {\n        return setTimeout(fn, delay, context);\n    }\n    fn.call(0, context);\n};\n\n/**\n * Internal clear timeout. The function checks that the `id` was not removed\n * (e.g. by `chart.destroy()`). For the details see\n * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).\n *\n * @function Highcharts.clearTimeout\n *\n * @param {number} id\n *        Id of a timeout.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clearTimeout = function (id) {\n    if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(id)) {\n        clearTimeout(id);\n    }\n};\n\n/**\n * Utility function to extend an object with the members of another.\n *\n * @function Highcharts.extend\n *\n * @param {Highcharts.Dictionary<*>} a\n *        The object to be extended.\n *\n * @param {Highcharts.Dictionary<*>} b\n *        The object to add to the first one.\n *\n * @return {Highcharts.Dictionary<*>}\n *         Object a, the original object.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend = function (a, b) {\n    var n;\n    if (!a) {\n        a = {};\n    }\n    for (n in b) {\n        a[n] = b[n];\n    }\n    return a;\n};\n\n\n/**\n * Return the first value that is not null or undefined.\n *\n * @function Highcharts.pick\n *\n * @param {...*} items\n *        Variable number of arguments to inspect.\n *\n * @return {*}\n *         The value of the first argument that is not null or undefined.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick = function () {\n    var args = arguments,\n        i,\n        arg,\n        length = args.length;\n    for (i = 0; i < length; i++) {\n        arg = args[i];\n        if (arg !== undefined && arg !== null) {\n            return arg;\n        }\n    }\n};\n\n/**\n * Set CSS on a given element.\n *\n * @function Highcharts.css\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML DOM element.\n *\n * @param {Highcharts.CSSObject} styles\n *        Style object with camel case property names.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css = function (el, styles) {\n    if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isMS && !_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg) { // #2686\n        if (styles && styles.opacity !== undefined) {\n            styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n        }\n    }\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(el.style, styles);\n};\n\n/**\n * Utility function to create an HTML element with attributes and styles.\n *\n * @function Highcharts.createElement\n *\n * @param {string} tag\n *        The HTML tag.\n *\n * @param {Highcharts.HTMLAttributes} [attribs]\n *        Attributes as an object of key-value pairs.\n *\n * @param {Highcharts.CSSObject} [styles]\n *        Styles as an object of key-value pairs.\n *\n * @param {Highcharts.HTMLDOMElement} [parent]\n *        The parent HTML object.\n *\n * @param {boolean} [nopad=false]\n *        If true, remove all padding, border and margin.\n *\n * @return {Highcharts.HTMLDOMElement}\n *         The created DOM element.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement = function (tag, attribs, styles, parent, nopad) {\n    var el = doc.createElement(tag),\n        css = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].css;\n    if (attribs) {\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(el, attribs);\n    }\n    if (nopad) {\n        css(el, { padding: 0, border: 'none', margin: 0 });\n    }\n    if (styles) {\n        css(el, styles);\n    }\n    if (parent) {\n        parent.appendChild(el);\n    }\n    return el;\n};\n\n/**\n * Extend a prototyped class by new members.\n *\n * @function Highcharts.extendClass\n *\n * @param {*} parent\n *        The parent prototype to inherit.\n *\n * @param {Highcharts.Dictionary<*>} members\n *        A collection of prototype members to add or override compared to the\n *        parent prototype.\n *\n * @return {*}\n *         A new prototype.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extendClass = function (parent, members) {\n    var object = function () {};\n    object.prototype = new parent(); // eslint-disable-line new-cap\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(object.prototype, members);\n    return object;\n};\n\n/**\n * Left-pad a string to a given length by adding a character repetetively.\n *\n * @function Highcharts.pad\n *\n * @param {number} number\n *        The input string or number.\n *\n * @param {number} length\n *        The desired string length.\n *\n * @param {string} [padder=0]\n *        The character to pad with.\n *\n * @return {string}\n *         The padded string.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pad = function (number, length, padder) {\n    return new Array(\n            (length || 2) +\n            1 -\n            String(number)\n                .replace('-', '')\n                .length\n        ).join(padder || 0) + number;\n};\n\n/**\n * Return a length based on either the integer value, or a percentage of a base.\n *\n * @function Highcharts.relativeLength\n *\n * @param {Highcharts.RelativeSize} value\n *        A percentage string or a number.\n *\n * @param {number} base\n *        The full length that represents 100%.\n *\n * @param {number} [offset=0]\n *        A pixel offset to apply for percentage values. Used internally in\n *        axis positioning.\n *\n * @return {number}\n *         The computed length.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].relativeLength = function (value, base, offset) {\n    return (/%$/).test(value) ?\n        (base * parseFloat(value) / 100) + (offset || 0) :\n        parseFloat(value);\n};\n\n/**\n * Wrap a method with extended functionality, preserving the original function.\n *\n * @function Highcharts.wrap\n *\n * @param {*} obj\n *        The context object that the method belongs to. In real cases, this is\n *        often a prototype.\n *\n * @param {string} method\n *        The name of the method to extend.\n *\n * @param {Function} func\n *        A wrapper function callback. This function is called with the same\n *        arguments as the original function, except that the original function\n *        is unshifted and passed as the first argument.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wrap = function (obj, method, func) {\n    var proceed = obj[method];\n    obj[method] = function () {\n        var args = Array.prototype.slice.call(arguments),\n            outerArgs = arguments,\n            ctx = this,\n            ret;\n        ctx.proceed = function () {\n            proceed.apply(ctx, arguments.length ? arguments : outerArgs);\n        };\n        args.unshift(proceed);\n        ret = func.apply(this, args);\n        ctx.proceed = null;\n        return ret;\n    };\n};\n\n\n\n/**\n * Format a single variable. Similar to sprintf, without the % prefix.\n *\n * @example\n * formatSingle('.2f', 5); // => '5.00'.\n *\n * @function Highcharts.formatSingle\n *\n * @param {string} format\n *        The format string.\n *\n * @param {*} val\n *        The value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted representation of the value.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].formatSingle = function (format, val, time) {\n    var floatRegex = /f$/,\n        decRegex = /\\.([0-9])/,\n        lang = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.lang,\n        decimals;\n\n    if (floatRegex.test(format)) { // float\n        decimals = format.match(decRegex);\n        decimals = decimals ? decimals[1] : -1;\n        if (val !== null) {\n            val = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat(\n                val,\n                decimals,\n                lang.decimalPoint,\n                format.indexOf(',') > -1 ? lang.thousandsSep : ''\n            );\n        }\n    } else {\n        val = (time || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].time).dateFormat(format, val);\n    }\n    return val;\n};\n\n/**\n * Format a string according to a subset of the rules of Python's String.format\n * method.\n *\n * @example\n * var s = Highcharts.format(\n *     'The {color} fox was {len:.2f} feet long',\n *     { color: 'red', len: Math.PI }\n * );\n * // => The red fox was 3.14 feet long\n *\n * @function Highcharts.format\n *\n * @param {string} str\n *        The string to format.\n *\n * @param {*} ctx\n *        The context, a collection of key-value pairs where each key is\n *        replaced by its value.\n *\n * @param {Highcharts.Time} [time]\n *        A `Time` instance that determines the date formatting, for example\n *        for applying time zone corrections to the formatted date.\n *\n * @return {string}\n *         The formatted string.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format = function (str, ctx, time) {\n    var splitter = '{',\n        isInside = false,\n        segment,\n        valueAndFormat,\n        path,\n        i,\n        len,\n        ret = [],\n        val,\n        index;\n\n    while (str) {\n        index = str.indexOf(splitter);\n        if (index === -1) {\n            break;\n        }\n\n        segment = str.slice(0, index);\n        if (isInside) { // we're on the closing bracket looking back\n\n            valueAndFormat = segment.split(':');\n            path = valueAndFormat.shift().split('.'); // get first and leave\n            len = path.length;\n            val = ctx;\n\n            // Assign deeper paths\n            for (i = 0; i < len; i++) {\n                if (val) {\n                    val = val[path[i]];\n                }\n            }\n\n            // Format the replacement\n            if (valueAndFormat.length) {\n                val = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].formatSingle(valueAndFormat.join(':'), val, time);\n            }\n\n            // Push the result and advance the cursor\n            ret.push(val);\n\n        } else {\n            ret.push(segment);\n\n        }\n        str = str.slice(index + 1); // the rest\n        isInside = !isInside; // toggle\n        splitter = isInside ? '}' : '{'; // now look for next matching bracket\n    }\n    ret.push(str);\n    return ret.join('');\n};\n\n/**\n * Get the magnitude of a number.\n *\n * @function Highcharts.getMagnitude\n *\n * @param {number} number\n *        The number.\n *\n * @return {number}\n *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMagnitude = function (num) {\n    return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n};\n\n/**\n * Take an interval and normalize it to multiples of round numbers.\n *\n * @deprecated\n * @function Highcharts.normalizeTickInterval\n *\n * @param {number} interval\n *        The raw, un-rounded interval.\n *\n * @param {Array} [multiples]\n *        Allowed multiples.\n *\n * @param {number} [magnitude]\n *        The magnitude of the number.\n *\n * @param {boolean} [allowDecimals]\n *        Whether to allow decimals.\n *\n * @param {boolean} [hasTickAmount]\n *        If it has tickAmount, avoid landing on tick intervals lower than\n *        original.\n *\n * @return {number}\n *         The normalized interval.\n *\n * @todo\n * Move this function to the Axis prototype. It is here only for historical\n * reasons.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeTickInterval = function (interval, multiples, magnitude,\n        allowDecimals, hasTickAmount) {\n    var normalized,\n        i,\n        retInterval = interval;\n\n    // round to a tenfold of 1, 2, 2.5 or 5\n    magnitude = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick(magnitude, 1);\n    normalized = interval / magnitude;\n\n    // multiples for a linear scale\n    if (!multiples) {\n        multiples = hasTickAmount ?\n            // Finer grained ticks when the tick amount is hard set, including\n            // when alignTicks is true on multiple axes (#4580).\n            [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :\n\n            // Else, let ticks fall on rounder numbers\n            [1, 2, 2.5, 5, 10];\n\n\n        // the allowDecimals option\n        if (allowDecimals === false) {\n            if (magnitude === 1) {\n                multiples = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep(multiples, function (num) {\n                    return num % 1 === 0;\n                });\n            } else if (magnitude <= 0.1) {\n                multiples = [1 / magnitude];\n            }\n        }\n    }\n\n    // normalize the interval to the nearest multiple\n    for (i = 0; i < multiples.length; i++) {\n        retInterval = multiples[i];\n        // only allow tick amounts smaller than natural\n        if (\n            (\n                hasTickAmount &&\n                retInterval * magnitude >= interval\n            ) ||\n            (\n                !hasTickAmount &&\n                (\n                    normalized <=\n                    (\n                        multiples[i] +\n                        (multiples[i + 1] || multiples[i])\n                    ) / 2\n                )\n            )\n        ) {\n            break;\n        }\n    }\n\n    // Multiply back to the correct magnitude. Correct floats to appropriate\n    // precision (#6085).\n    retInterval = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat(\n        retInterval * magnitude,\n        -Math.round(Math.log(0.001) / Math.LN10)\n    );\n\n    return retInterval;\n};\n\n\n/**\n * Sort an object array and keep the order of equal items. The ECMAScript\n * standard does not specify the behaviour when items are equal.\n *\n * @function Highcharts.stableSort\n *\n * @param {Array} arr\n *        The array to sort.\n *\n * @param {Function} sortFunction\n *        The function to sort it with, like with regular Array.prototype.sort.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stableSort = function (arr, sortFunction) {\n    var length = arr.length,\n        sortValue,\n        i;\n\n    // Add index to each item\n    for (i = 0; i < length; i++) {\n        arr[i].safeI = i; // stable sort index\n    }\n\n    arr.sort(function (a, b) {\n        sortValue = sortFunction(a, b);\n        return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n    });\n\n    // Remove index from items\n    for (i = 0; i < length; i++) {\n        delete arr[i].safeI; // stable sort index\n    }\n};\n\n/**\n * Non-recursive method to find the lowest member of an array. `Math.min` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMin\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The lowest number.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMin = function (data) {\n    var i = data.length,\n        min = data[0];\n\n    while (i--) {\n        if (data[i] < min) {\n            min = data[i];\n        }\n    }\n    return min;\n};\n\n/**\n * Non-recursive method to find the lowest member of an array. `Math.max` raises\n * a maximum call stack size exceeded error in Chrome when trying to apply more\n * than 150.000 points. This method is slightly slower, but safe.\n *\n * @function Highcharts.arrayMax\n *\n * @param {Array} data\n *        An array of numbers.\n *\n * @return {number}\n *         The highest number.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].arrayMax = function (data) {\n    var i = data.length,\n        max = data[0];\n\n    while (i--) {\n        if (data[i] > max) {\n            max = data[i];\n        }\n    }\n    return max;\n};\n\n/**\n * Utility method that destroys any SVGElement instances that are properties on\n * the given object. It loops all properties and invokes destroy if there is a\n * destroy method. The property is then delete.\n *\n * @function Highcharts.destroyObjectProperties\n *\n * @param {*} obj\n *        The object to destroy properties on.\n *\n * @param {*} [except]\n *        Exception, do not destroy this property, only delete it.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].destroyObjectProperties = function (obj, except) {\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(obj, function (val, n) {\n        // If the object is non-null and destroy is defined\n        if (val && val !== except && val.destroy) {\n            // Invoke the destroy\n            val.destroy();\n        }\n\n        // Delete the property from the object.\n        delete obj[n];\n    });\n};\n\n\n/**\n * Discard a HTML element by moving it to the bin and delete.\n *\n * @function Highcharts.discardElement\n *\n * @param {Highcharts.HTMLDOMElement} element\n *        The HTML node to discard.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].discardElement = function (element) {\n    var garbageBin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].garbageBin;\n    // create a garbage bin element, not part of the DOM\n    if (!garbageBin) {\n        garbageBin = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement('div');\n    }\n\n    // move the node and empty bin\n    if (element) {\n        garbageBin.appendChild(element);\n    }\n    garbageBin.innerHTML = '';\n};\n\n/**\n * Fix JS round off float errors.\n *\n * @function Highcharts.correctFloat\n *\n * @param {number} num\n *        A float number to fix.\n *\n * @param {number} [prec=14]\n *        The precision.\n *\n * @return {number}\n *         The corrected float number.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].correctFloat = function (num, prec) {\n    return parseFloat(\n        num.toPrecision(prec || 14)\n    );\n};\n\n/**\n * Set the global animation to either a given value, or fall back to the given\n * chart's animation option.\n *\n * @function Highcharts.setAnimation\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        The animation object.\n *\n * @param {Highcharts.Chart} chart\n *        The chart instance.\n *\n * @todo\n * This function always relates to a chart, and sets a property on the renderer,\n * so it should be moved to the SVGRenderer.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setAnimation = function (animation, chart) {\n    chart.renderer.globalAnimation = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick(\n        animation,\n        chart.options.chart.animation,\n        true\n    );\n};\n\n/**\n * Get the animation in object form, where a disabled animation is always\n * returned as `{ duration: 0 }`.\n *\n * @function Highcharts.animObject\n *\n * @param {boolean|Highcharts.AnimationOptionsObject} animation\n *        An animation setting. Can be an object with duration, complete and\n *        easing properties, or a boolean to enable or disable.\n *\n * @return {Highcharts.AnimationOptionsObject}\n *         An object with at least a duration property.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animObject = function (animation) {\n    return _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(animation) ?\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(animation) :\n        { duration: animation ? 500 : 0 };\n};\n\n/**\n * The time unit lookup\n *\n * @ignore\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timeUnits = {\n    millisecond: 1,\n    second: 1000,\n    minute: 60000,\n    hour: 3600000,\n    day: 24 * 3600000,\n    week: 7 * 24 * 3600000,\n    month: 28 * 24 * 3600000,\n    year: 364 * 24 * 3600000\n};\n\n/**\n * Format a number and return a string based on input settings.\n *\n * @sample highcharts/members/highcharts-numberformat/\n *         Custom number format\n *\n * @function Highcharts.numberFormat\n *\n * @param {number} number\n *        The input number to format.\n *\n * @param {number} decimals\n *        The amount of decimals. A value of -1 preserves the amount in the\n *        input number.\n *\n * @param {string} [decimalPoint]\n *        The decimal point, defaults to the one given in the lang options, or\n *        a dot.\n *\n * @param {string} [thousandsSep]\n *        The thousands separator, defaults to the one given in the lang\n *        options, or a space character.\n *\n * @return {string}\n *         The formatted number.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n    number = +number || 0;\n    decimals = +decimals;\n\n    var lang = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultOptions.lang,\n        origDec = (number.toString().split('.')[1] || '').split('e')[0].length,\n        strinteger,\n        thousands,\n        ret,\n        roundedNumber,\n        exponent = number.toString().split('e'),\n        fractionDigits;\n\n    if (decimals === -1) {\n        // Preserve decimals. Not huge numbers (#3793).\n        decimals = Math.min(origDec, 20);\n    } else if (!_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(decimals)) {\n        decimals = 2;\n    } else if (decimals && exponent[1] && exponent[1] < 0) {\n        // Expose decimals from exponential notation (#7042)\n        fractionDigits = decimals + +exponent[1];\n        if (fractionDigits >= 0) {\n            // remove too small part of the number while keeping the notation\n            exponent[0] = (+exponent[0]).toExponential(fractionDigits)\n                .split('e')[0];\n            decimals = fractionDigits;\n        } else {\n            // fractionDigits < 0\n            exponent[0] = exponent[0].split('.')[0] || 0;\n\n            if (decimals < 20) {\n                // use number instead of exponential notation (#7405)\n                number = (exponent[0] * Math.pow(10, exponent[1]))\n                    .toFixed(decimals);\n            } else {\n                // or zero\n                number = 0;\n            }\n            exponent[1] = 0;\n        }\n    }\n\n    // Add another decimal to avoid rounding errors of float numbers. (#4573)\n    // Then use toFixed to handle rounding.\n    roundedNumber = (\n        Math.abs(exponent[1] ? exponent[0] : number) +\n        Math.pow(10, -Math.max(decimals, origDec) - 1)\n    ).toFixed(decimals);\n\n    // A string containing the positive integer component of the number\n    strinteger = String(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt(roundedNumber));\n\n    // Leftover after grouping into thousands. Can be 0, 1 or 2.\n    thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n    // Language\n    decimalPoint = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick(decimalPoint, lang.decimalPoint);\n    thousandsSep = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick(thousandsSep, lang.thousandsSep);\n\n    // Start building the return\n    ret = number < 0 ? '-' : '';\n\n    // Add the leftover after grouping into thousands. For example, in the\n    // number 42 000 000, this line adds 42.\n    ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n    // Add the remaining thousands groups, joined by the thousands separator\n    ret += strinteger\n        .substr(thousands)\n        .replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n    // Add the decimal point and the decimal component\n    if (decimals) {\n        // Get the decimal component\n        ret += decimalPoint + roundedNumber.slice(-decimals);\n    }\n\n    if (exponent[1] && +ret !== 0) {\n        ret += 'e' + exponent[1];\n    }\n\n    return ret;\n};\n\n/**\n * Easing definition\n *\n * @private\n * @function Math.easeInOutSine\n *\n * @param {number} pos\n *        Current position, ranging from 0 to 1.\n *\n * @return {number}\n */\nMath.easeInOutSine = function (pos) {\n    return -0.5 * (Math.cos(Math.PI * pos) - 1);\n};\n\n/**\n * Get the computed CSS value for given element and property, only for numerical\n * properties. For width and height, the dimension of the inner box (excluding\n * padding) is returned. Used for fitting the chart within the container.\n *\n * @function Highcharts.getStyle\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        An HTML element.\n *\n * @param {string} prop\n *        The property name.\n *\n * @param {boolean} [toInt=true]\n *        Parse to integer.\n *\n * @return {number}\n *         The numeric value.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle = function (el, prop, toInt) {\n\n    var style;\n\n    // For width and height, return the actual inner pixel size (#4913)\n    if (prop === 'width') {\n        return Math.max(\n            0, // #8377\n            Math.min(el.offsetWidth, el.scrollWidth) -\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(el, 'padding-left') -\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(el, 'padding-right')\n        );\n    } else if (prop === 'height') {\n        return Math.max(\n            0, // #8377\n            Math.min(el.offsetHeight, el.scrollHeight) -\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(el, 'padding-top') -\n                _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(el, 'padding-bottom')\n        );\n    }\n\n    if (!win.getComputedStyle) {\n        // SVG not supported, forgot to load oldie.js?\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(27, true);\n    }\n\n    // Otherwise, get the computed style\n    style = win.getComputedStyle(el, undefined);\n    if (style) {\n        style = style.getPropertyValue(prop);\n        if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pick(toInt, prop !== 'opacity')) {\n            style = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pInt(style);\n        }\n    }\n    return style;\n};\n\n/**\n * Search for an item in an array.\n *\n * @function Highcharts.inArray\n *\n * @param {*} item\n *        The item to search for.\n *\n * @param {Array} arr\n *        The array or node collection to search in.\n *\n * @param {number} [fromIndex=0]\n *        The index to start searching from.\n *\n * @return {number}\n *         The index within the array, or -1 if not found.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray = function (item, arr, fromIndex) {\n    return (\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].indexOfPolyfill ||\n        Array.prototype.indexOf\n    ).call(arr, item, fromIndex);\n};\n\n/**\n * Filter an array by a callback.\n *\n * @function Highcharts.grep\n *\n * @param {Array} arr\n *        The array to filter.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if the item is to be preserved.\n *\n * @return {Array}\n *         A new, filtered array.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].grep = function (arr, callback) {\n    return (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].filterPolyfill || Array.prototype.filter).call(arr, callback);\n};\n\n/**\n * Return the value of the first element in the array that satisfies the\n * provided testing function.\n *\n * @function Highcharts.find\n *\n * @param {Array} arr\n *        The array to test.\n *\n * @param {Function} callback\n *        The callback function. The function receives the item as the first\n *        argument. Return `true` if this item satisfies the condition.\n *\n * @return {*}\n *         The value of the element.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].find = Array.prototype.find ?\n    function (arr, callback) {\n        return arr.find(callback);\n    } :\n    // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.\n    function (arr, fn) {\n        var i,\n            length = arr.length;\n\n        for (i = 0; i < length; i++) {\n            if (fn(arr[i], i)) {\n                return arr[i];\n            }\n        }\n    };\n\n/**\n * Test whether at least one element in the array passes the test implemented by\n * the provided function.\n *\n * @function Highcharts.some\n *\n * @param {Array} arr\n *        The array to test\n *\n * @param {Function} fn\n *        The function to run on each item. Return truty to pass the test.\n *        Receives arguments `currentValue`, `index` and `array`.\n *\n * @param {*} ctx\n *        The context.\n *\n * @return {boolean}\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].some = function (arr, fn, ctx) {\n    return (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].somePolyfill || Array.prototype.some).call(arr, fn, ctx);\n};\n\n/**\n * Map an array by a callback.\n *\n * @function Highcharts.map\n *\n * @param {Array} arr\n *        The array to map.\n *\n * @param {Function} fn\n *        The callback function. Return the new value for the new array.\n *\n * @return {Array}\n *         A new array item with modified items.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].map = function (arr, fn) {\n    var results = [],\n        i = 0,\n        len = arr.length;\n\n    for (; i < len; i++) {\n        results[i] = fn.call(arr[i], arr[i], i, arr);\n    }\n\n    return results;\n};\n\n/**\n * Returns an array of a given object's own properties.\n *\n * @function Highcharts.keys\n *\n * @param {*} obj\n *        The object of which the properties are to be returned.\n *\n * @return {Array<string>}\n *         An array of strings that represents all the properties.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keys = function (obj) {\n    return (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].keysPolyfill || Object.keys).call(undefined, obj);\n};\n\n/**\n * Reduce an array to a single value.\n *\n * @function Highcharts.reduce\n *\n * @param {Array<*>} arr\n *        The array to reduce.\n *\n * @param {Function} fn\n *        The callback function. Return the reduced value. Receives 4\n *        arguments: Accumulated/reduced value, current value, current array\n *        index, and the array.\n *\n * @param {*} initialValue\n *        The initial value of the accumulator.\n *\n * @return {*}\n *         The reduced value.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reduce = function (arr, func, initialValue) {\n    var fn = (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reducePolyfill || Array.prototype.reduce);\n    return fn.apply(\n        arr,\n        (arguments.length > 2 ? [func, initialValue] : [func])\n    );\n};\n\n/**\n * Get the element's offset position, corrected for `overflow: auto`.\n *\n * @function Highcharts.offset\n *\n * @param {Highcharts.HTMLDOMElement} el\n *        The HTML element.\n *\n * @return {Highcharts.OffsetObject}\n *         An object containing `left` and `top` properties for the position in\n *         the page.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].offset = function (el) {\n    var docElem = doc.documentElement,\n        box = (el.parentElement || el.parentNode) ?\n            el.getBoundingClientRect() :\n            { top: 0, left: 0 };\n\n    return {\n        top: box.top + (win.pageYOffset || docElem.scrollTop) -\n            (docElem.clientTop || 0),\n        left: box.left + (win.pageXOffset || docElem.scrollLeft) -\n            (docElem.clientLeft || 0)\n    };\n};\n\n/**\n * Stop running animation.\n *\n * @function Highcharts.stop\n *\n * @param {Highcharts.SVGElement} el\n *        The SVGElement to stop animation on.\n *\n * @param {string} [prop]\n *        The property to stop animating. If given, the stop method will stop a\n *        single property from animating, while others continue.\n *\n * @todo\n * A possible extension to this would be to stop a single property, when\n * we want to continue animating others. Then assign the prop to the timer\n * in the Fx.run method, and check for the prop here. This would be an\n * improvement in all cases where we stop the animation from .attr. Instead of\n * stopping everything, we can just stop the actual attributes we're setting.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stop = function (el, prop) {\n\n    var i = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers.length;\n\n    // Remove timers related to this element (#4519)\n    while (i--) {\n        if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers[i].elem === el && (!prop || prop === _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers[i].prop)) {\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timers[i].stopped = true; // #4667\n        }\n    }\n};\n\n/**\n * Iterate over an array.\n *\n * @function Highcharts.each<T>\n *\n * @param {Array<T>} arr\n *        The array to iterate over.\n *\n * @param {Highcharts.EachCallbackFunction<T>} fn\n *        The iterator callback. It passes three arguments:\n *        * item - The array item.\n *        * index - The item's index in the array.\n *        * arr - The array that each is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each = function (arr, fn, ctx) { // modern browsers\n    return (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);\n};\n\n/**\n * Iterate over object key pairs in an object.\n *\n * @function Highcharts.objectEach\n *\n * @param {*} obj\n *        The object to iterate over.\n *\n * @param {Highcharts.ObjectEachCallbackFunction} fn\n *        The iterator callback. It passes three arguments:\n *        * value - The property value.\n *        * key - The property key.\n *        * obj - The object that objectEach is being applied to.\n *\n * @param {*} [ctx]\n *        The context.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach = function (obj, fn, ctx) {\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            fn.call(ctx || obj[key], obj[key], key, obj);\n        }\n    }\n};\n\n/**\n * Add an event listener.\n *\n * @function Highcharts.addEvent\n *\n * @param {*} el\n *        The element or object to add a listener to. It can be a\n *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The event type.\n *\n * @param {Highcharts.EventCallbackFunction} fn\n *        The function callback to execute when the event is fired.\n *\n * @param {Highcharts.Dictionary<*>} options\n *        Event options\n *\n * @param {number} options.order\n *        The order the event handler should be called. This opens for having\n *        one handler be called before another, independent of in which order\n *        they were added.\n *\n * @return {Function}\n *         A callback function to remove the added event.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEvent = function (el, type, fn, options) {\n\n    var events,\n        addEventListener = el.addEventListener || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addEventListenerPolyfill;\n\n    // If we're setting events directly on the constructor, use a separate\n    // collection, `protoEvents` to distinguish it from the item events in\n    // `hcEvents`.\n    if (typeof el === 'function' && el.prototype) {\n        events = el.prototype.protoEvents = el.prototype.protoEvents || {};\n    } else {\n        events = el.hcEvents = el.hcEvents || {};\n    }\n\n    // Allow click events added to points, otherwise they will be prevented by\n    // the TouchPointer.pinch function after a pinch zoom operation (#7091).\n    if (_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point && el instanceof _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point && el.series && el.series.chart) {\n        el.series.chart.runTrackerClick = true;\n    }\n\n    // Handle DOM events\n    if (addEventListener) {\n        addEventListener.call(el, type, fn, false);\n    }\n\n    if (!events[type]) {\n        events[type] = [];\n    }\n\n    events[type].push(fn);\n\n    // Order the calls\n    if (options && _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(options.order)) {\n        fn.order = options.order;\n        events[type].sort(function (a, b) {\n            return a.order - b.order;\n        });\n    }\n\n    // Return a function that can be called to remove this event.\n    return function () {\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent(el, type, fn);\n    };\n};\n\n/**\n * Remove an event that was added with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.removeEvent\n *\n * @param {*} el\n *        The element to remove events on.\n *\n * @param {string} [type]\n *        The type of events to remove. If undefined, all events are removed\n *        from the element.\n *\n * @param {Function} [fn]\n *        The specific callback to remove. If undefined, all events that match\n *        the element and optionally the type are removed.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEvent = function (el, type, fn) {\n\n    var events,\n        index;\n\n    function removeOneEvent(type, fn) {\n        var removeEventListener =\n            el.removeEventListener || _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeEventListenerPolyfill;\n\n        if (removeEventListener) {\n            removeEventListener.call(el, type, fn, false);\n        }\n    }\n\n    function removeAllEvents(eventCollection) {\n        var types,\n            len;\n\n        if (!el.nodeName) {\n            return; // break on non-DOM events\n        }\n\n        if (type) {\n            types = {};\n            types[type] = true;\n        } else {\n            types = eventCollection;\n        }\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(types, function (val, n) {\n            if (eventCollection[n]) {\n                len = eventCollection[n].length;\n                while (len--) {\n                    removeOneEvent(n, eventCollection[n][len]);\n                }\n            }\n        });\n    }\n\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each(['protoEvents', 'hcEvents'], function (coll) {\n        var eventCollection = el[coll];\n        if (eventCollection) {\n            if (type) {\n                events = eventCollection[type] || [];\n                if (fn) {\n                    index = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inArray(fn, events);\n                    if (index > -1) {\n                        events.splice(index, 1);\n                        eventCollection[type] = events;\n                    }\n                    removeOneEvent(type, fn);\n\n                } else {\n                    removeAllEvents(eventCollection);\n                    eventCollection[type] = [];\n                }\n            } else {\n                removeAllEvents(eventCollection);\n                el[coll] = {};\n            }\n        }\n    });\n};\n\n/**\n * Fire an event that was registered with {@link Highcharts#addEvent}.\n *\n * @function Highcharts.fireEvent\n *\n * @param {*} el\n *        The object to fire the event on. It can be a {@link HTMLDOMElement},\n *        an {@link SVGElement} or any other object.\n *\n * @param {string} type\n *        The type of event.\n *\n * @param {Highcharts.Dictionary<*>} [eventArguments]\n *        Custom event arguments that are passed on as an argument to the event\n *        handler.\n *\n * @param {Function} [defaultFunction]\n *        The default function to execute if the other listeners haven't\n *        returned false.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fireEvent = function (el, type, eventArguments, defaultFunction) {\n    var e,\n        events,\n        len,\n        i,\n        fn;\n\n    eventArguments = eventArguments || {};\n\n    if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n        e = doc.createEvent('Events');\n        e.initEvent(type, true, true);\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(e, eventArguments);\n\n        if (el.dispatchEvent) {\n            el.dispatchEvent(e);\n        } else {\n            el.fireEvent(type, e);\n        }\n\n    } else {\n\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].each(['protoEvents', 'hcEvents'], function (coll) {\n\n            if (el[coll]) {\n                events = el[coll][type] || [];\n                len = events.length;\n\n                if (!eventArguments.target) { // We're running a custom event\n\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend(eventArguments, {\n                        // Attach a simple preventDefault function to skip\n                        // default handler if called. The built-in\n                        // defaultPrevented property is not overwritable (#5112)\n                        preventDefault: function () {\n                            eventArguments.defaultPrevented = true;\n                        },\n                        // Setting target to native events fails with clicking\n                        // the zoom-out button in Chrome.\n                        target: el,\n                        // If the type is not set, we're running a custom event\n                        // (#2297). If it is set, we're running a browser event,\n                        // and setting it will cause en error in IE8 (#2465).\n                        type: type\n                    });\n                }\n\n\n                for (i = 0; i < len; i++) {\n                    fn = events[i];\n\n                    // If the event handler return false, prevent the default\n                    // handler from executing\n                    if (fn && fn.call(el, eventArguments) === false) {\n                        eventArguments.preventDefault();\n                    }\n                }\n            }\n        });\n    }\n\n    // Run the default if not prevented\n    if (defaultFunction && !eventArguments.defaultPrevented) {\n        defaultFunction.call(el, eventArguments);\n    }\n};\n\n/**\n * The global animate method, which uses Fx to create individual animators.\n *\n * @function Highcharts.animate\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el\n *        The element to animate.\n *\n * @param {Highcharts.HTMLAttributes|Highcharts.SVGAttributes} params\n *        An object containing key-value pairs of the properties to animate.\n *        Supports numeric as pixel-based CSS properties for HTML objects and\n *        attributes for SVGElements.\n *\n * @param {Highcharts.AnimationOptionsObject} [opt]\n *        Animation options.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].animate = function (el, params, opt) {\n    var start,\n        unit = '',\n        end,\n        fx,\n        args;\n\n    if (!_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(opt)) { // Number or undefined/null\n        args = arguments;\n        opt = {\n            duration: args[2],\n            easing: args[3],\n            complete: args[4]\n        };\n    }\n    if (!_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNumber(opt.duration)) {\n        opt.duration = 400;\n    }\n    opt.easing = typeof opt.easing === 'function' ?\n        opt.easing :\n        (Math[opt.easing] || Math.easeInOutSine);\n    opt.curAnim = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(params);\n\n    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].objectEach(params, function (val, prop) {\n        // Stop current running animation of this property\n        _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stop(el, prop);\n\n        fx = new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Fx(el, opt, prop);\n        end = null;\n\n        if (prop === 'd') {\n            fx.paths = fx.initPath(\n                el,\n                el.d,\n                params.d\n            );\n            fx.toD = params.d;\n            start = 0;\n            end = 1;\n        } else if (el.attr) {\n            start = el.attr(prop);\n        } else {\n            start = parseFloat(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStyle(el, prop)) || 0;\n            if (prop !== 'opacity') {\n                unit = 'px';\n            }\n        }\n\n        if (!end) {\n            end = val;\n        }\n        if (end && end.match && end.match('px')) {\n            end = end.replace(/px/g, ''); // #4351\n        }\n        fx.run(start, end, unit);\n    });\n};\n\n/**\n * Factory to create new series prototypes.\n *\n * @function Highcharts.seriesType\n *\n * @param {string} type\n *        The series type name.\n *\n * @param {string} parent\n *        The parent series type name. Use `line` to inherit from the basic\n *        {@link Series} object.\n *\n * @param {*} options\n *        The additional default options that is merged with the parent's\n *        options.\n *\n * @param {*} props\n *        The properties (functions and primitives) to set on the new\n *        prototype.\n *\n * @param {*} [pointProps]\n *        Members for a series-specific extension of the {@link Point}\n *        prototype if needed.\n *\n * @return {Highcharts.Series}\n *         The newly created prototype as extended from {@link Series} or its\n *         derivatives.\n */\n// docs: add to API + extending Highcharts\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesType = function (type, parent, options, props, pointProps) {\n    var defaultOptions = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getOptions(),\n        seriesTypes = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].seriesTypes;\n\n    // Merge the options\n    defaultOptions.plotOptions[type] = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merge(\n        defaultOptions.plotOptions[parent],\n        options\n    );\n\n    // Create the class\n    seriesTypes[type] = _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extendClass(seriesTypes[parent] ||\n        function () {}, props);\n    seriesTypes[type].prototype.type = type;\n\n    // Create the point class if needed\n    if (pointProps) {\n        seriesTypes[type].prototype.pointClass =\n            _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extendClass(_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point, pointProps);\n    }\n\n    return seriesTypes[type];\n};\n\n/**\n * Get a unique key for using in internal element id's and pointers. The key is\n * composed of a random hash specific to this Highcharts instance, and a\n * counter.\n *\n * @example\n * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'\n *\n * @function Highcharts.uniqueKey\n *\n * @return {string}\n *         A unique key.\n */\n_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uniqueKey = (function () {\n\n    var uniqueKeyHash = Math.random().toString(36).substring(2, 9),\n        idCounter = 0;\n\n    return function () {\n        return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;\n    };\n}());\n\n// Register Highcharts as a plugin in jQuery\nif (win.jQuery) {\n\n    /**\n     * Highcharts-extended JQuery.\n     *\n     * @external JQuery\n     */\n\n    /**\n     * Factory function to create a chart in the current JQuery selector\n     * element.\n     *\n     * @function external:JQuery#highcharts\n     *\n     * @param {\"Chart\"|\"Map\"|\"StockChart\"|string} [className]\n     *        Name of the factory class in the Highcharts namespace.\n     *\n     * @param {Highcharts.Options} options\n     *        The chart options structure.\n     *\n     * @param {Highcharts.ChartCallbackFunction} [callback]\n     *        Function to run when the chart has loaded and and all external\n     *        images are loaded. Defining a [chart.event.load\n     *        ](https://api.highcharts.com/highcharts/chart.events.load) handler\n     *        is equivalent.\n     *\n     * @return {JQuery}\n     *         The current JQuery selector.\n     */\n    win.jQuery.fn.highcharts = function () {\n        var args = [].slice.call(arguments);\n\n        if (this[0]) { // this[0] is the renderTo div\n\n            // Create the chart\n            if (args[0]) {\n                new _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][ // eslint-disable-line no-new\n                    // Constructor defaults to Chart\n                    _Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(args[0]) ? args.shift() : 'Chart'\n                ](this[0], args[0], args[1]);\n                return this;\n            }\n\n            // When called without parameters or with the return argument,\n            // return an existing chart\n            return charts[_Globals_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].attr(this[0], 'data-highcharts-chart')];\n        }\n    };\n}\n\n\n//# sourceURL=webpack://test/./node_modules/highcharts/js/es-modules/parts/Utilities.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"legacyPrototypeMethod\": () => (/* binding */ legacyPrototypeMethod),\n/* harmony export */   \"standardPrototypeMethod\": () => (/* binding */ standardPrototypeMethod),\n/* harmony export */   \"decorateProperty\": () => (/* binding */ decorateProperty)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst legacyPrototypeMethod = (descriptor, proto, name) => {\n    Object.defineProperty(proto, name, descriptor);\n};\nconst standardPrototypeMethod = (descriptor, element) => ({\n    kind: 'method',\n    placement: 'prototype',\n    key: element.key,\n    descriptor,\n});\n/**\n * Helper for decorating a property that is compatible with both TypeScript\n * and Babel decorators. The optional `finisher` can be used to perform work on\n * the class. The optional `descriptor` should return a PropertyDescriptor\n * to install for the given property.\n *\n * @param finisher {function} Optional finisher method; receives the element\n * constructor and property key as arguments and has no return value.\n * @param descriptor {function} Optional descriptor method; receives the\n * property key as an argument and returns a property descriptor to define for\n * the given property.\n * @returns {ClassElement|void}\n */\nconst decorateProperty = ({ finisher, descriptor, }) => (protoOrDescriptor, name\n// Note TypeScript requires the return type to be `void|any`\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    var _a;\n    // TypeScript / Babel legacy mode\n    if (name !== undefined) {\n        const ctor = protoOrDescriptor\n            .constructor;\n        if (descriptor !== undefined) {\n            Object.defineProperty(protoOrDescriptor, name, descriptor(name));\n        }\n        finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);\n        // Babel standard mode\n    }\n    else {\n        // Note, the @property decorator saves `key` as `originalKey`\n        // so try to use it here.\n        const key = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (_a = protoOrDescriptor.originalKey) !== null && _a !== void 0 ? _a : protoOrDescriptor.key;\n        const info = descriptor != undefined\n            ? {\n                kind: 'method',\n                placement: 'prototype',\n                key,\n                descriptor: descriptor(protoOrDescriptor.key),\n            }\n            : { ...protoOrDescriptor, key };\n        if (finisher != undefined) {\n            info.finisher = function (ctor) {\n                finisher(ctor, key);\n            };\n        }\n        return info;\n    }\n};\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/base.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/custom-element.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/custom-element.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"customElement\": () => (/* binding */ customElement)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        },\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nconst customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === 'function'\n    ? legacyCustomElement(tagName, classOrDescriptor)\n    : standardCustomElement(tagName, classOrDescriptor);\n//# sourceMappingURL=custom-element.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/custom-element.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/event-options.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/event-options.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventOptions\": () => (/* binding */ eventOptions)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * ```ts\n * class MyElement {\n *   clicked = false;\n *\n *   render() {\n *     return html`\n *       <div @click=${this._onClick}`>\n *         <button></button>\n *       </div>\n *     `;\n *   }\n *\n *   @eventOptions({capture: true})\n *   _onClick(e) {\n *     this.clicked = true;\n *   }\n * }\n * ```\n * @category Decorator\n */\nfunction eventOptions(options) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        finisher: (ctor, name) => {\n            Object.assign(ctor.prototype[name], options);\n        },\n    });\n}\n//# sourceMappingURL=event-options.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/event-options.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/property.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/property.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"property\": () => (/* binding */ property)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst standardProperty = (options, element) => {\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n    // stomp over the user's accessor.\n    if (element.kind === 'method' &&\n        element.descriptor &&\n        !('value' in element.descriptor)) {\n        return {\n            ...element,\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            },\n        };\n    }\n    else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: 'field',\n            key: Symbol(),\n            placement: 'own',\n            descriptor: {},\n            // store the original key so subsequent decorators have access to it.\n            originalKey: element.key,\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: 'initializer',\n            //     placement: 'own',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer() {\n                if (typeof element.initializer === 'function') {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            },\n        };\n    }\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a reactive property that reflects a\n * corresponding attribute value. When a decorated property is set\n * the element will update and render. A [[`PropertyDeclaration`]] may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the [[`state`]] decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the [[`state`]] decorator should be used. When needed,\n * state properties can be initialized via public properties to facilitate\n * complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nfunction property(options) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (protoOrDescriptor, name) => name !== undefined\n        ? legacyProperty(options, protoOrDescriptor, name)\n        : standardProperty(options, protoOrDescriptor);\n}\n//# sourceMappingURL=property.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/property.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/query-all.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/query-all.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queryAll\": () => (/* binding */ queryAll)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nfunction queryAll(selector) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name) => ({\n            get() {\n                var _a, _b;\n                return (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector)) !== null && _b !== void 0 ? _b : [];\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-all.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/query-all.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queryAssignedNodes\": () => (/* binding */ queryAssignedNodes)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given named `slot`. Note, the type of\n * this property should be annotated as `NodeListOf<HTMLElement>`.\n *\n * @param slotName A string name of the slot.\n * @param flatten A boolean which when true flattens the assigned nodes,\n *     meaning any assigned nodes that are slot elements are replaced with their\n *     assigned nodes.\n * @param selector A string which filters the results to elements that match\n *     the given css selector.\n *\n * ```ts\n * class MyElement {\n *   @queryAssignedNodes('list', true, '.item')\n *   listItems;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nfunction queryAssignedNodes(slotName = '', flatten = false, selector = '') {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name) => ({\n            get() {\n                var _a, _b, _c;\n                const slotSelector = `slot${slotName ? `[name=${slotName}]` : ':not([name])'}`;\n                const slot = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);\n                let nodes = (_c = (_b = slot) === null || _b === void 0 ? void 0 : _b.assignedNodes({ flatten })) !== null && _c !== void 0 ? _c : [];\n                if (selector) {\n                    nodes = nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE &&\n                        node.matches(selector));\n                }\n                return nodes;\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-assigned-nodes.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/query-async.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/query-async.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queryAsync\": () => (/* binding */ queryAsync)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @queryAsync('#first')\n *   first;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n *\n * // external usage\n * async doSomethingWithFirst() {\n *  (await aMyElement.first).doSomething();\n * }\n * ```\n * @category Decorator\n */\nfunction queryAsync(selector) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name) => ({\n            async get() {\n                var _a;\n                await this.updateComplete;\n                return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        }),\n    });\n}\n//# sourceMappingURL=query-async.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/query-async.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/query.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/query.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"query\": () => (/* binding */ query)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nfunction query(selector, cache) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (name) => {\n            const descriptor = {\n                get() {\n                    var _a, _b;\n                    return (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector)) !== null && _b !== void 0 ? _b : null;\n                },\n                enumerable: true,\n                configurable: true,\n            };\n            if (cache) {\n                const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n                descriptor.get = function () {\n                    var _a, _b;\n                    if (this[key] === undefined) {\n                        this[key] = (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector)) !== null && _b !== void 0 ? _b : null;\n                    }\n                    return this[key];\n                };\n            }\n            return descriptor;\n        },\n    });\n}\n//# sourceMappingURL=query.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/query.js?");

/***/ }),

/***/ "./node_modules/@lit/reactive-element/development/decorators/state.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/development/decorators/state.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"state\": () => (/* binding */ state)\n/* harmony export */ });\n/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property.js */ \"./node_modules/@lit/reactive-element/development/decorators/property.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */\nfunction state(options) {\n    return (0,_property_js__WEBPACK_IMPORTED_MODULE_0__.property)({\n        ...options,\n        state: true,\n    });\n}\n//# sourceMappingURL=state.js.map\n\n//# sourceURL=webpack://test/./node_modules/@lit/reactive-element/development/decorators/state.js?");

/***/ }),

/***/ "./node_modules/lit-element/development/decorators.js":
/*!************************************************************!*\
  !*** ./node_modules/lit-element/development/decorators.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decorateProperty\": () => (/* reexport safe */ _lit_reactive_element_decorators_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty),\n/* harmony export */   \"legacyPrototypeMethod\": () => (/* reexport safe */ _lit_reactive_element_decorators_base_js__WEBPACK_IMPORTED_MODULE_0__.legacyPrototypeMethod),\n/* harmony export */   \"standardPrototypeMethod\": () => (/* reexport safe */ _lit_reactive_element_decorators_base_js__WEBPACK_IMPORTED_MODULE_0__.standardPrototypeMethod),\n/* harmony export */   \"customElement\": () => (/* reexport safe */ _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.customElement),\n/* harmony export */   \"property\": () => (/* reexport safe */ _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__.property),\n/* harmony export */   \"state\": () => (/* reexport safe */ _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_3__.state),\n/* harmony export */   \"eventOptions\": () => (/* reexport safe */ _lit_reactive_element_decorators_event_options_js__WEBPACK_IMPORTED_MODULE_4__.eventOptions),\n/* harmony export */   \"query\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_js__WEBPACK_IMPORTED_MODULE_5__.query),\n/* harmony export */   \"queryAll\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_all_js__WEBPACK_IMPORTED_MODULE_6__.queryAll),\n/* harmony export */   \"queryAsync\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_async_js__WEBPACK_IMPORTED_MODULE_7__.queryAsync),\n/* harmony export */   \"queryAssignedNodes\": () => (/* reexport safe */ _lit_reactive_element_decorators_query_assigned_nodes_js__WEBPACK_IMPORTED_MODULE_8__.queryAssignedNodes)\n/* harmony export */ });\n/* harmony import */ var _lit_reactive_element_decorators_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/base.js */ \"./node_modules/@lit/reactive-element/development/decorators/base.js\");\n/* harmony import */ var _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/reactive-element/decorators/custom-element.js */ \"./node_modules/@lit/reactive-element/development/decorators/custom-element.js\");\n/* harmony import */ var _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lit/reactive-element/decorators/property.js */ \"./node_modules/@lit/reactive-element/development/decorators/property.js\");\n/* harmony import */ var _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lit/reactive-element/decorators/state.js */ \"./node_modules/@lit/reactive-element/development/decorators/state.js\");\n/* harmony import */ var _lit_reactive_element_decorators_event_options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lit/reactive-element/decorators/event-options.js */ \"./node_modules/@lit/reactive-element/development/decorators/event-options.js\");\n/* harmony import */ var _lit_reactive_element_decorators_query_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lit/reactive-element/decorators/query.js */ \"./node_modules/@lit/reactive-element/development/decorators/query.js\");\n/* harmony import */ var _lit_reactive_element_decorators_query_all_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lit/reactive-element/decorators/query-all.js */ \"./node_modules/@lit/reactive-element/development/decorators/query-all.js\");\n/* harmony import */ var _lit_reactive_element_decorators_query_async_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lit/reactive-element/decorators/query-async.js */ \"./node_modules/@lit/reactive-element/development/decorators/query-async.js\");\n/* harmony import */ var _lit_reactive_element_decorators_query_assigned_nodes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lit/reactive-element/decorators/query-assigned-nodes.js */ \"./node_modules/@lit/reactive-element/development/decorators/query-assigned-nodes.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=decorators.js.map\n\n//# sourceURL=webpack://test/./node_modules/lit-element/development/decorators.js?");

/***/ }),

/***/ "./node_modules/lit-element/development/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lit-element/development/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CSSResult\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.CSSResult),\n/* harmony export */   \"ReactiveElement\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement),\n/* harmony export */   \"adoptStyles\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.adoptStyles),\n/* harmony export */   \"css\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"defaultConverter\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.defaultConverter),\n/* harmony export */   \"getCompatibleStyle\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.getCompatibleStyle),\n/* harmony export */   \"notEqual\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.notEqual),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.supportsAdoptingStyleSheets),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS),\n/* harmony export */   \"INTERNAL\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.INTERNAL),\n/* harmony export */   \"_$LH\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__._$LH),\n/* harmony export */   \"html\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.html),\n/* harmony export */   \"noChange\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.noChange),\n/* harmony export */   \"nothing\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.nothing),\n/* harmony export */   \"render\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.render),\n/* harmony export */   \"svg\": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_1__.svg),\n/* harmony export */   \"LitElement\": () => (/* reexport safe */ _lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),\n/* harmony export */   \"UpdatingElement\": () => (/* reexport safe */ _lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),\n/* harmony export */   \"_$LE\": () => (/* reexport safe */ _lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),\n/* harmony export */   \"customElement\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.customElement),\n/* harmony export */   \"decorateProperty\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.decorateProperty),\n/* harmony export */   \"eventOptions\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.eventOptions),\n/* harmony export */   \"legacyPrototypeMethod\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.legacyPrototypeMethod),\n/* harmony export */   \"property\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.property),\n/* harmony export */   \"query\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.query),\n/* harmony export */   \"queryAll\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.queryAll),\n/* harmony export */   \"queryAssignedNodes\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.queryAssignedNodes),\n/* harmony export */   \"queryAsync\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.queryAsync),\n/* harmony export */   \"standardPrototypeMethod\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.standardPrototypeMethod),\n/* harmony export */   \"state\": () => (/* reexport safe */ _decorators_js__WEBPACK_IMPORTED_MODULE_3__.state)\n/* harmony export */ });\n/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ \"./node_modules/@lit/reactive-element/development/reactive-element.js\");\n/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ \"./node_modules/lit-html/development/lit-html.js\");\n/* harmony import */ var _lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lit-element.js */ \"./node_modules/lit-element/development/lit-element.js\");\n/* harmony import */ var _decorators_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decorators.js */ \"./node_modules/lit-element/development/decorators.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\nconsole.warn(\"The main 'lit-element' module entrypoint is deprecated. Please update \" +\n    \"your imports to use the 'lit' package: 'lit' and 'lit/decorators.ts' \" +\n    \"or import from 'lit-element/lit-element.ts'. See \" +\n    'https://lit.dev/msg/deprecated-import-path for more information.');\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://test/./node_modules/lit-element/development/index.js?");

/***/ })

}]);